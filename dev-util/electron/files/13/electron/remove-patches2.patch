diff --git a/patches/v8/cherry-pick-1231950.patch b/patches/v8/cherry-pick-1231950.patch
index a2abb59390..22ffd73591 100644
--- a/patches/v8/cherry-pick-1231950.patch
+++ b/patches/v8/cherry-pick-1231950.patch
@@ -141,52 +141,3 @@ index 39ef8528e5267a76f69a251d358ed5a9259246e0..17b2b840f236c249e5a9d2a5fa61098b
    if (protected_store_pc) *protected_store_pc = pc_offset();
  
    MachineRepresentation rep = type.mem_rep();
-diff --git a/test/mjsunit/mjsunit.status b/test/mjsunit/mjsunit.status
-index b6dd59ec697547fa5c56c2ecdb679186ca7f80c7..bb860434536ebc2d5296c5bbf979a4f2f87bc6dd 100644
---- a/test/mjsunit/mjsunit.status
-+++ b/test/mjsunit/mjsunit.status
-@@ -1447,7 +1447,8 @@
-   'regress/wasm/regress-1161954': [SKIP],
-   'regress/wasm/regress-1165966': [SKIP],
-   'regress/wasm/regress-1187831': [SKIP],
--}],  # no_simd_sse == True
-+  'regress/wasm/regress-1231950': [SKIP],
-+}],  # no_simd_hardware == True
- 
- ##############################################################################
- # TODO(v8:11421): Port baseline compiler to other architectures.
-@@ -1465,4 +1466,10 @@
-   'concurrent-initial-prototype-change-1': [SKIP],
- }],  # variant == concurrent_inlining
- 
-+##############################################################################
-+['variant == instruction_scheduling or variant == stress_instruction_scheduling', {
-+  # BUG(12018): This test currently fails with --turbo-instruction-scheduling.
-+  'regress/wasm/regress-1231950': [SKIP],
-+}],  # variant == instruction_scheduling or variant == stress_instruction_scheduling
-+
- ]
-diff --git a/test/mjsunit/regress/wasm/regress-1231950.js b/test/mjsunit/regress/wasm/regress-1231950.js
-new file mode 100644
-index 0000000000000000000000000000000000000000..972754c6d52094727a93dae4c0847f013b6c7675
---- /dev/null
-+++ b/test/mjsunit/regress/wasm/regress-1231950.js
-@@ -0,0 +1,18 @@
-+// Copyright 2021 the V8 project authors. All rights reserved.
-+// Use of this source code is governed by a BSD-style license that can be
-+// found in the LICENSE file.
-+
-+load('test/mjsunit/wasm/wasm-module-builder.js');
-+
-+const builder = new WasmModuleBuilder();
-+builder.addMemory(1, 1);
-+builder.addFunction('main', kSig_d_v)
-+    .addBody([
-+      ...wasmI32Const(-3),                            // i32.const
-+      kExprI32SExtendI8,                              // i32.extend8_s
-+      kSimdPrefix, kExprS128Load32Splat, 0x01, 0x02,  // s128.load32_splat
-+      kExprUnreachable,                               // unreachable
-+    ])
-+    .exportFunc();
-+const instance = builder.instantiate();
-+assertTraps(kTrapMemOutOfBounds, instance.exports.main);
diff --git a/patches/chromium/dpwas_window_control_overlay_api_values_account_for_page_zoom_factor.patch b/patches/chromium/dpwas_window_control_overlay_api_values_account_for_page_zoom_factor.patch
index 1126cbe5b7..9610e8a411 100644
--- a/patches/chromium/dpwas_window_control_overlay_api_values_account_for_page_zoom_factor.patch
+++ b/patches/chromium/dpwas_window_control_overlay_api_values_account_for_page_zoom_factor.patch
@@ -687,15 +687,3 @@ index 1f13dc8bce4a41b96bb2bfce776d6b55500db5b6..d33496ce445cb2af4b21cdd23bdc011d
    } else {
      // Widgets in a WebView's frame tree without a local main frame
      // set the size of the WebView to be the |visible_viewport_size|, in order
-diff --git a/third_party/blink/tools/blinkpy/presubmit/audit_non_blink_usage.py b/third_party/blink/tools/blinkpy/presubmit/audit_non_blink_usage.py
-index 2816268f68d8910b11c5b6ea6d0c2a1a92bd2e1a..ac95c2f8e18081cca7a2c14899c9d7a9444fa565 100755
---- a/third_party/blink/tools/blinkpy/presubmit/audit_non_blink_usage.py
-+++ b/third_party/blink/tools/blinkpy/presubmit/audit_non_blink_usage.py
-@@ -279,6 +279,7 @@ _CONFIG = [
-             'gfx::RectF',
-             'gfx::RRectF',
-             'gfx::ScaleToCeiledSize',
-+            'gfx::ScaleToEnclosingRectSafe',
-             'gfx::ScaleVector2d',
-             'gfx::Size',
-             'gfx::SizeF',
diff --git a/patches/v8/regexp_add_a_currently_failing_cctest_for_irregexp_reentrancy.patch b/patches/v8/regexp_add_a_currently_failing_cctest_for_irregexp_reentrancy.patch
deleted file mode 100644
index c6cae630d3..0000000000
--- a/patches/v8/regexp_add_a_currently_failing_cctest_for_irregexp_reentrancy.patch
+++ /dev/null
@@ -1,109 +0,0 @@
-From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
-From: Jakob Gruber <jgruber@chromium.org>
-Date: Mon, 6 Sep 2021 08:29:33 +0200
-Subject: Add a (currently failing) cctest for irregexp reentrancy
-
-The test should be enabled once reentrancy is supported.
-
-Bug: v8:11382
-Change-Id: Ifb90d8a6fd8bf9f05e9ca2405d4e04e013ce7ee3
-Reviewed-on: https://chromium-review.googlesource.com/c/v8/v8/+/3138201
-Commit-Queue: Jakob Gruber <jgruber@chromium.org>
-Auto-Submit: Jakob Gruber <jgruber@chromium.org>
-Reviewed-by: Patrick Thier <pthier@chromium.org>
-Cr-Commit-Position: refs/heads/main@{#76667}
-
-diff --git a/test/cctest/cctest.status b/test/cctest/cctest.status
-index 7b1bf8caa5e3f3975a457e061d966fd60c5ef441..d6691b5e861d29100d0f1c15c887dd824f3929cb 100644
---- a/test/cctest/cctest.status
-+++ b/test/cctest/cctest.status
-@@ -126,6 +126,9 @@
-   'test-strings/StringOOM*': [PASS, ['mode == debug', SKIP]],
-   'test-serialize/CustomSnapshotDataBlobImmortalImmovableRoots': [PASS, ['mode == debug', SKIP]],
-   'test-parsing/ObjectRestNegativeTestSlow': [PASS, ['mode == debug', SKIP]],
-+
-+  # TODO(v8:11382): Reenable once irregexp is reentrant.
-+  'test-regexp/RegExpInterruptReentrantExecution': [FAIL],
- }],  # ALWAYS
- 
- ##############################################################################
-@@ -606,6 +609,9 @@
- 
-   # Instruction cache flushing is disabled in jitless mode.
-   'test-icache/*': [SKIP],
-+
-+  # Tests generated irregexp code.
-+  'test-regexp/RegExpInterruptReentrantExecution': [SKIP],
- }], # lite_mode or variant == jitless
- 
- ##############################################################################
-diff --git a/test/cctest/test-api.cc b/test/cctest/test-api.cc
-index 5eafa420bc21f40a2eb0caaa76ad2ffd4bd8db85..db0fb3c965c66e7d5a173559c52deca36bc47ebd 100644
---- a/test/cctest/test-api.cc
-+++ b/test/cctest/test-api.cc
-@@ -21581,10 +21581,6 @@ TEST(RegExpInterruptAndMakeSubjectTwoByteExternal) {
-   // experimental engine.
-   i::FLAG_enable_experimental_regexp_engine_on_excessive_backtracks = false;
-   RegExpInterruptTest test;
--  // We want to be stuck regexp execution, so no fallback to linear-time
--  // engine.
--  // TODO(mbid,v8:10765): Find a way to test interrupt support of the
--  // experimental engine.
-   test.RunTest(RegExpInterruptTest::MakeSubjectTwoByteExternal);
- }
- 
-diff --git a/test/cctest/test-regexp.cc b/test/cctest/test-regexp.cc
-index 63495194d4fbce61abbe9a7e83a446341f6f3dd6..fa02c23c47dcefb4ee77c9fc4c8222f52653e576 100644
---- a/test/cctest/test-regexp.cc
-+++ b/test/cctest/test-regexp.cc
-@@ -2340,6 +2340,50 @@ TEST(UnicodePropertyEscapeCodeSize) {
-   }
- }
- 
-+namespace {
-+
-+struct RegExpExecData {
-+  i::Isolate* isolate;
-+  i::Handle<i::JSRegExp> regexp;
-+  i::Handle<i::String> subject;
-+};
-+
-+i::Handle<i::Object> RegExpExec(const RegExpExecData* d) {
-+  return i::RegExp::Exec(d->isolate, d->regexp, d->subject, 0,
-+                         d->isolate->regexp_last_match_info())
-+      .ToHandleChecked();
-+}
-+
-+void ReenterRegExp(v8::Isolate* isolate, void* data) {
-+  RegExpExecData* d = static_cast<RegExpExecData*>(data);
-+  i::Handle<i::Object> result = RegExpExec(d);
-+  CHECK(result->IsNull());
-+}
-+
-+}  // namespace
-+
-+// Tests reentrant irregexp calls.
-+TEST(RegExpInterruptReentrantExecution) {
-+  CHECK(!i::FLAG_jitless);
-+  i::FLAG_regexp_tier_up = false;  // Enter irregexp, not the interpreter.
-+
-+  LocalContext context;
-+  v8::Isolate* isolate = context->GetIsolate();
-+  v8::HandleScope scope(isolate);
-+
-+  RegExpExecData d;
-+  d.isolate = reinterpret_cast<i::Isolate*>(isolate);
-+  d.regexp = v8::Utils::OpenHandle(
-+      *v8::RegExp::New(context.local(), v8_str("(a*)*x"), v8::RegExp::kNone)
-+           .ToLocalChecked());
-+  d.subject = v8::Utils::OpenHandle(*v8_str("aaaa"));
-+
-+  isolate->RequestInterrupt(&ReenterRegExp, &d);
-+
-+  i::Handle<i::Object> result = RegExpExec(&d);
-+  CHECK(result->IsNull());
-+}
-+
- #undef CHECK_PARSE_ERROR
- #undef CHECK_SIMPLE
- #undef CHECK_MIN_MAX
diff --git a/patches/v8/regexp_allow_reentrant_irregexp_execution.patch b/patches/v8/regexp_allow_reentrant_irregexp_execution.patch
index 1df91f8bee..fdf648d00b 100644
--- a/patches/v8/regexp_allow_reentrant_irregexp_execution.patch
+++ b/patches/v8/regexp_allow_reentrant_irregexp_execution.patch
@@ -1717,17 +1717,3 @@ index 517a05d93900bd4d13b68e0e2b48061d4801f397..ff9ce0a43daa591343e8cebb25b5fdda
  
    // Labels used internally.
    Label entry_label_;
-diff --git a/test/cctest/cctest.status b/test/cctest/cctest.status
-index d6691b5e861d29100d0f1c15c887dd824f3929cb..8f6df5f58a2989068b4aec95a8ed7e0343e4ded4 100644
---- a/test/cctest/cctest.status
-+++ b/test/cctest/cctest.status
-@@ -126,9 +126,6 @@
-   'test-strings/StringOOM*': [PASS, ['mode == debug', SKIP]],
-   'test-serialize/CustomSnapshotDataBlobImmortalImmovableRoots': [PASS, ['mode == debug', SKIP]],
-   'test-parsing/ObjectRestNegativeTestSlow': [PASS, ['mode == debug', SKIP]],
--
--  # TODO(v8:11382): Reenable once irregexp is reentrant.
--  'test-regexp/RegExpInterruptReentrantExecution': [FAIL],
- }],  # ALWAYS
- 
- ##############################################################################
diff --git a/patches/chromium/cherry-pick-8af66de55aad.patch b/patches/chromium/cherry-pick-8af66de55aad.patch
index 2189c677d3..bfd649811d 100644
--- a/patches/chromium/cherry-pick-8af66de55aad.patch
+++ b/patches/chromium/cherry-pick-8af66de55aad.patch
@@ -110,17 +110,3 @@ index 589580b9795f3908c4f5d978bd4366c98e52847a..40b8af83cdb2dc61b78628c223c0d95f
        required_csp_ = value;
        CSPAttributeChanged();
        UseCounter::Count(GetDocument(), WebFeature::kIFrameCSPAttribute);
-diff --git a/third_party/blink/web_tests/external/wpt/content-security-policy/embedded-enforcement/required_csp-header.html b/third_party/blink/web_tests/external/wpt/content-security-policy/embedded-enforcement/required_csp-header.html
-index a9ad787408786e594ccb554d2bd9186a9e8e7c1e..e0a31db8e28fb1a9d2884c7677597072d4badba2 100644
---- a/third_party/blink/web_tests/external/wpt/content-security-policy/embedded-enforcement/required_csp-header.html
-+++ b/third_party/blink/web_tests/external/wpt/content-security-policy/embedded-enforcement/required_csp-header.html
-@@ -59,6 +59,9 @@
-       { "name": "Wrong and dangerous value of `csp` should not trigger sending Sec-Required-CSP Header - report-to present",
-         "csp": "script-src 'unsafe-inline'; report-to resources/dummy-report.php",
-         "expected": null },
-+      { "name": "Sec-Required-CSP is not sent if `csp` attribute is longer than 4096 bytes",
-+        "csp": "style-src " + Array.from(Array(2044).keys()).map(i => 'a').join(' '),
-+        "expected":  null },
-     ];
- 
-     tests.forEach(test => {
diff --git a/patches/v8/merged_cppgc_fix_marking_of_ephemerons_with_keys_in_construction.patch b/patches/v8/merged_cppgc_fix_marking_of_ephemerons_with_keys_in_construction.patch
index e89bfbbc78..ed20c3e29f 100644
--- a/patches/v8/merged_cppgc_fix_marking_of_ephemerons_with_keys_in_construction.patch
+++ b/patches/v8/merged_cppgc_fix_marking_of_ephemerons_with_keys_in_construction.patch
@@ -86,58 +86,3 @@ index 6e08fc3e10e38e9349f09071f74871a37f93f694..bf1f40bdbde2e985b9d69d64e4936d90
      if (value_desc.base_object_payload) {
        MarkAndPush(value_desc.base_object_payload, value_desc);
      } else {
-diff --git a/test/unittests/heap/cppgc/ephemeron-pair-unittest.cc b/test/unittests/heap/cppgc/ephemeron-pair-unittest.cc
-index 32a5929fe4094aaece314dcd90670c66c4649f02..f5d07c7fd52f9d5acd1e8ff1894f0eb2473b8612 100644
---- a/test/unittests/heap/cppgc/ephemeron-pair-unittest.cc
-+++ b/test/unittests/heap/cppgc/ephemeron-pair-unittest.cc
-@@ -239,5 +239,50 @@ TEST_F(EphemeronPairTest, EphemeronPairWithEmptyMixinValue) {
-   FinishMarking();
- }
- 
-+namespace {
-+
-+class KeyWithCallback final : public GarbageCollected<KeyWithCallback> {
-+ public:
-+  template <typename Callback>
-+  explicit KeyWithCallback(Callback callback) {
-+    callback(this);
-+  }
-+  void Trace(Visitor*) const {}
-+};
-+
-+class EphemeronHolderForKeyWithCallback final
-+    : public GarbageCollected<EphemeronHolderForKeyWithCallback> {
-+ public:
-+  EphemeronHolderForKeyWithCallback(KeyWithCallback* key, GCed* value)
-+      : ephemeron_pair_(key, value) {}
-+  void Trace(cppgc::Visitor* visitor) const { visitor->Trace(ephemeron_pair_); }
-+
-+ private:
-+  const EphemeronPair<KeyWithCallback, GCed> ephemeron_pair_;
-+};
-+
-+}  // namespace
-+
-+TEST_F(EphemeronPairTest, EphemeronPairWithKeyInConstruction) {
-+  GCed* value = MakeGarbageCollected<GCed>(GetAllocationHandle());
-+  Persistent<EphemeronHolderForKeyWithCallback> holder;
-+  InitializeMarker(*Heap::From(GetHeap()), GetPlatformHandle().get());
-+  FinishSteps();
-+  MakeGarbageCollected<KeyWithCallback>(
-+      GetAllocationHandle(), [this, &holder, value](KeyWithCallback* thiz) {
-+        // The test doesn't use conservative stack scanning to retain key to
-+        // avoid retaining value as a side effect.
-+        EXPECT_TRUE(HeapObjectHeader::FromObject(thiz).TryMarkAtomic());
-+        holder = MakeGarbageCollected<EphemeronHolderForKeyWithCallback>(
-+            GetAllocationHandle(), thiz, value);
-+        // Finishing marking at this point will leave an ephemeron pair
-+        // reachable where the key is still in construction. The GC needs to
-+        // mark the value for such pairs as live in the atomic pause as they key
-+        // is considered live.
-+        FinishMarking();
-+      });
-+  EXPECT_TRUE(HeapObjectHeader::FromObject(value).IsMarked());
-+}
-+
- }  // namespace internal
- }  // namespace cppgc
