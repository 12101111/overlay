diff --git a/patches/chromium/a11y_axplatformnodebase_getindexinparent_returns_base_optional.patch b/patches/chromium/a11y_axplatformnodebase_getindexinparent_returns_base_optional.patch
index 5a35a5c0e..dfa406141 100644
--- a/patches/chromium/a11y_axplatformnodebase_getindexinparent_returns_base_optional.patch
+++ b/patches/chromium/a11y_axplatformnodebase_getindexinparent_returns_base_optional.patch
@@ -36,29 +36,6 @@ Reviewed-by: Martin Robinson <mrobinson@igalia.com>
 Reviewed-by: Joanmarie Diggs <jdiggs@igalia.com>
 Cr-Commit-Position: refs/heads/master@{#757381}
 
-diff --git a/content/test/data/accessibility/event/css-flex-text-update-expected-auralinux.txt b/content/test/data/accessibility/event/css-flex-text-update-expected-auralinux.txt
-index c68cfe98572b9b2edf3658053be3dea2040524e4..483d5bb7eb7be40fa0dbd81cb336fe41fe665efe 100644
---- a/content/test/data/accessibility/event/css-flex-text-update-expected-auralinux.txt
-+++ b/content/test/data/accessibility/event/css-flex-text-update-expected-auralinux.txt
-@@ -1,3 +1,3 @@
--CHILDREN-CHANGED index:0 CHILD:(role=ROLE_STATIC) role=ROLE_STATIC ENABLED,SENSITIVE,SHOWING,VISIBLE
-+CHILDREN-CHANGED index:-1 CHILD:(role=ROLE_STATIC) role=ROLE_STATIC ENABLED,SENSITIVE,SHOWING,VISIBLE
- NAME-CHANGED:new role=ROLE_STATIC name='new' ENABLED,SENSITIVE,SHOWING,VISIBLE
- STATE-CHANGE:DEFUNCT:TRUE role=ROLE_INVALID name='(null)' DEFUNCT
-diff --git a/content/test/data/accessibility/event/text-changed-expected-auralinux.txt b/content/test/data/accessibility/event/text-changed-expected-auralinux.txt
-index b1573d5a3e84bc168403ad989632333473a5c0a8..0fe6700c90e82846aa862cc09a567d5ad36bccc6 100644
---- a/content/test/data/accessibility/event/text-changed-expected-auralinux.txt
-+++ b/content/test/data/accessibility/event/text-changed-expected-auralinux.txt
-@@ -1,7 +1,7 @@
-+CHILDREN-CHANGED index:-1 CHILD:(role=ROLE_STATIC) role=ROLE_STATIC ENABLED,SENSITIVE,SHOWING,VISIBLE
-+CHILDREN-CHANGED index:-1 CHILD:(role=ROLE_STATIC) role=ROLE_STATIC ENABLED,SENSITIVE,SHOWING,VISIBLE
- CHILDREN-CHANGED index:0 CHILD:(role=ROLE_STATIC) role=ROLE_PARAGRAPH ENABLED,SENSITIVE,SHOWING,VISIBLE
- CHILDREN-CHANGED index:0 CHILD:(role=ROLE_STATIC) role=ROLE_PARAGRAPH ENABLED,SENSITIVE,SHOWING,VISIBLE
--CHILDREN-CHANGED index:0 CHILD:(role=ROLE_STATIC) role=ROLE_STATIC ENABLED,SENSITIVE,SHOWING,VISIBLE
--CHILDREN-CHANGED index:0 CHILD:(role=ROLE_STATIC) role=ROLE_STATIC ENABLED,SENSITIVE,SHOWING,VISIBLE
- NAME-CHANGED:Modified Div role=ROLE_STATIC name='Modified Div' ENABLED,SENSITIVE,SHOWING,VISIBLE
- NAME-CHANGED:Modified Heading role=ROLE_STATIC name='Modified Heading' ENABLED,SENSITIVE,SHOWING,VISIBLE
- STATE-CHANGE:DEFUNCT:TRUE role=ROLE_INVALID name='(null)' DEFUNCT
 diff --git a/ui/accessibility/platform/ax_platform_node_auralinux.cc b/ui/accessibility/platform/ax_platform_node_auralinux.cc
 index 2f150dbbae32f9faae0f8b55a65133fb333aa5e5..f3e9ab6b2bb8ab0c4a688fe84861fe9d7e766a5a 100644
 --- a/ui/accessibility/platform/ax_platform_node_auralinux.cc
diff --git a/patches/chromium/allow_focus_to_move_into_an_editable_combobox_s_listbox.patch b/patches/chromium/allow_focus_to_move_into_an_editable_combobox_s_listbox.patch
index d0af6721b..058f22ac0 100644
--- a/patches/chromium/allow_focus_to_move_into_an_editable_combobox_s_listbox.patch
+++ b/patches/chromium/allow_focus_to_move_into_an_editable_combobox_s_listbox.patch
@@ -35,81 +35,3 @@ index 33324bbca5953f6f2f9d829e4c7b5d7daa3f49ea..a27cacfd303706ef3ee637107d2de0c8
    // Otherwise, follow the active descendant.
    return GetActiveDescendant(focus);
  }
-diff --git a/content/test/data/accessibility/aria/aria-combobox-expected-mac.txt b/content/test/data/accessibility/aria/aria-combobox-expected-mac.txt
-index d28f2235dedeedab23bf23db0475087c3d3ec73e..9dd9803232490edb95c80abcb2f084b8c42ceb7e 100644
---- a/content/test/data/accessibility/aria/aria-combobox-expected-mac.txt
-+++ b/content/test/data/accessibility/aria/aria-combobox-expected-mac.txt
-@@ -1,7 +1,7 @@
- AXWebArea
- ++AXGroup
- ++++AXStaticText AXValue='State'
--++AXComboBox AXTitle='State' AXAutocompleteValue='list' AXFocused='1'
-+++AXComboBox AXTitle='State' AXAutocompleteValue='list'
- ++AXList
- ++++AXStaticText AXValue='Alabama'
--++++AXStaticText AXValue='Alaska'
-\ No newline at end of file
-+++++AXStaticText AXFocused='1' AXValue='Alaska'
-diff --git a/content/test/data/accessibility/event/aria-combo-box-collapse-expected-mac.txt b/content/test/data/accessibility/event/aria-combo-box-collapse-expected-mac.txt
-index 97c3c417f30812abecdde273f130088df86bd4ae..93ef79e311977bb4277842fa5332f6097faba837 100644
---- a/content/test/data/accessibility/event/aria-combo-box-collapse-expected-mac.txt
-+++ b/content/test/data/accessibility/event/aria-combo-box-collapse-expected-mac.txt
-@@ -1,2 +1,3 @@
- AXExpandedChanged on AXComboBox
--AXSelectedChildrenChanged on AXComboBox
-+AXFocusedUIElementChanged on AXComboBox
-+AXSelectedChildrenChanged on AXComboBox
-\ No newline at end of file
-diff --git a/content/test/data/accessibility/event/aria-combo-box-delay-add-list-expected-mac.txt b/content/test/data/accessibility/event/aria-combo-box-delay-add-list-expected-mac.txt
-index 47ff72a2689baa23600ededfe38d79fd6b5bedcf..f7d4c30f49fe3f3f62132cddf59942181b8127b8 100644
---- a/content/test/data/accessibility/event/aria-combo-box-delay-add-list-expected-mac.txt
-+++ b/content/test/data/accessibility/event/aria-combo-box-delay-add-list-expected-mac.txt
-@@ -1 +1,2 @@
--AXSelectedChildrenChanged on AXComboBox
-+AXFocusedUIElementChanged on AXStaticText AXValue="Apple"
-+AXSelectedChildrenChanged on AXComboBox
-\ No newline at end of file
-diff --git a/content/test/data/accessibility/event/aria-combo-box-delay-show-list-expected-mac.txt b/content/test/data/accessibility/event/aria-combo-box-delay-show-list-expected-mac.txt
-index 47ff72a2689baa23600ededfe38d79fd6b5bedcf..ab757bb0687ff49affcc67076eddd52e18b0eacc 100644
---- a/content/test/data/accessibility/event/aria-combo-box-delay-show-list-expected-mac.txt
-+++ b/content/test/data/accessibility/event/aria-combo-box-delay-show-list-expected-mac.txt
-@@ -1 +1,2 @@
-+AXFocusedUIElementChanged on AXStaticText AXValue="Apple"
- AXSelectedChildrenChanged on AXComboBox
-diff --git a/content/test/data/accessibility/event/aria-combo-box-expand-expected-mac.txt b/content/test/data/accessibility/event/aria-combo-box-expand-expected-mac.txt
-index 97cdb8b8b67d46e0a952d22765c823bd346aef3a..343feae3d79a48981cc1e27015ba2a93423eedc0 100644
---- a/content/test/data/accessibility/event/aria-combo-box-expand-expected-mac.txt
-+++ b/content/test/data/accessibility/event/aria-combo-box-expand-expected-mac.txt
-@@ -1,3 +1,4 @@
- AXExpandedChanged on AXComboBox
-+AXFocusedUIElementChanged on AXStaticText AXValue="Apple"
- AXSelectedChildrenChanged on AXComboBox
--AXSelectedChildrenChanged on AXList
-+AXSelectedChildrenChanged on AXList
-\ No newline at end of file
-diff --git a/content/test/data/accessibility/event/aria-combo-box-focus-expected-mac.txt b/content/test/data/accessibility/event/aria-combo-box-focus-expected-mac.txt
-index 2bfc70f5fecea2c2a5e7268cef641d6d0e7d4a47..ad5e2bf2c8029185c51eecc94cac1dbe7608c99e 100644
---- a/content/test/data/accessibility/event/aria-combo-box-focus-expected-mac.txt
-+++ b/content/test/data/accessibility/event/aria-combo-box-focus-expected-mac.txt
-@@ -1,3 +1,3 @@
--AXFocusedUIElementChanged on AXComboBox
--AXSelectedTextChanged on AXComboBox
--AXSelectedTextChanged on AXWebArea
-+AXFocusedUIElementChanged on AXStaticText AXValue="Apple not selected"
-+AXSelectedTextChanged on AXStaticText AXValue="Apple not selected"
-+AXSelectedTextChanged on AXWebArea
-\ No newline at end of file
-diff --git a/content/test/data/accessibility/event/aria-combo-box-next-expected-mac.txt b/content/test/data/accessibility/event/aria-combo-box-next-expected-mac.txt
-index d5f21183c3d0a1c24cb6665194a93c3299dbfd56..9e7d0c0aaeb1c52dc1f1b3afed36f287851b89ff 100644
---- a/content/test/data/accessibility/event/aria-combo-box-next-expected-mac.txt
-+++ b/content/test/data/accessibility/event/aria-combo-box-next-expected-mac.txt
-@@ -1,5 +1,7 @@
-+AXFocusedUIElementChanged on AXStaticText AXValue="Orange"
- AXSelectedChildrenChanged on AXComboBox
- AXSelectedChildrenChanged on AXList
- === Start Continuation ===
-+AXFocusedUIElementChanged on AXStaticText AXValue="Banana"
- AXSelectedChildrenChanged on AXComboBox
--AXSelectedChildrenChanged on AXList
-+AXSelectedChildrenChanged on AXList
-\ No newline at end of file
diff --git a/patches/v8/wasm_do_not_log_code_of_functions_whose_module_is_not_fully_loaded.patch b/patches/v8/wasm_do_not_log_code_of_functions_whose_module_is_not_fully_loaded.patch
index fc1234d6f..4e76cbad2 100644
--- a/patches/v8/wasm_do_not_log_code_of_functions_whose_module_is_not_fully_loaded.patch
+++ b/patches/v8/wasm_do_not_log_code_of_functions_whose_module_is_not_fully_loaded.patch
@@ -101,56 +101,4 @@ index 4b176f3ba61bcdfb922c5f5cbb92981d79393ffa..6960c224c32d3c8b237f973ecc399c49
    void SetWireBytes(OwnedVector<const uint8_t> wire_bytes);
  
    WasmCode* Lookup(Address) const;
-diff --git a/test/cctest/wasm/test-streaming-compilation.cc b/test/cctest/wasm/test-streaming-compilation.cc
-index 4d3f83daff766edb96d25934bb7ab5564f193046..87da8ea1d62b14f792e9525f5707fb4b4e05cd94 100644
---- a/test/cctest/wasm/test-streaming-compilation.cc
-+++ b/test/cctest/wasm/test-streaming-compilation.cc
-@@ -1248,6 +1248,48 @@ STREAM_TEST(TestSetModuleCodeSection) {
-   CHECK(tester.IsPromiseFulfilled());
- }
- 
-+// Test that profiler does not crash when module is only partly compiled.
-+STREAM_TEST(TestProfilingMidStreaming) {
-+  StreamTester tester;
-+  v8::Isolate* isolate = CcTest::isolate();
-+  Isolate* i_isolate = CcTest::i_isolate();
-+  Zone* zone = tester.zone();
-+
-+  // Build module with one exported (named) function.
-+  ZoneBuffer buffer(zone);
-+  {
-+    TestSignatures sigs;
-+    WasmModuleBuilder builder(zone);
-+    WasmFunctionBuilder* f = builder.AddFunction(sigs.v_v());
-+    uint8_t code[] = {kExprEnd};
-+    f->EmitCode(code, arraysize(code));
-+    builder.AddExport(VectorOf("foo", 3), f);
-+    builder.WriteTo(&buffer);
-+  }
-+
-+  // Start profiler to force code logging.
-+  v8::CpuProfiler* cpu_profiler = v8::CpuProfiler::New(isolate);
-+  v8::CpuProfilingOptions profile_options;
-+  cpu_profiler->StartProfiling(v8::String::Empty(isolate), profile_options);
-+
-+  // Send incomplete wire bytes and start compilation.
-+  tester.OnBytesReceived(buffer.begin(), buffer.end() - buffer.begin());
-+  tester.RunCompilerTasks();
-+
-+  // Trigger code logging explicitly like the profiler would do.
-+  CHECK(WasmCode::ShouldBeLogged(i_isolate));
-+  i_isolate->wasm_engine()->LogOutstandingCodesForIsolate(i_isolate);
-+  CHECK(tester.IsPromisePending());
-+
-+  // Finalize stream, stop profiler and clean up.
-+  tester.FinishStream();
-+  CHECK(tester.IsPromiseFulfilled());
-+  v8::CpuProfile* profile =
-+      cpu_profiler->StopProfiling(v8::String::Empty(isolate));
-+  profile->Delete();
-+  cpu_profiler->Dispose();
-+}
-+
- #undef STREAM_TEST
- 
- }  // namespace wasm
+
diff --git a/patches/v8/cherry-pick-146bd99e762b.patch b/patches/v8/cherry-pick-146bd99e762b.patch
index e5dbf970c..d45ac851e 100644
--- a/patches/v8/cherry-pick-146bd99e762b.patch
+++ b/patches/v8/cherry-pick-146bd99e762b.patch
@@ -65,230 +65,3 @@ index 2dc288628c8ea69d425e3b86e63e151157b9f925..1799cff1a2284c9b0d7cdaec99d0c310
    set_is_deprecated(true);
    if (FLAG_trace_maps) {
      LOG(isolate, MapEvent("Deprecate", handle(*this, isolate), Handle<Map>()));
-diff --git a/test/cctest/test-field-type-tracking.cc b/test/cctest/test-field-type-tracking.cc
-index 840478a5203847f331f792eae7125a60396f896a..7abbcbde350a08bbb7d364c15184bc896607848b 100644
---- a/test/cctest/test-field-type-tracking.cc
-+++ b/test/cctest/test-field-type-tracking.cc
-@@ -1019,7 +1019,8 @@ namespace {
- // where "p2A" and "p2B" differ only in the attributes.
- //
- void TestReconfigureDataFieldAttribute_GeneralizeField(
--    const CRFTData& from, const CRFTData& to, const CRFTData& expected) {
-+    const CRFTData& from, const CRFTData& to, const CRFTData& expected,
-+    bool expected_deprecation) {
-   Isolate* isolate = CcTest::i_isolate();
- 
-   Expectations expectations(isolate);
-@@ -1079,22 +1080,26 @@ void TestReconfigureDataFieldAttribute_GeneralizeField(
-   CHECK_NE(*map2, *new_map);
-   CHECK(expectations2.Check(*map2));
- 
--  // |map| should be deprecated and |new_map| should match new expectations.
-   for (int i = kSplitProp; i < kPropCount; i++) {
-     expectations.SetDataField(i, expected.constness, expected.representation,
-                               expected.type);
-   }
--  CHECK(map->is_deprecated());
--  CHECK(!code->marked_for_deoptimization());
--  CHECK_NE(*map, *new_map);
-+  if (expected_deprecation) {
-+    CHECK(map->is_deprecated());
-+    CHECK(!code->marked_for_deoptimization());
-+    CHECK_NE(*map, *new_map);
- 
--  CHECK(!new_map->is_deprecated());
--  CHECK(expectations.Check(*new_map));
-+    CHECK(!new_map->is_deprecated());
-+    CHECK(expectations.Check(*new_map));
- 
--  // Update deprecated |map|, it should become |new_map|.
--  Handle<Map> updated_map = Map::Update(isolate, map);
--  CHECK_EQ(*new_map, *updated_map);
--  CheckMigrationTarget(isolate, *map, *updated_map);
-+    // Update deprecated |map|, it should become |new_map|.
-+    Handle<Map> updated_map = Map::Update(isolate, map);
-+    CHECK_EQ(*new_map, *updated_map);
-+    CheckMigrationTarget(isolate, *map, *updated_map);
-+  } else {
-+    CHECK(!map->is_deprecated());
-+    CHECK(expectations.Check(*map));
-+  }
- }
- 
- // This test ensures that trivial field generalization (from HeapObject to
-@@ -1200,22 +1205,22 @@ TEST(ReconfigureDataFieldAttribute_GeneralizeSmiFieldToDouble) {
-   TestReconfigureDataFieldAttribute_GeneralizeField(
-       {PropertyConstness::kConst, Representation::Smi(), any_type},
-       {PropertyConstness::kConst, Representation::Double(), any_type},
--      {PropertyConstness::kConst, Representation::Double(), any_type});
-+      {PropertyConstness::kConst, Representation::Double(), any_type}, true);
- 
-   TestReconfigureDataFieldAttribute_GeneralizeField(
-       {PropertyConstness::kConst, Representation::Smi(), any_type},
-       {PropertyConstness::kMutable, Representation::Double(), any_type},
--      {PropertyConstness::kMutable, Representation::Double(), any_type});
-+      {PropertyConstness::kMutable, Representation::Double(), any_type}, true);
- 
-   TestReconfigureDataFieldAttribute_GeneralizeField(
-       {PropertyConstness::kMutable, Representation::Smi(), any_type},
-       {PropertyConstness::kConst, Representation::Double(), any_type},
--      {PropertyConstness::kMutable, Representation::Double(), any_type});
-+      {PropertyConstness::kMutable, Representation::Double(), any_type}, true);
- 
-   TestReconfigureDataFieldAttribute_GeneralizeField(
-       {PropertyConstness::kMutable, Representation::Smi(), any_type},
-       {PropertyConstness::kMutable, Representation::Double(), any_type},
--      {PropertyConstness::kMutable, Representation::Double(), any_type});
-+      {PropertyConstness::kMutable, Representation::Double(), any_type}, true);
- }
- 
- TEST(ReconfigureDataFieldAttribute_GeneralizeSmiFieldToTagged) {
-@@ -1230,22 +1235,26 @@ TEST(ReconfigureDataFieldAttribute_GeneralizeSmiFieldToTagged) {
-   TestReconfigureDataFieldAttribute_GeneralizeField(
-       {PropertyConstness::kConst, Representation::Smi(), any_type},
-       {PropertyConstness::kConst, Representation::HeapObject(), value_type},
--      {PropertyConstness::kConst, Representation::Tagged(), any_type});
-+      {PropertyConstness::kConst, Representation::Tagged(), any_type},
-+      !FLAG_modify_field_representation_inplace);
- 
-   TestReconfigureDataFieldAttribute_GeneralizeField(
-       {PropertyConstness::kConst, Representation::Smi(), any_type},
-       {PropertyConstness::kMutable, Representation::HeapObject(), value_type},
--      {PropertyConstness::kMutable, Representation::Tagged(), any_type});
-+      {PropertyConstness::kMutable, Representation::Tagged(), any_type},
-+      !FLAG_modify_field_representation_inplace);
- 
-   TestReconfigureDataFieldAttribute_GeneralizeField(
-       {PropertyConstness::kMutable, Representation::Smi(), any_type},
-       {PropertyConstness::kConst, Representation::HeapObject(), value_type},
--      {PropertyConstness::kMutable, Representation::Tagged(), any_type});
-+      {PropertyConstness::kMutable, Representation::Tagged(), any_type},
-+      !FLAG_modify_field_representation_inplace);
- 
-   TestReconfigureDataFieldAttribute_GeneralizeField(
-       {PropertyConstness::kMutable, Representation::Smi(), any_type},
-       {PropertyConstness::kMutable, Representation::HeapObject(), value_type},
--      {PropertyConstness::kMutable, Representation::Tagged(), any_type});
-+      {PropertyConstness::kMutable, Representation::Tagged(), any_type},
-+      !FLAG_modify_field_representation_inplace);
- }
- 
- TEST(ReconfigureDataFieldAttribute_GeneralizeDoubleFieldToTagged) {
-@@ -1260,22 +1269,26 @@ TEST(ReconfigureDataFieldAttribute_GeneralizeDoubleFieldToTagged) {
-   TestReconfigureDataFieldAttribute_GeneralizeField(
-       {PropertyConstness::kConst, Representation::Double(), any_type},
-       {PropertyConstness::kConst, Representation::HeapObject(), value_type},
--      {PropertyConstness::kConst, Representation::Tagged(), any_type});
-+      {PropertyConstness::kConst, Representation::Tagged(), any_type},
-+      FLAG_unbox_double_fields || !FLAG_modify_field_representation_inplace);
- 
-   TestReconfigureDataFieldAttribute_GeneralizeField(
-       {PropertyConstness::kConst, Representation::Double(), any_type},
-       {PropertyConstness::kMutable, Representation::HeapObject(), value_type},
--      {PropertyConstness::kMutable, Representation::Tagged(), any_type});
-+      {PropertyConstness::kMutable, Representation::Tagged(), any_type},
-+      FLAG_unbox_double_fields || !FLAG_modify_field_representation_inplace);
- 
-   TestReconfigureDataFieldAttribute_GeneralizeField(
-       {PropertyConstness::kMutable, Representation::Double(), any_type},
-       {PropertyConstness::kConst, Representation::HeapObject(), value_type},
--      {PropertyConstness::kMutable, Representation::Tagged(), any_type});
-+      {PropertyConstness::kMutable, Representation::Tagged(), any_type},
-+      FLAG_unbox_double_fields || !FLAG_modify_field_representation_inplace);
- 
-   TestReconfigureDataFieldAttribute_GeneralizeField(
-       {PropertyConstness::kMutable, Representation::Double(), any_type},
-       {PropertyConstness::kMutable, Representation::HeapObject(), value_type},
--      {PropertyConstness::kMutable, Representation::Tagged(), any_type});
-+      {PropertyConstness::kMutable, Representation::Tagged(), any_type},
-+      FLAG_unbox_double_fields || !FLAG_modify_field_representation_inplace);
- }
- 
- TEST(ReconfigureDataFieldAttribute_GeneralizeHeapObjFieldToHeapObj) {
-@@ -1361,7 +1374,8 @@ TEST(ReconfigureDataFieldAttribute_GeneralizeHeapObjectFieldToTagged) {
-   TestReconfigureDataFieldAttribute_GeneralizeField(
-       {PropertyConstness::kMutable, Representation::HeapObject(), value_type},
-       {PropertyConstness::kMutable, Representation::Smi(), any_type},
--      {PropertyConstness::kMutable, Representation::Tagged(), any_type});
-+      {PropertyConstness::kMutable, Representation::Tagged(), any_type},
-+      !FLAG_modify_field_representation_inplace);
- }
- 
- 
-diff --git a/test/mjsunit/regress/regress-1143772.js b/test/mjsunit/regress/regress-1143772.js
-new file mode 100644
-index 0000000000000000000000000000000000000000..40bc494d458afec816fd72e3fbb36b20a7942649
---- /dev/null
-+++ b/test/mjsunit/regress/regress-1143772.js
-@@ -0,0 +1,71 @@
-+// Copyright 2020 the V8 project authors. All rights reserved.
-+// Use of this source code is governed by a BSD-style license that can be
-+// found in the LICENSE file.
-+//
-+// Flags: --allow-natives-syntax
-+
-+(function() {
-+    // Only run this test if doubles are transitioned in-place to tagged.
-+    let x = {};
-+    x.a = 0.1;
-+    let y = {};
-+    y.a = {};
-+    if (!%HaveSameMap(x, y)) return;
-+
-+    // m1: {}
-+    let m1 = {};
-+
-+    // m2: {a:d}
-+    let m2 = {};
-+    assertTrue(%HaveSameMap(m2, m1));
-+    m2.a = 13.37;
-+
-+    // m3: {a:d, b:s}
-+    let m3 = {};
-+    m3.a = 13.37;
-+    assertTrue(%HaveSameMap(m3, m2));
-+    m3.b = 1;
-+
-+    // m4: {a:d, b:s, c:h}
-+    let m4 = {};
-+    m4.a = 13.37;
-+    m4.b = 1;
-+    assertTrue(%HaveSameMap(m4, m3));
-+    m4.c = {};
-+
-+    // m4_2 == m4
-+    let m4_2 = {};
-+    m4_2.a = 13.37;
-+    m4_2.b = 1;
-+    m4_2.c = {};
-+    assertTrue(%HaveSameMap(m4_2, m4));
-+
-+    // m5: {a:d, b:d}
-+    let m5 = {};
-+    m5.a = 13.37;
-+    assertTrue(%HaveSameMap(m5, m2));
-+    m5.b = 13.37;
-+    assertFalse(%HaveSameMap(m5, m3));
-+
-+    // At this point, Map3 and Map4 are both deprecated. Map2 transitions to
-+    // Map5. Map5 is the migration target for Map3.
-+    assertFalse(%HaveSameMap(m5, m3));
-+
-+    // m6: {a:d, b:d, c:d}
-+    let m6 = {};
-+    m6.a = 13.37;
-+    assertTrue(%HaveSameMap(m6, m2));
-+    m6.b = 13.37;
-+    assertTrue(%HaveSameMap(m6, m5));
-+    m6.c = 13.37
-+
-+    // Make m7: {a:d, b:d, c:t}
-+    let m7 = m4_2;
-+    assertTrue(%HaveSameMap(m7, m4));
-+    // Map4 is deprecated, so this property access triggers a Map migration.
-+    // With in-place map updates and no double unboxing, this should end up
-+    // migrating to Map6, and updating it in-place.
-+    m7.c;
-+    assertFalse(%HaveSameMap(m7, m4));
-+    assertTrue(%HaveSameMap(m6, m7));
-+})();
diff --git a/patches/v8/cherry-pick-815b12dfb5ec.patch b/patches/v8/cherry-pick-815b12dfb5ec.patch
index 9c1588dc1..e2093a04e 100644
--- a/patches/v8/cherry-pick-815b12dfb5ec.patch
+++ b/patches/v8/cherry-pick-815b12dfb5ec.patch
@@ -361,458 +361,3 @@ index 5a7db13e516cf9be9314cf99f274145d21090f64..055bf41c9144197288bd7d9eb0275adb
  
    // Search a non-property transition (like elements kind, observe or frozen
    // transitions).
-diff --git a/test/cctest/BUILD.gn b/test/cctest/BUILD.gn
-index 89fe36f65b681d420a6d9b4d964ca0bc60c7a0be..983ec3c8c31cbb2374503c047bf9f41e44eeda8c 100644
---- a/test/cctest/BUILD.gn
-+++ b/test/cctest/BUILD.gn
-@@ -194,6 +194,7 @@ v8_source_set("cctest_sources") {
-     "test-debug.cc",
-     "test-decls.cc",
-     "test-deoptimization.cc",
-+    "test-descriptor-array.cc",
-     "test-dictionary.cc",
-     "test-diy-fp.cc",
-     "test-double.cc",
-diff --git a/test/cctest/test-descriptor-array.cc b/test/cctest/test-descriptor-array.cc
-new file mode 100644
-index 0000000000000000000000000000000000000000..7abd36ec6c84959c3da59b8e78d9e4a0ee291632
---- /dev/null
-+++ b/test/cctest/test-descriptor-array.cc
-@@ -0,0 +1,424 @@
-+// Copyright 2020 the V8 project authors. All rights reserved.
-+// Use of this source code is governed by a BSD-style license that can be
-+// found in the LICENSE file.
-+
-+#include "src/base/logging.h"
-+#include "src/codegen/code-stub-assembler.h"
-+#include "src/common/globals.h"
-+#include "src/objects/descriptor-array.h"
-+#include "src/objects/property-details.h"
-+#include "src/objects/string-inl.h"
-+#include "src/objects/transitions-inl.h"
-+#include "test/cctest/cctest.h"
-+#include "test/cctest/compiler/code-assembler-tester.h"
-+#include "test/cctest/compiler/function-tester.h"
-+#include "test/cctest/test-transitions.h"
-+
-+namespace v8 {
-+namespace internal {
-+
-+namespace {
-+
-+using Label = compiler::CodeAssemblerLabel;
-+template <class T>
-+using TVariable = compiler::TypedCodeAssemblerVariable<T>;
-+
-+Handle<Name> NewNameWithHash(Isolate* isolate, const char* str, uint32_t hash,
-+                             bool is_integer) {
-+  uint32_t hash_field = hash << Name::kHashShift;
-+
-+  static_assert(Name::kNofHashBitFields == 2, "This test needs updating");
-+  static_assert(Name::kHashNotComputedMask == 1, "This test needs updating");
-+  static_assert(Name::kIsNotIntegerIndexMask == 2, "This test needs updating");
-+
-+  if (!is_integer) {
-+    hash_field |= Name::kIsNotIntegerIndexMask;
-+  }
-+  Handle<Name> name = isolate->factory()->NewOneByteInternalizedString(
-+      OneByteVector(str), hash_field);
-+  name->set_hash_field(hash_field);
-+  CHECK(name->IsUniqueName());
-+  return name;
-+}
-+
-+template <typename... Args>
-+MaybeHandle<Object> Call(Isolate* isolate, Handle<JSFunction> function,
-+                         Args... args) {
-+  const int nof_args = sizeof...(Args);
-+  Handle<Object> call_args[] = {args...};
-+  Handle<Object> receiver = isolate->factory()->undefined_value();
-+  return Execution::Call(isolate, function, receiver, nof_args, call_args);
-+}
-+
-+void CheckDescriptorArrayLookups(Isolate* isolate, Handle<Map> map,
-+                                 std::vector<Handle<Name>>& names,
-+                                 Handle<JSFunction> csa_lookup) {
-+  // Test C++ implementation.
-+  {
-+    DisallowHeapAllocation no_gc;
-+    DescriptorArray descriptors = map->instance_descriptors();
-+    DCHECK(descriptors.IsSortedNoDuplicates());
-+    int nof_descriptors = descriptors.number_of_descriptors();
-+
-+    for (size_t i = 0; i < names.size(); ++i) {
-+      Name name = *names[i];
-+      InternalIndex index = descriptors.Search(name, nof_descriptors, false);
-+      CHECK(index.is_found());
-+      CHECK_EQ(i, index.as_uint32());
-+    }
-+  }
-+
-+  // Test CSA implementation.
-+  if (!FLAG_jitless) {
-+    for (size_t i = 0; i < names.size(); ++i) {
-+      Handle<Object> name_index =
-+          Call(isolate, csa_lookup, map, names[i]).ToHandleChecked();
-+      CHECK(name_index->IsSmi());
-+      CHECK_EQ(DescriptorArray::ToKeyIndex(static_cast<int>(i)),
-+               Smi::ToInt(*name_index));
-+    }
-+  }
-+}
-+
-+void CheckTransitionArrayLookups(Isolate* isolate,
-+                                 Handle<TransitionArray> transitions,
-+                                 std::vector<Handle<Map>>& maps,
-+                                 Handle<JSFunction> csa_lookup) {
-+  // Test C++ implementation.
-+  {
-+    DisallowHeapAllocation no_gc;
-+    DCHECK(transitions->IsSortedNoDuplicates());
-+
-+    for (size_t i = 0; i < maps.size(); ++i) {
-+      Map expected_map = *maps[i];
-+      Name name =
-+          expected_map.instance_descriptors().GetKey(expected_map.LastAdded());
-+
-+      Map map = transitions->SearchAndGetTargetForTesting(PropertyKind::kData,
-+                                                          name, NONE);
-+      CHECK(!map.is_null());
-+      CHECK_EQ(expected_map, map);
-+    }
-+  }
-+
-+  // Test CSA implementation.
-+  if (!FLAG_jitless) {
-+    for (size_t i = 0; i < maps.size(); ++i) {
-+      Handle<Map> expected_map = maps[i];
-+      Handle<Name> name(expected_map->instance_descriptors().GetKey(
-+                            expected_map->LastAdded()),
-+                        isolate);
-+
-+      Handle<Object> transition_map =
-+          Call(isolate, csa_lookup, transitions, name).ToHandleChecked();
-+      CHECK(transition_map->IsMap());
-+      CHECK_EQ(*expected_map, *transition_map);
-+    }
-+  }
-+}
-+
-+// Creates function with (Map, Name) arguments. Returns Smi with the index of
-+// the name value of the found descriptor (DescriptorArray::ToKeyIndex())
-+// or null otherwise.
-+Handle<JSFunction> CreateCsaDescriptorArrayLookup(Isolate* isolate) {
-+  // We are not allowed to generate code in jitless mode.
-+  if (FLAG_jitless) return Handle<JSFunction>();
-+
-+  // Preallocate handle for the result in the current handle scope.
-+  Handle<JSFunction> result_function(JSFunction{}, isolate);
-+
-+  const int kNumParams = 2;
-+
-+  compiler::CodeAssemblerTester asm_tester(
-+      isolate, kNumParams + 1,  // +1 to include receiver.
-+      CodeKind::STUB);
-+  {
-+    CodeStubAssembler m(asm_tester.state());
-+
-+    TNode<Map> map = m.CAST(m.Parameter(1));
-+    TNode<Name> unique_name = m.CAST(m.Parameter(2));
-+
-+    Label passed(&m), failed(&m);
-+    Label if_found(&m), if_not_found(&m);
-+    TVariable<IntPtrT> var_name_index(&m);
-+
-+    TNode<Uint32T> bit_field3 = m.LoadMapBitField3(map);
-+    TNode<DescriptorArray> descriptors = m.LoadMapDescriptors(map);
-+
-+    m.DescriptorLookup(unique_name, descriptors, bit_field3, &if_found,
-+                       &var_name_index, &if_not_found);
-+
-+    m.BIND(&if_found);
-+    m.Return(m.SmiTag(var_name_index.value()));
-+
-+    m.BIND(&if_not_found);
-+    m.Return(m.NullConstant());
-+  }
-+
-+  {
-+    compiler::FunctionTester ft(asm_tester.GenerateCode(), kNumParams);
-+    // Copy function value to a handle created in the outer handle scope.
-+    *(result_function.location()) = ft.function->ptr();
-+  }
-+
-+  return result_function;
-+}
-+
-+// Creates function with (TransitionArray, Name) arguments. Returns transition
-+// map if transition is found or null otherwise.
-+Handle<JSFunction> CreateCsaTransitionArrayLookup(Isolate* isolate) {
-+  // We are not allowed to generate code in jitless mode.
-+  if (FLAG_jitless) return Handle<JSFunction>();
-+
-+  // Preallocate handle for the result in the current handle scope.
-+  Handle<JSFunction> result_function(JSFunction{}, isolate);
-+
-+  const int kNumParams = 2;
-+  compiler::CodeAssemblerTester asm_tester(
-+      isolate, kNumParams + 1,  // +1 to include receiver.
-+      CodeKind::STUB);
-+  {
-+    CodeStubAssembler m(asm_tester.state());
-+
-+    TNode<TransitionArray> transitions = m.CAST(m.Parameter(1));
-+    TNode<Name> unique_name = m.CAST(m.Parameter(2));
-+
-+    Label passed(&m), failed(&m);
-+    Label if_found(&m), if_not_found(&m);
-+    TVariable<IntPtrT> var_name_index(&m);
-+
-+    m.TransitionLookup(unique_name, transitions, &if_found, &var_name_index,
-+                       &if_not_found);
-+
-+    m.BIND(&if_found);
-+    {
-+      STATIC_ASSERT(kData == 0);
-+      STATIC_ASSERT(NONE == 0);
-+      const int kKeyToTargetOffset = (TransitionArray::kEntryTargetIndex -
-+                                      TransitionArray::kEntryKeyIndex) *
-+                                     kTaggedSize;
-+      TNode<Map> transition_map = m.CAST(m.GetHeapObjectAssumeWeak(
-+          m.LoadArrayElement(transitions, WeakFixedArray::kHeaderSize,
-+                             var_name_index.value(), kKeyToTargetOffset)));
-+      m.Return(transition_map);
-+    }
-+
-+    m.BIND(&if_not_found);
-+    m.Return(m.NullConstant());
-+  }
-+
-+  {
-+    compiler::FunctionTester ft(asm_tester.GenerateCode(), kNumParams);
-+    // Copy function value to a handle created in the outer handle scope.
-+    *(result_function.location()) = ft.function->ptr();
-+  }
-+
-+  return result_function;
-+}
-+
-+}  // namespace
-+
-+TEST(DescriptorArrayHashCollisionMassive) {
-+  CcTest::InitializeVM();
-+  Isolate* isolate = CcTest::i_isolate();
-+  HandleScope handle_scope(isolate);
-+
-+  static_assert(Name::kNofHashBitFields == 2, "This test needs updating");
-+
-+  std::vector<Handle<Name>> names;
-+
-+  // Use the same hash value for all names.
-+  uint32_t hash =
-+      static_cast<uint32_t>(isolate->GenerateIdentityHash(Name::kHashBitMask));
-+
-+  for (int i = 0; i < kMaxNumberOfDescriptors / 2; ++i) {
-+    // Add pairs of names having the same base hash value but having different
-+    // values of is_integer bit.
-+    bool first_is_integer = (i & 1) != 0;
-+    bool second_is_integer = (i & 2) != 0;
-+
-+    names.push_back(NewNameWithHash(isolate, "a", hash, first_is_integer));
-+    names.push_back(NewNameWithHash(isolate, "b", hash, second_is_integer));
-+  }
-+
-+  // Create descriptor array with the created names by appending fields to some
-+  // map. DescriptorArray marking relies on the fact that it's attached to an
-+  // owning map.
-+  Handle<Map> map = Map::Create(isolate, 0);
-+
-+  Handle<FieldType> any_type = FieldType::Any(isolate);
-+
-+  for (size_t i = 0; i < names.size(); ++i) {
-+    map = Map::CopyWithField(isolate, map, names[i], any_type, NONE,
-+                             PropertyConstness::kMutable,
-+                             Representation::Tagged(), OMIT_TRANSITION)
-+              .ToHandleChecked();
-+  }
-+
-+  Handle<JSFunction> csa_lookup = CreateCsaDescriptorArrayLookup(isolate);
-+
-+  CheckDescriptorArrayLookups(isolate, map, names, csa_lookup);
-+
-+  // Sort descriptor array and check it again.
-+  map->instance_descriptors().Sort();
-+  CheckDescriptorArrayLookups(isolate, map, names, csa_lookup);
-+}
-+
-+TEST(DescriptorArrayHashCollision) {
-+  CcTest::InitializeVM();
-+  Isolate* isolate = CcTest::i_isolate();
-+  HandleScope handle_scope(isolate);
-+
-+  static_assert(Name::kNofHashBitFields == 2, "This test needs updating");
-+
-+  std::vector<Handle<Name>> names;
-+  uint32_t hash = 0;
-+
-+  for (int i = 0; i < kMaxNumberOfDescriptors / 2; ++i) {
-+    if (i % 2 == 0) {
-+      // Change hash value for every pair of names.
-+      hash = static_cast<uint32_t>(
-+          isolate->GenerateIdentityHash(Name::kHashBitMask));
-+    }
-+
-+    // Add pairs of names having the same base hash value but having different
-+    // values of is_integer bit.
-+    bool first_is_integer = (i & 1) != 0;
-+    bool second_is_integer = (i & 2) != 0;
-+
-+    names.push_back(NewNameWithHash(isolate, "a", hash, first_is_integer));
-+    names.push_back(NewNameWithHash(isolate, "b", hash, second_is_integer));
-+  }
-+
-+  // Create descriptor array with the created names by appending fields to some
-+  // map. DescriptorArray marking relies on the fact that it's attached to an
-+  // owning map.
-+  Handle<Map> map = Map::Create(isolate, 0);
-+
-+  Handle<FieldType> any_type = FieldType::Any(isolate);
-+
-+  for (size_t i = 0; i < names.size(); ++i) {
-+    map = Map::CopyWithField(isolate, map, names[i], any_type, NONE,
-+                             PropertyConstness::kMutable,
-+                             Representation::Tagged(), OMIT_TRANSITION)
-+              .ToHandleChecked();
-+  }
-+
-+  Handle<JSFunction> csa_lookup = CreateCsaDescriptorArrayLookup(isolate);
-+
-+  CheckDescriptorArrayLookups(isolate, map, names, csa_lookup);
-+
-+  // Sort descriptor array and check it again.
-+  map->instance_descriptors().Sort();
-+  CheckDescriptorArrayLookups(isolate, map, names, csa_lookup);
-+}
-+
-+TEST(TransitionArrayHashCollisionMassive) {
-+  CcTest::InitializeVM();
-+  Isolate* isolate = CcTest::i_isolate();
-+  HandleScope handle_scope(isolate);
-+
-+  static_assert(Name::kNofHashBitFields == 2, "This test needs updating");
-+
-+  std::vector<Handle<Name>> names;
-+
-+  // Use the same hash value for all names.
-+  uint32_t hash =
-+      static_cast<uint32_t>(isolate->GenerateIdentityHash(Name::kHashBitMask));
-+
-+  for (int i = 0; i < TransitionsAccessor::kMaxNumberOfTransitions / 2; ++i) {
-+    // Add pairs of names having the same base hash value but having different
-+    // values of is_integer bit.
-+    bool first_is_integer = (i & 1) != 0;
-+    bool second_is_integer = (i & 2) != 0;
-+
-+    names.push_back(NewNameWithHash(isolate, "a", hash, first_is_integer));
-+    names.push_back(NewNameWithHash(isolate, "b", hash, second_is_integer));
-+  }
-+
-+  // Create transitions for each name.
-+  Handle<Map> root_map = Map::Create(isolate, 0);
-+
-+  std::vector<Handle<Map>> maps;
-+
-+  Handle<FieldType> any_type = FieldType::Any(isolate);
-+
-+  for (size_t i = 0; i < names.size(); ++i) {
-+    Handle<Map> map =
-+        Map::CopyWithField(isolate, root_map, names[i], any_type, NONE,
-+                           PropertyConstness::kMutable,
-+                           Representation::Tagged(), INSERT_TRANSITION)
-+            .ToHandleChecked();
-+    maps.push_back(map);
-+  }
-+
-+  Handle<JSFunction> csa_lookup = CreateCsaTransitionArrayLookup(isolate);
-+
-+  Handle<TransitionArray> transition_array(
-+      TestTransitionsAccessor(isolate, root_map).transitions(), isolate);
-+
-+  CheckTransitionArrayLookups(isolate, transition_array, maps, csa_lookup);
-+
-+  // Sort transition array and check it again.
-+  transition_array->Sort();
-+  CheckTransitionArrayLookups(isolate, transition_array, maps, csa_lookup);
-+}
-+
-+TEST(TransitionArrayHashCollision) {
-+  CcTest::InitializeVM();
-+  Isolate* isolate = CcTest::i_isolate();
-+  HandleScope handle_scope(isolate);
-+
-+  static_assert(Name::kNofHashBitFields == 2, "This test needs updating");
-+
-+  std::vector<Handle<Name>> names;
-+
-+  // Use the same hash value for all names.
-+  uint32_t hash =
-+      static_cast<uint32_t>(isolate->GenerateIdentityHash(Name::kHashBitMask));
-+
-+  for (int i = 0; i < TransitionsAccessor::kMaxNumberOfTransitions / 2; ++i) {
-+    if (i % 2 == 0) {
-+      // Change hash value for every pair of names.
-+      hash = static_cast<uint32_t>(
-+          isolate->GenerateIdentityHash(Name::kHashBitMask));
-+    }
-+    // Add pairs of names having the same base hash value but having different
-+    // values of is_integer bit.
-+    bool first_is_integer = (i & 1) != 0;
-+    bool second_is_integer = (i & 2) != 0;
-+
-+    names.push_back(NewNameWithHash(isolate, "a", hash, first_is_integer));
-+    names.push_back(NewNameWithHash(isolate, "b", hash, second_is_integer));
-+  }
-+
-+  // Create transitions for each name.
-+  Handle<Map> root_map = Map::Create(isolate, 0);
-+
-+  std::vector<Handle<Map>> maps;
-+
-+  Handle<FieldType> any_type = FieldType::Any(isolate);
-+
-+  for (size_t i = 0; i < names.size(); ++i) {
-+    Handle<Map> map =
-+        Map::CopyWithField(isolate, root_map, names[i], any_type, NONE,
-+                           PropertyConstness::kMutable,
-+                           Representation::Tagged(), INSERT_TRANSITION)
-+            .ToHandleChecked();
-+    maps.push_back(map);
-+  }
-+
-+  Handle<JSFunction> csa_lookup = CreateCsaTransitionArrayLookup(isolate);
-+
-+  Handle<TransitionArray> transition_array(
-+      TestTransitionsAccessor(isolate, root_map).transitions(), isolate);
-+
-+  CheckTransitionArrayLookups(isolate, transition_array, maps, csa_lookup);
-+
-+  // Sort transition array and check it again.
-+  transition_array->Sort();
-+  CheckTransitionArrayLookups(isolate, transition_array, maps, csa_lookup);
-+}
-+
-+}  // namespace internal
-+}  // namespace v8
-diff --git a/test/cctest/test-transitions.h b/test/cctest/test-transitions.h
-index 724eb3d3c544b5e9535e7a1b14d95eccec34f4cc..66bbbfa76dd7c2aa4c84363a69705d2564fee8a6 100644
---- a/test/cctest/test-transitions.h
-+++ b/test/cctest/test-transitions.h
-@@ -24,6 +24,8 @@ class TestTransitionsAccessor : public TransitionsAccessor {
-   bool IsFullTransitionArrayEncoding() {
-     return encoding() == kFullTransitionArray;
-   }
-+
-+  TransitionArray transitions() { return TransitionsAccessor::transitions(); }
- };
- 
- }  // namespace internal
diff --git a/patches/angle/cherry-pick-2882e1afd982.patch b/patches/angle/cherry-pick-2882e1afd982.patch
index 8f7bd5959..f65e3ebb1 100644
--- a/patches/angle/cherry-pick-2882e1afd982.patch
+++ b/patches/angle/cherry-pick-2882e1afd982.patch
@@ -21,15 +21,3 @@ index 3233d12dd233786b0988f299ace57d932e0d0fe6..0bdc3f6e5e8ebfcc6bbb2ff1bef57a1d
  }
  
  void StateCache::onProgramExecutableChange(Context *context)
-diff --git a/src/libANGLE/Context.h b/src/libANGLE/Context.h
-index 06eeff3b94c937067e674fc127afdeab34e63f21..1e61266921bc7aafb26388b12d0aa1b914c4b5a9 100644
---- a/src/libANGLE/Context.h
-+++ b/src/libANGLE/Context.h
-@@ -203,6 +203,7 @@ class StateCache final : angle::NonCopyable
-     // 2. onVertexArrayBufferStateChange.
-     // 3. onBufferBindingChange.
-     // 4. onVertexArrayStateChange.
-+    // 5. onVertexArrayBindingStateChange.
-     intptr_t getBasicDrawElementsError(const Context *context) const
-     {
-         if (mCachedBasicDrawElementsError != kInvalidPointer)
diff --git a/patches/chromium/ignore_renderframehostimpl_detach_for_speculative_rfhs.patch b/patches/chromium/ignore_renderframehostimpl_detach_for_speculative_rfhs.patch
index b128bc8eb..1b17ed2bb 100644
--- a/patches/chromium/ignore_renderframehostimpl_detach_for_speculative_rfhs.patch
+++ b/patches/chromium/ignore_renderframehostimpl_detach_for_speculative_rfhs.patch
@@ -129,34 +129,3 @@ index 8c2e904462c655c9a587e5243572e60b8327ad1c..d4b16a127f92559469f386b734ffa1e6
  // Generate a URL for a file path including a query string.
  GURL GetFileUrlWithQuery(const base::FilePath& path,
                           const std::string& query_string);
-diff --git a/content/test/data/cross_site_iframe_factory.html b/content/test/data/cross_site_iframe_factory.html
-index 959f45a6be7f233082e364f90d6875d125ae6fe6..e4807d1ad3f7526d7b21843ba8f49e50f7ed8d7e 100644
---- a/content/test/data/cross_site_iframe_factory.html
-+++ b/content/test/data/cross_site_iframe_factory.html
-@@ -10,12 +10,12 @@ Example usage in a browsertest, explained:
- When you navigate to the above URL, the outer document (on a.com) will create a
- single iframe:
- 
--  <iframe src="http://b.com:1234/cross_site_iframe_factory.html?b(c(),d())">
-+  <iframe id="child-0" src="http://b.com:1234/cross_site_iframe_factory.html?b(c(),d())">
- 
- Inside of which, then, are created the two leaf iframes:
- 
--  <iframe src="http://c.com:1234/cross_site_iframe_factory.html?c()">
--  <iframe src="http://d.com:1234/cross_site_iframe_factory.html?d()">
-+  <iframe id="child-0" src="http://c.com:1234/cross_site_iframe_factory.html?c()">
-+  <iframe id="child-1" src="http://d.com:1234/cross_site_iframe_factory.html?d()">
- 
- Add iframe options by enclosing them in '{' and '}' characters after the
- hostname (multiple options can be separated with commas):
-@@ -24,8 +24,8 @@ hostname (multiple options can be separated with commas):
- 
- Will create two iframes:
- 
--  <iframe src="http://a.com:1234/cross_site_iframe_factory.html?b()" allowfullscreen>
--  <iframe src="http://c.com:1234/cross_site_iframe_factory.html?c{sandbox-allow-scripts}(d())" sandbox="allow-scripts">
-+  <iframe id="child-0" src="http://a.com:1234/cross_site_iframe_factory.html?b()" allowfullscreen>
-+  <iframe id="child-1" src="http://c.com:1234/cross_site_iframe_factory.html?c{sandbox-allow-scripts}(d())" sandbox="allow-scripts">
- 
- To specify the site for each iframe, you can use a simple identifier like "a"
- or "b", and ".com" will be automatically appended. You can also specify a port
