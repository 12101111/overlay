diff --git a/patches/chromium/avoid_allocating_recordid_objects_in_elementtiming_and_lcp.patch b/patches/chromium/avoid_allocating_recordid_objects_in_elementtiming_and_lcp.patch
index 130cdd7042..7d3025956b 100644
--- a/patches/chromium/avoid_allocating_recordid_objects_in_elementtiming_and_lcp.patch
+++ b/patches/chromium/avoid_allocating_recordid_objects_in_elementtiming_and_lcp.patch
@@ -641,15 +641,3 @@ index 0000000000000000000000000000000000000000..32952101e8463e31617d1b5f67c36abf
 +
 +}  // namespace blink
 +#endif
-diff --git a/third_party/blink/tools/blinkpy/presubmit/audit_non_blink_usage.py b/third_party/blink/tools/blinkpy/presubmit/audit_non_blink_usage.py
-index 408a2916a00bb2a871f3a680215de54e7be2077c..caa3d8277acbecbeb25b3449719866e061a82761 100755
---- a/third_party/blink/tools/blinkpy/presubmit/audit_non_blink_usage.py
-+++ b/third_party/blink/tools/blinkpy/presubmit/audit_non_blink_usage.py
-@@ -67,6 +67,7 @@ _CONFIG = [
-             'base::DefaultTickClock',
-             'base::ElapsedTimer',
-             'base::EnumSet',
-+            'base::HashInts',
-             'base::JobDelegate',
-             'base::JobHandle',
-             'base::PostJob',
diff --git a/patches/chromium/cherry-pick-80106e31c7ea.patch b/patches/chromium/cherry-pick-80106e31c7ea.patch
index 3f8ae7d1b2..af8859a1a5 100644
--- a/patches/chromium/cherry-pick-80106e31c7ea.patch
+++ b/patches/chromium/cherry-pick-80106e31c7ea.patch
@@ -361,68 +361,3 @@ index 3d562fa22bd84dc438abfe9fa883eff6f5846b1b..c64c7fb1b15f7f523b37671abca2ab50
    auto* resolver = MakeGarbageCollected<ScriptPromiseResolver>(
        script_state, exception_state.GetContext());
    ScriptPromise promise = resolver->Promise();
-diff --git a/third_party/blink/web_tests/external/wpt/webusb/usbDevice.https.any.js b/third_party/blink/web_tests/external/wpt/webusb/usbDevice.https.any.js
-index b1b0c133ce160a314ea392514ac5b38e4cac136d..804af2afb9db3a0d5fafbeb26aed64f89badb1b3 100644
---- a/third_party/blink/web_tests/external/wpt/webusb/usbDevice.https.any.js
-+++ b/third_party/blink/web_tests/external/wpt/webusb/usbDevice.https.any.js
-@@ -1247,3 +1247,60 @@ usb_test((t) => {
-         .then(() => promise_rejects_dom(t, 'NotFoundError', device.reset()));
-   });
- }, 'resetDevice rejects when called on a disconnected device');
-+
-+usb_test(async (t) => {
-+  const PACKET_COUNT = 4;
-+  const PACKET_LENGTH = 8;
-+  const {device, fakeDevice} = await getFakeDevice();
-+  await device.open();
-+  await device.selectConfiguration(2);
-+  await device.claimInterface(0);
-+  await device.selectAlternateInterface(0, 1);
-+  const buffer = new Uint8Array(PACKET_COUNT * PACKET_LENGTH);
-+  const packetLengths = new Array(PACKET_COUNT).fill(PACKET_LENGTH);
-+  packetLengths[0] = PACKET_LENGTH - 1;
-+  await promise_rejects_dom(
-+      t, 'DataError', device.isochronousTransferOut(1, buffer, packetLengths));
-+}, 'isochronousTransferOut rejects when buffer size exceeds packet lengths');
-+
-+usb_test(async (t) => {
-+  const PACKET_COUNT = 4;
-+  const PACKET_LENGTH = 8;
-+  const {device, fakeDevice} = await getFakeDevice();
-+  await device.open();
-+  await device.selectConfiguration(2);
-+  await device.claimInterface(0);
-+  await device.selectAlternateInterface(0, 1);
-+  const buffer = new Uint8Array(PACKET_COUNT * PACKET_LENGTH);
-+  const packetLengths = new Array(PACKET_COUNT).fill(PACKET_LENGTH);
-+  packetLengths[0] = PACKET_LENGTH + 1;
-+  await promise_rejects_dom(
-+      t, 'DataError', device.isochronousTransferOut(1, buffer, packetLengths));
-+}, 'isochronousTransferOut rejects when packet lengths exceed buffer size');
-+
-+usb_test(async (t) => {
-+  const PACKET_COUNT = 2;
-+  const PACKET_LENGTH = 8;
-+  const {device, fakeDevice} = await getFakeDevice();
-+  await device.open();
-+  await device.selectConfiguration(2);
-+  await device.claimInterface(0);
-+  await device.selectAlternateInterface(0, 1);
-+  const packetLengths = [0xffffffff, 1];
-+  await promise_rejects_dom(
-+      t, 'DataError', device.isochronousTransferIn(1, packetLengths));
-+}, 'isochronousTransferIn rejects when packet lengths exceed maximum size');
-+
-+usb_test(async (t) => {
-+  const PACKET_COUNT = 2;
-+  const PACKET_LENGTH = 8;
-+  const {device, fakeDevice} = await getFakeDevice();
-+  await device.open();
-+  await device.selectConfiguration(2);
-+  await device.claimInterface(0);
-+  await device.selectAlternateInterface(0, 1);
-+  const buffer = new Uint8Array(PACKET_LENGTH * PACKET_COUNT);
-+  const packetLengths = [0xffffffff, 1];
-+  await promise_rejects_dom(
-+      t, 'DataError', device.isochronousTransferOut(1, buffer, packetLengths));
-+}, 'isochronousTransferOut rejects when packet lengths exceed maximum size');
diff --git a/patches/chromium/cherry-pick-5b2fddadaa12.patch b/patches/chromium/cherry-pick-5b2fddadaa12.patch
index 3974cd3916..acddb07fb9 100644
--- a/patches/chromium/cherry-pick-5b2fddadaa12.patch
+++ b/patches/chromium/cherry-pick-5b2fddadaa12.patch
@@ -49,13 +49,3 @@ index 8c7b9d07bb68ec51d21ea2132cc5ecbc39e5cd95..95a40d39c9214fd6555523bd7e7bd91e
  }
  
  float AudioParam::defaultValue() const {
-diff --git a/third_party/blink/web_tests/webaudio/AudioParam/worklet-warnings-expected.txt b/third_party/blink/web_tests/webaudio/AudioParam/worklet-warnings-expected.txt
-index 7bb2d0aec7feaed69424f209a2e3e031c7a9e512..ebe05a2c239d35be4729cc187aa77de6a44f5a41 100644
---- a/third_party/blink/web_tests/webaudio/AudioParam/worklet-warnings-expected.txt
-+++ b/third_party/blink/web_tests/webaudio/AudioParam/worklet-warnings-expected.txt
-@@ -1,5 +1,4 @@
- CONSOLE WARNING: AudioWorkletNode("noise-generator").amplitude.value 99 outside nominal range [0, 1]; value will be clamped.
--CONSOLE WARNING: AudioWorkletNode("noise-generator").amplitude.setValueAtTime value 99 outside nominal range [0, 1]; value will be clamped.
- CONSOLE WARNING: AudioWorkletNode("noise-generator").amplitude.setValueAtTime value -1 outside nominal range [0, 1]; value will be clamped.
- CONSOLE WARNING: AudioWorkletNode("noise-generator").amplitude.linearRampToValueAtTime value 5 outside nominal range [0, 1]; value will be clamped.
- This is a testharness.js-based test.
diff --git a/patches/v8/cherry-pick-389ea9be7d68.patch b/patches/v8/cherry-pick-389ea9be7d68.patch
index a3d97adcfb..ed2acbdee4 100644
--- a/patches/v8/cherry-pick-389ea9be7d68.patch
+++ b/patches/v8/cherry-pick-389ea9be7d68.patch
@@ -204,138 +204,3 @@ index 18ce25614edaae28f2dac7721bde4b4a83a45af6..f0483acadb8d1c9f3ea1bfbe258dc1a5
    bool success = false;
    PropertyKey lookup_key(isolate, key, &success);
    if (!success) return Nothing<bool>();
-diff --git a/test/cctest/test-field-type-tracking.cc b/test/cctest/test-field-type-tracking.cc
-index 34e3db375bfd34f5f2f31090e766593d2102a26c..9ed4871db490761415c38468855e740239c3c201 100644
---- a/test/cctest/test-field-type-tracking.cc
-+++ b/test/cctest/test-field-type-tracking.cc
-@@ -3027,126 +3027,10 @@ TEST(RepresentationPredicatesAreInSync) {
-   }
- }
- 
--TEST(DeletePropertyGeneralizesConstness) {
--  CcTest::InitializeVM();
--  v8::HandleScope scope(CcTest::isolate());
--  Isolate* isolate = CcTest::i_isolate();
--  Handle<FieldType> any_type = FieldType::Any(isolate);
--
--  // Create a map with some properties.
--  Handle<Map> initial_map = Map::Create(isolate, kPropCount + 3);
--  Handle<Map> map = initial_map;
--  for (int i = 0; i < kPropCount; i++) {
--    Handle<String> name = CcTest::MakeName("prop", i);
--    map = Map::CopyWithField(isolate, map, name, any_type, NONE,
--                             PropertyConstness::kConst, Representation::Smi(),
--                             INSERT_TRANSITION)
--              .ToHandleChecked();
--  }
--  Handle<Map> parent_map = map;
--  CHECK(!map->is_deprecated());
--
--  Handle<String> name_x = CcTest::MakeString("x");
--  Handle<String> name_y = CcTest::MakeString("y");
--
--  map = Map::CopyWithField(isolate, parent_map, name_x, any_type, NONE,
--                           PropertyConstness::kConst, Representation::Smi(),
--                           INSERT_TRANSITION)
--            .ToHandleChecked();
--
--  // Create an object, initialize its properties and add a couple of clones.
--  Handle<JSObject> object1 = isolate->factory()->NewJSObjectFromMap(map);
--  for (int i = 0; i < kPropCount; i++) {
--    FieldIndex index = FieldIndex::ForDescriptor(*map, InternalIndex(i));
--    object1->FastPropertyAtPut(index, Smi::FromInt(i));
--  }
--  Handle<JSObject> object2 = isolate->factory()->CopyJSObject(object1);
--
--  CHECK(!map->is_deprecated());
--  CHECK(!parent_map->is_deprecated());
--
--  // Transition to Double must deprecate m1.
--  CHECK(!Representation::Smi().CanBeInPlaceChangedTo(Representation::Double()));
--
--  // Reconfigure one of the first properties to make the whole transition tree
--  // deprecated (including |parent_map| and |map|).
--  Handle<Map> new_map =
--      ReconfigureProperty(isolate, map, InternalIndex(0), PropertyKind::kData,
--                          NONE, Representation::Double(), any_type);
--  CHECK(map->is_deprecated());
--  CHECK(parent_map->is_deprecated());
--  CHECK(!new_map->is_deprecated());
--  // The "x" property is still kConst.
--  CHECK_EQ(new_map->GetLastDescriptorDetails(isolate).constness(),
--           PropertyConstness::kConst);
--
--  Handle<Map> new_parent_map = Map::Update(isolate, parent_map);
--  CHECK(!new_parent_map->is_deprecated());
--
--  // |new_parent_map| must have exactly one outgoing transition to |new_map|.
--  {
--    TransitionsAccessor ta(isolate, *new_parent_map);
--    CHECK_EQ(ta.NumberOfTransitions(), 1);
--    CHECK_EQ(ta.GetTarget(0), *new_map);
--  }
--
--  // Deletion of the property from |object1| must migrate it to |new_parent_map|
--  // which is an up-to-date version of the |parent_map|. The |new_map|'s "x"
--  // property should be marked as mutable.
--  CHECK_EQ(object1->map(isolate), *map);
--  CHECK(Runtime::DeleteObjectProperty(isolate, object1, name_x,
--                                      LanguageMode::kSloppy)
--            .ToChecked());
--  CHECK_EQ(object1->map(isolate), *new_parent_map);
--  CHECK_EQ(new_map->GetLastDescriptorDetails(isolate).constness(),
--           PropertyConstness::kMutable);
--
--  // Now add transitions to "x" and "y" properties from |new_parent_map|.
--  std::vector<Handle<Map>> transitions;
--  Handle<Object> value = handle(Smi::FromInt(0), isolate);
--  for (int i = 0; i < kPropertyAttributesCombinationsCount; i++) {
--    auto attributes = PropertyAttributesFromInt(i);
--
--    Handle<Map> tmp;
--    // Add some transitions to "x" and "y".
--    tmp = Map::TransitionToDataProperty(isolate, new_parent_map, name_x, value,
--                                        attributes, PropertyConstness::kConst,
--                                        StoreOrigin::kNamed);
--    CHECK(!tmp->map(isolate).is_dictionary_map());
--    transitions.push_back(tmp);
--
--    tmp = Map::TransitionToDataProperty(isolate, new_parent_map, name_y, value,
--                                        attributes, PropertyConstness::kConst,
--                                        StoreOrigin::kNamed);
--    CHECK(!tmp->map(isolate).is_dictionary_map());
--    transitions.push_back(tmp);
--  }
--
--  // Deletion of the property from |object2| must migrate it to |new_parent_map|
--  // which is an up-to-date version of the |parent_map|.
--  // All outgoing transitions from |new_map| that add "x" must be marked as
--  // mutable, transitions to other properties must remain const.
--  CHECK_EQ(object2->map(isolate), *map);
--  CHECK(Runtime::DeleteObjectProperty(isolate, object2, name_x,
--                                      LanguageMode::kSloppy)
--            .ToChecked());
--  CHECK_EQ(object2->map(isolate), *new_parent_map);
--  for (Handle<Map> m : transitions) {
--    if (m->GetLastDescriptorName(isolate) == *name_x) {
--      CHECK_EQ(m->GetLastDescriptorDetails(isolate).constness(),
--               PropertyConstness::kMutable);
--
--    } else {
--      CHECK_EQ(m->GetLastDescriptorDetails(isolate).constness(),
--               PropertyConstness::kConst);
--    }
--  }
--}
--
--#define CHECK_SAME(object, rep, expected)           \
--  CHECK_EQ(object->FitsRepresentation(rep, true),   \
--           object->FitsRepresentation(rep, false)); \
--  CHECK_EQ(object->FitsRepresentation(rep, true), expected)
-+#define CHECK_SAME(object, rep, expected)                    \
-+  CHECK_EQ(Object::FitsRepresentation(*object, rep, true),   \
-+           Object::FitsRepresentation(*object, rep, false)); \
-+  CHECK_EQ(Object::FitsRepresentation(*object, rep, true), expected)
- 
- TEST(CheckFitsRepresentationPredicate) {
-   CcTest::InitializeVM();
diff --git a/patches/chromium/cherry-pick-cc07a95bc309.patch b/patches/chromium/cherry-pick-cc07a95bc309.patch
index 546d93875d..b2c602786b 100644
--- a/patches/chromium/cherry-pick-cc07a95bc309.patch
+++ b/patches/chromium/cherry-pick-cc07a95bc309.patch
@@ -120,31 +120,3 @@ index fa1de8f37b9be681f7ac447bc3e3859e8909216d..4730383dafa957c2e84c009387d15d6f
        automatic_pull_handlers_need_updating_ = false;
      }
    }
-diff --git a/third_party/blink/web_tests/external/wpt/webaudio/the-audio-api/the-audioworklet-interface/audioworkletprocessor-process-frozen-array.https.html b/third_party/blink/web_tests/external/wpt/webaudio/the-audio-api/the-audioworklet-interface/audioworkletprocessor-process-frozen-array.https.html
-index 33627204a6f538eba77bd8346952404814e4affa..ce0cfa40b691d859d372c9e6da7ff54fe64bbbe1 100644
---- a/third_party/blink/web_tests/external/wpt/webaudio/the-audio-api/the-audioworklet-interface/audioworkletprocessor-process-frozen-array.https.html
-+++ b/third_party/blink/web_tests/external/wpt/webaudio/the-audio-api/the-audioworklet-interface/audioworkletprocessor-process-frozen-array.https.html
-@@ -43,7 +43,10 @@
-           if (actual.done)
-             task.done();
-         };
--        sourceNode.connect(workletNode);
-+        // To have valid ArrayBuffers for both input and output, we need
-+        // both connections.
-+        // See: https://github.com/WebAudio/web-audio-api/issues/2566
-+        sourceNode.connect(workletNode).connect(context.destination);
-         sourceNode.start();
-       });
- 
-diff --git a/third_party/blink/web_tests/external/wpt/webaudio/the-audio-api/the-audioworklet-interface/process-parameters.https-expected.txt b/third_party/blink/web_tests/external/wpt/webaudio/the-audio-api/the-audioworklet-interface/process-parameters.https-expected.txt
-new file mode 100644
-index 0000000000000000000000000000000000000000..fbac76d9b865bfdec552bf280e4a19ae1743ef4a
---- /dev/null
-+++ b/third_party/blink/web_tests/external/wpt/webaudio/the-audio-api/the-audioworklet-interface/process-parameters.https-expected.txt
-@@ -0,0 +1,6 @@
-+This is a testharness.js-based test.
-+[PASS] 3 inputs; 0 outputs
-+[FAIL] 0 inputs; 3 outputs
-+  assert_equals: outputs[0].length expected 1 but got 0
-+Harness: the test ran to completion.
-+
