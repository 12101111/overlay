diff --git a/patches/v8/regexp_allow_reentrant_irregexp_execution.patch b/patches/v8/regexp_allow_reentrant_irregexp_execution.patch
index 1256bdf2de..482b0588e9 100644
--- a/patches/v8/regexp_allow_reentrant_irregexp_execution.patch
+++ b/patches/v8/regexp_allow_reentrant_irregexp_execution.patch
@@ -1720,17 +1720,3 @@ index c3a3cb90f2a9d865057af80801e2a95bbb873140..74a3c95b06c771078ab03e6787e59123
  
    // Labels used internally.
    Label entry_label_;
-diff --git a/test/cctest/cctest.status b/test/cctest/cctest.status
-index 21afa5310647eb67f3fe3fc4f2e0721b4bb4e0f6..ea49ec9b4096e986ea5fe64b2b06177855d24f69 100644
---- a/test/cctest/cctest.status
-+++ b/test/cctest/cctest.status
-@@ -136,9 +136,6 @@
-   'test-strings/Traverse': [PASS, HEAVY],
-   'test-swiss-name-dictionary-csa/DeleteAtBoundaries': [PASS, HEAVY],
-   'test-swiss-name-dictionary-csa/SameH2': [PASS, HEAVY],
--
--  # TODO(v8:11382): Reenable once irregexp is reentrant.
--  'test-regexp/RegExpInterruptReentrantExecution': [FAIL],
- }],  # ALWAYS
- 
- ##############################################################################
diff --git a/patches/chromium/cherry-pick-8af66de55aad.patch b/patches/chromium/cherry-pick-8af66de55aad.patch
index 75716cfaef..10452867b9 100644
--- a/patches/chromium/cherry-pick-8af66de55aad.patch
+++ b/patches/chromium/cherry-pick-8af66de55aad.patch
@@ -110,17 +110,3 @@ index c60e3281ea96ef39e16034c88abf4c6c2a9bd2eb..f9434ae7a2c1066dd2c97f552ee572ca
        required_csp_ = value;
        DidChangeAttributes();
        UseCounter::Count(GetDocument(), WebFeature::kIFrameCSPAttribute);
-diff --git a/third_party/blink/web_tests/external/wpt/content-security-policy/embedded-enforcement/required_csp-header.html b/third_party/blink/web_tests/external/wpt/content-security-policy/embedded-enforcement/required_csp-header.html
-index a9ad787408786e594ccb554d2bd9186a9e8e7c1e..e0a31db8e28fb1a9d2884c7677597072d4badba2 100644
---- a/third_party/blink/web_tests/external/wpt/content-security-policy/embedded-enforcement/required_csp-header.html
-+++ b/third_party/blink/web_tests/external/wpt/content-security-policy/embedded-enforcement/required_csp-header.html
-@@ -59,6 +59,9 @@
-       { "name": "Wrong and dangerous value of `csp` should not trigger sending Sec-Required-CSP Header - report-to present",
-         "csp": "script-src 'unsafe-inline'; report-to resources/dummy-report.php",
-         "expected": null },
-+      { "name": "Sec-Required-CSP is not sent if `csp` attribute is longer than 4096 bytes",
-+        "csp": "style-src " + Array.from(Array(2044).keys()).map(i => 'a').join(' '),
-+        "expected":  null },
-     ];
- 
-     tests.forEach(test => {
diff --git a/patches/v8/merge_inspector_use_ephemeron_table_for_exception_metadata.patch b/patches/v8/merge_inspector_use_ephemeron_table_for_exception_metadata.patch
index d3afab773d..71fb5699d1 100644
--- a/patches/v8/merge_inspector_use_ephemeron_table_for_exception_metadata.patch
+++ b/patches/v8/merge_inspector_use_ephemeron_table_for_exception_metadata.patch
@@ -306,74 +306,3 @@ index e1607f88c0e6591d748d0c82634e327d2bbebad7..e6e4cde61c5845cac95d058b36126063
    int m_capturingStackTracesCount;
    unsigned m_lastExceptionId;
    int m_lastContextId;
-diff --git a/test/cctest/test-debug.cc b/test/cctest/test-debug.cc
-index 2effdabc1dbd0e993971fe175b2483a9e555d0dd..30c6b2674901a0004b773ae0f0204d83b1964697 100644
---- a/test/cctest/test-debug.cc
-+++ b/test/cctest/test-debug.cc
-@@ -594,10 +594,11 @@ TEST(BreakPointApiIntrinsics) {
-     CHECK_EQ(2, break_point_hit_count);
- 
-     break_point_hit_count = 0;
--    v8::Local<v8::debug::WeakMap> weakmap =
--        v8::debug::WeakMap::New(env->GetIsolate());
--    CHECK(!weakmap->Set(env.local(), weakmap, v8_num(1)).IsEmpty());
--    CHECK(!weakmap->Get(env.local(), weakmap).IsEmpty());
-+    v8::Local<v8::debug::EphemeronTable> weakmap =
-+        v8::debug::EphemeronTable::New(env->GetIsolate());
-+    v8::Local<v8::Object> key = v8::Object::New(env->GetIsolate());
-+    CHECK(!weakmap->Set(env->GetIsolate(), key, v8_num(1)).IsEmpty());
-+    CHECK(!weakmap->Get(env->GetIsolate(), key).IsEmpty());
-     CHECK_EQ(0, break_point_hit_count);
-   }
- 
-diff --git a/test/cctest/test-inspector.cc b/test/cctest/test-inspector.cc
-index e36ce19eca04831f8a80c459590506e497836716..7fb3bef3bb9e7ef88cd441ce4023b780fff5d982 100644
---- a/test/cctest/test-inspector.cc
-+++ b/test/cctest/test-inspector.cc
-@@ -8,6 +8,7 @@
- #include "include/v8.h"
- #include "src/inspector/protocol/Runtime.h"
- #include "src/inspector/string-util.h"
-+#include "src/inspector/v8-inspector-impl.h"
- #include "test/cctest/cctest.h"
- 
- using v8_inspector::StringBuffer;
-@@ -168,3 +169,38 @@ TEST(BinaryBase64RoundTrip) {
-     CHECK_EQ(values[i], roundtrip_binary.data()[i]);
-   }
- }
-+
-+TEST(NoInterruptOnGetAssociatedData) {
-+  LocalContext env;
-+  v8::Isolate* isolate = env->GetIsolate();
-+  v8::HandleScope handle_scope(isolate);
-+
-+  v8_inspector::V8InspectorClient default_client;
-+  std::unique_ptr<v8_inspector::V8InspectorImpl> inspector(
-+      new v8_inspector::V8InspectorImpl(isolate, &default_client));
-+
-+  v8::Local<v8::Context> context = env->GetIsolate()->GetCurrentContext();
-+  v8::Local<v8::Value> error = v8::Exception::Error(v8_str("custom error"));
-+  v8::Local<v8::Name> key = v8_str("key");
-+  v8::Local<v8::Value> value = v8_str("value");
-+  inspector->associateExceptionData(context, error, key, value);
-+
-+  struct InterruptRecorder {
-+    static void handler(v8::Isolate* isolate, void* data) {
-+      reinterpret_cast<InterruptRecorder*>(data)->WasInvoked = true;
-+    }
-+
-+    bool WasInvoked = false;
-+  } recorder;
-+
-+  isolate->RequestInterrupt(&InterruptRecorder::handler, &recorder);
-+
-+  v8::Local<v8::Object> data =
-+      inspector->getAssociatedExceptionData(error).ToLocalChecked();
-+  CHECK(!recorder.WasInvoked);
-+
-+  CHECK_EQ(data->Get(context, key).ToLocalChecked(), value);
-+
-+  CompileRun("0");
-+  CHECK(recorder.WasInvoked);
-+}
diff --git a/patches/chromium/cachestorage_store_partial_opaque_responses.patch b/patches/chromium/cachestorage_store_partial_opaque_responses.patch
index 417cafafa2..5f8780775e 100644
--- a/patches/chromium/cachestorage_store_partial_opaque_responses.patch
+++ b/patches/chromium/cachestorage_store_partial_opaque_responses.patch
@@ -72,23 +72,3 @@ index c76c7677a17fd58be83d5e9f2bc263b710e528ae..8c267d2f54ae6e83b86d53dd473e2ed1
      exception_state.ThrowTypeError(
          "Partial response (status code 206) is unsupported");
      return;
-diff --git a/third_party/blink/web_tests/external/wpt/service-workers/cache-storage/script-tests/cache-put.js b/third_party/blink/web_tests/external/wpt/service-workers/cache-storage/script-tests/cache-put.js
-index b45910a3b8ba089e1724efa8b9e8a8d679c59320..f60c4b905ebcb61854b83177d59861ef92095624 100644
---- a/third_party/blink/web_tests/external/wpt/service-workers/cache-storage/script-tests/cache-put.js
-+++ b/third_party/blink/web_tests/external/wpt/service-workers/cache-storage/script-tests/cache-put.js
-@@ -144,7 +144,14 @@ cache_test(function(cache, test) {
-               'Test framework error: The status code should be 0 for an ' +
-               ' opaque-filtered response. This is actually HTTP 206.');
-           response = fetch_result.clone();
--          return promise_rejects_js(test, TypeError, cache.put(request, fetch_result));
-+          return cache.put(request, fetch_result);
-+        })
-+      .then(function() {
-+          return cache.match(test_url);
-+        })
-+      .then(function(result) {
-+          assert_not_equals(result, undefined,
-+              'Cache.put should store an entry for the opaque response');
-         });
-   }, 'Cache.put with opaque-filtered HTTP 206 response');
- 
diff --git a/patches/chromium/cherry-pick-dbde8795233a.patch b/patches/chromium/cherry-pick-dbde8795233a.patch
index 13cb04679e..8a669ff93c 100644
--- a/patches/chromium/cherry-pick-dbde8795233a.patch
+++ b/patches/chromium/cherry-pick-dbde8795233a.patch
@@ -52,257 +52,3 @@ index c7ae11a459051edab1fcaf1cc5feb5d9f19ff52d..29d34ddc211350a834ca94466cce1dcf
    if (type == kDidFinishLoading) {
      resource->Finish(response_end, freezable_task_runner_.get());
  
-diff --git a/third_party/blink/web_tests/external/wpt/fetch/range/resources/partial-text.py b/third_party/blink/web_tests/external/wpt/fetch/range/resources/partial-text.py
-new file mode 100644
-index 0000000000000000000000000000000000000000..a0058551d52d45b3c16882014be740d75e51ddd1
---- /dev/null
-+++ b/third_party/blink/web_tests/external/wpt/fetch/range/resources/partial-text.py
-@@ -0,0 +1,47 @@
-+"""
-+This generates a partial response for a 100-byte text file.
-+"""
-+import re
-+
-+from wptserve.utils import isomorphic_decode
-+
-+def main(request, response):
-+    total_length = int(request.GET.first(b'length', b'100'))
-+    partial_code = int(request.GET.first(b'partial', b'206'))
-+    range_header = request.headers.get(b'Range', b'')
-+
-+    # Send a 200 if there is no range request
-+    if not range_header:
-+        to_send = ''.zfill(total_length)
-+        response.headers.set(b"Content-Type", b"text/plain")
-+        response.headers.set(b"Cache-Control", b"no-cache")
-+        response.headers.set(b"Content-Length", total_length)
-+        response.content = to_send
-+        return
-+
-+    # Simple range parsing, requires specifically "bytes=xxx-xxxx"
-+    range_header_match = re.search(r'^bytes=(\d*)-(\d*)$', isomorphic_decode(range_header))
-+    start, end = range_header_match.groups()
-+    start = int(start)
-+    end = int(end) if end else total_length
-+    length = end - start
-+
-+    # Error the request if the range goes beyond the length
-+    if length <= 0 or end > total_length:
-+        response.set_error(416, u"Range Not Satisfiable")
-+        response.write()
-+        return
-+
-+    # Generate a partial response of the requested length
-+    to_send = ''.zfill(length)
-+    response.headers.set(b"Content-Type", b"text/plain")
-+    response.headers.set(b"Accept-Ranges", b"bytes")
-+    response.headers.set(b"Cache-Control", b"no-cache")
-+    response.status = partial_code
-+
-+    content_range = b"bytes %d-%d/%d" % (start, end, total_length)
-+
-+    response.headers.set(b"Content-Range", content_range)
-+    response.headers.set(b"Content-Length", length)
-+
-+    response.content = to_send
-diff --git a/third_party/blink/web_tests/external/wpt/fetch/range/resources/range-sw.js b/third_party/blink/web_tests/external/wpt/fetch/range/resources/range-sw.js
-index 3680c0c471d3d5f36c4aba4cc58dcd52c38a08df..b47823f03b4ef3749e622fbf7dd3b515a216b5be 100644
---- a/third_party/blink/web_tests/external/wpt/fetch/range/resources/range-sw.js
-+++ b/third_party/blink/web_tests/external/wpt/fetch/range/resources/range-sw.js
-@@ -12,7 +12,7 @@ async function broadcast(msg) {
-   }
- }
- 
--addEventListener('fetch', event => {
-+addEventListener('fetch', async event => {
-   /** @type Request */
-   const request = event.request;
-   const url = new URL(request.url);
-@@ -34,6 +34,11 @@ addEventListener('fetch', event => {
-     case 'broadcast-accept-encoding':
-       broadcastAcceptEncoding(event);
-       return;
-+    case 'record-media-range-request':
-+      return recordMediaRangeRequest(event);
-+    case 'use-media-range-request':
-+      useMediaRangeRequest(event);
-+      return;
-   }
- });
- 
-@@ -157,3 +162,57 @@ function broadcastAcceptEncoding(event) {
-   // Just send back any response, it isn't important for the test.
-   event.respondWith(new Response(''));
- }
-+
-+let rangeResponse = {};
-+
-+async function recordMediaRangeRequest(event) {
-+  /** @type Request */
-+  const request = event.request;
-+  const url = new URL(request.url);
-+  const urlParams = new URLSearchParams(url.search);
-+  const size = urlParams.get("size");
-+  const id = urlParams.get('id');
-+  const key = 'size' + size;
-+
-+  if (key in rangeResponse) {
-+    // Don't re-fetch ranges we already have.
-+    const clonedResponse = rangeResponse[key].clone();
-+    event.respondWith(clonedResponse);
-+  } else if (event.request.headers.get("range") === "bytes=0-") {
-+    // Generate a bogus 206 response to trigger subsequent range requests
-+    // of the desired size.
-+    const length = urlParams.get("length") + 100;
-+    const body = "A".repeat(Number(size));
-+    event.respondWith(new Response(body, {status: 206, headers: {
-+      "Content-Type": "audio/mp4",
-+      "Content-Range": `bytes 0-1/${length}`
-+    }}));
-+  } else if (event.request.headers.get("range") === `bytes=${Number(size)}-`) {
-+    // Pass through actual range requests which will attempt to fetch up to the
-+    // length in the original response which is bigger than the actual resource
-+    // to make sure 206 and 416 responses are treated the same.
-+    rangeResponse[key] = await fetch(event.request);
-+
-+    // Let the client know we have the range response for the given ID
-+    broadcast({id});
-+  } else {
-+    event.respondWith(Promise.reject(Error("Invalid Request")));
-+  }
-+}
-+
-+function useMediaRangeRequest(event) {
-+  /** @type Request */
-+  const request = event.request;
-+  const url = new URL(request.url);
-+  const urlParams = new URLSearchParams(url.search);
-+  const size = urlParams.get("size");
-+  const key = 'size' + size;
-+
-+  // Send a clone of the range response to preload.
-+  if (key in rangeResponse) {
-+    const clonedResponse = rangeResponse[key].clone();
-+    event.respondWith(clonedResponse);
-+  } else {
-+    event.respondWith(Promise.reject(Error("Invalid Request")));
-+  }
-+}
-diff --git a/third_party/blink/web_tests/external/wpt/fetch/range/resources/utils.js b/third_party/blink/web_tests/external/wpt/fetch/range/resources/utils.js
-index 16ed737f63e8eee26a306c70acb0589e424db35d..ad2853b33dc7474293df1423dd8af459571736b9 100644
---- a/third_party/blink/web_tests/external/wpt/fetch/range/resources/utils.js
-+++ b/third_party/blink/web_tests/external/wpt/fetch/range/resources/utils.js
-@@ -8,6 +8,18 @@ function loadScript(url, { doc = document }={}) {
-   })
- }
- 
-+function preloadImage(url, { doc = document }={}) {
-+  return new Promise((resolve, reject) => {
-+    const preload = doc.createElement('link');
-+    preload.rel = 'preload';
-+    preload.as = 'image';
-+    preload.onload = () => resolve();
-+    preload.onerror = () => resolve();
-+    preload.href = url;
-+    doc.body.appendChild(preload);
-+  })
-+}
-+
- /**
-  *
-  * @param {Document} document
-diff --git a/third_party/blink/web_tests/external/wpt/fetch/range/sw.https.window-expected.txt b/third_party/blink/web_tests/external/wpt/fetch/range/sw.https.window-expected.txt
-index 134b0a7abd817599921d4fb430e8247a2cb40f82..a9577f01727678cd7a76bcc65e132fd6fcb230ac 100644
---- a/third_party/blink/web_tests/external/wpt/fetch/range/sw.https.window-expected.txt
-+++ b/third_party/blink/web_tests/external/wpt/fetch/range/sw.https.window-expected.txt
-@@ -4,6 +4,7 @@ PASS Defer range header passthrough tests to service worker
- PASS Ranged response not allowed following no-cors ranged request
- PASS Non-opaque ranged response executed
- FAIL Accept-Encoding should not appear in a service worker assert_equals: Accept-Encoding should not be set for media expected (object) null but got (string) "identity;q=1, *;q=0"
-+PASS Opaque range preload successes and failures should be indistinguishable
- PASS Range headers correctly preserved
- PASS Range headers correctly removed
- PASS Headers correctly filtered
-diff --git a/third_party/blink/web_tests/external/wpt/fetch/range/sw.https.window.js b/third_party/blink/web_tests/external/wpt/fetch/range/sw.https.window.js
-index 76f80e9416c615417ad2a9fbaa565641ff5b8a12..42e4ac6d75afdcbb2ad1e9d3e4069d9cbfd10dbd 100644
---- a/third_party/blink/web_tests/external/wpt/fetch/range/sw.https.window.js
-+++ b/third_party/blink/web_tests/external/wpt/fetch/range/sw.https.window.js
-@@ -149,3 +149,78 @@ promise_test(async t => {
- 
-   assert_equals((await audioBroadcast).acceptEncoding, null, "Accept-Encoding should not be set for media");
- }, `Accept-Encoding should not appear in a service worker`);
-+
-+promise_test(async t => {
-+  const scope = BASE_SCOPE + Math.random();
-+  await setupRegistration(t, scope);
-+  const iframe = await with_iframe(scope);
-+  const w = iframe.contentWindow;
-+  const length = 100;
-+  const count = 3;
-+  const counts = {};
-+
-+  // test a single range request size
-+  async function testSizedRange(size, partialResponseCode) {
-+    const rangeId = Math.random() + '';
-+    const rangeBroadcast = awaitMessage(w.navigator.serviceWorker, rangeId);
-+
-+    // Create a bogus audo element to trick the browser into sending
-+    // cross-origin range requests that can be manipulated by the service worker.
-+    const sound_url = new URL('partial-text.py', w.location);
-+    sound_url.hostname = REMOTE_HOST;
-+    sound_url.searchParams.set('action', 'record-media-range-request');
-+    sound_url.searchParams.set('length', length);
-+    sound_url.searchParams.set('size', size);
-+    sound_url.searchParams.set('partial', partialResponseCode);
-+    sound_url.searchParams.set('id', rangeId);
-+    appendAudio(w.document, sound_url);
-+
-+    // wait for the range requests to happen
-+    await rangeBroadcast;
-+
-+    // Create multiple preload requests and count the number of resource timing
-+    // entries that get created to make sure 206 and 416 range responses are treated
-+    // the same.
-+    const url = new URL('partial-text.py', w.location);
-+    url.searchParams.set('action', 'use-media-range-request');
-+    url.searchParams.set('size', size);
-+    counts['size' + size] = 0;
-+    for (let i = 0; i < count; i++) {
-+      await preloadImage(url, { doc: w.document });
-+    }
-+  }
-+
-+  // Test range requests from 1 smaller than the correct size to 1 larger than
-+  // the correct size to exercise the various permutations using the default 206
-+  // response code for successful range requests.
-+  for (let size = length - 1; size <= length + 1; size++) {
-+    await testSizedRange(size, '206');
-+  }
-+
-+  // Test a successful range request using a 200 response.
-+  await testSizedRange(length - 2, '200');
-+
-+  // Check the resource timing entries and count the reported number of fetches of each type
-+  const resources = w.performance.getEntriesByType("resource");
-+  for (const entry of resources) {
-+    const url = new URL(entry.name);
-+    if (url.searchParams.has('action') &&
-+        url.searchParams.get('action') == 'use-media-range-request' &&
-+        url.searchParams.has('size')) {
-+      counts['size' + url.searchParams.get('size')]++;
-+    }
-+  }
-+
-+  // Make sure there are a non-zero number of preload requests and they are all the same
-+  let counts_valid = true;
-+  const first = 'size' + (length - 2);
-+  for (let size = length - 2; size <= length + 1; size++) {
-+    let key = 'size' + size;
-+    if (!(key in counts) || counts[key] <= 0 || counts[key] != counts[first]) {
-+      counts_valid = false;
-+      break;
-+    }
-+  }
-+
-+  assert_true(counts_valid, `Opaque range request preloads were different for error and success`);
-+}, `Opaque range preload successes and failures should be indistinguishable`);
diff --git a/patches/chromium/cherry-pick-27eb11a28555.patch b/patches/chromium/cherry-pick-27eb11a28555.patch
index 6d72498f48..01ace9539d 100644
--- a/patches/chromium/cherry-pick-27eb11a28555.patch
+++ b/patches/chromium/cherry-pick-27eb11a28555.patch
@@ -44,28 +44,3 @@ index 89813366845757aaa31a37ba155ad2e50a2f5010..88f9236a91c3b32cd1daabca4d42e47c
    timing_allow_failed_flag_ = !PassesTimingAllowOriginCheck(*response_head);
  
    // Because we initiate a new request on redirect in some cases, we cannot
-diff --git a/third_party/blink/web_tests/external/wpt/fetch/api/redirect/redirect-mode.any.js b/third_party/blink/web_tests/external/wpt/fetch/api/redirect/redirect-mode.any.js
-index eed44e0414cb8947c9b7c21df6ef288f733f8994..9f1ff98c65af97bcf185867ac6c6e128dbd77715 100644
---- a/third_party/blink/web_tests/external/wpt/fetch/api/redirect/redirect-mode.any.js
-+++ b/third_party/blink/web_tests/external/wpt/fetch/api/redirect/redirect-mode.any.js
-@@ -1,6 +1,7 @@
- // META: script=/common/get-host-info.sub.js
- 
- var redirectLocation = "cors-top.txt";
-+const { ORIGIN, REMOTE_ORIGIN } = get_host_info();
- 
- function testRedirect(origin, redirectStatus, redirectMode, corsMode) {
-   var url = new URL("../resources/redirect.py", self.location);
-@@ -47,4 +48,12 @@ for (var origin of ["same-origin", "cross-origin"]) {
-   }
- }
- 
-+promise_test(async (t) => {
-+  const destination = `${ORIGIN}/common/blank.html`;
-+  // We use /common/redirect.py intentionally, as we want a CORS error.
-+  const url =
-+    `${REMOTE_ORIGIN}/common/redirect.py?location=${destination}`;
-+  await promise_rejects_js(t, TypeError,  fetch(url, { redirect: "manual" }));
-+}, "manual redirect with a CORS error should be rejected");
-+
- done();
diff --git a/patches/chromium/fire_iframe_onload_for_cross-origin-initiated_same-document.patch b/patches/chromium/fire_iframe_onload_for_cross-origin-initiated_same-document.patch
index 9fef6aba84..0d0636095b 100644
--- a/patches/chromium/fire_iframe_onload_for_cross-origin-initiated_same-document.patch
+++ b/patches/chromium/fire_iframe_onload_for_cross-origin-initiated_same-document.patch
@@ -46,146 +46,3 @@ index 5f0be38667a04a3a47f190099b81778cc8b02757..ae8baa6ab44f83e114646247f99bd0b9
  
    // If the item sequence number didn't change, there's no need to trigger
    // popstate, restore scroll positions, or scroll to fragments for this
-diff --git a/third_party/blink/web_tests/http/tests/navigation/cross-origin-fragment-navigation-is-async-expected.txt b/third_party/blink/web_tests/http/tests/navigation/cross-origin-fragment-navigation-is-async-expected.txt
-index 850c54970953c62eae282e177949f9082f22a03c..09122d9c3f39f042116d197276420cc1841c5ea8 100644
---- a/third_party/blink/web_tests/http/tests/navigation/cross-origin-fragment-navigation-is-async-expected.txt
-+++ b/third_party/blink/web_tests/http/tests/navigation/cross-origin-fragment-navigation-is-async-expected.txt
-@@ -1,4 +1,6 @@
-+ALERT: iframe onload fired
- ALERT: PASS: url fragment is changing asynchronously
- ALERT: PASS: scheduled postMessage() before hashchange triggered.
-+ALERT: iframe onload fired
- ALERT: PASS: hashchange triggered after postMessage().
--This tests that cross-origin fragment navigations are asynchronous. It does so by scheduling a postMessage before scheduling the navigation. If the navigation is synchronous, the internals API will be able to report the presence of an url fragment immediately.
-+This tests that cross-origin-initiated fragment navigations are asynchronous and always fire the load event at their embedding iframe element if it's cross-origin. It does so by scheduling a postMessage before scheduling the navigation. If the navigation is synchronous, the internals API will be able to report the presence of an url fragment immediately.
-diff --git a/third_party/blink/web_tests/http/tests/navigation/cross-origin-fragment-navigation-is-async.html b/third_party/blink/web_tests/http/tests/navigation/cross-origin-fragment-navigation-is-async.html
-index 3d74de086c1a7f8a5fedff72d7c6bb970fca57ed..a1fc3bc87ccd2319f2dff3c5d8729a1a62875ec8 100644
---- a/third_party/blink/web_tests/http/tests/navigation/cross-origin-fragment-navigation-is-async.html
-+++ b/third_party/blink/web_tests/http/tests/navigation/cross-origin-fragment-navigation-is-async.html
-@@ -1,48 +1,51 @@
- <!DOCTYPE html>
- <html>
--<head>
--    <script>
--        if (window.testRunner) {
--            testRunner.dumpAsText();
--            testRunner.waitUntilDone();
--        }
-+<body>
-+<script>
-+if (window.testRunner) {
-+    testRunner.dumpAsText();
-+    testRunner.waitUntilDone();
-+}
- 
--        function testFragmentNavigation() {
--            window.postMessage("postmessage", "*");
--            document.querySelector('iframe').src = "http://localhost:8000/navigation/resources/postmessage-on-hashchange.html#anchor1";
--            if (window.internals) {
--                if (internals.doesWindowHaveUrlFragment(document.querySelector('iframe').contentWindow))
--                    alert("FAIL: url fragment should change asynchronously");
--                else
--                    alert("PASS: url fragment is changing asynchronously");
--            }
--        }
-+window.onload = function() {
-+    window.postMessage("postmessage", "*");
-+    document.querySelector('iframe').src = "http://localhost:8000/navigation/resources/postmessage-on-hashchange.html#anchor1";
-+    if (window.internals) {
-+        if (internals.doesWindowHaveUrlFragment(document.querySelector('iframe').contentWindow))
-+            alert("FAIL: url fragment should change asynchronously");
-+        else
-+            alert("PASS: url fragment is changing asynchronously");
-+    }
-+}
- 
--        var receivedScheduledPostMessage = false;
--        var receivedHashchangeMessage = false;
--        window.addEventListener('message', function (e) {
--            if (e.data === 'postmessage') {
--                receivedScheduledPostMessage = true;
--                if (receivedHashchangeMessage)
--                    alert('FAIL: hashchange already triggered!');
--                else
--                    alert('PASS: scheduled postMessage() before hashchange triggered.');
--            } else {
--                receivedHashchangeMessage = true;
--                if (receivedScheduledPostMessage)
--                    alert('PASS: hashchange triggered after postMessage().');
--                else
--                    alert('FAIL: hashchange triggered before postMessage().');
--                testRunner.notifyDone();
--            }
--        });
--    </script>
--</head>
--<body>
--    <p>This tests that cross-origin fragment navigations are asynchronous. It does
--    so by scheduling a postMessage before scheduling the navigation. If the
--    navigation is synchronous, the internals API will be able to report the presence
--    of an url fragment immediately.</p>
--    <iframe src="http://localhost:8000/navigation/resources/postmessage-on-hashchange.html" onload='testFragmentNavigation()'></iframe>
-+var receivedScheduledPostMessage = false;
-+var receivedHashchangeMessage = false;
-+window.addEventListener('message', function (e) {
-+    if (e.data === 'postmessage') {
-+        receivedScheduledPostMessage = true;
-+        if (receivedHashchangeMessage)
-+            alert('FAIL: hashchange already triggered!');
-+        else
-+            alert('PASS: scheduled postMessage() before hashchange triggered.');
-+    } else {
-+        receivedHashchangeMessage = true;
-+        if (receivedScheduledPostMessage)
-+            alert('PASS: hashchange triggered after postMessage().');
-+        else
-+            alert('FAIL: hashchange triggered before postMessage().');
-+        testRunner.notifyDone();
-+    }
-+});
-+
-+function onloadFired() {
-+    alert("iframe onload fired");
-+}
-+</script>
-+<p>This tests that cross-origin-initiated fragment navigations are asynchronous
-+and always fire the load event at their embedding iframe element if it's cross-origin. It does
-+so by scheduling a postMessage before scheduling the navigation. If the
-+navigation is synchronous, the internals API will be able to report the presence
-+of an url fragment immediately.</p>
-+<iframe src="http://localhost:8000/navigation/resources/postmessage-on-hashchange.html" onload="onloadFired()"></iframe>
- </body>
- </html>
-diff --git a/third_party/blink/web_tests/http/tests/navigation/same-origin-fragment-navigation-is-sync-expected.txt b/third_party/blink/web_tests/http/tests/navigation/same-origin-fragment-navigation-is-sync-expected.txt
-index c1c1143026cad5cfe51829a8c34d61c01a63ffbf..5a6ccc855e14417df8039f18dba7aa0474ff552d 100644
---- a/third_party/blink/web_tests/http/tests/navigation/same-origin-fragment-navigation-is-sync-expected.txt
-+++ b/third_party/blink/web_tests/http/tests/navigation/same-origin-fragment-navigation-is-sync-expected.txt
-@@ -1,3 +1,4 @@
-+ALERT: iframe onload fired
- ALERT: PASS: url fragment has changed synchronously
- ALERT: PASS: scheduled postMessage() before hashchange triggered.
- ALERT: PASS: hashchange triggered after postMessage().
-diff --git a/third_party/blink/web_tests/http/tests/navigation/same-origin-fragment-navigation-is-sync.html b/third_party/blink/web_tests/http/tests/navigation/same-origin-fragment-navigation-is-sync.html
-index 0ffe3cc8759e8e0ff4df7cad66c93cd5e2cbbe69..2cb9143bfce9a28d8803b49cf6afa7403554cdf4 100644
---- a/third_party/blink/web_tests/http/tests/navigation/same-origin-fragment-navigation-is-sync.html
-+++ b/third_party/blink/web_tests/http/tests/navigation/same-origin-fragment-navigation-is-sync.html
-@@ -36,6 +36,11 @@
-                 testRunner.notifyDone();
-             }
-         });
-+
-+    function onloadFired() {
-+        alert("iframe onload fired");
-+        testFragmentNavigation();
-+    }
-     </script>
- </head>
- <body>
-@@ -43,6 +48,6 @@
-     so by scheduling a postMessage before scheduling the navigation. If the
-     navigation is synchronous, the internals API will be able to report the presence
-     of an url fragment immediately.</p>
--    <iframe src="http://127.0.0.1:8000/navigation/resources/postmessage-on-hashchange.html" onload='testFragmentNavigation()'></iframe>
-+    <iframe src="http://127.0.0.1:8000/navigation/resources/postmessage-on-hashchange.html" onload='onloadFired()'></iframe>
- </body>
- </html>
diff --git a/patches/chromium/merge_m-97_serial_check_for_detached_buffers_when_writing.patch b/patches/chromium/merge_m-97_serial_check_for_detached_buffers_when_writing.patch
index 52581f51bd..cd6b1827c9 100644
--- a/patches/chromium/merge_m-97_serial_check_for_detached_buffers_when_writing.patch
+++ b/patches/chromium/merge_m-97_serial_check_for_detached_buffers_when_writing.patch
@@ -53,70 +53,3 @@ index 08ab2c7e05668710b77712f3ffc0d5aeef4dd213..7876baf19a1f547c71e2a115db8a2cc4
    const uint8_t* data = array_piece.Bytes();
    const uint32_t length = static_cast<uint32_t>(array_piece.ByteLength());
  
-diff --git a/third_party/blink/web_tests/external/wpt/serial/serialPort_writable.https.any.js b/third_party/blink/web_tests/external/wpt/serial/serialPort_writable.https.any.js
-index 9728af7de5051dce874e10082e1443a3ca9fa7dc..5e3b8548a91ddc2a0afa9793dea167f8e89defe3 100644
---- a/third_party/blink/web_tests/external/wpt/serial/serialPort_writable.https.any.js
-+++ b/third_party/blink/web_tests/external/wpt/serial/serialPort_writable.https.any.js
-@@ -70,7 +70,7 @@ serial_test(async (t, fake) => {
-   compareArrays(data, value);
- 
-   await port.close();
--}, 'Can read a large amount of data');
-+}, 'Can write a large amount of data');
- 
- serial_test(async (t, fake) => {
-   const {port, fakePort} = await getFakeSerialPort(fake);
-diff --git a/third_party/blink/web_tests/external/wpt/serial/serialPort_writable_detachBuffer.https.any.js b/third_party/blink/web_tests/external/wpt/serial/serialPort_writable_detachBuffer.https.any.js
-new file mode 100644
-index 0000000000000000000000000000000000000000..828e877726b1c63dba14efc36324d9a16aa4e62f
---- /dev/null
-+++ b/third_party/blink/web_tests/external/wpt/serial/serialPort_writable_detachBuffer.https.any.js
-@@ -0,0 +1,48 @@
-+// META: script=/resources/test-only-api.js
-+// META: script=/serial/resources/common.js
-+// META: script=resources/automation.js
-+
-+function detachBuffer(buffer) {
-+  const channel = new MessageChannel();
-+  channel.port1.postMessage('', [buffer]);
-+}
-+
-+serial_test(async (t, fake) => {
-+  const {port, fakePort} = await getFakeSerialPort(fake);
-+  await port.open({baudRate: 9600, bufferSize: 64});
-+
-+  const writer = port.writable.getWriter();
-+  const data = new Uint8Array(64);
-+  detachBuffer(data.buffer);
-+
-+  // Writing a detached buffer is equivalent to writing an empty buffer so this
-+  // should trivially succeed.
-+  await writer.write(data);
-+  writer.releaseLock();
-+
-+  await port.close();
-+}, 'Writing a detached buffer is safe');
-+
-+serial_test(async (t, fake) => {
-+  const {port, fakePort} = await getFakeSerialPort(fake);
-+  // Select a buffer size smaller than the amount of data transferred.
-+  await port.open({baudRate: 9600, bufferSize: 64});
-+
-+  // Start writing a buffer much larger than bufferSize above so that it can't
-+  // all be transfered in a single operation.
-+  const writer = port.writable.getWriter();
-+  const data = new Uint8Array(1024);
-+  const promise = writer.write(data);
-+  writer.releaseLock();
-+
-+  // Read half of the written data and then detach the buffer.
-+  await fakePort.readable();
-+  await fakePort.readWithLength(data.byteLength / 2);
-+  detachBuffer(data.buffer);
-+
-+  // When the buffer is detached its length becomes zero and so the write should
-+  // succeed but it is undefined how much data was written before that happened.
-+  await promise;
-+
-+  await port.close();
-+}, 'Detaching a buffer while writing is safe');
diff --git a/patches/chromium/pin_scrolltop_to_0_during_autofill_preview.patch b/patches/chromium/pin_scrolltop_to_0_during_autofill_preview.patch
index 426bffef7a..d434f18352 100644
--- a/patches/chromium/pin_scrolltop_to_0_during_autofill_preview.patch
+++ b/patches/chromium/pin_scrolltop_to_0_during_autofill_preview.patch
@@ -115,21 +115,3 @@ index c855514e9ac6c7521515c417cceffc2dacbab2d9..967f1a0ff38db262b74650915efcc44d
  }
  
  void Internals::setEditingValue(Element* element,
-diff --git a/third_party/blink/web_tests/fast/forms/text/input-appearance-autocomplete-suggested-value-over-placeholder-value-expected.html b/third_party/blink/web_tests/fast/forms/text/input-appearance-autocomplete-suggested-value-over-placeholder-value-expected.html
-index cac91c4f2fbecf5117b35318e7a88bda1a268135..30e454a79c4d3a5bc2a49879f0929557e011f819 100644
---- a/third_party/blink/web_tests/fast/forms/text/input-appearance-autocomplete-suggested-value-over-placeholder-value-expected.html
-+++ b/third_party/blink/web_tests/fast/forms/text/input-appearance-autocomplete-suggested-value-over-placeholder-value-expected.html
-@@ -1 +1,4 @@
- <input id="input" value="Springfield">
-+<script>
-+internals.setAutofilled(input, true);
-+</script>
-diff --git a/third_party/blink/web_tests/fast/forms/text/input-appearance-autocomplete-suggested-value-when-underlying-placeholder-is-removed-expected.html b/third_party/blink/web_tests/fast/forms/text/input-appearance-autocomplete-suggested-value-when-underlying-placeholder-is-removed-expected.html
-index cac91c4f2fbecf5117b35318e7a88bda1a268135..30e454a79c4d3a5bc2a49879f0929557e011f819 100644
---- a/third_party/blink/web_tests/fast/forms/text/input-appearance-autocomplete-suggested-value-when-underlying-placeholder-is-removed-expected.html
-+++ b/third_party/blink/web_tests/fast/forms/text/input-appearance-autocomplete-suggested-value-when-underlying-placeholder-is-removed-expected.html
-@@ -1 +1,4 @@
- <input id="input" value="Springfield">
-+<script>
-+internals.setAutofilled(input, true);
-+</script>
diff --git a/patches/v8/cherry-pick-27bc67f761e6.patch b/patches/v8/cherry-pick-27bc67f761e6.patch
index 72e1506e16..deff779a6b 100644
--- a/patches/v8/cherry-pick-27bc67f761e6.patch
+++ b/patches/v8/cherry-pick-27bc67f761e6.patch
@@ -226,28 +226,3 @@ index 69b0f6241bd006c90b57fd371e01f311d4fee115..8f54f7607bd572933cafae62ca8361e8
  
    return ReadOnlyRoots(isolate).undefined_value();
  }
-diff --git a/test/cctest/test-api.cc b/test/cctest/test-api.cc
-index b21222f14c533cb630946b6066bfe24d1be49f93..9ba0707c33b4e96940d2aeaafe044a6548fa9923 100644
---- a/test/cctest/test-api.cc
-+++ b/test/cctest/test-api.cc
-@@ -62,6 +62,7 @@
- #include "src/objects/js-array-inl.h"
- #include "src/objects/js-promise-inl.h"
- #include "src/objects/lookup.h"
-+#include "src/objects/map-updater.h"
- #include "src/objects/module-inl.h"
- #include "src/objects/objects-inl.h"
- #include "src/objects/string-inl.h"
-@@ -2972,9 +2973,9 @@ TEST(InternalFieldsSubclassing) {
-         CHECK_LE(i_value->map().GetInObjectProperties(), kMaxNofProperties);
-       }
- 
--      // Make Sure we get the precise property count.
--      i_value->map().FindRootMap(i_isolate).CompleteInobjectSlackTracking(
--          i_isolate);
-+      // Make sure we get the precise property count.
-+      i::MapUpdater::CompleteInobjectSlackTracking(
-+          i_isolate, i_value->map().FindRootMap(i_isolate));
-       // TODO(cbruni): fix accounting to make this condition true.
-       // CHECK_EQ(0, i_value->map()->UnusedPropertyFields());
-       if (in_object_only) {
diff --git a/patches/v8/cherry-pick-26b7ad6967b1.patch b/patches/v8/cherry-pick-26b7ad6967b1.patch
index 86adb18ac0..c8d77385d7 100644
--- a/patches/v8/cherry-pick-26b7ad6967b1.patch
+++ b/patches/v8/cherry-pick-26b7ad6967b1.patch
@@ -48,37 +48,3 @@ index 2f16615536ae5d44bd55774a0282e5017100a9d0..99e9ccad058406370ee6666af787e74c
        }
  
        case LookupIterator::ACCESSOR: {
-diff --git a/test/cctest/test-api-interceptors.cc b/test/cctest/test-api-interceptors.cc
-index 815c538d227ae048d382798c9f99bebe054fb6d7..475003f73c49b8e462ef1896f3fad97857e24574 100644
---- a/test/cctest/test-api-interceptors.cc
-+++ b/test/cctest/test-api-interceptors.cc
-@@ -5636,10 +5636,10 @@ void DatabaseGetter(Local<Name> name,
-                     const v8::PropertyCallbackInfo<Value>& info) {
-   ApiTestFuzzer::Fuzz();
-   auto context = info.GetIsolate()->GetCurrentContext();
--  Local<v8::Object> db = info.Holder()
--                             ->GetRealNamedProperty(context, v8_str("db"))
--                             .ToLocalChecked()
--                             .As<v8::Object>();
-+  v8::MaybeLocal<Value> maybe_db =
-+      info.Holder()->GetRealNamedProperty(context, v8_str("db"));
-+  if (maybe_db.IsEmpty()) return;
-+  Local<v8::Object> db = maybe_db.ToLocalChecked().As<v8::Object>();
-   if (!db->Has(context, name).FromJust()) return;
-   info.GetReturnValue().Set(db->Get(context, name).ToLocalChecked());
- }
-diff --git a/test/unittests/api/interceptor-unittest.cc b/test/unittests/api/interceptor-unittest.cc
-index 8a1db3f823e5d957907e193971d220853c2b2e91..bc00462a29d707ec296f72b82ee2992ea8c9031f 100644
---- a/test/unittests/api/interceptor-unittest.cc
-+++ b/test/unittests/api/interceptor-unittest.cc
-@@ -170,8 +170,8 @@ TEST_F(InterceptorLoggingTest, DispatchTest) {
-   EXPECT_EQ(Run("obj.foo"), "named getter");
-   EXPECT_EQ(Run("obj[42]"), "indexed getter");
- 
--  EXPECT_EQ(Run("obj.foo = null"), "named setter");
--  EXPECT_EQ(Run("obj[42] = null"), "indexed setter");
-+  EXPECT_EQ(Run("obj.foo = null"), "named setter, named descriptor");
-+  EXPECT_EQ(Run("obj[42] = null"), "indexed setter, indexed descriptor");
- 
-   EXPECT_EQ(Run("Object.getOwnPropertyDescriptor(obj, 'foo')"),
-             "named descriptor");
diff --git a/patches/v8/.patches b/patches/v8/.patches
index 9928105a6a..2aeb832115 100644
--- a/patches/v8/.patches
+++ b/patches/v8/.patches
@@ -7,7 +7,6 @@ do_not_export_private_v8_symbols_on_windows.patch
 fix_build_deprecated_attirbute_for_older_msvc_versions.patch
 fix_disable_implies_dcheck_for_node_stream_array_buffers.patch
 cppgc-js_support_eager_traced_value_in_ephemeron_pairs.patch
-regexp_add_a_currently_failing_cctest_for_irregexp_reentrancy.patch
 regexp_allow_reentrant_irregexp_execution.patch
 regexp_remove_the_stack_parameter_from_regexp_matchers.patch
 cherry-pick-6de4e210688e.patch
