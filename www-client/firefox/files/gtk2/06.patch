From 3987158be14b1a6a30510c83c4dfcf95a2502165 Mon Sep 17 00:00:00 2001
From: David Parks <daparks@mozilla.com>
Date: Mon, 5 Apr 2021 23:48:35 +0000
Subject: [PATCH] Bug 1682030 - Remove some dead NPAPI code from dom/plugins
 and related spots.  r=jmathies,mconley,ipc-reviewers,mccr8

This is the first of two patches in this series that removes a large amount of now dead code from dom/plugins as part of removing all NPAPI plugin support.  This patch removes re-entrancy guards we have for Windows OnPaint messages, as the guards were only needed for windowed plugins.

Differential Revision: https://phabricator.services.mozilla.com/D107144
---
 browser/installer/package-manifest.in         |    1 -
 dom/base/nsObjectLoadingContent.cpp           |  343 +-
 dom/base/nsObjectLoadingContent.h             |    9 +-
 dom/events/TextComposition.cpp                |    4 -
 dom/ipc/ContentChild.cpp                      |   27 +-
 dom/ipc/ContentChild.h                        |    4 -
 dom/ipc/ContentParent.cpp                     |   25 -
 dom/ipc/ContentParent.h                       |    8 -
 dom/ipc/PContent.ipdl                         |   31 -
 dom/ipc/ProcessHangMonitor.cpp                |   35 +-
 dom/moz.build                                 |    4 -
 dom/plugins/base/moz.build                    |   34 -
 dom/plugins/base/npfunctions.h                |  356 --
 dom/plugins/base/npruntime.h                  |  382 --
 dom/plugins/base/nsIHTTPHeaderListener.idl    |   29 -
 dom/plugins/base/nsIPluginInputStream.idl     |   20 -
 dom/plugins/base/nsIPluginInstanceOwner.idl   |  121 -
 dom/plugins/base/nsJSNPRuntime.cpp            | 2185 ----------
 dom/plugins/base/nsJSNPRuntime.h              |   99 -
 dom/plugins/base/nsNPAPIPlugin.cpp            | 1886 ---------
 dom/plugins/base/nsNPAPIPlugin.h              |  288 --
 dom/plugins/base/nsNPAPIPluginInstance.cpp    |  695 +---
 dom/plugins/base/nsNPAPIPluginInstance.h      |   38 +-
 .../base/nsNPAPIPluginStreamListener.cpp      |  776 ----
 .../base/nsNPAPIPluginStreamListener.h        |  126 -
 dom/plugins/base/nsPluginHost.cpp             | 1091 +----
 dom/plugins/base/nsPluginHost.h               |   70 -
 dom/plugins/base/nsPluginInstanceOwner.cpp    | 1724 --------
 dom/plugins/base/nsPluginInstanceOwner.h      |  365 --
 dom/plugins/base/nsPluginManifestLineReader.h |  101 -
 dom/plugins/base/nsPluginNativeWindow.cpp     |   61 -
 dom/plugins/base/nsPluginNativeWindow.h       |   76 -
 dom/plugins/base/nsPluginNativeWindowWin.cpp  |  633 ---
 .../base/nsPluginStreamListenerPeer.cpp       |  605 ---
 dom/plugins/base/nsPluginStreamListenerPeer.h |  149 -
 dom/plugins/base/nsPluginTags.cpp             |   41 +-
 dom/plugins/base/nsPluginTags.h               |    5 -
 dom/plugins/base/nsPluginsCID.h               |   16 -
 dom/plugins/base/nsPluginsDir.h               |   80 -
 dom/plugins/base/nsPluginsDirDarwin.cpp       |  522 ---
 dom/plugins/base/nsPluginsDirUnix.cpp         |  188 -
 dom/plugins/base/nsPluginsDirUtils.h          |   88 -
 dom/plugins/base/nsPluginsDirWin.cpp          |  349 --
 dom/plugins/base/nspluginroot.idl             |   23 -
 dom/plugins/ipc/AStream.h                     |   26 -
 dom/plugins/ipc/BrowserStreamChild.cpp        |  217 -
 dom/plugins/ipc/BrowserStreamChild.h          |  150 -
 dom/plugins/ipc/BrowserStreamParent.cpp       |   85 -
 dom/plugins/ipc/BrowserStreamParent.h         |   58 -
 dom/plugins/ipc/ChildTimer.cpp                |   31 -
 dom/plugins/ipc/ChildTimer.h                  |   55 -
 dom/plugins/ipc/D3D11SurfaceHolder.cpp        |   81 -
 dom/plugins/ipc/D3D11SurfaceHolder.h          |   46 -
 dom/plugins/ipc/FunctionBroker.cpp            | 1429 -------
 dom/plugins/ipc/FunctionBroker.h              | 1452 -------
 dom/plugins/ipc/FunctionBrokerChild.cpp       |  111 -
 dom/plugins/ipc/FunctionBrokerChild.h         |   51 -
 dom/plugins/ipc/FunctionBrokerIPCUtils.cpp    |  334 --
 dom/plugins/ipc/FunctionBrokerIPCUtils.h      |  436 --
 dom/plugins/ipc/FunctionBrokerParent.cpp      |  139 -
 dom/plugins/ipc/FunctionBrokerParent.h        |   67 -
 dom/plugins/ipc/FunctionBrokerThread.h        |   52 -
 dom/plugins/ipc/FunctionHook.cpp              |  359 --
 dom/plugins/ipc/FunctionHook.h                |  206 -
 dom/plugins/ipc/IpdlTuple.h                   |  186 -
 dom/plugins/ipc/MiniShmParent.cpp             |  178 -
 dom/plugins/ipc/MiniShmParent.h               |   87 -
 dom/plugins/ipc/NPEventAndroid.h              |   50 -
 dom/plugins/ipc/NPEventOSX.h                  |  198 -
 dom/plugins/ipc/NPEventUnix.h                 |   90 -
 dom/plugins/ipc/NPEventWindows.h              |  158 -
 dom/plugins/ipc/PBrowserStream.ipdl           |   42 -
 dom/plugins/ipc/PFunctionBroker.ipdl          |   23 -
 .../ipc/PPluginBackgroundDestroyer.ipdl       |   34 -
 dom/plugins/ipc/PPluginInstance.ipdl          |  270 --
 dom/plugins/ipc/PPluginModule.ipdl            |  148 -
 dom/plugins/ipc/PPluginScriptableObject.ipdl  |  102 -
 dom/plugins/ipc/PStreamNotify.ipdl            |   39 -
 dom/plugins/ipc/PluginBackgroundDestroyer.cpp |   35 -
 dom/plugins/ipc/PluginBackgroundDestroyer.h   |   56 -
 dom/plugins/ipc/PluginBridge.h                |   41 -
 dom/plugins/ipc/PluginHangUIParent.cpp        |  400 --
 dom/plugins/ipc/PluginHangUIParent.h          |  142 -
 dom/plugins/ipc/PluginInstanceChild.cpp       | 3694 -----------------
 dom/plugins/ipc/PluginInstanceChild.h         |  577 ---
 dom/plugins/ipc/PluginInstanceParent.cpp      | 2277 ----------
 dom/plugins/ipc/PluginInstanceParent.h        |  391 --
 dom/plugins/ipc/PluginLibrary.h               |  122 -
 dom/plugins/ipc/PluginMessageUtils.cpp        |  141 -
 dom/plugins/ipc/PluginMessageUtils.h          |  562 ---
 dom/plugins/ipc/PluginModuleChild.cpp         | 1974 ---------
 dom/plugins/ipc/PluginModuleChild.h           |  333 --
 dom/plugins/ipc/PluginModuleParent.cpp        | 2469 -----------
 dom/plugins/ipc/PluginModuleParent.h          |  532 ---
 dom/plugins/ipc/PluginProcessChild.cpp        |  186 -
 dom/plugins/ipc/PluginProcessChild.h          |   53 -
 dom/plugins/ipc/PluginProcessParent.cpp       |  191 -
 dom/plugins/ipc/PluginProcessParent.h         |   97 -
 dom/plugins/ipc/PluginQuirks.cpp              |   54 -
 dom/plugins/ipc/PluginQuirks.h                |   64 -
 .../ipc/PluginScriptableObjectChild.cpp       | 1198 ------
 dom/plugins/ipc/PluginScriptableObjectChild.h |  275 --
 .../ipc/PluginScriptableObjectParent.cpp      | 1289 ------
 .../ipc/PluginScriptableObjectParent.h        |  169 -
 .../ipc/PluginScriptableObjectUtils-inl.h     |  154 -
 dom/plugins/ipc/PluginScriptableObjectUtils.h |  253 --
 dom/plugins/ipc/PluginTypes.ipdlh             |   48 -
 dom/plugins/ipc/PluginUtilsOSX.h              |   94 -
 dom/plugins/ipc/PluginUtilsOSX.mm             |  429 --
 dom/plugins/ipc/PluginUtilsWin.cpp            |  271 --
 dom/plugins/ipc/PluginUtilsWin.h              |   27 -
 dom/plugins/ipc/StreamNotifyChild.h           |   60 -
 dom/plugins/ipc/StreamNotifyParent.h          |   41 -
 dom/plugins/ipc/hangui/HangUIDlg.h            |   17 -
 dom/plugins/ipc/hangui/HangUIDlg.rc           |   26 -
 dom/plugins/ipc/hangui/MiniShmBase.h          |  280 --
 dom/plugins/ipc/hangui/MiniShmChild.cpp       |  160 -
 dom/plugins/ipc/hangui/MiniShmChild.h         |   63 -
 dom/plugins/ipc/hangui/PluginHangUI.h         |   39 -
 dom/plugins/ipc/hangui/PluginHangUIChild.cpp  |  386 --
 dom/plugins/ipc/hangui/PluginHangUIChild.h    |  100 -
 dom/plugins/ipc/hangui/module.ver             |    6 -
 dom/plugins/ipc/hangui/moz.build              |   27 -
 .../ipc/hangui/plugin-hang-ui.exe.manifest    |   37 -
 dom/plugins/ipc/moz.build                     |  124 -
 dom/webidl/HTMLObjectElement.webidl           |    7 -
 ipc/glue/ProcessUtils_mac.mm                  |   95 +-
 ipc/ipdl/sync-messages.ini                    |   38 -
 tools/lint/rejected-words.yml                 |    1 -
 widget/nsIPluginWidget.h                      |    5 -
 widget/windows/nsWindow.cpp                   |   64 -
 widget/windows/nsWindowGfx.cpp                |   50 -
 132 files changed, 178 insertions(+), 40749 deletions(-)
 delete mode 100644 dom/plugins/base/npfunctions.h
 delete mode 100644 dom/plugins/base/npruntime.h
 delete mode 100644 dom/plugins/base/nsIHTTPHeaderListener.idl
 delete mode 100644 dom/plugins/base/nsIPluginInputStream.idl
 delete mode 100644 dom/plugins/base/nsIPluginInstanceOwner.idl
 delete mode 100644 dom/plugins/base/nsJSNPRuntime.cpp
 delete mode 100644 dom/plugins/base/nsJSNPRuntime.h
 delete mode 100644 dom/plugins/base/nsNPAPIPlugin.cpp
 delete mode 100644 dom/plugins/base/nsNPAPIPlugin.h
 delete mode 100644 dom/plugins/base/nsNPAPIPluginStreamListener.cpp
 delete mode 100644 dom/plugins/base/nsNPAPIPluginStreamListener.h
 delete mode 100644 dom/plugins/base/nsPluginInstanceOwner.cpp
 delete mode 100644 dom/plugins/base/nsPluginInstanceOwner.h
 delete mode 100644 dom/plugins/base/nsPluginManifestLineReader.h
 delete mode 100644 dom/plugins/base/nsPluginNativeWindow.cpp
 delete mode 100644 dom/plugins/base/nsPluginNativeWindow.h
 delete mode 100644 dom/plugins/base/nsPluginNativeWindowWin.cpp
 delete mode 100644 dom/plugins/base/nsPluginStreamListenerPeer.cpp
 delete mode 100644 dom/plugins/base/nsPluginStreamListenerPeer.h
 delete mode 100644 dom/plugins/base/nsPluginsCID.h
 delete mode 100644 dom/plugins/base/nsPluginsDir.h
 delete mode 100644 dom/plugins/base/nsPluginsDirDarwin.cpp
 delete mode 100644 dom/plugins/base/nsPluginsDirUnix.cpp
 delete mode 100644 dom/plugins/base/nsPluginsDirUtils.h
 delete mode 100644 dom/plugins/base/nsPluginsDirWin.cpp
 delete mode 100644 dom/plugins/ipc/AStream.h
 delete mode 100644 dom/plugins/ipc/BrowserStreamChild.cpp
 delete mode 100644 dom/plugins/ipc/BrowserStreamChild.h
 delete mode 100644 dom/plugins/ipc/BrowserStreamParent.cpp
 delete mode 100644 dom/plugins/ipc/BrowserStreamParent.h
 delete mode 100644 dom/plugins/ipc/ChildTimer.cpp
 delete mode 100644 dom/plugins/ipc/ChildTimer.h
 delete mode 100644 dom/plugins/ipc/D3D11SurfaceHolder.cpp
 delete mode 100644 dom/plugins/ipc/D3D11SurfaceHolder.h
 delete mode 100644 dom/plugins/ipc/FunctionBroker.cpp
 delete mode 100644 dom/plugins/ipc/FunctionBroker.h
 delete mode 100644 dom/plugins/ipc/FunctionBrokerChild.cpp
 delete mode 100644 dom/plugins/ipc/FunctionBrokerChild.h
 delete mode 100644 dom/plugins/ipc/FunctionBrokerIPCUtils.cpp
 delete mode 100644 dom/plugins/ipc/FunctionBrokerIPCUtils.h
 delete mode 100644 dom/plugins/ipc/FunctionBrokerParent.cpp
 delete mode 100644 dom/plugins/ipc/FunctionBrokerParent.h
 delete mode 100644 dom/plugins/ipc/FunctionBrokerThread.h
 delete mode 100644 dom/plugins/ipc/FunctionHook.cpp
 delete mode 100644 dom/plugins/ipc/FunctionHook.h
 delete mode 100644 dom/plugins/ipc/IpdlTuple.h
 delete mode 100644 dom/plugins/ipc/MiniShmParent.cpp
 delete mode 100644 dom/plugins/ipc/MiniShmParent.h
 delete mode 100644 dom/plugins/ipc/NPEventAndroid.h
 delete mode 100644 dom/plugins/ipc/NPEventOSX.h
 delete mode 100644 dom/plugins/ipc/NPEventUnix.h
 delete mode 100644 dom/plugins/ipc/NPEventWindows.h
 delete mode 100644 dom/plugins/ipc/PBrowserStream.ipdl
 delete mode 100644 dom/plugins/ipc/PFunctionBroker.ipdl
 delete mode 100644 dom/plugins/ipc/PPluginBackgroundDestroyer.ipdl
 delete mode 100644 dom/plugins/ipc/PPluginInstance.ipdl
 delete mode 100644 dom/plugins/ipc/PPluginModule.ipdl
 delete mode 100644 dom/plugins/ipc/PPluginScriptableObject.ipdl
 delete mode 100644 dom/plugins/ipc/PStreamNotify.ipdl
 delete mode 100644 dom/plugins/ipc/PluginBackgroundDestroyer.cpp
 delete mode 100644 dom/plugins/ipc/PluginBackgroundDestroyer.h
 delete mode 100644 dom/plugins/ipc/PluginBridge.h
 delete mode 100644 dom/plugins/ipc/PluginHangUIParent.cpp
 delete mode 100644 dom/plugins/ipc/PluginHangUIParent.h
 delete mode 100644 dom/plugins/ipc/PluginInstanceChild.cpp
 delete mode 100644 dom/plugins/ipc/PluginInstanceChild.h
 delete mode 100644 dom/plugins/ipc/PluginInstanceParent.cpp
 delete mode 100644 dom/plugins/ipc/PluginInstanceParent.h
 delete mode 100644 dom/plugins/ipc/PluginLibrary.h
 delete mode 100644 dom/plugins/ipc/PluginMessageUtils.cpp
 delete mode 100644 dom/plugins/ipc/PluginMessageUtils.h
 delete mode 100644 dom/plugins/ipc/PluginModuleChild.cpp
 delete mode 100644 dom/plugins/ipc/PluginModuleChild.h
 delete mode 100644 dom/plugins/ipc/PluginModuleParent.cpp
 delete mode 100644 dom/plugins/ipc/PluginModuleParent.h
 delete mode 100644 dom/plugins/ipc/PluginProcessChild.cpp
 delete mode 100644 dom/plugins/ipc/PluginProcessChild.h
 delete mode 100644 dom/plugins/ipc/PluginProcessParent.cpp
 delete mode 100644 dom/plugins/ipc/PluginProcessParent.h
 delete mode 100644 dom/plugins/ipc/PluginQuirks.cpp
 delete mode 100644 dom/plugins/ipc/PluginQuirks.h
 delete mode 100644 dom/plugins/ipc/PluginScriptableObjectChild.cpp
 delete mode 100644 dom/plugins/ipc/PluginScriptableObjectChild.h
 delete mode 100644 dom/plugins/ipc/PluginScriptableObjectParent.cpp
 delete mode 100644 dom/plugins/ipc/PluginScriptableObjectParent.h
 delete mode 100644 dom/plugins/ipc/PluginScriptableObjectUtils-inl.h
 delete mode 100644 dom/plugins/ipc/PluginScriptableObjectUtils.h
 delete mode 100644 dom/plugins/ipc/PluginTypes.ipdlh
 delete mode 100644 dom/plugins/ipc/PluginUtilsOSX.h
 delete mode 100644 dom/plugins/ipc/PluginUtilsOSX.mm
 delete mode 100644 dom/plugins/ipc/PluginUtilsWin.cpp
 delete mode 100644 dom/plugins/ipc/PluginUtilsWin.h
 delete mode 100644 dom/plugins/ipc/StreamNotifyChild.h
 delete mode 100644 dom/plugins/ipc/StreamNotifyParent.h
 delete mode 100644 dom/plugins/ipc/hangui/HangUIDlg.h
 delete mode 100644 dom/plugins/ipc/hangui/HangUIDlg.rc
 delete mode 100644 dom/plugins/ipc/hangui/MiniShmBase.h
 delete mode 100644 dom/plugins/ipc/hangui/MiniShmChild.cpp
 delete mode 100644 dom/plugins/ipc/hangui/MiniShmChild.h
 delete mode 100644 dom/plugins/ipc/hangui/PluginHangUI.h
 delete mode 100644 dom/plugins/ipc/hangui/PluginHangUIChild.cpp
 delete mode 100644 dom/plugins/ipc/hangui/PluginHangUIChild.h
 delete mode 100644 dom/plugins/ipc/hangui/module.ver
 delete mode 100644 dom/plugins/ipc/hangui/moz.build
 delete mode 100644 dom/plugins/ipc/hangui/plugin-hang-ui.exe.manifest
 delete mode 100644 dom/plugins/ipc/moz.build

diff --git a/browser/installer/package-manifest.in b/browser/installer/package-manifest.in
index 7f18811a1590e..8c25bce084fee 100644
--- a/browser/installer/package-manifest.in
+++ b/browser/installer/package-manifest.in
@@ -94,7 +94,6 @@
 @BINPATH@/@MOZ_CHILD_PROCESS_NAME@
 #endif
 #ifdef XP_WIN
-@BINPATH@/plugin-hang-ui@BIN_SUFFIX@
 #if MOZ_PACKAGE_MSVC_DLLS
 @BINPATH@/@MSVC_C_RUNTIME_DLL@
 @BINPATH@/@MSVC_CXX_RUNTIME_DLL@
diff --git a/dom/base/nsObjectLoadingContent.cpp b/dom/base/nsObjectLoadingContent.cpp
index a3ffe3ebf22cf..c7166e31ebceb 100644
--- a/dom/base/nsObjectLoadingContent.cpp
+++ b/dom/base/nsObjectLoadingContent.cpp
@@ -23,10 +23,9 @@
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsIOService.h"
 #include "nsIPermissionManager.h"
+#include "nsNPAPIPluginInstance.h"
 #include "nsPluginHost.h"
-#include "nsPluginInstanceOwner.h"
 #include "nsIHttpChannel.h"
-#include "nsJSNPRuntime.h"
 #include "nsINestedURI.h"
 #include "nsScriptSecurityManager.h"
 #include "nsIURILoader.h"
@@ -108,8 +107,6 @@
 #  endif
 #endif  // XP_WIN
 
-static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
-
 static const char kPrefYoutubeRewrite[] = "plugins.rewrite_youtube_embeds";
 static const char kPrefFavorFallbackMode[] = "plugins.favorfallback.mode";
 static const char kPrefFavorFallbackRules[] = "plugins.favorfallback.rules";
@@ -497,26 +494,7 @@ void nsObjectLoadingContent::QueueCheckPluginStopEvent() {
 
 // Tedious syntax to create a plugin stream listener with checks and put it in
 // mFinalListener
-bool nsObjectLoadingContent::MakePluginListener() {
-  if (!mInstanceOwner) {
-    MOZ_ASSERT_UNREACHABLE("expecting a spawned plugin");
-    return false;
-  }
-  RefPtr<nsPluginHost> pluginHost = nsPluginHost::GetInst();
-  if (!pluginHost) {
-    MOZ_ASSERT_UNREACHABLE("No pluginHost");
-    return false;
-  }
-  NS_ASSERTION(!mFinalListener, "overwriting a final listener");
-  nsresult rv;
-  RefPtr<nsNPAPIPluginInstance> inst = mInstanceOwner->GetInstance();
-  nsCOMPtr<nsIStreamListener> finalListener;
-  rv = pluginHost->NewPluginStreamListener(mURI, inst,
-                                           getter_AddRefs(finalListener));
-  NS_ENSURE_SUCCESS(rv, false);
-  mFinalListener = finalListener;
-  return true;
-}
+bool nsObjectLoadingContent::MakePluginListener() { return false; }
 
 // Helper to spawn the frameloader.
 void nsObjectLoadingContent::SetupFrameLoader(int32_t aJSPluginId) {
@@ -580,15 +558,7 @@ void nsObjectLoadingContent::UnbindFromTree(bool aNullParent) {
   Document* ownerDoc = thisElement->OwnerDoc();
   ownerDoc->RemovePlugin(this);
 
-  /// XXX(johns): Do we want to somehow propogate the reparenting behavior to
-  ///             FakePlugin types as well?
-  if (mType == eType_Plugin && (mInstanceOwner || mInstantiating)) {
-    // we'll let the plugin continue to run at least until we get back to
-    // the event loop. If we get back to the event loop and the node
-    // has still not been added back to the document then we tear down the
-    // plugin
-    QueueCheckPluginStopEvent();
-  } else if (mType != eType_Image) {
+  if (mType != eType_Image) {
     // nsImageLoadingContent handles the image case.
     // Reset state and clear pending events
     /// XXX(johns): The implementation for GenericFrame notes that ideally we
@@ -632,7 +602,7 @@ nsObjectLoadingContent::~nsObjectLoadingContent() {
         "Should not be tearing down frame loaders at this point");
     mFrameLoader->Destroy();
   }
-  if (mInstanceOwner || mInstantiating) {
+  if (mInstantiating) {
     // This is especially bad as delayed stop will try to hold on to this
     // object...
     MOZ_ASSERT_UNREACHABLE(
@@ -643,137 +613,7 @@ nsObjectLoadingContent::~nsObjectLoadingContent() {
 }
 
 nsresult nsObjectLoadingContent::InstantiatePluginInstance(bool aIsLoading) {
-  if (mInstanceOwner || mType != eType_Plugin || (mIsLoading != aIsLoading) ||
-      mInstantiating) {
-    // If we hit this assertion it's probably because LoadObject re-entered :(
-    //
-    // XXX(johns): This hackiness will go away in bug 767635
-    NS_ASSERTION(mIsLoading || !aIsLoading,
-                 "aIsLoading should only be true inside LoadObject");
-    return NS_OK;
-  }
-
-  mInstantiating = true;
-  AutoSetInstantiatingToFalse autoInstantiating(this);
-
-  nsCOMPtr<nsIContent> thisContent =
-      do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
-
-  nsCOMPtr<Document> doc = thisContent->GetComposedDoc();
-  if (!doc || !InActiveDocument(thisContent)) {
-    NS_ERROR(
-        "Shouldn't be calling "
-        "InstantiatePluginInstance without an active document");
-    return NS_ERROR_FAILURE;
-  }
-
-  // Instantiating an instance can result in script execution, which
-  // can destroy this DOM object. Don't allow that for the scope
-  // of this method.
-  nsCOMPtr<nsIObjectLoadingContent> kungFuDeathGrip = this;
-
-  // Flush layout so that the frame is created if possible and the plugin is
-  // initialized with the latest information.
-  doc->FlushPendingNotifications(FlushType::Layout);
-  // Flushing layout may have re-entered and loaded something underneath us
-  NS_ENSURE_TRUE(mInstantiating, NS_OK);
-
-  if (!thisContent->GetPrimaryFrame()) {
-    LOG(("OBJLC [%p]: Not instantiating plugin with no frame", this));
-    return NS_OK;
-  }
-
-  RefPtr<nsPluginHost> pluginHost = nsPluginHost::GetInst();
-
-  if (!pluginHost) {
-    MOZ_ASSERT_UNREACHABLE("No pluginhost");
-    return NS_ERROR_FAILURE;
-  }
-
-  // If you add early return(s), be sure to balance this call to
-  // appShell->SuspendNative() with additional call(s) to
-  // appShell->ReturnNative().
-  nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
-  if (appShell) {
-    appShell->SuspendNative();
-  }
-
-  RefPtr<nsPluginInstanceOwner> newOwner;
-  nsresult rv = pluginHost->InstantiatePluginInstance(
-      mContentType, mURI.get(), this, getter_AddRefs(newOwner));
-
-  // XXX(johns): We don't suspend native inside stopping plugins...
-  if (appShell) {
-    appShell->ResumeNative();
-  }
-
-  if (!mInstantiating || NS_FAILED(rv)) {
-    LOG(
-        ("OBJLC [%p]: Plugin instantiation failed or re-entered, "
-         "killing old instance",
-         this));
-    // XXX(johns): This needs to be de-duplicated with DoStopPlugin, but we
-    //             don't want to touch the protochain or delayed stop.
-    //             (Bug 767635)
-    if (newOwner) {
-      RefPtr<nsNPAPIPluginInstance> inst = newOwner->GetInstance();
-      if (inst) {
-        pluginHost->StopPluginInstance(inst);
-      }
-      newOwner->Destroy();
-    }
-    return NS_OK;
-  }
-
-  mInstanceOwner = newOwner;
-
-  if (mInstanceOwner) {
-    RefPtr<nsNPAPIPluginInstance> inst = mInstanceOwner->GetInstance();
-
-    rv = inst->GetRunID(&mRunID);
-    mHasRunID = NS_SUCCEEDED(rv);
-  }
-
-  // Set up scripting interfaces.
-  NotifyContentObjectWrapper();
-
-  RefPtr<nsNPAPIPluginInstance> pluginInstance = GetPluginInstance();
-  if (pluginInstance) {
-    nsCOMPtr<nsIPluginTag> pluginTag;
-    pluginHost->GetPluginTagForInstance(pluginInstance,
-                                        getter_AddRefs(pluginTag));
-
-    uint32_t blockState = nsIBlocklistService::STATE_NOT_BLOCKED;
-    pluginTag->GetBlocklistState(&blockState);
-    if (blockState == nsIBlocklistService::STATE_OUTDATED) {
-      // Fire plugin outdated event if necessary
-      LOG(("OBJLC [%p]: Dispatching plugin outdated event for content\n",
-           this));
-      nsCOMPtr<nsIRunnable> ev =
-          new nsSimplePluginEvent(thisContent, u"PluginOutdated"_ns);
-      nsresult rv = NS_DispatchToCurrentThread(ev);
-      if (NS_FAILED(rv)) {
-        NS_WARNING("failed to dispatch nsSimplePluginEvent");
-      }
-    }
-
-    // If we have a URI but didn't open a channel yet (eAllowPluginSkipChannel)
-    // or we did load with a channel but are re-instantiating, re-open the
-    // channel. OpenChannel() performs security checks, and this plugin has
-    // already passed content policy in LoadObject.
-    if ((mURI && !mChannelLoaded) || (mChannelLoaded && !aIsLoading)) {
-      NS_ASSERTION(!mChannel, "should not have an existing channel here");
-      // We intentionally ignore errors here, leaving it up to the plugin to
-      // deal with not having an initial stream.
-      OpenChannel();
-    }
-  }
-
-  nsCOMPtr<nsIRunnable> ev =
-      new nsSimplePluginEvent(thisContent, doc, u"PluginInstantiated"_ns);
-  NS_DispatchToCurrentThread(ev);
-
-  return NS_OK;
+  return NS_ERROR_FAILURE;
 }
 
 void nsObjectLoadingContent::GetPluginAttributes(
@@ -898,7 +738,7 @@ void nsObjectLoadingContent::NotifyOwnerDocumentActivityChanged() {
 
   // If we have a plugin we want to queue an event to stop it unless we are
   // moved into an active document before returning to the event loop.
-  if (mInstanceOwner || mInstantiating) {
+  if (mInstantiating) {
     QueueCheckPluginStopEvent();
   }
   nsImageLoadingContent::NotifyOwnerDocumentActivityChanged();
@@ -916,25 +756,6 @@ nsObjectLoadingContent::OnStartRequest(nsIRequest* aRequest) {
     return NS_BINDING_ABORTED;
   }
 
-  // If we already switched to type plugin, this channel can just be passed to
-  // the final listener.
-  if (mType == eType_Plugin) {
-    if (!mInstanceOwner) {
-      // We drop mChannel when stopping plugins, so something is wrong
-      MOZ_ASSERT_UNREACHABLE(
-          "Opened a channel in plugin mode, but don't have "
-          "a plugin");
-      return NS_BINDING_ABORTED;
-    }
-    if (MakePluginListener()) {
-      return mFinalListener->OnStartRequest(aRequest);
-    }
-    MOZ_ASSERT_UNREACHABLE(
-        "Failed to create PluginStreamListener, aborting "
-        "channel");
-    return NS_BINDING_ABORTED;
-  }
-
   nsCOMPtr<nsIChannel> chan(do_QueryInterface(aRequest));
   NS_ASSERTION(chan, "Why is our request not a channel?");
 
@@ -1097,11 +918,7 @@ nsObjectLoadingContent::GetDisplayedType(uint32_t* aType) {
 }
 
 nsNPAPIPluginInstance* nsObjectLoadingContent::GetPluginInstance() {
-  if (!mInstanceOwner) {
-    return nullptr;
-  }
-
-  return mInstanceOwner->GetInstance();
+  return nullptr;
 }
 
 NS_IMETHODIMP
@@ -2023,7 +1840,7 @@ nsresult nsObjectLoadingContent::LoadObject(bool aNotify, bool aForceLoad,
 
   // Sanity check: We shouldn't have any loaded resources, pending events, or
   // a final listener at this point
-  if (mFrameLoader || mPendingInstantiateEvent || mInstanceOwner ||
+  if (mFrameLoader || mPendingInstantiateEvent ||
       mPendingCheckPluginStopEvent || mFinalListener) {
     MOZ_ASSERT_UNREACHABLE("Trying to load new plugin with existing content");
     return NS_OK;
@@ -2157,7 +1974,7 @@ nsresult nsObjectLoadingContent::LoadObject(bool aNotify, bool aForceLoad,
   // If we didn't load anything, handle switching to fallback state
   if (mType == eType_Null) {
     LOG(("OBJLC [%p]: Loading fallback, type %u", this, fallbackType));
-    NS_ASSERTION(!mFrameLoader && !mInstanceOwner,
+    NS_ASSERTION(!mFrameLoader,
                  "switched to type null but also loaded something");
 
     // Don't fire error events if we're falling back to click-to-play or if we
@@ -2426,7 +2243,7 @@ void nsObjectLoadingContent::Destroy() {
     mFrameLoader = nullptr;
   }
 
-  if (mInstanceOwner || mInstantiating) {
+  if (mInstantiating) {
     QueueCheckPluginStopEvent();
   }
 
@@ -2479,13 +2296,7 @@ void nsObjectLoadingContent::UnloadObject(bool aResetState) {
 
   mScriptRequested = false;
 
-  if (mIsStopping) {
-    // The protochain is normally thrown out after a plugin stops, but if we
-    // re-enter while stopping a plugin and try to load something new, we need
-    // to throw away the old protochain in the nested unload.
-    TeardownProtoChain();
-    mIsStopping = false;
-  }
+  mIsStopping = false;
 
   mCachedAttributes.Clear();
   mCachedParameters.Clear();
@@ -2595,17 +2406,7 @@ void nsObjectLoadingContent::CreateStaticClone(
 }
 
 NS_IMETHODIMP
-nsObjectLoadingContent::PluginDestroyed() {
-  // Called when our plugin is destroyed from under us, usually when reloading
-  // plugins in plugin host. Invalidate instance owner / prototype but otherwise
-  // don't take any action.
-  TeardownProtoChain();
-  if (mInstanceOwner) {
-    mInstanceOwner->Destroy();
-    mInstanceOwner = nullptr;
-  }
-  return NS_OK;
-}
+nsObjectLoadingContent::PluginDestroyed() { return NS_OK; }
 
 NS_IMETHODIMP
 nsObjectLoadingContent::PluginCrashed(nsIPluginTag* aPluginTag,
@@ -2674,7 +2475,7 @@ nsNPAPIPluginInstance* nsObjectLoadingContent::ScriptRequestPluginInstance(
       MOZ_ASSERT_UNREACHABLE("failed to dispatch PluginScripted event");
     }
     mScriptRequested = true;
-  } else if (callerIsContentJS && mType == eType_Plugin && !mInstanceOwner &&
+  } else if (callerIsContentJS && mType == eType_Plugin &&
              nsContentUtils::IsSafeToRunScript() &&
              InActiveDocument(thisContent)) {
     // If we're configured as a plugin in an active document and it's safe to
@@ -2682,10 +2483,6 @@ nsNPAPIPluginInstance* nsObjectLoadingContent::ScriptRequestPluginInstance(
     SyncStartPluginInstance();
   }
 
-  if (mInstanceOwner) {
-    return mInstanceOwner->GetInstance();
-  }
-
   // Note that returning a null plugin is expected (and happens often)
   return nullptr;
 }
@@ -2713,8 +2510,7 @@ nsObjectLoadingContent::SyncStartPluginInstance() {
 
 NS_IMETHODIMP
 nsObjectLoadingContent::AsyncStartPluginInstance() {
-  // OK to have an instance already or a pending spawn.
-  if (mInstanceOwner || mPendingInstantiateEvent) {
+  if (mPendingInstantiateEvent) {
     return NS_OK;
   }
 
@@ -2746,7 +2542,7 @@ void nsObjectLoadingContent::LoadFallback(FallbackType aType, bool aNotify) {
   ObjectType oldType = mType;
   FallbackType oldFallbackType = mFallbackType;
 
-  NS_ASSERTION(!mInstanceOwner && !mFrameLoader && !mChannel,
+  NS_ASSERTION(!mFrameLoader && !mChannel,
                "LoadFallback called with loaded content");
 
   //
@@ -2813,49 +2609,6 @@ void nsObjectLoadingContent::LoadFallback(FallbackType aType, bool aNotify) {
   NotifyStateChanged(oldType, oldState, oldFallbackType, false, true);
 }
 
-void nsObjectLoadingContent::DoStopPlugin(
-    nsPluginInstanceOwner* aInstanceOwner) {
-  // DoStopPlugin can process events -- There may be pending
-  // CheckPluginStopEvent events which can drop in underneath us and destroy the
-  // instance we are about to destroy. We prevent that with the mIsStopping
-  // flag.
-  if (mIsStopping) {
-    return;
-  }
-  mIsStopping = true;
-
-  RefPtr<nsPluginInstanceOwner> kungFuDeathGrip(aInstanceOwner);
-  if (mType == eType_FakePlugin) {
-    if (mFrameLoader) {
-      mFrameLoader->Destroy();
-      mFrameLoader = nullptr;
-    }
-  } else {
-    RefPtr<nsNPAPIPluginInstance> inst = aInstanceOwner->GetInstance();
-    if (inst) {
-#if defined(XP_MACOSX)
-      aInstanceOwner->HidePluginWindow();
-#endif
-
-      RefPtr<nsPluginHost> pluginHost = nsPluginHost::GetInst();
-      NS_ASSERTION(pluginHost, "No plugin host?");
-      pluginHost->StopPluginInstance(inst);
-    }
-  }
-
-  aInstanceOwner->Destroy();
-
-  // If we re-enter in plugin teardown UnloadObject will tear down the
-  // protochain -- the current protochain could be from a new, unrelated, load.
-  if (!mIsStopping) {
-    LOG(("OBJLC [%p]: Re-entered in plugin teardown", this));
-    return;
-  }
-
-  TeardownProtoChain();
-  mIsStopping = false;
-}
-
 NS_IMETHODIMP
 nsObjectLoadingContent::StopPluginInstance() {
   AUTO_PROFILER_LABEL("nsObjectLoadingContent::StopPluginInstance", OTHER);
@@ -2867,26 +2620,6 @@ nsObjectLoadingContent::StopPluginInstance() {
   // InstantiatePluginInstance's re-entrance check to destroy the created plugin
   mInstantiating = false;
 
-  if (!mInstanceOwner) {
-    return NS_OK;
-  }
-
-  if (mChannel) {
-    // The plugin has already used data from this channel, we'll need to
-    // re-open it to handle instantiating again, even if we don't invalidate
-    // our loaded state.
-    /// XXX(johns): Except currently, we don't, just leaving re-opening channels
-    ///             to plugins...
-    LOG(("OBJLC [%p]: StopPluginInstance - Closing used channel", this));
-    CloseChannel();
-  }
-
-  RefPtr<nsPluginInstanceOwner> ownerGrip(mInstanceOwner);
-  mInstanceOwner = nullptr;
-
-  // This can/will re-enter
-  DoStopPlugin(ownerGrip);
-
   return NS_OK;
 }
 
@@ -3318,52 +3051,6 @@ nsresult nsObjectLoadingContent::GetPluginJSObject(
   return NS_OK;
 }
 
-void nsObjectLoadingContent::TeardownProtoChain() {
-  nsCOMPtr<nsIContent> thisContent =
-      do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
-
-  NS_ENSURE_TRUE_VOID(thisContent->GetWrapper());
-
-  // We don't init the AutoJSAPI with our wrapper because we don't want it
-  // reporting errors to our window's onerror listeners.
-  AutoJSAPI jsapi;
-  jsapi.Init();
-  JSContext* cx = jsapi.cx();
-  JS::Rooted<JSObject*> obj(cx, thisContent->GetWrapper());
-  MOZ_ASSERT(obj);
-
-  JS::Rooted<JSObject*> proto(cx);
-  JSAutoRealm ar(cx, obj);
-
-  // Loop over the DOM element's JS object prototype chain and remove
-  // all JS objects of the class sNPObjectJSWrapperClass
-  DebugOnly<bool> removed = false;
-  while (obj) {
-    if (!::JS_GetPrototype(cx, obj, &proto)) {
-      return;
-    }
-    if (!proto) {
-      break;
-    }
-    // Unwrap while checking the class - if the prototype is a wrapper for
-    // an NP object, that counts too.
-    if (nsNPObjWrapper::IsWrapper(js::UncheckedUnwrap(proto))) {
-      // We found an NPObject on the proto chain, get its prototype...
-      if (!::JS_GetPrototype(cx, proto, &proto)) {
-        return;
-      }
-
-      MOZ_ASSERT(!removed, "more than one NPObject in prototype chain");
-      removed = true;
-
-      // ... and pull it out of the chain.
-      ::JS_SetPrototype(cx, obj, proto);
-    }
-
-    obj = proto;
-  }
-}
-
 bool nsObjectLoadingContent::DoResolve(
     JSContext* aCx, JS::Handle<JSObject*> aObject, JS::Handle<jsid> aId,
     JS::MutableHandle<JS::PropertyDescriptor> aDesc) {
diff --git a/dom/base/nsObjectLoadingContent.h b/dom/base/nsObjectLoadingContent.h
index 1f1180f829e06..77dfad7fc616f 100644
--- a/dom/base/nsObjectLoadingContent.h
+++ b/dom/base/nsObjectLoadingContent.h
@@ -29,7 +29,6 @@ class nsStopPluginRunnable;
 class AutoSetInstantiatingToFalse;
 class nsIPrincipal;
 class nsFrameLoader;
-class nsPluginInstanceOwner;
 
 namespace mozilla {
 namespace dom {
@@ -174,9 +173,6 @@ class nsObjectLoadingContent : public nsImageLoadingContent,
   // Helper for WebIDL node wrapping
   void SetupProtoChain(JSContext* aCx, JS::Handle<JSObject*> aObject);
 
-  // Remove plugin from protochain
-  void TeardownProtoChain();
-
   // Helper for WebIDL NeedResolve
   bool DoResolve(JSContext* aCx, JS::Handle<JSObject*> aObject,
                  JS::Handle<jsid> aId,
@@ -214,7 +210,7 @@ class nsObjectLoadingContent : public nsImageLoadingContent,
   uint32_t DefaultFallbackType();
 
   uint32_t PluginFallbackType() const { return mFallbackType; }
-  bool HasRunningPlugin() const { return !!mInstanceOwner; }
+
   // FIXME rename this
   void SkipFakePlugins(mozilla::ErrorResult& aRv) { aRv = SkipFakePlugins(); }
   void SwapFrameLoaders(mozilla::dom::HTMLIFrameElement& aOtherLoaderOwner,
@@ -328,8 +324,6 @@ class nsObjectLoadingContent : public nsImageLoadingContent,
 
   void CreateStaticClone(nsObjectLoadingContent* aDest) const;
 
-  void DoStopPlugin(nsPluginInstanceOwner* aInstanceOwner);
-
   nsresult BindToTree(mozilla::dom::BindContext&, nsINode& aParent);
   void UnbindFromTree(bool aNullParent = true);
 
@@ -700,7 +694,6 @@ class nsObjectLoadingContent : public nsImageLoadingContent,
   bool mPreferFallback : 1;
   bool mPreferFallbackKnown : 1;
 
-  RefPtr<nsPluginInstanceOwner> mInstanceOwner;
   nsTArray<mozilla::dom::MozPluginParameter> mCachedAttributes;
   nsTArray<mozilla::dom::MozPluginParameter> mCachedParameters;
 
diff --git a/dom/events/TextComposition.cpp b/dom/events/TextComposition.cpp
index 748b5f4fdf3ce..9e25ec41be248 100644
--- a/dom/events/TextComposition.cpp
+++ b/dom/events/TextComposition.cpp
@@ -31,8 +31,6 @@
 #  define Comment _Comment
 #endif
 
-#include "nsPluginInstanceOwner.h"
-
 #ifdef XP_MACOSX
 #  undef TextRange
 #  undef TextRangeArray
@@ -149,8 +147,6 @@ void TextComposition::DispatchEvent(
     WidgetCompositionEvent* aDispatchEvent, nsEventStatus* aStatus,
     EventDispatchingCallback* aCallBack,
     const WidgetCompositionEvent* aOriginalEvent) {
-  nsPluginInstanceOwner::GeneratePluginEvent(aOriginalEvent, aDispatchEvent);
-
   if (aDispatchEvent->mMessage == eCompositionChange) {
     aDispatchEvent->mFlags.mOnlySystemGroupDispatchInContent = true;
   }
diff --git a/dom/ipc/ContentChild.cpp b/dom/ipc/ContentChild.cpp
index 8d78849c99d33..8b914f75d6bc5 100644
--- a/dom/ipc/ContentChild.cpp
+++ b/dom/ipc/ContentChild.cpp
@@ -107,8 +107,6 @@
 #include "mozilla/net/DocumentChannelChild.h"
 #include "mozilla/net/HttpChannelChild.h"
 #include "mozilla/net/NeckoChild.h"
-#include "mozilla/plugins/PluginInstanceParent.h"
-#include "mozilla/plugins/PluginModuleParent.h"
 #include "mozilla/widget/RemoteLookAndFeel.h"
 #include "mozilla/widget/ScreenManager.h"
 #include "mozilla/widget/WidgetMessageUtils.h"
@@ -143,6 +141,7 @@
 #    include "mozilla/SandboxInfo.h"
 #  elif defined(XP_MACOSX)
 #    include "mozilla/Sandbox.h"
+#    include "mozilla/gfx/QuartzSupport.h"
 #  elif defined(__OpenBSD__)
 #    include <err.h>
 #    include <sys/stat.h>
@@ -2928,26 +2927,10 @@ void ContentChild::ShutdownInternal() {
 
 mozilla::ipc::IPCResult ContentChild::RecvUpdateWindow(
     const uintptr_t& aChildId) {
-#if defined(XP_WIN)
-  NS_ASSERTION(aChildId,
-               "Expected child hwnd value for remote plugin instance.");
-  mozilla::plugins::PluginInstanceParent* parentInstance =
-      mozilla::plugins::PluginInstanceParent::LookupPluginInstanceByID(
-          aChildId);
-  if (parentInstance) {
-    // sync! update call to the plugin instance that forces the
-    // plugin to paint its child window.
-    if (!parentInstance->CallUpdateWindow()) {
-      return IPC_FAIL_NO_REASON(this);
-    }
-  }
-  return IPC_OK();
-#else
   MOZ_ASSERT(
       false,
       "ContentChild::RecvUpdateWindow calls unexpected on this platform.");
   return IPC_FAIL_NO_REASON(this);
-#endif
 }
 
 PContentPermissionRequestChild*
@@ -3313,14 +3296,6 @@ mozilla::ipc::IPCResult ContentChild::RecvRefreshScreens(
   return IPC_OK();
 }
 
-mozilla::ipc::IPCResult ContentChild::RecvSetPluginList(
-    const uint32_t& aPluginEpoch, nsTArray<plugins::PluginTag>&& aPluginTags,
-    nsTArray<plugins::FakePluginTag>&& aFakePluginTags) {
-  RefPtr<nsPluginHost> host = nsPluginHost::GetInst();
-  host->SetPluginsInContent(aPluginEpoch, aPluginTags, aFakePluginTags);
-  return IPC_OK();
-}
-
 mozilla::ipc::IPCResult ContentChild::RecvShareCodeCoverageMutex(
     const CrossProcessMutexHandle& aHandle) {
 #ifdef MOZ_CODE_COVERAGE
diff --git a/dom/ipc/ContentChild.h b/dom/ipc/ContentChild.h
index 59da30be77010..99b6bcaaebb76 100644
--- a/dom/ipc/ContentChild.h
+++ b/dom/ipc/ContentChild.h
@@ -612,10 +612,6 @@ class ContentChild final : public PContentChild,
   nsresult AsyncOpenAnonymousTemporaryFile(
       const AnonymousTemporaryFileCallback& aCallback);
 
-  mozilla::ipc::IPCResult RecvSetPluginList(
-      const uint32_t& aPluginEpoch, nsTArray<PluginTag>&& aPluginTags,
-      nsTArray<FakePluginTag>&& aFakePluginTags);
-
   mozilla::ipc::IPCResult RecvSaveRecording(const FileDescriptor& aFile);
 
   mozilla::ipc::IPCResult RecvCrossProcessRedirect(
diff --git a/dom/ipc/ContentParent.cpp b/dom/ipc/ContentParent.cpp
index ab09824894698..9cd35b55e670e 100644
--- a/dom/ipc/ContentParent.cpp
+++ b/dom/ipc/ContentParent.cpp
@@ -154,7 +154,6 @@
 #include "mozilla/net/NeckoMessageUtils.h"
 #include "mozilla/net/NeckoParent.h"
 #include "mozilla/net/PCookieServiceParent.h"
-#include "mozilla/plugins/PluginBridge.h"
 #include "mozilla/Telemetry.h"
 #include "mozilla/TelemetryComms.h"
 #include "mozilla/TelemetryEventEnums.h"
@@ -1272,16 +1271,6 @@ mozilla::ipc::IPCResult ContentParent::RecvCreateGMPService() {
   return IPC_OK();
 }
 
-mozilla::ipc::IPCResult ContentParent::RecvLoadPlugin(
-    const uint32_t& aPluginId, nsresult* aRv, uint32_t* aRunID,
-    Endpoint<PPluginModuleParent>* aEndpoint) {
-  *aRv = NS_OK;
-  if (!mozilla::plugins::SetupBridge(aPluginId, this, aRv, aRunID, aEndpoint)) {
-    return IPC_FAIL_NO_REASON(this);
-  }
-  return IPC_OK();
-}
-
 mozilla::ipc::IPCResult ContentParent::RecvUngrabPointer(
     const uint32_t& aTime) {
 #if !defined(MOZ_WIDGET_GTK)
@@ -1451,20 +1440,6 @@ mozilla::ipc::IPCResult ContentParent::RecvRemovePermission(
   return IPC_OK();
 }
 
-mozilla::ipc::IPCResult ContentParent::RecvConnectPluginBridge(
-    const uint32_t& aPluginId, nsresult* aRv,
-    Endpoint<PPluginModuleParent>* aEndpoint) {
-  *aRv = NS_OK;
-  // We don't need to get the run ID for the plugin, since we already got it
-  // in the first call to SetupBridge in RecvLoadPlugin, so we pass in a dummy
-  // pointer and just throw it away.
-  uint32_t dummy = 0;
-  if (!mozilla::plugins::SetupBridge(aPluginId, this, aRv, &dummy, aEndpoint)) {
-    return IPC_FAIL(this, "SetupBridge failed");
-  }
-  return IPC_OK();
-}
-
 /*static*/
 already_AddRefed<RemoteBrowser> ContentParent::CreateBrowser(
     const TabContext& aContext, Element* aFrameElement,
diff --git a/dom/ipc/ContentParent.h b/dom/ipc/ContentParent.h
index f0bd638ee75d4..fdb51e072ee17 100644
--- a/dom/ipc/ContentParent.h
+++ b/dom/ipc/ContentParent.h
@@ -336,16 +336,8 @@ class ContentParent final
 
   mozilla::ipc::IPCResult RecvCreateGMPService();
 
-  mozilla::ipc::IPCResult RecvLoadPlugin(
-      const uint32_t& aPluginId, nsresult* aRv, uint32_t* aRunID,
-      Endpoint<PPluginModuleParent>* aEndpoint);
-
   mozilla::ipc::IPCResult RecvMaybeReloadPlugins();
 
-  mozilla::ipc::IPCResult RecvConnectPluginBridge(
-      const uint32_t& aPluginId, nsresult* aRv,
-      Endpoint<PPluginModuleParent>* aEndpoint);
-
   mozilla::ipc::IPCResult RecvUngrabPointer(const uint32_t& aTime);
 
   mozilla::ipc::IPCResult RecvRemovePermission(const IPC::Principal& aPrincipal,
diff --git a/dom/ipc/PContent.ipdl b/dom/ipc/PContent.ipdl
index 4cb6a69b2d436..e7cb79a34dd8e 100644
--- a/dom/ipc/PContent.ipdl
+++ b/dom/ipc/PContent.ipdl
@@ -24,7 +24,6 @@ include protocol PNecko;
 include protocol PStreamFilter;
 include protocol PGMPContent;
 include protocol PGMPService;
-include protocol PPluginModule;
 include protocol PGMP;
 include protocol PPrinting;
 include protocol PChildToParentStream;
@@ -51,7 +50,6 @@ include WindowGlobalTypes;
 include IPCBlob;
 include IPCStream;
 include PTabContext;
-include PluginTypes;
 include ProtocolTypes;
 include PBackgroundSharedTypes;
 include PContentPermission;
@@ -777,18 +775,6 @@ child:
 
     async PRemoteLazyInputStream(nsID aID, uint64_t aSize);
 
-    /**
-     * This call takes the set of plugins loaded in the chrome process, and
-     * sends them to the content process. However, in many cases this set will
-     * not have changed since the last SetPluginList message. To keep track of
-     * this, the chrome process increments an epoch number every time the set of
-     * plugins changes. The chrome process sends up the last epoch it observed.
-     * If the epoch last seen by the content process is the same, the content
-     * process ignores the update. Otherwise the content process updates its
-     * list and reloads its plugins.
-     **/
-    async SetPluginList(uint32_t pluginEpoch, PluginTag[] plugins, FakePluginTag[] fakePlugins);
-
     async ShareCodeCoverageMutex(CrossProcessMutexHandle handle);
     async FlushCodeCoverageCounters() returns (bool unused);
 
@@ -967,23 +953,6 @@ parent:
     async InitStreamFilter(uint64_t channelId, nsString addonId)
         returns (Endpoint<PStreamFilterChild> aEndpoint);
 
-    /**
-     * This call connects the content process to a plugin process. This call
-     * returns an endpoint for a new PluginModuleParent. The corresponding
-     * PluginModuleChild will be started up in the plugin process.
-     */
-    sync LoadPlugin(uint32_t aPluginId)
-        returns (nsresult aResult, uint32_t aRunID, Endpoint<PPluginModuleParent> aEndpoint);
-
-    /**
-     * This call is used by asynchronous plugin instantiation to notify the
-     * content parent that it is now safe to initiate the plugin bridge for
-     * the specified plugin id. The endpoint for the content process part of the
-     * bridge is returned.
-     */
-    sync ConnectPluginBridge(uint32_t aPluginId)
-        returns (nsresult rv, Endpoint<PPluginModuleParent> aEndpoint);
-
     async PRemoteSpellcheckEngine();
 
     async InitCrashReporter(NativeThreadId tid);
diff --git a/dom/ipc/ProcessHangMonitor.cpp b/dom/ipc/ProcessHangMonitor.cpp
index ad740135317b6..ebdeb675a73dd 100644
--- a/dom/ipc/ProcessHangMonitor.cpp
+++ b/dom/ipc/ProcessHangMonitor.cpp
@@ -24,7 +24,6 @@
 #include "mozilla/ipc/Endpoint.h"
 #include "mozilla/ipc/TaskFactory.h"
 #include "mozilla/Monitor.h"
-#include "mozilla/plugins/PluginBridge.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/StaticPrefs_browser.h"
 #include "mozilla/StaticPrefs_dom.h"
@@ -841,18 +840,10 @@ void HangMonitorParent::SendHangNotification(const HangData& aHangData,
   MOZ_RELEASE_ASSERT(NS_IsMainThread());
 
   nsString dumpId;
-  if ((aHangData.type() == HangData::TPluginHangData) && aTakeMinidump) {
-    // We've been handed a partial minidump; complete it with plugin and
-    // content process dumps.
-    const PluginHangData& phd = aHangData.get_PluginHangData();
-
-    plugins::TakeFullMinidump(phd.pluginId(), phd.contentProcessId(),
-                              aBrowserDumpId, dumpId);
-    UpdateMinidump(phd.pluginId(), dumpId);
-  } else {
-    // We already have a full minidump; go ahead and use it.
-    dumpId = aBrowserDumpId;
-  }
+  MOZ_ASSERT(aHangData.type() != HangData::TPluginHangData);
+
+  // We already have a full minidump; go ahead and use it.
+  dumpId = aBrowserDumpId;
 
   mProcess->SetHangData(aHangData, dumpId);
 
@@ -1174,23 +1165,7 @@ HangMonitoredProcess::EndStartingDebugger() {
 }
 
 NS_IMETHODIMP
-HangMonitoredProcess::TerminatePlugin() {
-  MOZ_RELEASE_ASSERT(NS_IsMainThread());
-  if (mHangData.type() != HangData::TPluginHangData) {
-    return NS_ERROR_UNEXPECTED;
-  }
-
-  // Use the multi-process crash report generated earlier.
-  uint32_t id = mHangData.get_PluginHangData().pluginId();
-  base::ProcessId contentPid =
-      mHangData.get_PluginHangData().contentProcessId();
-  plugins::TerminatePlugin(id, contentPid, "HangMonitor"_ns, mDumpId);
-
-  if (mActor) {
-    mActor->CleanupPluginHang(id, false);
-  }
-  return NS_OK;
-}
+HangMonitoredProcess::TerminatePlugin() { return NS_ERROR_UNEXPECTED; }
 
 NS_IMETHODIMP
 HangMonitoredProcess::IsReportForBrowserOrChildren(nsFrameLoader* aFrameLoader,
diff --git a/dom/moz.build b/dom/moz.build
index a447700e7c721..2a9fa64144c35 100644
--- a/dom/moz.build
+++ b/dom/moz.build
@@ -72,7 +72,6 @@ DIRS += [
     "network",
     "permission",
     "plugins/base",
-    "plugins/ipc",
     "prototype",
     "indexedDB",
     "system",
@@ -110,9 +109,6 @@ DIRS += [
     "l10n",
 ]
 
-if CONFIG["OS_ARCH"] == "WINNT":
-    DIRS += ["plugins/ipc/hangui"]
-
 TEST_DIRS += [
     "tests",
     "imptests",
diff --git a/dom/plugins/base/moz.build b/dom/plugins/base/moz.build
index e1ee17fc5c443..5b5e10f1f1034 100644
--- a/dom/plugins/base/moz.build
+++ b/dom/plugins/base/moz.build
@@ -5,11 +5,8 @@
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 XPIDL_SOURCES += [
-    "nsIHTTPHeaderListener.idl",
     "nsIPluginDocument.idl",
     "nsIPluginHost.idl",
-    "nsIPluginInputStream.idl",
-    "nsIPluginInstanceOwner.idl",
     "nsIPluginTag.idl",
     "nspluginroot.idl",
 ]
@@ -18,59 +15,28 @@ XPIDL_MODULE = "plugin"
 
 EXPORTS += [
     "npapi.h",
-    "npfunctions.h",
-    "npruntime.h",
     "nptypes.h",
-    "nsJSNPRuntime.h",
     "nsNPAPIPluginInstance.h",
     "nsPluginHost.h",
-    "nsPluginInstanceOwner.h",
     "nsPluginLogging.h",
-    "nsPluginNativeWindow.h",
-    "nsPluginsCID.h",
-    "nsPluginsDir.h",
     "nsPluginTags.h",
 ]
 
 UNIFIED_SOURCES += [
-    "nsJSNPRuntime.cpp",
     "nsNPAPIPluginInstance.cpp",
-    "nsNPAPIPluginStreamListener.cpp",
-    "nsPluginInstanceOwner.cpp",
-    "nsPluginStreamListenerPeer.cpp",
     "nsPluginTags.cpp",
 ]
 
 SOURCES += [
-    "nsNPAPIPlugin.cpp",  # Conflict with X11 headers
     "nsPluginHost.cpp",  # Conflict with NS_NPAPIPLUGIN_CALLBACK
 ]
 
-if CONFIG["OS_ARCH"] == "WINNT":
-    UNIFIED_SOURCES += [
-        "nsPluginNativeWindowWin.cpp",
-        "nsPluginsDirWin.cpp",
-    ]
-elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "cocoa":
-    UNIFIED_SOURCES += [
-        "nsPluginNativeWindow.cpp",
-    ]
-    SOURCES += [
-        "nsPluginsDirDarwin.cpp",  # conflict with mozilla::EventPriority
-    ]
-else:
-    UNIFIED_SOURCES += [
-        "nsPluginNativeWindow.cpp",
-        "nsPluginsDirUnix.cpp",
-    ]
-
 XPCOM_MANIFESTS += [
     "components.conf",
 ]
 
 LOCAL_INCLUDES += [
     "/dom/base",
-    "/dom/plugins/ipc",
     "/layout/generic",
     "/layout/xul",
     "/netwerk/base",
diff --git a/dom/plugins/base/npfunctions.h b/dom/plugins/base/npfunctions.h
deleted file mode 100644
index 72d279b25ffc6..0000000000000
--- a/dom/plugins/base/npfunctions.h
+++ /dev/null
@@ -1,356 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef npfunctions_h_
-#define npfunctions_h_
-
-#include "npapi.h"
-#include "npruntime.h"
-
-typedef NPError (*NPP_NewProcPtr)(NPMIMEType pluginType, NPP instance,
-                                  uint16_t mode, int16_t argc, char* argn[],
-                                  char* argv[], NPSavedData* saved);
-typedef NPError (*NPP_DestroyProcPtr)(NPP instance, NPSavedData** save);
-typedef NPError (*NPP_SetWindowProcPtr)(NPP instance, NPWindow* window);
-typedef NPError (*NPP_NewStreamProcPtr)(NPP instance, NPMIMEType type,
-                                        NPStream* stream, NPBool seekable,
-                                        uint16_t* stype);
-typedef NPError (*NPP_DestroyStreamProcPtr)(NPP instance, NPStream* stream,
-                                            NPReason reason);
-typedef int32_t (*NPP_WriteReadyProcPtr)(NPP instance, NPStream* stream);
-typedef int32_t (*NPP_WriteProcPtr)(NPP instance, NPStream* stream,
-                                    int32_t offset, int32_t len, void* buffer);
-typedef void (*NPP_StreamAsFileProcPtr)(NPP instance, NPStream* stream,
-                                        const char* fname);
-typedef void (*NPP_PrintProcPtr)(NPP instance, NPPrint* platformPrint);
-typedef int16_t (*NPP_HandleEventProcPtr)(NPP instance, void* event);
-typedef void (*NPP_URLNotifyProcPtr)(NPP instance, const char* url,
-                                     NPReason reason, void* notifyData);
-/* Any NPObjects returned to the browser via NPP_GetValue should be retained
-   by the plugin on the way out. The browser is responsible for releasing. */
-typedef NPError (*NPP_GetValueProcPtr)(NPP instance, NPPVariable variable,
-                                       void* ret_value);
-typedef NPError (*NPP_SetValueProcPtr)(NPP instance, NPNVariable variable,
-                                       void* value);
-typedef NPBool (*NPP_GotFocusPtr)(NPP instance, NPFocusDirection direction);
-typedef void (*NPP_LostFocusPtr)(NPP instance);
-typedef void (*NPP_URLRedirectNotifyPtr)(NPP instance, const char* url,
-                                         int32_t status, void* notifyData);
-typedef NPError (*NPP_ClearSiteDataPtr)(const char* site, uint64_t flags,
-                                        uint64_t maxAge);
-typedef char** (*NPP_GetSitesWithDataPtr)(void);
-typedef void (*NPP_DidCompositePtr)(NPP instance);
-
-typedef NPError (*NPN_GetValueProcPtr)(NPP instance, NPNVariable variable,
-                                       void* ret_value);
-typedef NPError (*NPN_SetValueProcPtr)(NPP instance, NPPVariable variable,
-                                       void* value);
-typedef NPError (*NPN_GetURLNotifyProcPtr)(NPP instance, const char* url,
-                                           const char* window,
-                                           void* notifyData);
-typedef NPError (*NPN_PostURLNotifyProcPtr)(NPP instance, const char* url,
-                                            const char* window, uint32_t len,
-                                            const char* buf, NPBool file,
-                                            void* notifyData);
-typedef NPError (*NPN_GetURLProcPtr)(NPP instance, const char* url,
-                                     const char* window);
-typedef NPError (*NPN_PostURLProcPtr)(NPP instance, const char* url,
-                                      const char* window, uint32_t len,
-                                      const char* buf, NPBool file);
-typedef NPError (*NPN_RequestReadProcPtr)(NPStream* stream,
-                                          NPByteRange* rangeList);
-typedef NPError (*NPN_NewStreamProcPtr)(NPP instance, NPMIMEType type,
-                                        const char* window, NPStream** stream);
-typedef int32_t (*NPN_WriteProcPtr)(NPP instance, NPStream* stream, int32_t len,
-                                    void* buffer);
-typedef NPError (*NPN_DestroyStreamProcPtr)(NPP instance, NPStream* stream,
-                                            NPReason reason);
-typedef void (*NPN_StatusProcPtr)(NPP instance, const char* message);
-/* Browser manages the lifetime of the buffer returned by NPN_UserAgent, don't
-   depend on it sticking around and don't free it. */
-typedef const char* (*NPN_UserAgentProcPtr)(NPP instance);
-typedef void* (*NPN_MemAllocProcPtr)(uint32_t size);
-typedef void (*NPN_MemFreeProcPtr)(void* ptr);
-typedef uint32_t (*NPN_MemFlushProcPtr)(uint32_t size);
-typedef void (*NPN_ReloadPluginsProcPtr)(NPBool reloadPages);
-typedef void* (*NPN_GetJavaEnvProcPtr)(void);
-typedef void* (*NPN_GetJavaPeerProcPtr)(NPP instance);
-typedef void (*NPN_InvalidateRectProcPtr)(NPP instance, NPRect* rect);
-typedef void (*NPN_InvalidateRegionProcPtr)(NPP instance, NPRegion region);
-typedef void (*NPN_ForceRedrawProcPtr)(NPP instance);
-typedef NPIdentifier (*NPN_GetStringIdentifierProcPtr)(const NPUTF8* name);
-typedef void (*NPN_GetStringIdentifiersProcPtr)(const NPUTF8** names,
-                                                int32_t nameCount,
-                                                NPIdentifier* identifiers);
-typedef NPIdentifier (*NPN_GetIntIdentifierProcPtr)(int32_t intid);
-typedef bool (*NPN_IdentifierIsStringProcPtr)(NPIdentifier identifier);
-typedef NPUTF8* (*NPN_UTF8FromIdentifierProcPtr)(NPIdentifier identifier);
-typedef int32_t (*NPN_IntFromIdentifierProcPtr)(NPIdentifier identifier);
-typedef NPObject* (*NPN_CreateObjectProcPtr)(NPP npp, NPClass* aClass);
-typedef NPObject* (*NPN_RetainObjectProcPtr)(NPObject* obj);
-typedef void (*NPN_ReleaseObjectProcPtr)(NPObject* obj);
-typedef bool (*NPN_InvokeProcPtr)(NPP npp, NPObject* obj,
-                                  NPIdentifier methodName,
-                                  const NPVariant* args, uint32_t argCount,
-                                  NPVariant* result);
-typedef bool (*NPN_InvokeDefaultProcPtr)(NPP npp, NPObject* obj,
-                                         const NPVariant* args,
-                                         uint32_t argCount, NPVariant* result);
-typedef bool (*NPN_EvaluateProcPtr)(NPP npp, NPObject* obj, NPString* script,
-                                    NPVariant* result);
-typedef bool (*NPN_GetPropertyProcPtr)(NPP npp, NPObject* obj,
-                                       NPIdentifier propertyName,
-                                       NPVariant* result);
-typedef bool (*NPN_SetPropertyProcPtr)(NPP npp, NPObject* obj,
-                                       NPIdentifier propertyName,
-                                       const NPVariant* value);
-typedef bool (*NPN_RemovePropertyProcPtr)(NPP npp, NPObject* obj,
-                                          NPIdentifier propertyName);
-typedef bool (*NPN_HasPropertyProcPtr)(NPP npp, NPObject* obj,
-                                       NPIdentifier propertyName);
-typedef bool (*NPN_HasMethodProcPtr)(NPP npp, NPObject* obj,
-                                     NPIdentifier propertyName);
-typedef void (*NPN_ReleaseVariantValueProcPtr)(NPVariant* variant);
-typedef void (*NPN_SetExceptionProcPtr)(NPObject* obj, const NPUTF8* message);
-typedef void (*NPN_PushPopupsEnabledStateProcPtr)(NPP npp, NPBool enabled);
-typedef void (*NPN_PopPopupsEnabledStateProcPtr)(NPP npp);
-typedef bool (*NPN_EnumerateProcPtr)(NPP npp, NPObject* obj,
-                                     NPIdentifier** identifier,
-                                     uint32_t* count);
-typedef void (*NPN_PluginThreadAsyncCallProcPtr)(NPP instance,
-                                                 void (*func)(void*),
-                                                 void* userData);
-typedef bool (*NPN_ConstructProcPtr)(NPP npp, NPObject* obj,
-                                     const NPVariant* args, uint32_t argCount,
-                                     NPVariant* result);
-typedef NPError (*NPN_GetValueForURLPtr)(NPP npp, NPNURLVariable variable,
-                                         const char* url, char** value,
-                                         uint32_t* len);
-typedef NPError (*NPN_SetValueForURLPtr)(NPP npp, NPNURLVariable variable,
-                                         const char* url, const char* value,
-                                         uint32_t len);
-typedef NPError (*NPN_GetAuthenticationInfoPtr)(
-    NPP npp, const char* protocol, const char* host, int32_t port,
-    const char* scheme, const char* realm, char** username, uint32_t* ulen,
-    char** password, uint32_t* plen);
-typedef uint32_t (*NPN_ScheduleTimerPtr)(NPP instance, uint32_t interval,
-                                         NPBool repeat,
-                                         void (*timerFunc)(NPP npp,
-                                                           uint32_t timerID));
-typedef void (*NPN_UnscheduleTimerPtr)(NPP instance, uint32_t timerID);
-typedef NPError (*NPN_PopUpContextMenuPtr)(NPP instance, NPMenu* menu);
-typedef NPBool (*NPN_ConvertPointPtr)(NPP instance, double sourceX,
-                                      double sourceY,
-                                      NPCoordinateSpace sourceSpace,
-                                      double* destX, double* destY,
-                                      NPCoordinateSpace destSpace);
-typedef NPBool (*NPN_HandleEventPtr)(NPP instance, void* event, NPBool handled);
-typedef NPBool (*NPN_UnfocusInstancePtr)(NPP instance,
-                                         NPFocusDirection direction);
-typedef void (*NPN_URLRedirectResponsePtr)(NPP instance, void* notifyData,
-                                           NPBool allow);
-typedef NPError (*NPN_InitAsyncSurfacePtr)(NPP instance, NPSize* size,
-                                           NPImageFormat format, void* initData,
-                                           NPAsyncSurface* surface);
-typedef NPError (*NPN_FinalizeAsyncSurfacePtr)(NPP instance,
-                                               NPAsyncSurface* surface);
-typedef void (*NPN_SetCurrentAsyncSurfacePtr)(NPP instance,
-                                              NPAsyncSurface* surface,
-                                              NPRect* changed);
-
-typedef void (*NPN_DummyPtr)(void);
-
-typedef struct _NPPluginFuncs {
-  uint16_t size;
-  uint16_t version;
-  NPP_NewProcPtr newp;
-  NPP_DestroyProcPtr destroy;
-  NPP_SetWindowProcPtr setwindow;
-  NPP_NewStreamProcPtr newstream;
-  NPP_DestroyStreamProcPtr destroystream;
-  NPP_StreamAsFileProcPtr asfile;
-  NPP_WriteReadyProcPtr writeready;
-  NPP_WriteProcPtr write;
-  NPP_PrintProcPtr print;
-  NPP_HandleEventProcPtr event;
-  NPP_URLNotifyProcPtr urlnotify;
-  void* javaClass;
-  NPP_GetValueProcPtr getvalue;
-  NPP_SetValueProcPtr setvalue;
-  NPP_GotFocusPtr gotfocus;
-  NPP_LostFocusPtr lostfocus;
-  NPP_URLRedirectNotifyPtr urlredirectnotify;
-  NPP_ClearSiteDataPtr clearsitedata;
-  NPP_GetSitesWithDataPtr getsiteswithdata;
-  NPP_DidCompositePtr didComposite;
-} NPPluginFuncs;
-
-typedef struct _NPNetscapeFuncs {
-  uint16_t size;
-  uint16_t version;
-  NPN_GetURLProcPtr geturl;
-  NPN_PostURLProcPtr posturl;
-  NPN_RequestReadProcPtr requestread;
-  NPN_NewStreamProcPtr newstream;
-  NPN_WriteProcPtr write;
-  NPN_DestroyStreamProcPtr destroystream;
-  NPN_StatusProcPtr status;
-  NPN_UserAgentProcPtr uagent;
-  NPN_MemAllocProcPtr memalloc;
-  NPN_MemFreeProcPtr memfree;
-  NPN_MemFlushProcPtr memflush;
-  NPN_ReloadPluginsProcPtr reloadplugins;
-  NPN_GetJavaEnvProcPtr getJavaEnv;
-  NPN_GetJavaPeerProcPtr getJavaPeer;
-  NPN_GetURLNotifyProcPtr geturlnotify;
-  NPN_PostURLNotifyProcPtr posturlnotify;
-  NPN_GetValueProcPtr getvalue;
-  NPN_SetValueProcPtr setvalue;
-  NPN_InvalidateRectProcPtr invalidaterect;
-  NPN_InvalidateRegionProcPtr invalidateregion;
-  NPN_ForceRedrawProcPtr forceredraw;
-  NPN_GetStringIdentifierProcPtr getstringidentifier;
-  NPN_GetStringIdentifiersProcPtr getstringidentifiers;
-  NPN_GetIntIdentifierProcPtr getintidentifier;
-  NPN_IdentifierIsStringProcPtr identifierisstring;
-  NPN_UTF8FromIdentifierProcPtr utf8fromidentifier;
-  NPN_IntFromIdentifierProcPtr intfromidentifier;
-  NPN_CreateObjectProcPtr createobject;
-  NPN_RetainObjectProcPtr retainobject;
-  NPN_ReleaseObjectProcPtr releaseobject;
-  NPN_InvokeProcPtr invoke;
-  NPN_InvokeDefaultProcPtr invokeDefault;
-  NPN_EvaluateProcPtr evaluate;
-  NPN_GetPropertyProcPtr getproperty;
-  NPN_SetPropertyProcPtr setproperty;
-  NPN_RemovePropertyProcPtr removeproperty;
-  NPN_HasPropertyProcPtr hasproperty;
-  NPN_HasMethodProcPtr hasmethod;
-  NPN_ReleaseVariantValueProcPtr releasevariantvalue;
-  NPN_SetExceptionProcPtr setexception;
-  NPN_PushPopupsEnabledStateProcPtr pushpopupsenabledstate;
-  NPN_PopPopupsEnabledStateProcPtr poppopupsenabledstate;
-  NPN_EnumerateProcPtr enumerate;
-  NPN_PluginThreadAsyncCallProcPtr pluginthreadasynccall;
-  NPN_ConstructProcPtr construct;
-  NPN_GetValueForURLPtr getvalueforurl;
-  NPN_SetValueForURLPtr setvalueforurl;
-  NPN_GetAuthenticationInfoPtr getauthenticationinfo;
-  NPN_ScheduleTimerPtr scheduletimer;
-  NPN_UnscheduleTimerPtr unscheduletimer;
-  NPN_PopUpContextMenuPtr popupcontextmenu;
-  NPN_ConvertPointPtr convertpoint;
-  NPN_HandleEventPtr handleevent;
-  NPN_UnfocusInstancePtr unfocusinstance;
-  NPN_URLRedirectResponsePtr urlredirectresponse;
-  NPN_InitAsyncSurfacePtr initasyncsurface;
-  NPN_FinalizeAsyncSurfacePtr finalizeasyncsurface;
-  NPN_SetCurrentAsyncSurfacePtr setcurrentasyncsurface;
-} NPNetscapeFuncs;
-
-#ifdef XP_MACOSX
-/*
- * Mac OS X version(s) of NP_GetMIMEDescription(const char *)
- * These can be called to retreive MIME information from the plugin dynamically
- *
- * Note: For compatibility with Quicktime, BPSupportedMIMEtypes is another way
- *       to get mime info from the plugin only on OSX and may not be supported
- *       in furture version -- use NP_GetMIMEDescription instead
- */
-enum { kBPSupportedMIMETypesStructVers_1 = 1 };
-typedef struct _BPSupportedMIMETypes {
-  SInt32 structVersion; /* struct version */
-  Handle typeStrings;   /* STR# formated handle, allocated by plug-in */
-  Handle infoStrings;   /* STR# formated handle, allocated by plug-in */
-} BPSupportedMIMETypes;
-OSErr BP_GetSupportedMIMETypes(BPSupportedMIMETypes* mimeInfo, UInt32 flags);
-#  define NP_GETMIMEDESCRIPTION_NAME "NP_GetMIMEDescription"
-typedef const char* (*NP_GetMIMEDescriptionProcPtr)(void);
-typedef OSErr (*BP_GetSupportedMIMETypesProcPtr)(BPSupportedMIMETypes*, UInt32);
-#endif
-
-#if defined(_WIN32)
-#  define OSCALL WINAPI
-#else
-#  define OSCALL
-#endif
-
-#if defined(XP_UNIX)
-/* GCC 3.3 and later support the visibility attribute. */
-#  if defined(__GNUC__) && \
-      ((__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3))
-#    define NP_VISIBILITY_DEFAULT __attribute__((visibility("default")))
-#  elif defined(__SUNPRO_C) || defined(__SUNPRO_CC)
-#    define NP_VISIBILITY_DEFAULT __global
-#  else
-#    define NP_VISIBILITY_DEFAULT
-#  endif
-#  define NP_EXPORT(__type) NP_VISIBILITY_DEFAULT __type
-#endif
-
-#if defined(_WIN32)
-#  ifdef __cplusplus
-extern "C" {
-#  endif
-/* plugin meta member functions */
-typedef NPError(OSCALL* NP_GetEntryPointsFunc)(NPPluginFuncs*);
-NPError OSCALL NP_GetEntryPoints(NPPluginFuncs* pFuncs);
-typedef NPError(OSCALL* NP_InitializeFunc)(NPNetscapeFuncs*);
-NPError OSCALL NP_Initialize(NPNetscapeFuncs* bFuncs);
-typedef NPError(OSCALL* NP_ShutdownFunc)(void);
-NPError OSCALL NP_Shutdown(void);
-typedef const char* (*NP_GetMIMEDescriptionFunc)(void);
-const char* NP_GetMIMEDescription(void);
-#  ifdef __cplusplus
-}
-#  endif
-#endif
-
-#ifdef XP_UNIX
-#  ifdef __cplusplus
-extern "C" {
-#  endif
-typedef char* (*NP_GetPluginVersionFunc)(void);
-NP_EXPORT(char*) NP_GetPluginVersion(void);
-typedef const char* (*NP_GetMIMEDescriptionFunc)(void);
-NP_EXPORT(const char*) NP_GetMIMEDescription(void);
-#  ifdef XP_MACOSX
-typedef NPError (*NP_InitializeFunc)(NPNetscapeFuncs*);
-NP_EXPORT(NPError) NP_Initialize(NPNetscapeFuncs* bFuncs);
-typedef NPError (*NP_GetEntryPointsFunc)(NPPluginFuncs*);
-NP_EXPORT(NPError) NP_GetEntryPoints(NPPluginFuncs* pFuncs);
-#  else
-typedef NPError (*NP_InitializeFunc)(NPNetscapeFuncs*, NPPluginFuncs*);
-NP_EXPORT(NPError)
-NP_Initialize(NPNetscapeFuncs* bFuncs, NPPluginFuncs* pFuncs);
-#  endif
-typedef NPError (*NP_ShutdownFunc)(void);
-NP_EXPORT(NPError) NP_Shutdown(void);
-typedef NPError (*NP_GetValueFunc)(void*, NPPVariable, void*);
-NP_EXPORT(NPError)
-NP_GetValue(void* future, NPPVariable aVariable, void* aValue);
-#  ifdef __cplusplus
-}
-#  endif
-#endif
-
-// clang-format off
-// See bug 1431030
-#if defined(XP_WIN)
-#define NS_NPAPIPLUGIN_CALLBACK(_type, _name) _type (__stdcall * _name)
-#else
-#define NS_NPAPIPLUGIN_CALLBACK(_type, _name) _type (* _name)
-#endif
-// clang-format on
-
-typedef NS_NPAPIPLUGIN_CALLBACK(NPError,
-                                NP_GETENTRYPOINTS)(NPPluginFuncs* pCallbacks);
-typedef NS_NPAPIPLUGIN_CALLBACK(NPError, NP_PLUGININIT)(
-    const NPNetscapeFuncs* pCallbacks);
-typedef NS_NPAPIPLUGIN_CALLBACK(NPError, NP_PLUGINUNIXINIT)(
-    const NPNetscapeFuncs* pCallbacks, NPPluginFuncs* fCallbacks);
-typedef NS_NPAPIPLUGIN_CALLBACK(NPError, NP_PLUGINSHUTDOWN)(void);
-
-#endif /* npfunctions_h_ */
diff --git a/dom/plugins/base/npruntime.h b/dom/plugins/base/npruntime.h
deleted file mode 100644
index a2c4fa1597a90..0000000000000
--- a/dom/plugins/base/npruntime.h
+++ /dev/null
@@ -1,382 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/*
- * Copyright (c) 2004, Apple Computer, Inc. and The Mozilla Foundation.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are
- * met:
- *
- * 1. Redistributions of source code must retain the above copyright
- * notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- * notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- * 3. Neither the names of Apple Computer, Inc. ("Apple") or The Mozilla
- * Foundation ("Mozilla") nor the names of their contributors may be used
- * to endorse or promote products derived from this software without
- * specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY APPLE, MOZILLA AND THEIR CONTRIBUTORS "AS
- * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
- * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
- * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE, MOZILLA OR
- * THEIR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
- * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
- * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
- * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- */
-#ifndef _NP_RUNTIME_H_
-#define _NP_RUNTIME_H_
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "nptypes.h"
-
-/*
-    This API is used to facilitate binding code written in C to script
-    objects.  The API in this header does not assume the presence of a
-    user agent.  That is, it can be used to bind C code to scripting
-    environments outside of the context of a user agent.
-
-    However, the normal use of the this API is in the context of a
-    scripting environment running in a browser or other user agent.
-    In particular it is used to support the extended Netscape
-    script-ability API for plugins (NP-SAP).  NP-SAP is an extension
-    of the Netscape plugin API.  As such we have adopted the use of
-    the "NP" prefix for this API.
-
-    The following NP{N|P}Variables were added to the Netscape plugin
-    API (in npapi.h):
-
-    NPNVWindowNPObject
-    NPNVPluginElementNPObject
-    NPPVpluginScriptableNPObject
-
-    These variables are exposed through NPN_GetValue() and
-    NPP_GetValue() (respectively) and are used to establish the
-    initial binding between the user agent and native code.  The DOM
-    objects in the user agent can be examined and manipulated using
-    the NPN_ functions that operate on NPObjects described in this
-    header.
-
-    To the extent possible the assumptions about the scripting
-    language used by the scripting environment have been minimized.
-*/
-
-#define NP_BEGIN_MACRO do {
-#define NP_END_MACRO \
-  }                  \
-  while (0)
-
-/*
-    Objects (non-primitive data) passed between 'C' and script is
-    always wrapped in an NPObject.  The 'interface' of an NPObject is
-    described by an NPClass.
-*/
-typedef struct NPObject NPObject;
-typedef struct NPClass NPClass;
-
-typedef char NPUTF8;
-typedef struct _NPString {
-  const NPUTF8* UTF8Characters;
-  uint32_t UTF8Length;
-} NPString;
-
-typedef enum {
-  NPVariantType_Void,
-  NPVariantType_Null,
-  NPVariantType_Bool,
-  NPVariantType_Int32,
-  NPVariantType_Double,
-  NPVariantType_String,
-  NPVariantType_Object
-} NPVariantType;
-
-typedef struct _NPVariant {
-  NPVariantType type;
-  union {
-    bool boolValue;
-    int32_t intValue;
-    double doubleValue;
-    NPString stringValue;
-    NPObject* objectValue;
-  } value;
-} NPVariant;
-
-/*
-    NPN_ReleaseVariantValue is called on all 'out' parameters
-    references.  Specifically it is to be called on variants that own
-    their value, as is the case with all non-const NPVariant*
-    arguments after a successful call to any methods (except this one)
-    in this API.
-
-    After calling NPN_ReleaseVariantValue, the type of the variant
-    will be NPVariantType_Void.
-*/
-void NPN_ReleaseVariantValue(NPVariant* variant);
-
-#define NPVARIANT_IS_VOID(_v) ((_v).type == NPVariantType_Void)
-#define NPVARIANT_IS_NULL(_v) ((_v).type == NPVariantType_Null)
-#define NPVARIANT_IS_BOOLEAN(_v) ((_v).type == NPVariantType_Bool)
-#define NPVARIANT_IS_INT32(_v) ((_v).type == NPVariantType_Int32)
-#define NPVARIANT_IS_DOUBLE(_v) ((_v).type == NPVariantType_Double)
-#define NPVARIANT_IS_STRING(_v) ((_v).type == NPVariantType_String)
-#define NPVARIANT_IS_OBJECT(_v) ((_v).type == NPVariantType_Object)
-
-#define NPVARIANT_TO_BOOLEAN(_v) ((_v).value.boolValue)
-#define NPVARIANT_TO_INT32(_v) ((_v).value.intValue)
-#define NPVARIANT_TO_DOUBLE(_v) ((_v).value.doubleValue)
-#define NPVARIANT_TO_STRING(_v) ((_v).value.stringValue)
-#define NPVARIANT_TO_OBJECT(_v) ((_v).value.objectValue)
-
-#define VOID_TO_NPVARIANT(_v)                   \
-  NP_BEGIN_MACRO(_v).type = NPVariantType_Void; \
-  (_v).value.objectValue = NULL;                \
-  NP_END_MACRO
-
-#define NULL_TO_NPVARIANT(_v)                   \
-  NP_BEGIN_MACRO(_v).type = NPVariantType_Null; \
-  (_v).value.objectValue = NULL;                \
-  NP_END_MACRO
-
-#define BOOLEAN_TO_NPVARIANT(_val, _v)          \
-  NP_BEGIN_MACRO(_v).type = NPVariantType_Bool; \
-  (_v).value.boolValue = !!(_val);              \
-  NP_END_MACRO
-
-#define INT32_TO_NPVARIANT(_val, _v)             \
-  NP_BEGIN_MACRO(_v).type = NPVariantType_Int32; \
-  (_v).value.intValue = _val;                    \
-  NP_END_MACRO
-
-#define DOUBLE_TO_NPVARIANT(_val, _v)             \
-  NP_BEGIN_MACRO(_v).type = NPVariantType_Double; \
-  (_v).value.doubleValue = _val;                  \
-  NP_END_MACRO
-
-#define STRINGZ_TO_NPVARIANT(_val, _v)             \
-  NP_BEGIN_MACRO(_v).type = NPVariantType_String;  \
-  NPString str = {_val, (uint32_t)(strlen(_val))}; \
-  (_v).value.stringValue = str;                    \
-  NP_END_MACRO
-
-#define STRINGN_TO_NPVARIANT(_val, _len, _v)      \
-  NP_BEGIN_MACRO(_v).type = NPVariantType_String; \
-  NPString str = {_val, (uint32_t)(_len)};        \
-  (_v).value.stringValue = str;                   \
-  NP_END_MACRO
-
-#define OBJECT_TO_NPVARIANT(_val, _v)             \
-  NP_BEGIN_MACRO(_v).type = NPVariantType_Object; \
-  (_v).value.objectValue = _val;                  \
-  NP_END_MACRO
-
-/*
-  Type mappings (JavaScript types have been used for illustration
-    purposes):
-
-  JavaScript       to             C (NPVariant with type:)
-  undefined                       NPVariantType_Void
-  null                            NPVariantType_Null
-  Boolean                         NPVariantType_Bool
-  Number                          NPVariantType_Double or NPVariantType_Int32
-  String                          NPVariantType_String
-  Object                          NPVariantType_Object
-
-  C (NPVariant with type:)   to   JavaScript
-  NPVariantType_Void              undefined
-  NPVariantType_Null              null
-  NPVariantType_Bool              Boolean
-  NPVariantType_Int32             Number
-  NPVariantType_Double            Number
-  NPVariantType_String            String
-  NPVariantType_Object            Object
-*/
-
-typedef void* NPIdentifier;
-
-/*
-    NPObjects have methods and properties.  Methods and properties are
-    identified with NPIdentifiers.  These identifiers may be reflected
-    in script.  NPIdentifiers can be either strings or integers, IOW,
-    methods and properties can be identified by either strings or
-    integers (i.e. foo["bar"] vs foo[1]). NPIdentifiers can be
-    compared using ==.  In case of any errors, the requested
-    NPIdentifier(s) will be NULL. NPIdentifier lifetime is controlled
-    by the browser. Plugins do not need to worry about memory management
-    with regards to NPIdentifiers.
-*/
-NPIdentifier NPN_GetStringIdentifier(const NPUTF8* name);
-void NPN_GetStringIdentifiers(const NPUTF8** names, int32_t nameCount,
-                              NPIdentifier* identifiers);
-NPIdentifier NPN_GetIntIdentifier(int32_t intid);
-bool NPN_IdentifierIsString(NPIdentifier identifier);
-
-/*
-    The NPUTF8 returned from NPN_UTF8FromIdentifier SHOULD be freed.
-*/
-NPUTF8* NPN_UTF8FromIdentifier(NPIdentifier identifier);
-
-/*
-    Get the integer represented by identifier. If identifier is not an
-    integer identifier, the behaviour is undefined.
-*/
-int32_t NPN_IntFromIdentifier(NPIdentifier identifier);
-
-/*
-    NPObject behavior is implemented using the following set of
-    callback functions.
-
-    The NPVariant *result argument of these functions (where
-    applicable) should be released using NPN_ReleaseVariantValue().
-*/
-typedef NPObject* (*NPAllocateFunctionPtr)(NPP npp, NPClass* aClass);
-typedef void (*NPDeallocateFunctionPtr)(NPObject* npobj);
-typedef void (*NPInvalidateFunctionPtr)(NPObject* npobj);
-typedef bool (*NPHasMethodFunctionPtr)(NPObject* npobj, NPIdentifier name);
-typedef bool (*NPInvokeFunctionPtr)(NPObject* npobj, NPIdentifier name,
-                                    const NPVariant* args, uint32_t argCount,
-                                    NPVariant* result);
-typedef bool (*NPInvokeDefaultFunctionPtr)(NPObject* npobj,
-                                           const NPVariant* args,
-                                           uint32_t argCount,
-                                           NPVariant* result);
-typedef bool (*NPHasPropertyFunctionPtr)(NPObject* npobj, NPIdentifier name);
-typedef bool (*NPGetPropertyFunctionPtr)(NPObject* npobj, NPIdentifier name,
-                                         NPVariant* result);
-typedef bool (*NPSetPropertyFunctionPtr)(NPObject* npobj, NPIdentifier name,
-                                         const NPVariant* value);
-typedef bool (*NPRemovePropertyFunctionPtr)(NPObject* npobj, NPIdentifier name);
-typedef bool (*NPEnumerationFunctionPtr)(NPObject* npobj, NPIdentifier** value,
-                                         uint32_t* count);
-typedef bool (*NPConstructFunctionPtr)(NPObject* npobj, const NPVariant* args,
-                                       uint32_t argCount, NPVariant* result);
-
-/*
-    NPObjects returned by create, retain, invoke, and getProperty pass
-    a reference count to the caller.  That is, the callee adds a
-    reference count which passes to the caller.  It is the caller's
-    responsibility to release the returned object.
-
-    NPInvokeFunctionPtr function may return 0 to indicate a void
-    result.
-
-    NPInvalidateFunctionPtr is called by the scripting environment
-    when the native code is shutdown.  Any attempt to message a
-    NPObject instance after the invalidate callback has been
-    called will result in undefined behavior, even if the native code
-    is still retaining those NPObject instances.  (The runtime
-    will typically return immediately, with 0 or NULL, from an
-    attempt to dispatch to a NPObject, but this behavior should not
-    be depended upon.)
-
-    The NPEnumerationFunctionPtr function may pass an array of
-    NPIdentifiers back to the caller. The callee allocs the memory of
-    the array using NPN_MemAlloc(), and it's the caller's responsibility
-    to release it using NPN_MemFree().
-*/
-struct NPClass {
-  uint32_t structVersion;
-  NPAllocateFunctionPtr allocate;
-  NPDeallocateFunctionPtr deallocate;
-  NPInvalidateFunctionPtr invalidate;
-  NPHasMethodFunctionPtr hasMethod;
-  NPInvokeFunctionPtr invoke;
-  NPInvokeDefaultFunctionPtr invokeDefault;
-  NPHasPropertyFunctionPtr hasProperty;
-  NPGetPropertyFunctionPtr getProperty;
-  NPSetPropertyFunctionPtr setProperty;
-  NPRemovePropertyFunctionPtr removeProperty;
-  NPEnumerationFunctionPtr enumerate;
-  NPConstructFunctionPtr construct;
-};
-
-#define NP_CLASS_STRUCT_VERSION 3
-
-#define NP_CLASS_STRUCT_VERSION_ENUM 2
-#define NP_CLASS_STRUCT_VERSION_CTOR 3
-
-#define NP_CLASS_STRUCT_VERSION_HAS_ENUM(npclass) \
-  ((npclass)->structVersion >= NP_CLASS_STRUCT_VERSION_ENUM)
-
-#define NP_CLASS_STRUCT_VERSION_HAS_CTOR(npclass) \
-  ((npclass)->structVersion >= NP_CLASS_STRUCT_VERSION_CTOR)
-
-struct NPObject {
-  NPClass* _class;
-  uint32_t referenceCount;
-  /*
-   * Additional space may be allocated here by types of NPObjects
-   */
-};
-
-/*
-    If the class has an allocate function, NPN_CreateObject invokes
-    that function, otherwise a NPObject is allocated and
-    returned. This method will initialize the referenceCount member of
-    the NPObject to 1.
-*/
-NPObject* NPN_CreateObject(NPP npp, NPClass* aClass);
-
-/*
-    Increment the NPObject's reference count.
-*/
-NPObject* NPN_RetainObject(NPObject* npobj);
-
-/*
-    Decremented the NPObject's reference count.  If the reference
-    count goes to zero, the class's destroy function is invoke if
-    specified, otherwise the object is freed directly.
-*/
-void NPN_ReleaseObject(NPObject* npobj);
-
-/*
-    Functions to access script objects represented by NPObject.
-
-    Calls to script objects are synchronous.  If a function returns a
-    value, it will be supplied via the result NPVariant
-    argument. Successful calls will return true, false will be
-    returned in case of an error.
-
-    Calls made from plugin code to script must be made from the thread
-    on which the plugin was initialized.
-*/
-
-bool NPN_Invoke(NPP npp, NPObject* npobj, NPIdentifier methodName,
-                const NPVariant* args, uint32_t argCount, NPVariant* result);
-bool NPN_InvokeDefault(NPP npp, NPObject* npobj, const NPVariant* args,
-                       uint32_t argCount, NPVariant* result);
-bool NPN_Evaluate(NPP npp, NPObject* npobj, NPString* script,
-                  NPVariant* result);
-bool NPN_GetProperty(NPP npp, NPObject* npobj, NPIdentifier propertyName,
-                     NPVariant* result);
-bool NPN_SetProperty(NPP npp, NPObject* npobj, NPIdentifier propertyName,
-                     const NPVariant* value);
-bool NPN_RemoveProperty(NPP npp, NPObject* npobj, NPIdentifier propertyName);
-bool NPN_HasProperty(NPP npp, NPObject* npobj, NPIdentifier propertyName);
-bool NPN_HasMethod(NPP npp, NPObject* npobj, NPIdentifier methodName);
-bool NPN_Enumerate(NPP npp, NPObject* npobj, NPIdentifier** identifier,
-                   uint32_t* count);
-bool NPN_Construct(NPP npp, NPObject* npobj, const NPVariant* args,
-                   uint32_t argCount, NPVariant* result);
-
-/*
-    NPN_SetException may be called to trigger a script exception upon
-    return from entry points into NPObjects.  Typical usage:
-
-    NPN_SetException (npobj, message);
-*/
-void NPN_SetException(NPObject* npobj, const NPUTF8* message);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
diff --git a/dom/plugins/base/nsIHTTPHeaderListener.idl b/dom/plugins/base/nsIHTTPHeaderListener.idl
deleted file mode 100644
index 4a2f34a798518..0000000000000
--- a/dom/plugins/base/nsIHTTPHeaderListener.idl
+++ /dev/null
@@ -1,29 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "nsISupports.idl"
-
-/**
- * The nsIHTTPHeaderListener interface allows plugin authors to
- * access HTTP Response headers after issuing an
- * nsIPluginHost::{GetURL,PostURL}() call. <P>
- */
-
-[scriptable, uuid(ea51e0b8-871c-4b85-92da-6f400394c5ec)]
-interface nsIHTTPHeaderListener : nsISupports
-{
-  /**
-   * Called for each HTTP Response header.
-   * NOTE: You must copy the values of the params.
-   */
-  void newResponseHeader(in string headerName, in string headerValue);
-
-  /**
-   * Called once for the HTTP Response status line.
-   * Value does NOT include a terminating newline.
-   * NOTE: You must copy this value.
-   */
-  void statusLine(in string line);
-};
diff --git a/dom/plugins/base/nsIPluginInputStream.idl b/dom/plugins/base/nsIPluginInputStream.idl
deleted file mode 100644
index 8868384417e28..0000000000000
--- a/dom/plugins/base/nsIPluginInputStream.idl
+++ /dev/null
@@ -1,20 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "nsIInputStream.idl"
-#include "nspluginroot.idl"
-
-/**
- * The nsIPluginInputStream interface ...
- */
-[uuid(af160530-542a-11d2-8164-006008119d7a)]
-interface nsIPluginInputStream : nsIInputStream {
-  /**
-   *  Corresponds to NPStream's lastmodified field.)
-   */
-  void getLastModified(out unsigned long aResult);
-
-  void requestRead(out NPByteRange aRangeList);
-};
diff --git a/dom/plugins/base/nsIPluginInstanceOwner.idl b/dom/plugins/base/nsIPluginInstanceOwner.idl
deleted file mode 100644
index 0aa23d2173ab7..0000000000000
--- a/dom/plugins/base/nsIPluginInstanceOwner.idl
+++ /dev/null
@@ -1,121 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "nsISupports.idl"
-#include "nspluginroot.idl"
-#include "nsIInputStream.idl"
-
-webidl Document;
-
-%{C++
-#include "npapi.h"
-#include "mozilla/EventForwards.h"
-class nsNPAPIPluginInstance;
-
-enum nsPluginTagType {
-  nsPluginTagType_Unknown,
-  nsPluginTagType_Embed,
-  nsPluginTagType_Object
-};
-%}
-
-[ptr] native nsNPAPIPluginInstancePtr(nsNPAPIPluginInstance);
-
-// Do not make this interface scriptable, because the virtual functions in C++
-// blocks will make script call the wrong functions.
-[uuid(7d65452e-c167-4cba-a0e3-ddc61bdde8c3)]
-interface nsIPluginInstanceOwner : nsISupports
-{
-  /**
-   * Let the owner know what its instance is
-   */
-  void setInstance(in nsNPAPIPluginInstancePtr aInstance);
-
-  /**
-   * Get the instance associated with this owner.
-   */
-  [notxpcom, nostdcall] nsNPAPIPluginInstancePtr getInstance();
-
-  /**
-   * Get a handle to the window structure of the owner.
-   * This pointer cannot be made persistent by the caller.
-   */
-  void getWindow(in NPWindowStarRef aWindow);
-
-  /**
-   * Get the display mode for the plugin instance.
-   */
-  readonly attribute int32_t mode;
-
-  /**
-   * Create a place for the plugin to live in the owner's
-   * environment. this may or may not create a window
-   * depending on the windowless state of the plugin instance.
-   */
-  void createWidget();
-
-%{C++
-  /**
-   * Called when there is a valid target so that the proper
-   * frame can be updated with new content. will not be called
-   * with nullptr aTarget.
-   */
-  NS_IMETHOD
-  GetURL(const char *aURL, const char *aTarget,
-         nsIInputStream *aPostStream,
-         void *aHeadersData, uint32_t aHeadersDataLen,
-         bool aDoCheckLoadURIChecks) = 0;
-%}
-
-  /**
-   * Get the associated document.
-   */
-  readonly attribute Document document;
-
-  /**
-   * Invalidate the rectangle
-   */
-  void invalidateRect(in NPRectPtr aRect);
-
-  /**
-   * Invalidate the region
-   */
-  void invalidateRegion(in NPRegion aRegion);
-
-  /**
-   * Have the plugin recomposited.
-   */
-  void redrawPlugin();
-
-  /**
-   * Get NetscapeWindow, corresponds to NPNVnetscapeWindow
-   */
-  void getNetscapeWindow(in voidPtr aValue);
-
-  /**
-   * Convert between plugin, window, and screen coordinate spaces.
-   */
-%{C++
-  virtual NPBool  ConvertPoint(double sourceX, double sourceY, NPCoordinateSpace sourceSpace,
-                               double *destX, double *destY, NPCoordinateSpace destSpace) = 0;
-  virtual NPError InitAsyncSurface(NPSize *size, NPImageFormat format,
-                                   void *initData, NPAsyncSurface *surface) = 0;
-  virtual NPError FinalizeAsyncSurface(NPAsyncSurface *surface) = 0;
-  virtual void SetCurrentAsyncSurface(NPAsyncSurface *surface, NPRect *changed) = 0;
-%}
-
-  void setEventModel(in int32_t eventModel);
-
-  /**
-   * Call NPP_SetWindow on the plugin.
-   */
-  void callSetWindow();
-
-  /**
-   * Get the contents scale factor for the screen the plugin is
-   * drawn on.
-   */
-  double getContentsScaleFactor();
-};
diff --git a/dom/plugins/base/nsJSNPRuntime.cpp b/dom/plugins/base/nsJSNPRuntime.cpp
deleted file mode 100644
index ca6589dafa3ca..0000000000000
--- a/dom/plugins/base/nsJSNPRuntime.cpp
+++ /dev/null
@@ -1,2185 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "base/basictypes.h"
-
-#include "jsfriendapi.h"
-
-#include "mozilla/UniquePtr.h"
-#include "nsIInterfaceRequestorUtils.h"
-#include "nsJSNPRuntime.h"
-#include "nsNPAPIPlugin.h"
-#include "nsNPAPIPluginInstance.h"
-#include "nsIGlobalObject.h"
-#include "nsIScriptGlobalObject.h"
-#include "nsIScriptContext.h"
-#include "nsDOMJSUtils.h"
-#include "nsJSUtils.h"
-#include "mozilla/dom/Document.h"
-#include "xpcpublic.h"
-#include "nsIContent.h"
-#include "nsPluginInstanceOwner.h"
-#include "nsWrapperCacheInlines.h"
-#include "js/friend/ErrorMessages.h"  // js::GetErrorMessage, JSMSG_*
-#include "js/GCHashTable.h"
-#include "js/Object.h"  // JS::GetClass, JS::GetCompartment, JS::GetPrivate, JS::SetPrivate
-#include "js/Symbol.h"
-#include "js/TracingAPI.h"
-#include "js/Wrapper.h"
-#include "mozilla/HashFunctions.h"
-#include "mozilla/ProfilerLabels.h"
-#include "mozilla/UniquePtr.h"
-#include "mozilla/dom/AutoEntryScript.h"
-#include "mozilla/dom/ScriptSettings.h"
-
-#define NPRUNTIME_JSCLASS_NAME "NPObject JS wrapper class"
-
-using namespace mozilla::plugins::parent;
-using namespace mozilla;
-
-#include "mozilla/plugins/PluginScriptableObjectParent.h"
-using mozilla::plugins::ParentNPObject;
-using mozilla::plugins::PluginScriptableObjectParent;
-
-struct JSObjWrapperHasher {
-  typedef nsJSObjWrapperKey Key;
-  typedef Key Lookup;
-
-  static uint32_t hash(const Lookup& l) {
-    return js::MovableCellHasher<JS::Heap<JSObject*>>::hash(l.mJSObj) ^
-           HashGeneric(l.mNpp);
-  }
-
-  static bool match(const Key& k, const Lookup& l) {
-    return js::MovableCellHasher<JS::Heap<JSObject*>>::match(k.mJSObj,
-                                                             l.mJSObj) &&
-           k.mNpp == l.mNpp;
-  }
-};
-
-namespace JS {
-template <>
-struct GCPolicy<nsJSObjWrapper*> {
-  static void trace(JSTracer* trc, nsJSObjWrapper** wrapper, const char* name) {
-    MOZ_ASSERT(wrapper);
-    MOZ_ASSERT(*wrapper);
-    (*wrapper)->trace(trc);
-  }
-
-  static bool isValid(const nsJSObjWrapper*& wrapper) { return true; }
-};
-}  // namespace JS
-
-class NPObjWrapperHashEntry : public PLDHashEntryHdr {
- public:
-  NPObject* mNPObj;  // Must be the first member for the PLDHash stubs to work
-  JS::TenuredHeap<JSObject*> mJSObj;
-  NPP mNpp;
-};
-
-// Hash of JSObject wrappers that wraps JSObjects as NPObjects. There
-// will be one wrapper per JSObject per plugin instance, i.e. if two
-// plugins access the JSObject x, two wrappers for x will be
-// created. This is needed to be able to properly drop the wrappers
-// when a plugin is torn down in case there's a leak in the plugin (we
-// don't want to leak the world just because a plugin leaks an
-// NPObject).
-typedef JS::GCHashMap<nsJSObjWrapperKey, nsJSObjWrapper*, JSObjWrapperHasher,
-                      js::SystemAllocPolicy>
-    JSObjWrapperTable;
-static UniquePtr<JSObjWrapperTable> sJSObjWrappers;
-
-// Whether it's safe to iterate sJSObjWrappers.  Set to true when sJSObjWrappers
-// has been initialized and is not currently being enumerated.
-static bool sJSObjWrappersAccessible = false;
-
-// Hash of NPObject wrappers that wrap NPObjects as JSObjects.
-static PLDHashTable* sNPObjWrappers;
-
-// Global wrapper count. This includes JSObject wrappers *and*
-// NPObject wrappers. When this count goes to zero, there are no more
-// wrappers and we can kill off hash tables etc.
-static int32_t sWrapperCount;
-
-static bool sCallbackIsRegistered = false;
-
-static nsTArray<NPObject*>* sDelayedReleases;
-
-namespace {
-
-inline bool NPObjectIsOutOfProcessProxy(NPObject* obj) {
-  return obj->_class == PluginScriptableObjectParent::GetClass();
-}
-
-}  // namespace
-
-// Helper class that suppresses any JS exceptions that were thrown while
-// the plugin executed JS, if the nsJSObjWrapper has a destroy pending.
-// Note that this class is the product (vestige?) of a long evolution in how
-// error reporting worked, and hence the mIsDestroyPending check, and hence this
-// class in general, may or may not actually be necessary.
-
-class MOZ_STACK_CLASS AutoJSExceptionSuppressor {
- public:
-  AutoJSExceptionSuppressor(dom::AutoEntryScript& aes, nsJSObjWrapper* aWrapper)
-      : mAes(aes), mIsDestroyPending(aWrapper->mDestroyPending) {}
-
-  ~AutoJSExceptionSuppressor() {
-    if (mIsDestroyPending) {
-      mAes.ClearException();
-    }
-  }
-
- protected:
-  dom::AutoEntryScript& mAes;
-  bool mIsDestroyPending;
-};
-
-NPClass nsJSObjWrapper::sJSObjWrapperNPClass = {
-    NP_CLASS_STRUCT_VERSION,           nsJSObjWrapper::NP_Allocate,
-    nsJSObjWrapper::NP_Deallocate,     nsJSObjWrapper::NP_Invalidate,
-    nsJSObjWrapper::NP_HasMethod,      nsJSObjWrapper::NP_Invoke,
-    nsJSObjWrapper::NP_InvokeDefault,  nsJSObjWrapper::NP_HasProperty,
-    nsJSObjWrapper::NP_GetProperty,    nsJSObjWrapper::NP_SetProperty,
-    nsJSObjWrapper::NP_RemoveProperty, nsJSObjWrapper::NP_Enumerate,
-    nsJSObjWrapper::NP_Construct};
-
-class NPObjWrapperProxyHandler : public js::BaseProxyHandler {
-  static const char family;
-
- public:
-  static const NPObjWrapperProxyHandler singleton;
-
-  constexpr NPObjWrapperProxyHandler() : BaseProxyHandler(&family) {}
-
-  bool defineProperty(JSContext* cx, JS::Handle<JSObject*> proxy,
-                      JS::Handle<jsid> id,
-                      JS::Handle<JS::PropertyDescriptor> desc,
-                      JS::ObjectOpResult& result) const override {
-    ::JS_ReportErrorASCII(cx,
-                          "Trying to add unsupported property on NPObject!");
-    return false;
-  }
-
-  bool getPrototypeIfOrdinary(
-      JSContext* cx, JS::Handle<JSObject*> proxy, bool* isOrdinary,
-      JS::MutableHandle<JSObject*> proto) const override {
-    *isOrdinary = true;
-    proto.set(js::GetStaticPrototype(proxy));
-    return true;
-  }
-
-  bool isExtensible(JSContext* cx, JS::Handle<JSObject*> proxy,
-                    bool* extensible) const override {
-    // Needs to be extensible so nsObjectLoadingContent can mutate our
-    // __proto__.
-    *extensible = true;
-    return true;
-  }
-
-  bool preventExtensions(JSContext* cx, JS::Handle<JSObject*> proxy,
-                         JS::ObjectOpResult& result) const override {
-    result.succeed();
-    return true;
-  }
-
-  bool getOwnPropertyDescriptor(
-      JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id,
-      JS::MutableHandle<JS::PropertyDescriptor> desc) const override;
-
-  bool ownPropertyKeys(JSContext* cx, JS::Handle<JSObject*> proxy,
-                       JS::MutableHandleVector<jsid> properties) const override;
-
-  bool delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id,
-               JS::ObjectOpResult& result) const override;
-
-  bool get(JSContext* cx, JS::Handle<JSObject*> proxy,
-           JS::Handle<JS::Value> receiver, JS::Handle<jsid> id,
-           JS::MutableHandle<JS::Value> vp) const override;
-
-  bool set(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id,
-           JS::Handle<JS::Value> vp, JS::Handle<JS::Value> receiver,
-           JS::ObjectOpResult& result) const override;
-
-  bool isCallable(JSObject* obj) const override { return true; }
-  bool call(JSContext* cx, JS::Handle<JSObject*> proxy,
-            const JS::CallArgs& args) const override;
-
-  bool isConstructor(JSObject* obj) const override { return true; }
-  bool construct(JSContext* cx, JS::Handle<JSObject*> proxy,
-                 const JS::CallArgs& args) const override;
-
-  bool finalizeInBackground(const JS::Value& priv) const override {
-    return false;
-  }
-  void finalize(JSFreeOp* fop, JSObject* proxy) const override;
-
-  size_t objectMoved(JSObject* obj, JSObject* old) const override;
-};
-
-const char NPObjWrapperProxyHandler::family = 0;
-const NPObjWrapperProxyHandler NPObjWrapperProxyHandler::singleton;
-
-static bool NPObjWrapper_Resolve(JSContext* cx, JS::Handle<JSObject*> obj,
-                                 JS::Handle<jsid> id, bool* resolved,
-                                 JS::MutableHandle<JSObject*> method);
-
-static bool NPObjWrapper_toPrimitive(JSContext* cx, unsigned argc,
-                                     JS::Value* vp);
-
-static bool CreateNPObjectMember(NPP npp, JSContext* cx,
-                                 JS::Handle<JSObject*> obj, NPObject* npobj,
-                                 JS::Handle<jsid> id,
-                                 NPVariant* getPropertyResult,
-                                 JS::MutableHandle<JS::Value> vp);
-
-const JSClass sNPObjWrapperProxyClass =
-    PROXY_CLASS_DEF(NPRUNTIME_JSCLASS_NAME, JSCLASS_HAS_RESERVED_SLOTS(1));
-
-typedef struct NPObjectMemberPrivate {
-  JS::Heap<JSObject*> npobjWrapper;
-  JS::Heap<JS::Value> fieldValue;
-  JS::Heap<jsid> methodName;
-  NPP npp = nullptr;
-} NPObjectMemberPrivate;
-
-static void NPObjectMember_Finalize(JSFreeOp* fop, JSObject* obj);
-
-static bool NPObjectMember_Call(JSContext* cx, unsigned argc, JS::Value* vp);
-
-static void NPObjectMember_Trace(JSTracer* trc, JSObject* obj);
-
-static bool NPObjectMember_toPrimitive(JSContext* cx, unsigned argc,
-                                       JS::Value* vp);
-
-static const JSClassOps sNPObjectMemberClassOps = {nullptr,
-                                                   nullptr,
-                                                   nullptr,
-                                                   nullptr,
-                                                   nullptr,
-                                                   nullptr,
-                                                   NPObjectMember_Finalize,
-                                                   NPObjectMember_Call,
-                                                   nullptr,
-                                                   nullptr,
-                                                   NPObjectMember_Trace};
-
-static const JSClass sNPObjectMemberClass = {
-    "NPObject Ambiguous Member class",
-    JSCLASS_HAS_PRIVATE | JSCLASS_FOREGROUND_FINALIZE,
-    &sNPObjectMemberClassOps};
-
-static void OnWrapperDestroyed();
-
-static void TraceJSObjWrappers(JSTracer* trc, void* data) {
-  if (sJSObjWrappers) {
-    sJSObjWrappers->trace(trc);
-  }
-}
-
-static void DelayedReleaseGCCallback(JSGCStatus status) {
-  if (JSGC_END == status) {
-    // Take ownership of sDelayedReleases and null it out now. The
-    // _releaseobject call below can reenter GC and double-free these objects.
-    UniquePtr<nsTArray<NPObject*>> delayedReleases(sDelayedReleases);
-    sDelayedReleases = nullptr;
-
-    if (delayedReleases) {
-      for (uint32_t i = 0; i < delayedReleases->Length(); ++i) {
-        NPObject* obj = (*delayedReleases)[i];
-        if (obj) _releaseobject(obj);
-        OnWrapperDestroyed();
-      }
-    }
-  }
-}
-
-static bool RegisterGCCallbacks() {
-  if (sCallbackIsRegistered) {
-    return true;
-  }
-
-  // Register a callback to trace wrapped JSObjects.
-  JSContext* cx = dom::danger::GetJSContext();
-  if (!JS_AddExtraGCRootsTracer(cx, TraceJSObjWrappers, nullptr)) {
-    return false;
-  }
-
-  // Register our GC callback to perform delayed destruction of finalized
-  // NPObjects.
-  xpc::AddGCCallback(DelayedReleaseGCCallback);
-
-  sCallbackIsRegistered = true;
-
-  return true;
-}
-
-static void UnregisterGCCallbacks() {
-  MOZ_ASSERT(sCallbackIsRegistered);
-
-  // Remove tracing callback.
-  JSContext* cx = dom::danger::GetJSContext();
-  JS_RemoveExtraGCRootsTracer(cx, TraceJSObjWrappers, nullptr);
-
-  // Remove delayed destruction callback.
-  if (sCallbackIsRegistered) {
-    xpc::RemoveGCCallback(DelayedReleaseGCCallback);
-    sCallbackIsRegistered = false;
-  }
-}
-
-static bool CreateJSObjWrapperTable() {
-  MOZ_ASSERT(!sJSObjWrappersAccessible);
-  MOZ_ASSERT(!sJSObjWrappers);
-
-  if (!RegisterGCCallbacks()) {
-    return false;
-  }
-
-  sJSObjWrappers = MakeUnique<JSObjWrapperTable>();
-  sJSObjWrappersAccessible = true;
-  return true;
-}
-
-static void DestroyJSObjWrapperTable() {
-  MOZ_ASSERT(sJSObjWrappersAccessible);
-  MOZ_ASSERT(sJSObjWrappers);
-  MOZ_ASSERT(sJSObjWrappers->count() == 0);
-
-  // No more wrappers. Delete the table.
-  sJSObjWrappers = nullptr;
-  sJSObjWrappersAccessible = false;
-}
-
-static bool CreateNPObjWrapperTable() {
-  MOZ_ASSERT(!sNPObjWrappers);
-
-  if (!RegisterGCCallbacks()) {
-    return false;
-  }
-
-  sNPObjWrappers =
-      new PLDHashTable(PLDHashTable::StubOps(), sizeof(NPObjWrapperHashEntry));
-  return true;
-}
-
-static void DestroyNPObjWrapperTable() {
-  MOZ_ASSERT(sNPObjWrappers->EntryCount() == 0);
-
-  delete sNPObjWrappers;
-  sNPObjWrappers = nullptr;
-}
-
-static void OnWrapperCreated() { ++sWrapperCount; }
-
-static void OnWrapperDestroyed() {
-  NS_ASSERTION(sWrapperCount, "Whaaa, unbalanced created/destroyed calls!");
-
-  if (--sWrapperCount == 0) {
-    if (sJSObjWrappersAccessible) {
-      DestroyJSObjWrapperTable();
-    }
-
-    if (sNPObjWrappers) {
-      // No more wrappers, and our hash was initialized. Finish the
-      // hash to prevent leaking it.
-      DestroyNPObjWrapperTable();
-    }
-
-    UnregisterGCCallbacks();
-  }
-}
-
-namespace mozilla::plugins::parent {
-
-static nsIGlobalObject* GetGlobalObject(NPP npp) {
-  NS_ENSURE_TRUE(npp, nullptr);
-
-  nsNPAPIPluginInstance* inst = (nsNPAPIPluginInstance*)npp->ndata;
-  NS_ENSURE_TRUE(inst, nullptr);
-
-  RefPtr<nsPluginInstanceOwner> owner = inst->GetOwner();
-  NS_ENSURE_TRUE(owner, nullptr);
-
-  nsCOMPtr<dom::Document> doc;
-  owner->GetDocument(getter_AddRefs(doc));
-  NS_ENSURE_TRUE(doc, nullptr);
-
-  return doc->GetScopeObject();
-}
-
-}  // namespace mozilla::plugins::parent
-
-static NPP LookupNPP(NPObject* npobj);
-
-static JS::Value NPVariantToJSVal(NPP npp, JSContext* cx,
-                                  const NPVariant* variant) {
-  switch (variant->type) {
-    case NPVariantType_Void:
-      return JS::UndefinedValue();
-    case NPVariantType_Null:
-      return JS::NullValue();
-    case NPVariantType_Bool:
-      return JS::BooleanValue(NPVARIANT_TO_BOOLEAN(*variant));
-    case NPVariantType_Int32: {
-      // Don't use INT_TO_JSVAL directly to prevent bugs when dealing
-      // with ints larger than what fits in a integer JS::Value.
-      return ::JS_NumberValue(NPVARIANT_TO_INT32(*variant));
-    }
-    case NPVariantType_Double: {
-      return ::JS_NumberValue(NPVARIANT_TO_DOUBLE(*variant));
-    }
-    case NPVariantType_String: {
-      const NPString* s = &NPVARIANT_TO_STRING(*variant);
-      NS_ConvertUTF8toUTF16 utf16String(s->UTF8Characters, s->UTF8Length);
-
-      JSString* str =
-          ::JS_NewUCStringCopyN(cx, utf16String.get(), utf16String.Length());
-
-      if (str) {
-        return JS::StringValue(str);
-      }
-
-      break;
-    }
-    case NPVariantType_Object: {
-      if (npp) {
-        JSObject* obj = nsNPObjWrapper::GetNewOrUsed(
-            npp, cx, NPVARIANT_TO_OBJECT(*variant));
-
-        if (obj) {
-          return JS::ObjectValue(*obj);
-        }
-      }
-
-      NS_ERROR("Error wrapping NPObject!");
-
-      break;
-    }
-    default:
-      NS_ERROR("Unknown NPVariant type!");
-  }
-
-  NS_ERROR("Unable to convert NPVariant to jsval!");
-
-  return JS::UndefinedValue();
-}
-
-bool JSValToNPVariant(NPP npp, JSContext* cx, const JS::Value& val,
-                      NPVariant* variant) {
-  NS_ASSERTION(npp, "Must have an NPP to wrap a jsval!");
-
-  if (val.isPrimitive()) {
-    if (val.isUndefined()) {
-      VOID_TO_NPVARIANT(*variant);
-    } else if (val.isNull()) {
-      NULL_TO_NPVARIANT(*variant);
-    } else if (val.isBoolean()) {
-      BOOLEAN_TO_NPVARIANT(val.toBoolean(), *variant);
-    } else if (val.isInt32()) {
-      INT32_TO_NPVARIANT(val.toInt32(), *variant);
-    } else if (val.isDouble()) {
-      double d = val.toDouble();
-      int i;
-      if (JS_DoubleIsInt32(d, &i)) {
-        INT32_TO_NPVARIANT(i, *variant);
-      } else {
-        DOUBLE_TO_NPVARIANT(d, *variant);
-      }
-    } else if (val.isString()) {
-      JSString* jsstr = val.toString();
-
-      nsAutoJSString str;
-      if (!str.init(cx, jsstr)) {
-        return false;
-      }
-
-      uint32_t len;
-      char* p = ToNewUTF8String(str, &len);
-
-      if (!p) {
-        return false;
-      }
-
-      STRINGN_TO_NPVARIANT(p, len, *variant);
-    } else {
-      NS_ERROR("Unknown primitive type!");
-
-      return false;
-    }
-
-    return true;
-  }
-
-  // The reflected plugin object may be in another compartment if the plugin
-  // element has since been adopted into a new document. We don't bother
-  // transplanting the plugin objects, and just do a unwrap with security
-  // checks if we encounter one of them as an argument. If the unwrap fails,
-  // we run with the original wrapped object, since sometimes there are
-  // legitimate cases where a security wrapper ends up here (for example,
-  // Location objects, which are _always_ behind security wrappers).
-  JS::Rooted<JSObject*> obj(cx, &val.toObject());
-  JS::Rooted<JSObject*> global(cx);
-  // CheckedUnwrapStatic is fine here; if we get a Location or WindowProxy,
-  // we'll just use the current global instead.
-  obj = js::CheckedUnwrapStatic(obj);
-  if (obj) {
-    global = JS::GetNonCCWObjectGlobal(obj);
-  } else {
-    obj = &val.toObject();
-    global = JS::CurrentGlobalOrNull(cx);
-  }
-
-  NPObject* npobj = nsJSObjWrapper::GetNewOrUsed(npp, obj, global);
-  if (!npobj) {
-    return false;
-  }
-
-  // Pass over ownership of npobj to *variant
-  OBJECT_TO_NPVARIANT(npobj, *variant);
-
-  return true;
-}
-
-static void ThrowJSExceptionASCII(JSContext* cx, const char* message) {
-  const char* ex = PeekException();
-
-  if (ex) {
-    nsAutoString ucex;
-
-    if (message) {
-      AppendASCIItoUTF16(mozilla::MakeStringSpan(message), ucex);
-
-      ucex.AppendLiteral(" [plugin exception: ");
-    }
-
-    AppendUTF8toUTF16(mozilla::MakeStringSpan(ex), ucex);
-
-    if (message) {
-      ucex.AppendLiteral("].");
-    }
-
-    JSString* str = ::JS_NewUCStringCopyN(cx, ucex.get(), ucex.Length());
-
-    if (str) {
-      JS::Rooted<JS::Value> exn(cx, JS::StringValue(str));
-      ::JS_SetPendingException(cx, exn);
-    }
-
-    PopException();
-  } else {
-    ::JS_ReportErrorASCII(cx, "%s", message);
-  }
-}
-
-static bool ReportExceptionIfPending(JSContext* cx) {
-  const char* ex = PeekException();
-
-  if (!ex) {
-    return true;
-  }
-
-  ThrowJSExceptionASCII(cx, nullptr);
-
-  return false;
-}
-
-nsJSObjWrapper::nsJSObjWrapper(NPP npp)
-    : mJSObj(nullptr),
-      mJSObjGlobal(nullptr),
-      mNpp(npp),
-      mDestroyPending(false) {
-  MOZ_COUNT_CTOR(nsJSObjWrapper);
-  OnWrapperCreated();
-}
-
-nsJSObjWrapper::~nsJSObjWrapper() {
-  MOZ_COUNT_DTOR(nsJSObjWrapper);
-
-  // Invalidate first, since it relies on sJSObjWrappers.
-  NP_Invalidate(this);
-
-  OnWrapperDestroyed();
-}
-
-// static
-NPObject* nsJSObjWrapper::NP_Allocate(NPP npp, NPClass* aClass) {
-  NS_ASSERTION(aClass == &sJSObjWrapperNPClass,
-               "Huh, wrong class passed to NP_Allocate()!!!");
-
-  return new nsJSObjWrapper(npp);
-}
-
-// static
-void nsJSObjWrapper::NP_Deallocate(NPObject* npobj) {
-  // nsJSObjWrapper::~nsJSObjWrapper() will call NP_Invalidate().
-  delete (nsJSObjWrapper*)npobj;
-}
-
-// static
-void nsJSObjWrapper::NP_Invalidate(NPObject* npobj) {
-  nsJSObjWrapper* jsnpobj = (nsJSObjWrapper*)npobj;
-
-  if (jsnpobj && jsnpobj->mJSObj) {
-    if (sJSObjWrappersAccessible) {
-      // Remove the wrapper from the hash
-      nsJSObjWrapperKey key(jsnpobj->mJSObj, jsnpobj->mNpp);
-      JSObjWrapperTable::Ptr ptr = sJSObjWrappers->lookup(key);
-      MOZ_ASSERT(ptr.found());
-      sJSObjWrappers->remove(ptr);
-    }
-
-    // Forget our reference to the JSObject.
-    jsnpobj->mJSObj = nullptr;
-    jsnpobj->mJSObjGlobal = nullptr;
-  }
-}
-
-static bool GetProperty(JSContext* cx, JSObject* objArg, NPIdentifier npid,
-                        JS::MutableHandle<JS::Value> rval) {
-  NS_ASSERTION(NPIdentifierIsInt(npid) || NPIdentifierIsString(npid),
-               "id must be either string or int!\n");
-  JS::Rooted<JSObject*> obj(cx, objArg);
-  JS::Rooted<jsid> id(cx, NPIdentifierToJSId(npid));
-  return ::JS_GetPropertyById(cx, obj, id, rval);
-}
-
-static void MarkCrossZoneNPIdentifier(JSContext* cx, NPIdentifier npid) {
-  JS_MarkCrossZoneId(cx, NPIdentifierToJSId(npid));
-}
-
-// static
-bool nsJSObjWrapper::NP_HasMethod(NPObject* npobj, NPIdentifier id) {
-  NPP npp = NPPStack::Peek();
-  nsIGlobalObject* globalObject = GetGlobalObject(npp);
-  if (NS_WARN_IF(!globalObject)) {
-    return false;
-  }
-
-  dom::AutoEntryScript aes(globalObject, "NPAPI HasMethod");
-  JSContext* cx = aes.cx();
-
-  if (!npobj) {
-    ThrowJSExceptionASCII(cx, "Null npobj in nsJSObjWrapper::NP_HasMethod!");
-
-    return false;
-  }
-
-  nsJSObjWrapper* npjsobj = (nsJSObjWrapper*)npobj;
-
-  JSAutoRealm ar(cx, npjsobj->mJSObjGlobal);
-  MarkCrossZoneNPIdentifier(cx, id);
-
-  AutoJSExceptionSuppressor suppressor(aes, npjsobj);
-
-  JS::Rooted<JS::Value> v(cx);
-  bool ok = GetProperty(cx, npjsobj->mJSObj, id, &v);
-
-  return ok && !v.isPrimitive() && ::JS_ObjectIsFunction(v.toObjectOrNull());
-}
-
-static bool doInvoke(NPObject* npobj, NPIdentifier method,
-                     const NPVariant* args, uint32_t argCount, bool ctorCall,
-                     NPVariant* result) {
-  NPP npp = NPPStack::Peek();
-
-  nsCOMPtr<nsIGlobalObject> globalObject = GetGlobalObject(npp);
-  if (NS_WARN_IF(!globalObject)) {
-    return false;
-  }
-
-  AutoAllowLegacyScriptExecution exemption;
-
-  // We're about to run script via JS_CallFunctionValue, so we need an
-  // AutoEntryScript. NPAPI plugins are Gecko-specific and not in any spec.
-  dom::AutoEntryScript aes(globalObject, "NPAPI doInvoke");
-  JSContext* cx = aes.cx();
-
-  if (!npobj || !result) {
-    ThrowJSExceptionASCII(cx, "Null npobj, or result in doInvoke!");
-
-    return false;
-  }
-
-  // Initialize *result
-  VOID_TO_NPVARIANT(*result);
-
-  nsJSObjWrapper* npjsobj = (nsJSObjWrapper*)npobj;
-
-  JS::Rooted<JSObject*> jsobj(cx, npjsobj->mJSObj);
-  JSAutoRealm ar(cx, npjsobj->mJSObjGlobal);
-  MarkCrossZoneNPIdentifier(cx, method);
-  JS::Rooted<JS::Value> fv(cx);
-
-  AutoJSExceptionSuppressor suppressor(aes, npjsobj);
-
-  if (method != NPIdentifier_VOID) {
-    if (!GetProperty(cx, jsobj, method, &fv) ||
-        ::JS_TypeOfValue(cx, fv) != JSTYPE_FUNCTION) {
-      return false;
-    }
-  } else {
-    fv.setObject(*jsobj);
-  }
-
-  // Convert args
-  JS::RootedVector<JS::Value> jsargs(cx);
-  if (!jsargs.reserve(argCount)) {
-    ::JS_ReportOutOfMemory(cx);
-    return false;
-  }
-  for (uint32_t i = 0; i < argCount; ++i) {
-    jsargs.infallibleAppend(NPVariantToJSVal(npp, cx, args + i));
-  }
-
-  JS::Rooted<JS::Value> v(cx);
-  bool ok = false;
-
-  if (ctorCall) {
-    JS::Rooted<JS::Value> objVal(cx, JS::ObjectValue(*jsobj));
-    JS::Rooted<JSObject*> result(cx);
-    ok = JS::Construct(cx, objVal, jsargs, &result);
-
-    if (ok) {
-      v.setObject(*result);
-    }
-  } else {
-    ok = ::JS_CallFunctionValue(cx, jsobj, fv, jsargs, &v);
-  }
-
-  if (ok) ok = JSValToNPVariant(npp, cx, v, result);
-
-  return ok;
-}
-
-// static
-bool nsJSObjWrapper::NP_Invoke(NPObject* npobj, NPIdentifier method,
-                               const NPVariant* args, uint32_t argCount,
-                               NPVariant* result) {
-  if (method == NPIdentifier_VOID) {
-    return false;
-  }
-
-  return doInvoke(npobj, method, args, argCount, false, result);
-}
-
-// static
-bool nsJSObjWrapper::NP_InvokeDefault(NPObject* npobj, const NPVariant* args,
-                                      uint32_t argCount, NPVariant* result) {
-  return doInvoke(npobj, NPIdentifier_VOID, args, argCount, false, result);
-}
-
-// static
-bool nsJSObjWrapper::NP_HasProperty(NPObject* npobj, NPIdentifier npid) {
-  NPP npp = NPPStack::Peek();
-  nsIGlobalObject* globalObject = GetGlobalObject(npp);
-  if (NS_WARN_IF(!globalObject)) {
-    return false;
-  }
-
-  dom::AutoEntryScript aes(globalObject, "NPAPI HasProperty");
-  JSContext* cx = aes.cx();
-
-  if (!npobj) {
-    ThrowJSExceptionASCII(cx, "Null npobj in nsJSObjWrapper::NP_HasProperty!");
-
-    return false;
-  }
-
-  nsJSObjWrapper* npjsobj = (nsJSObjWrapper*)npobj;
-  bool found, ok = false;
-
-  AutoJSExceptionSuppressor suppressor(aes, npjsobj);
-  JS::Rooted<JSObject*> jsobj(cx, npjsobj->mJSObj);
-  JSAutoRealm ar(cx, npjsobj->mJSObjGlobal);
-  MarkCrossZoneNPIdentifier(cx, npid);
-
-  NS_ASSERTION(NPIdentifierIsInt(npid) || NPIdentifierIsString(npid),
-               "id must be either string or int!\n");
-  JS::Rooted<jsid> id(cx, NPIdentifierToJSId(npid));
-  ok = ::JS_HasPropertyById(cx, jsobj, id, &found);
-  return ok && found;
-}
-
-// static
-bool nsJSObjWrapper::NP_GetProperty(NPObject* npobj, NPIdentifier id,
-                                    NPVariant* result) {
-  NPP npp = NPPStack::Peek();
-
-  nsCOMPtr<nsIGlobalObject> globalObject = GetGlobalObject(npp);
-  if (NS_WARN_IF(!globalObject)) {
-    return false;
-  }
-
-  // We're about to run script via JS_CallFunctionValue, so we need an
-  // AutoEntryScript. NPAPI plugins are Gecko-specific and not in any spec.
-  dom::AutoEntryScript aes(globalObject, "NPAPI get");
-  JSContext* cx = aes.cx();
-
-  if (!npobj) {
-    ThrowJSExceptionASCII(cx, "Null npobj in nsJSObjWrapper::NP_GetProperty!");
-
-    return false;
-  }
-
-  nsJSObjWrapper* npjsobj = (nsJSObjWrapper*)npobj;
-
-  AutoJSExceptionSuppressor suppressor(aes, npjsobj);
-  JSAutoRealm ar(cx, npjsobj->mJSObjGlobal);
-  MarkCrossZoneNPIdentifier(cx, id);
-
-  JS::Rooted<JS::Value> v(cx);
-  return (GetProperty(cx, npjsobj->mJSObj, id, &v) &&
-          JSValToNPVariant(npp, cx, v, result));
-}
-
-// static
-bool nsJSObjWrapper::NP_SetProperty(NPObject* npobj, NPIdentifier npid,
-                                    const NPVariant* value) {
-  NPP npp = NPPStack::Peek();
-
-  nsCOMPtr<nsIGlobalObject> globalObject = GetGlobalObject(npp);
-  if (NS_WARN_IF(!globalObject)) {
-    return false;
-  }
-
-  // We're about to run script via JS_CallFunctionValue, so we need an
-  // AutoEntryScript. NPAPI plugins are Gecko-specific and not in any spec.
-  dom::AutoEntryScript aes(globalObject, "NPAPI set");
-  JSContext* cx = aes.cx();
-
-  if (!npobj) {
-    ThrowJSExceptionASCII(cx, "Null npobj in nsJSObjWrapper::NP_SetProperty!");
-
-    return false;
-  }
-
-  nsJSObjWrapper* npjsobj = (nsJSObjWrapper*)npobj;
-  bool ok = false;
-
-  AutoJSExceptionSuppressor suppressor(aes, npjsobj);
-  JS::Rooted<JSObject*> jsObj(cx, npjsobj->mJSObj);
-  JSAutoRealm ar(cx, npjsobj->mJSObjGlobal);
-  MarkCrossZoneNPIdentifier(cx, npid);
-
-  JS::Rooted<JS::Value> v(cx, NPVariantToJSVal(npp, cx, value));
-
-  NS_ASSERTION(NPIdentifierIsInt(npid) || NPIdentifierIsString(npid),
-               "id must be either string or int!\n");
-  JS::Rooted<jsid> id(cx, NPIdentifierToJSId(npid));
-  ok = ::JS_SetPropertyById(cx, jsObj, id, v);
-
-  return ok;
-}
-
-// static
-bool nsJSObjWrapper::NP_RemoveProperty(NPObject* npobj, NPIdentifier npid) {
-  NPP npp = NPPStack::Peek();
-  nsIGlobalObject* globalObject = GetGlobalObject(npp);
-  if (NS_WARN_IF(!globalObject)) {
-    return false;
-  }
-
-  dom::AutoEntryScript aes(globalObject, "NPAPI RemoveProperty");
-  JSContext* cx = aes.cx();
-
-  if (!npobj) {
-    ThrowJSExceptionASCII(cx,
-                          "Null npobj in nsJSObjWrapper::NP_RemoveProperty!");
-
-    return false;
-  }
-
-  nsJSObjWrapper* npjsobj = (nsJSObjWrapper*)npobj;
-
-  AutoJSExceptionSuppressor suppressor(aes, npjsobj);
-  JS::ObjectOpResult result;
-  JS::Rooted<JSObject*> obj(cx, npjsobj->mJSObj);
-  JSAutoRealm ar(cx, npjsobj->mJSObjGlobal);
-  MarkCrossZoneNPIdentifier(cx, npid);
-
-  NS_ASSERTION(NPIdentifierIsInt(npid) || NPIdentifierIsString(npid),
-               "id must be either string or int!\n");
-  JS::Rooted<jsid> id(cx, NPIdentifierToJSId(npid));
-  if (!::JS_DeletePropertyById(cx, obj, id, result)) return false;
-
-  if (result) {
-    // FIXME: See bug 425823, we shouldn't need to do this, and once
-    // that bug is fixed we can remove this code.
-    bool hasProp;
-    if (!::JS_HasPropertyById(cx, obj, id, &hasProp)) return false;
-    if (!hasProp) return true;
-
-    // The property might have been deleted, but it got
-    // re-resolved, so no, it's not really deleted.
-    result.failCantDelete();
-  }
-
-  return result.reportError(cx, obj, id);
-}
-
-// static
-bool nsJSObjWrapper::NP_Enumerate(NPObject* npobj, NPIdentifier** idarray,
-                                  uint32_t* count) {
-  NPP npp = NPPStack::Peek();
-  nsIGlobalObject* globalObject = GetGlobalObject(npp);
-  if (NS_WARN_IF(!globalObject)) {
-    return false;
-  }
-
-  dom::AutoEntryScript aes(globalObject, "NPAPI Enumerate");
-  JSContext* cx = aes.cx();
-
-  *idarray = 0;
-  *count = 0;
-
-  if (!npobj) {
-    ThrowJSExceptionASCII(cx, "Null npobj in nsJSObjWrapper::NP_Enumerate!");
-
-    return false;
-  }
-
-  nsJSObjWrapper* npjsobj = (nsJSObjWrapper*)npobj;
-
-  AutoJSExceptionSuppressor suppressor(aes, npjsobj);
-  JS::Rooted<JSObject*> jsobj(cx, npjsobj->mJSObj);
-  JSAutoRealm ar(cx, npjsobj->mJSObjGlobal);
-
-  JS::Rooted<JS::IdVector> ida(cx, JS::IdVector(cx));
-  if (!JS_Enumerate(cx, jsobj, &ida)) {
-    return false;
-  }
-
-  *count = ida.length();
-  *idarray = (NPIdentifier*)malloc(*count * sizeof(NPIdentifier));
-  if (!*idarray) {
-    ThrowJSExceptionASCII(cx, "Memory allocation failed for NPIdentifier!");
-    return false;
-  }
-
-  for (uint32_t i = 0; i < *count; i++) {
-    JS::Rooted<JS::Value> v(cx);
-    if (!JS_IdToValue(cx, ida[i], &v)) {
-      free(*idarray);
-      return false;
-    }
-
-    NPIdentifier id;
-    if (v.isString()) {
-      JS::Rooted<JSString*> str(cx, v.toString());
-      str = JS_AtomizeAndPinJSString(cx, str);
-      if (!str) {
-        free(*idarray);
-        return false;
-      }
-      id = StringToNPIdentifier(cx, str);
-    } else {
-      NS_ASSERTION(v.isInt32(),
-                   "The element in ida must be either string or int!\n");
-      id = IntToNPIdentifier(v.toInt32());
-    }
-
-    (*idarray)[i] = id;
-  }
-
-  return true;
-}
-
-// static
-bool nsJSObjWrapper::NP_Construct(NPObject* npobj, const NPVariant* args,
-                                  uint32_t argCount, NPVariant* result) {
-  return doInvoke(npobj, NPIdentifier_VOID, args, argCount, true, result);
-}
-
-// Look up or create an NPObject that wraps the JSObject obj.
-
-// static
-NPObject* nsJSObjWrapper::GetNewOrUsed(NPP npp, JS::Handle<JSObject*> obj,
-                                       JS::Handle<JSObject*> objGlobal) {
-  if (!npp) {
-    NS_ERROR("Null NPP passed to nsJSObjWrapper::GetNewOrUsed()!");
-
-    return nullptr;
-  }
-
-  MOZ_ASSERT(JS_IsGlobalObject(objGlobal));
-  MOZ_RELEASE_ASSERT(JS::GetCompartment(obj) == JS::GetCompartment(objGlobal));
-
-  // No need to enter the right compartment here as we only get the
-  // class and private from the JSObject, neither of which cares about
-  // compartments.
-
-  if (nsNPObjWrapper::IsWrapper(obj)) {
-    // obj is one of our own, its private data is the NPObject we're
-    // looking for.
-
-    NPObject* npobj = (NPObject*)js::GetProxyPrivate(obj).toPrivate();
-
-    // If the private is null, that means that the object has already been torn
-    // down, possible because the owning plugin was destroyed (there can be
-    // multiple plugins, so the fact that it was destroyed does not prevent one
-    // of its dead JS objects from being passed to another plugin). There's not
-    // much use in wrapping such a dead object, so we just return null, causing
-    // us to throw.
-    if (!npobj) return nullptr;
-
-    if (LookupNPP(npobj) == npp) return _retainobject(npobj);
-  }
-
-  if (!sJSObjWrappers) {
-    // No hash yet (or any more), initialize it.
-    if (!CreateJSObjWrapperTable()) return nullptr;
-  }
-  MOZ_ASSERT(sJSObjWrappersAccessible);
-
-  JSObjWrapperTable::Ptr p =
-      sJSObjWrappers->lookup(nsJSObjWrapperKey(obj, npp));
-  if (p) {
-    MOZ_ASSERT(p->value());
-    // Found a live nsJSObjWrapper, return it.
-
-    return _retainobject(p->value());
-  }
-
-  // No existing nsJSObjWrapper, create one.
-
-  nsJSObjWrapper* wrapper =
-      (nsJSObjWrapper*)_createobject(npp, &sJSObjWrapperNPClass);
-
-  if (!wrapper) {
-    // Out of memory, entry not yet added to table.
-    return nullptr;
-  }
-
-  wrapper->mJSObj = obj;
-  wrapper->mJSObjGlobal = objGlobal;
-
-  // Insert the new wrapper into the hashtable, rooting the JSObject. Its
-  // lifetime is now tied to that of the NPObject.
-  if (!sJSObjWrappers->putNew(nsJSObjWrapperKey(obj, npp), wrapper)) {
-    // Out of memory, free the wrapper we created.
-    _releaseobject(wrapper);
-    return nullptr;
-  }
-
-  return wrapper;
-}
-
-// Climb the prototype chain, unwrapping as necessary until we find an NP object
-// wrapper.
-//
-// Because this function unwraps, its return value must be wrapped for the cx
-// compartment for callers that plan to hold onto the result or do anything
-// substantial with it.
-static JSObject* GetNPObjectWrapper(JSContext* cx, JS::Handle<JSObject*> aObj,
-                                    bool wrapResult = true) {
-  JS::Rooted<JSObject*> obj(cx, aObj);
-
-  // We can't have WindowProxy or Location objects with NP object wrapper
-  // objects on their proto chain, since they have immutable prototypes.  So
-  // CheckedUnwrapStatic is ok here.
-  while (obj && (obj = js::CheckedUnwrapStatic(obj))) {
-    if (nsNPObjWrapper::IsWrapper(obj)) {
-      if (wrapResult && !JS_WrapObject(cx, &obj)) {
-        return nullptr;
-      }
-      return obj;
-    }
-
-    JSAutoRealm ar(cx, obj);
-    if (!::JS_GetPrototype(cx, obj, &obj)) {
-      return nullptr;
-    }
-  }
-  return nullptr;
-}
-
-static NPObject* GetNPObject(JSContext* cx, JS::Handle<JSObject*> aObj) {
-  JS::Rooted<JSObject*> obj(cx, aObj);
-  obj = GetNPObjectWrapper(cx, obj, /* wrapResult = */ false);
-  if (!obj) {
-    return nullptr;
-  }
-
-  return (NPObject*)js::GetProxyPrivate(obj).toPrivate();
-}
-
-static JSObject* NPObjWrapper_GetResolvedProps(JSContext* cx,
-                                               JS::Handle<JSObject*> obj) {
-  JS::Value slot = js::GetProxyReservedSlot(obj, 0);
-  if (slot.isObject()) return &slot.toObject();
-
-  MOZ_ASSERT(slot.isUndefined());
-
-  JSObject* res = JS_NewObject(cx, nullptr);
-  if (!res) return nullptr;
-
-  SetProxyReservedSlot(obj, 0, JS::ObjectValue(*res));
-  return res;
-}
-
-bool NPObjWrapperProxyHandler::delete_(JSContext* cx,
-                                       JS::Handle<JSObject*> proxy,
-                                       JS::Handle<jsid> id,
-                                       JS::ObjectOpResult& result) const {
-  NPObject* npobj = GetNPObject(cx, proxy);
-
-  if (!npobj || !npobj->_class || !npobj->_class->hasProperty ||
-      !npobj->_class->removeProperty) {
-    ThrowJSExceptionASCII(cx, "Bad NPObject as private data!");
-
-    return false;
-  }
-
-  JS::Rooted<JSObject*> resolvedProps(cx,
-                                      NPObjWrapper_GetResolvedProps(cx, proxy));
-  if (!resolvedProps) return false;
-  if (!JS_DeletePropertyById(cx, resolvedProps, id, result)) return false;
-
-  PluginDestructionGuard pdg(LookupNPP(npobj));
-
-  NPIdentifier identifier = JSIdToNPIdentifier(id);
-
-  if (!NPObjectIsOutOfProcessProxy(npobj)) {
-    bool hasProperty = npobj->_class->hasProperty(npobj, identifier);
-    if (!ReportExceptionIfPending(cx)) return false;
-
-    if (!hasProperty) return result.succeed();
-  }
-
-  // This removeProperty hook may throw an exception and return false; or just
-  // return false without an exception pending, which behaves like `delete
-  // obj.prop` returning false: in strict mode it becomes a TypeError. Legacy
-  // code---nothing else that uses the JSAPI works this way anymore.
-  bool succeeded = npobj->_class->removeProperty(npobj, identifier);
-  if (!ReportExceptionIfPending(cx)) return false;
-  return succeeded ? result.succeed() : result.failCantDelete();
-}
-
-bool NPObjWrapperProxyHandler::set(JSContext* cx, JS::Handle<JSObject*> proxy,
-                                   JS::Handle<jsid> id,
-                                   JS::Handle<JS::Value> vp,
-                                   JS::Handle<JS::Value> receiver,
-                                   JS::ObjectOpResult& result) const {
-  NPObject* npobj = GetNPObject(cx, proxy);
-
-  if (!npobj || !npobj->_class || !npobj->_class->hasProperty ||
-      !npobj->_class->setProperty) {
-    ThrowJSExceptionASCII(cx, "Bad NPObject as private data!");
-
-    return false;
-  }
-
-  // Find out what plugin (NPP) is the owner of the object we're
-  // manipulating, and make it own any JSObject wrappers created here.
-  NPP npp = LookupNPP(npobj);
-
-  if (!npp) {
-    ThrowJSExceptionASCII(cx, "No NPP found for NPObject!");
-
-    return false;
-  }
-
-  {
-    bool resolved = false;
-    JS::Rooted<JSObject*> method(cx);
-    if (!NPObjWrapper_Resolve(cx, proxy, id, &resolved, &method)) return false;
-    if (!resolved) {
-      // We don't have a property/method with this id. Forward to the prototype
-      // chain.
-      return js::BaseProxyHandler::set(cx, proxy, id, vp, receiver, result);
-    }
-  }
-
-  PluginDestructionGuard pdg(npp);
-
-  NPIdentifier identifier = JSIdToNPIdentifier(id);
-
-  if (!NPObjectIsOutOfProcessProxy(npobj)) {
-    bool hasProperty = npobj->_class->hasProperty(npobj, identifier);
-    if (!ReportExceptionIfPending(cx)) return false;
-
-    if (!hasProperty) {
-      ThrowJSExceptionASCII(cx,
-                            "Trying to set unsupported property on NPObject!");
-
-      return false;
-    }
-  }
-
-  NPVariant npv;
-  if (!JSValToNPVariant(npp, cx, vp, &npv)) {
-    ThrowJSExceptionASCII(cx, "Error converting jsval to NPVariant!");
-
-    return false;
-  }
-
-  bool ok = npobj->_class->setProperty(npobj, identifier, &npv);
-  _releasevariantvalue(&npv);  // Release the variant
-  if (!ReportExceptionIfPending(cx)) return false;
-
-  if (!ok) {
-    ThrowJSExceptionASCII(cx, "Error setting property on NPObject!");
-
-    return false;
-  }
-
-  return result.succeed();
-}
-
-static bool CallNPMethod(JSContext* cx, unsigned argc, JS::Value* vp);
-
-bool NPObjWrapperProxyHandler::get(JSContext* cx, JS::Handle<JSObject*> proxy,
-                                   JS::Handle<JS::Value> receiver,
-                                   JS::Handle<jsid> id,
-                                   JS::MutableHandle<JS::Value> vp) const {
-  NPObject* npobj = GetNPObject(cx, proxy);
-
-  if (!npobj || !npobj->_class || !npobj->_class->hasProperty ||
-      !npobj->_class->hasMethod || !npobj->_class->getProperty) {
-    ThrowJSExceptionASCII(cx, "Bad NPObject as private data!");
-
-    return false;
-  }
-
-  if (id.isSymbol()) {
-    if (id.isWellKnownSymbol(JS::SymbolCode::toPrimitive)) {
-      JS::RootedObject obj(
-          cx, JS_GetFunctionObject(JS_NewFunction(cx, NPObjWrapper_toPrimitive,
-                                                  1, 0, "Symbol.toPrimitive")));
-      if (!obj) return false;
-      vp.setObject(*obj);
-      return true;
-    }
-
-    if (id.isWellKnownSymbol(JS::SymbolCode::toStringTag)) {
-      JS::RootedString tag(cx, JS_NewStringCopyZ(cx, NPRUNTIME_JSCLASS_NAME));
-      if (!tag) {
-        return false;
-      }
-
-      vp.setString(tag);
-      return true;
-    }
-
-    return js::BaseProxyHandler::get(cx, proxy, receiver, id, vp);
-  }
-
-  // Find out what plugin (NPP) is the owner of the object we're
-  // manipulating, and make it own any JSObject wrappers created here.
-  NPP npp = LookupNPP(npobj);
-  if (!npp) {
-    ThrowJSExceptionASCII(cx, "No NPP found for NPObject!");
-
-    return false;
-  }
-
-  {
-    bool resolved = false;
-    JS::Rooted<JSObject*> method(cx);
-    if (!NPObjWrapper_Resolve(cx, proxy, id, &resolved, &method)) return false;
-    if (method) {
-      vp.setObject(*method);
-      return true;
-    }
-    if (!resolved) {
-      // We don't have a property/method with this id. Forward to the prototype
-      // chain.
-      return js::BaseProxyHandler::get(cx, proxy, receiver, id, vp);
-    }
-  }
-
-  PluginDestructionGuard pdg(npp);
-
-  bool hasProperty, hasMethod;
-
-  NPVariant npv;
-  VOID_TO_NPVARIANT(npv);
-
-  NPIdentifier identifier = JSIdToNPIdentifier(id);
-
-  if (NPObjectIsOutOfProcessProxy(npobj)) {
-    PluginScriptableObjectParent* actor =
-        static_cast<ParentNPObject*>(npobj)->parent;
-
-    // actor may be null if the plugin crashed.
-    if (!actor) return false;
-
-    bool success =
-        actor->GetPropertyHelper(identifier, &hasProperty, &hasMethod, &npv);
-
-    if (!ReportExceptionIfPending(cx)) {
-      if (success) _releasevariantvalue(&npv);
-      return false;
-    }
-
-    if (success) {
-      // We return NPObject Member class here to support ambiguous members.
-      if (hasProperty && hasMethod)
-        return CreateNPObjectMember(npp, cx, proxy, npobj, id, &npv, vp);
-
-      if (hasProperty) {
-        vp.set(NPVariantToJSVal(npp, cx, &npv));
-        _releasevariantvalue(&npv);
-
-        if (!ReportExceptionIfPending(cx)) return false;
-        return true;
-      }
-    }
-    return js::BaseProxyHandler::get(cx, proxy, receiver, id, vp);
-  }
-
-  hasProperty = npobj->_class->hasProperty(npobj, identifier);
-  if (!ReportExceptionIfPending(cx)) return false;
-
-  hasMethod = npobj->_class->hasMethod(npobj, identifier);
-  if (!ReportExceptionIfPending(cx)) return false;
-
-  // We return NPObject Member class here to support ambiguous members.
-  if (hasProperty && hasMethod)
-    return CreateNPObjectMember(npp, cx, proxy, npobj, id, nullptr, vp);
-
-  if (hasProperty) {
-    if (npobj->_class->getProperty(npobj, identifier, &npv))
-      vp.set(NPVariantToJSVal(npp, cx, &npv));
-
-    _releasevariantvalue(&npv);
-
-    if (!ReportExceptionIfPending(cx)) return false;
-    return true;
-  }
-
-  return js::BaseProxyHandler::get(cx, proxy, receiver, id, vp);
-}
-
-static bool CallNPMethodInternal(JSContext* cx, JS::Handle<JSObject*> obj,
-                                 unsigned argc, JS::Value* argv,
-                                 JS::Value* rval, bool ctorCall) {
-  NPObject* npobj = GetNPObject(cx, obj);
-
-  if (!npobj || !npobj->_class) {
-    ThrowJSExceptionASCII(cx, "Bad NPObject as private data!");
-
-    return false;
-  }
-
-  // Find out what plugin (NPP) is the owner of the object we're
-  // manipulating, and make it own any JSObject wrappers created here.
-  NPP npp = LookupNPP(npobj);
-
-  if (!npp) {
-    ThrowJSExceptionASCII(cx, "Error finding NPP for NPObject!");
-
-    return false;
-  }
-
-  PluginDestructionGuard pdg(npp);
-
-  NPVariant npargs_buf[8];
-  NPVariant* npargs = npargs_buf;
-
-  if (argc > (sizeof(npargs_buf) / sizeof(NPVariant))) {
-    // Our stack buffer isn't large enough to hold all arguments,
-    // malloc a buffer.
-    npargs = (NPVariant*)malloc(argc * sizeof(NPVariant));
-
-    if (!npargs) {
-      ThrowJSExceptionASCII(cx, "Out of memory!");
-
-      return false;
-    }
-  }
-
-  // Convert arguments
-  uint32_t i;
-  for (i = 0; i < argc; ++i) {
-    if (!JSValToNPVariant(npp, cx, argv[i], npargs + i)) {
-      ThrowJSExceptionASCII(cx, "Error converting jsvals to NPVariants!");
-
-      if (npargs != npargs_buf) {
-        free(npargs);
-      }
-
-      return false;
-    }
-  }
-
-  NPVariant v;
-  VOID_TO_NPVARIANT(v);
-
-  JSObject* funobj = argv[-2].toObjectOrNull();
-  bool ok;
-  const char* msg = "Error calling method on NPObject!";
-
-  if (ctorCall) {
-    // construct a new NPObject based on the NPClass in npobj. Fail if
-    // no construct method is available.
-
-    if (NP_CLASS_STRUCT_VERSION_HAS_CTOR(npobj->_class) &&
-        npobj->_class->construct) {
-      ok = npobj->_class->construct(npobj, npargs, argc, &v);
-    } else {
-      ok = false;
-
-      msg = "Attempt to construct object from class with no constructor.";
-    }
-  } else if (funobj != obj) {
-    // A obj.function() style call is made, get the method name from
-    // the function object.
-
-    if (npobj->_class->invoke) {
-      JSFunction* fun = ::JS_GetObjectFunction(funobj);
-      JS::Rooted<JSString*> funId(cx, ::JS_GetFunctionId(fun));
-      JSString* name = ::JS_AtomizeAndPinJSString(cx, funId);
-      NPIdentifier id = StringToNPIdentifier(cx, name);
-
-      ok = npobj->_class->invoke(npobj, id, npargs, argc, &v);
-    } else {
-      ok = false;
-
-      msg = "Attempt to call a method on object with no invoke method.";
-    }
-  } else {
-    if (npobj->_class->invokeDefault) {
-      // obj is a callable object that is being called, no method name
-      // available then. Invoke the default method.
-
-      ok = npobj->_class->invokeDefault(npobj, npargs, argc, &v);
-    } else {
-      ok = false;
-
-      msg =
-          "Attempt to call a default method on object with no "
-          "invokeDefault method.";
-    }
-  }
-
-  // Release arguments.
-  for (i = 0; i < argc; ++i) {
-    _releasevariantvalue(npargs + i);
-  }
-
-  if (npargs != npargs_buf) {
-    free(npargs);
-  }
-
-  if (!ok) {
-    // ReportExceptionIfPending returns a return value, which is true
-    // if no exception was thrown. In that case, throw our own.
-    if (ReportExceptionIfPending(cx)) ThrowJSExceptionASCII(cx, msg);
-
-    return false;
-  }
-
-  *rval = NPVariantToJSVal(npp, cx, &v);
-
-  // *rval now owns the value, release our reference.
-  _releasevariantvalue(&v);
-
-  return ReportExceptionIfPending(cx);
-}
-
-static bool CallNPMethod(JSContext* cx, unsigned argc, JS::Value* vp) {
-  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
-  if (!args.thisv().isObject()) {
-    ThrowJSExceptionASCII(cx,
-                          "plug-in method called on incompatible non-object");
-    return false;
-  }
-  JS::Rooted<JSObject*> obj(cx, &args.thisv().toObject());
-  return CallNPMethodInternal(cx, obj, args.length(), args.array(), vp, false);
-}
-
-bool NPObjWrapperProxyHandler::getOwnPropertyDescriptor(
-    JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id,
-    JS::MutableHandle<JS::PropertyDescriptor> desc) const {
-  bool resolved = false;
-  JS::Rooted<JSObject*> method(cx);
-  if (!NPObjWrapper_Resolve(cx, proxy, id, &resolved, &method)) return false;
-  if (!resolved) {
-    // No such property.
-    desc.object().set(nullptr);
-    return true;
-  }
-
-  // This returns a descriptor with |null| JS value if this is a plugin
-  // property (as opposed to a method). That should be fine, hopefully, as the
-  // previous code had very inconsistent behavior in this case as well. The main
-  // reason for returning a descriptor here is to make property enumeration work
-  // correctly (it will call getOwnPropertyDescriptor to check enumerability).
-  JS::Rooted<JS::Value> val(cx, JS::ObjectOrNullValue(method));
-  desc.initFields(proxy, val, JSPROP_ENUMERATE, nullptr, nullptr);
-  return true;
-}
-
-bool NPObjWrapperProxyHandler::ownPropertyKeys(
-    JSContext* cx, JS::Handle<JSObject*> proxy,
-    JS::MutableHandleVector<jsid> properties) const {
-  NPObject* npobj = GetNPObject(cx, proxy);
-  if (!npobj || !npobj->_class) {
-    ThrowJSExceptionASCII(cx, "Bad NPObject as private data!");
-    return false;
-  }
-
-  PluginDestructionGuard pdg(LookupNPP(npobj));
-
-  if (!NP_CLASS_STRUCT_VERSION_HAS_ENUM(npobj->_class) ||
-      !npobj->_class->enumerate) {
-    return true;
-  }
-
-  NPIdentifier* identifiers;
-  uint32_t length;
-  if (!npobj->_class->enumerate(npobj, &identifiers, &length)) {
-    if (ReportExceptionIfPending(cx)) {
-      // ReportExceptionIfPending returns a return value, which is true
-      // if no exception was thrown. In that case, throw our own.
-      ThrowJSExceptionASCII(cx,
-                            "Error enumerating properties on scriptable "
-                            "plugin object");
-    }
-    return false;
-  }
-
-  if (!properties.reserve(length)) return false;
-
-  JS::Rooted<jsid> id(cx);
-  for (uint32_t i = 0; i < length; i++) {
-    id = NPIdentifierToJSId(identifiers[i]);
-    properties.infallibleAppend(id);
-  }
-
-  free(identifiers);
-  return true;
-}
-
-// This function is very similar to a resolve hook for native objects. Instead
-// of defining properties on the object, it defines them on a resolvedProps
-// object (a plain JS object that's never exposed to script) that's stored in
-// the NPObjWrapper proxy's reserved slot. The behavior is as follows:
-//
-// - *resolvedp is set to true iff the plugin object has a property or method
-//   (or both) with this id.
-//
-// - If the plugin object has a *property* with this id, the caller is
-//   responsible for getting/setting its value. In this case we assign |null|
-//   to resolvedProps[id] so we don't have to call hasProperty each time.
-//
-// - If the plugin object has a *method* with this id, we create a JSFunction to
-//   call it and assign it to resolvedProps[id]. This function is also assigned
-//   to the |method| outparam so callers can return it directly if we're doing a
-//   |get|.
-static bool NPObjWrapper_Resolve(JSContext* cx, JS::Handle<JSObject*> obj,
-                                 JS::Handle<jsid> id, bool* resolvedp,
-                                 JS::MutableHandle<JSObject*> method) {
-  if (JSID_IS_SYMBOL(id)) return true;
-
-  AUTO_PROFILER_LABEL("NPObjWrapper_Resolve", JS);
-
-  NPObject* npobj = GetNPObject(cx, obj);
-
-  if (!npobj || !npobj->_class || !npobj->_class->hasProperty ||
-      !npobj->_class->hasMethod) {
-    ThrowJSExceptionASCII(cx, "Bad NPObject as private data!");
-
-    return false;
-  }
-
-  JS::Rooted<JSObject*> resolvedProps(cx,
-                                      NPObjWrapper_GetResolvedProps(cx, obj));
-  if (!resolvedProps) return false;
-  JS::Rooted<JS::Value> res(cx);
-  if (!JS_GetPropertyById(cx, resolvedProps, id, &res)) return false;
-  if (res.isObjectOrNull()) {
-    method.set(res.toObjectOrNull());
-    *resolvedp = true;
-    return true;
-  }
-
-  PluginDestructionGuard pdg(LookupNPP(npobj));
-
-  NPIdentifier identifier = JSIdToNPIdentifier(id);
-
-  bool hasProperty = npobj->_class->hasProperty(npobj, identifier);
-  if (!ReportExceptionIfPending(cx)) return false;
-
-  if (hasProperty) {
-    if (!JS_SetPropertyById(cx, resolvedProps, id, JS::NullHandleValue))
-      return false;
-    *resolvedp = true;
-
-    return true;
-  }
-
-  bool hasMethod = npobj->_class->hasMethod(npobj, identifier);
-  if (!ReportExceptionIfPending(cx)) return false;
-
-  if (hasMethod) {
-    NS_ASSERTION(JSID_IS_STRING(id) || JSID_IS_INT(id),
-                 "id must be either string or int!\n");
-
-    JSFunction* fnc = ::JS_DefineFunctionById(
-        cx, resolvedProps, id, CallNPMethod, 0, JSPROP_ENUMERATE);
-    if (!fnc) return false;
-
-    method.set(JS_GetFunctionObject(fnc));
-    *resolvedp = true;
-    return true;
-  }
-
-  // no property or method
-  return true;
-}
-
-void NPObjWrapperProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy) const {
-  JS::AutoAssertGCCallback inCallback;
-
-  NPObject* npobj = (NPObject*)js::GetProxyPrivate(proxy).toPrivate();
-  if (npobj) {
-    if (sNPObjWrappers) {
-      // If the sNPObjWrappers map contains an entry that refers to this
-      // wrapper, remove it.
-      auto entry =
-          static_cast<NPObjWrapperHashEntry*>(sNPObjWrappers->Search(npobj));
-      if (entry && entry->mJSObj == proxy) {
-        sNPObjWrappers->Remove(npobj);
-      }
-    }
-  }
-
-  if (!sDelayedReleases) sDelayedReleases = new nsTArray<NPObject*>;
-  sDelayedReleases->AppendElement(npobj);
-}
-
-size_t NPObjWrapperProxyHandler::objectMoved(JSObject* obj,
-                                             JSObject* old) const {
-  // The wrapper JSObject has been moved, so we need to update the entry in the
-  // sNPObjWrappers hash table, if present.
-
-  if (!sNPObjWrappers) {
-    return 0;
-  }
-
-  NPObject* npobj = (NPObject*)js::GetProxyPrivate(obj).toPrivate();
-  if (!npobj) {
-    return 0;
-  }
-
-  // Calling PLDHashTable::Search() will not result in GC.
-  JS::AutoSuppressGCAnalysis nogc;
-
-  auto entry =
-      static_cast<NPObjWrapperHashEntry*>(sNPObjWrappers->Search(npobj));
-  MOZ_ASSERT(entry && entry->mJSObj);
-  MOZ_ASSERT(entry->mJSObj == old);
-  entry->mJSObj = obj;
-  return 0;
-}
-
-bool NPObjWrapperProxyHandler::call(JSContext* cx, JS::Handle<JSObject*> proxy,
-                                    const JS::CallArgs& args) const {
-  return CallNPMethodInternal(cx, proxy, args.length(), args.array(),
-                              args.rval().address(), false);
-}
-
-bool NPObjWrapperProxyHandler::construct(JSContext* cx,
-                                         JS::Handle<JSObject*> proxy,
-                                         const JS::CallArgs& args) const {
-  return CallNPMethodInternal(cx, proxy, args.length(), args.array(),
-                              args.rval().address(), true);
-}
-
-static bool NPObjWrapper_toPrimitive(JSContext* cx, unsigned argc,
-                                     JS::Value* vp) {
-  // Plugins do not simply use the default OrdinaryToPrimitive behavior,
-  // because that behavior involves calling toString or valueOf on objects
-  // which weren't designed to accommodate this.  Usually this wouldn't be a
-  // problem, because the absence of either property, or the presence of either
-  // property with a value that isn't callable, will cause that property to
-  // simply be ignored.  But there is a problem in one specific case: Java,
-  // specifically java.lang.Integer.  The Integer class has static valueOf
-  // methods, none of which are nullary, so the JS-reflected method will behave
-  // poorly when called with no arguments.  We work around this problem by
-  // giving plugins a [Symbol.toPrimitive]() method which uses only toString
-  // and not valueOf.
-
-  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
-  JS::RootedValue thisv(cx, args.thisv());
-  if (thisv.isPrimitive()) return true;
-
-  JS::RootedObject obj(cx, &thisv.toObject());
-  JS::RootedValue v(cx);
-  if (!JS_GetProperty(cx, obj, "toString", &v)) return false;
-  if (v.isObject() && JS::IsCallable(&v.toObject())) {
-    if (!JS_CallFunctionValue(cx, obj, v, JS::HandleValueArray::empty(),
-                              args.rval()))
-      return false;
-    if (args.rval().isPrimitive()) return true;
-  }
-
-  JS_ReportErrorNumberASCII(cx, js::GetErrorMessage, nullptr,
-                            JSMSG_CANT_CONVERT_TO, JS::GetClass(obj)->name,
-                            "primitive type");
-  return false;
-}
-
-bool nsNPObjWrapper::IsWrapper(JSObject* obj) {
-  return JS::GetClass(obj) == &sNPObjWrapperProxyClass;
-}
-
-// An NPObject is going away, make sure we null out the JS object's
-// private data in case this is an NPObject that came from a plugin
-// and it's destroyed prematurely.
-
-// static
-void nsNPObjWrapper::OnDestroy(NPObject* npobj) {
-  if (!npobj) {
-    return;
-  }
-
-  if (npobj->_class == &nsJSObjWrapper::sJSObjWrapperNPClass) {
-    // npobj is one of our own, no private data to clean up here.
-
-    return;
-  }
-
-  if (!sNPObjWrappers) {
-    // No hash yet (or any more), no used wrappers available.
-
-    return;
-  }
-
-  auto entry =
-      static_cast<NPObjWrapperHashEntry*>(sNPObjWrappers->Search(npobj));
-
-  if (entry && entry->mJSObj) {
-    // Found an NPObject wrapper, null out its JSObjects' private data.
-    js::SetProxyPrivate(entry->mJSObj.unbarrieredGetPtr(),
-                        JS::PrivateValue(nullptr));
-
-    // Remove the npobj from the hash now that it went away.
-    sNPObjWrappers->RawRemove(entry);
-
-    // The finalize hook will call OnWrapperDestroyed().
-  }
-}
-
-// Look up or create a JSObject that wraps the NPObject npobj. The return value
-// is always in the compartment of the passed-in JSContext (it might be a CCW).
-
-// static
-JSObject* nsNPObjWrapper::GetNewOrUsed(NPP npp, JSContext* cx,
-                                       NPObject* npobj) {
-  if (!npobj) {
-    NS_ERROR("Null NPObject passed to nsNPObjWrapper::GetNewOrUsed()!");
-
-    return nullptr;
-  }
-
-  if (npobj->_class == &nsJSObjWrapper::sJSObjWrapperNPClass) {
-    // npobj is one of our own, return its existing JSObject.
-
-    JS::Rooted<JSObject*> obj(cx, ((nsJSObjWrapper*)npobj)->mJSObj);
-    if (!JS_WrapObject(cx, &obj)) {
-      return nullptr;
-    }
-    return obj;
-  }
-
-  if (!npp) {
-    NS_ERROR("No npp passed to nsNPObjWrapper::GetNewOrUsed()!");
-
-    return nullptr;
-  }
-
-  if (!sNPObjWrappers) {
-    // No hash yet (or any more), initialize it.
-    if (!CreateNPObjWrapperTable()) {
-      return nullptr;
-    }
-  }
-
-  auto entry =
-      static_cast<NPObjWrapperHashEntry*>(sNPObjWrappers->Add(npobj, fallible));
-
-  if (!entry) {
-    // Out of memory
-    JS_ReportOutOfMemory(cx);
-
-    return nullptr;
-  }
-
-  if (entry->mJSObj) {
-    // Found a NPObject wrapper. First check it is still alive.
-    JSObject* obj = entry->mJSObj.unbarrieredGetPtr();
-    if (js::gc::EdgeNeedsSweepUnbarriered(&obj)) {
-      // The object is dead (finalization will happen at a later time). By the
-      // time we leave this function, this entry will either be updated with a
-      // new wrapper or removed if that fails. Clear it anyway to make sure
-      // nothing touches the dead object.
-      entry->mJSObj = nullptr;
-    } else {
-      // It may not be in the same compartment as cx, so we need to wrap it
-      // before returning it.
-      JS::Rooted<JSObject*> obj(cx, entry->mJSObj);
-      if (!JS_WrapObject(cx, &obj)) {
-        return nullptr;
-      }
-      return obj;
-    }
-  }
-
-  entry->mNPObj = npobj;
-  entry->mNpp = npp;
-
-  uint32_t generation = sNPObjWrappers->Generation();
-
-  // No existing JSObject, create one.
-
-  JS::RootedValue priv(cx, JS::PrivateValue(nullptr));
-  js::ProxyOptions options;
-  options.setClass(&sNPObjWrapperProxyClass);
-  JS::Rooted<JSObject*> obj(
-      cx, js::NewProxyObject(cx, &NPObjWrapperProxyHandler::singleton, priv,
-                             nullptr, options));
-
-  if (generation != sNPObjWrappers->Generation()) {
-    // Reload entry if the JS_NewObject call caused a GC and reallocated
-    // the table (see bug 445229). This is guaranteed to succeed.
-
-    entry = static_cast<NPObjWrapperHashEntry*>(sNPObjWrappers->Search(npobj));
-    NS_ASSERTION(entry, "Hashtable didn't find what we just added?");
-  }
-
-  if (!obj) {
-    // OOM? Remove the stale entry from the hash.
-
-    sNPObjWrappers->RawRemove(entry);
-
-    return nullptr;
-  }
-
-  OnWrapperCreated();
-
-  entry->mJSObj = obj;
-
-  js::SetProxyPrivate(obj, JS::PrivateValue(npobj));
-
-  // The new JSObject now holds on to npobj
-  _retainobject(npobj);
-
-  return obj;
-}
-
-// static
-void nsJSNPRuntime::OnPluginDestroy(NPP npp) {
-  if (sJSObjWrappersAccessible) {
-    // Prevent modification of sJSObjWrappers table if we go reentrant.
-    sJSObjWrappersAccessible = false;
-
-    for (auto iter = sJSObjWrappers->modIter(); !iter.done(); iter.next()) {
-      nsJSObjWrapper* npobj = iter.get().value();
-      MOZ_ASSERT(npobj->_class == &nsJSObjWrapper::sJSObjWrapperNPClass);
-      if (npobj->mNpp == npp) {
-        if (npobj->_class && npobj->_class->invalidate) {
-          npobj->_class->invalidate(npobj);
-        }
-
-        _releaseobject(npobj);
-
-        iter.remove();
-      }
-    }
-
-    sJSObjWrappersAccessible = true;
-  }
-
-  if (sNPObjWrappers) {
-    for (auto i = sNPObjWrappers->Iter(); !i.Done(); i.Next()) {
-      auto entry = static_cast<NPObjWrapperHashEntry*>(i.Get());
-
-      if (entry->mNpp == npp) {
-        // HACK: temporarily hide the table we're enumerating so that
-        // invalidate() and deallocate() don't touch it.
-        PLDHashTable* tmp = sNPObjWrappers;
-        sNPObjWrappers = nullptr;
-
-        NPObject* npobj = entry->mNPObj;
-
-        if (npobj->_class && npobj->_class->invalidate) {
-          npobj->_class->invalidate(npobj);
-        }
-
-#ifdef NS_BUILD_REFCNT_LOGGING
-        {
-          int32_t refCnt = npobj->referenceCount;
-          while (refCnt) {
-            --refCnt;
-            NS_LOG_RELEASE(npobj, refCnt, "BrowserNPObject");
-          }
-        }
-#endif
-
-        // Force deallocation of plugin objects since the plugin they came
-        // from is being torn down.
-        if (npobj->_class && npobj->_class->deallocate) {
-          npobj->_class->deallocate(npobj);
-        } else {
-          free(npobj);
-        }
-
-        js::SetProxyPrivate(entry->mJSObj.unbarrieredGetPtr(),
-                            JS::PrivateValue(nullptr));
-
-        sNPObjWrappers = tmp;
-
-        if (sDelayedReleases && sDelayedReleases->RemoveElement(npobj)) {
-          OnWrapperDestroyed();
-        }
-
-        i.Remove();
-      }
-    }
-  }
-}
-
-// static
-void nsJSNPRuntime::OnPluginDestroyPending(NPP npp) {
-  if (sJSObjWrappersAccessible) {
-    // Prevent modification of sJSObjWrappers table if we go reentrant.
-    sJSObjWrappersAccessible = false;
-    for (auto iter = sJSObjWrappers->iter(); !iter.done(); iter.next()) {
-      nsJSObjWrapper* npobj = iter.get().value();
-      MOZ_ASSERT(npobj->_class == &nsJSObjWrapper::sJSObjWrapperNPClass);
-      if (npobj->mNpp == npp) {
-        npobj->mDestroyPending = true;
-      }
-    }
-    sJSObjWrappersAccessible = true;
-  }
-}
-
-// Find the NPP for a NPObject.
-static NPP LookupNPP(NPObject* npobj) {
-  if (npobj->_class == &nsJSObjWrapper::sJSObjWrapperNPClass) {
-    nsJSObjWrapper* o = static_cast<nsJSObjWrapper*>(npobj);
-    return o->mNpp;
-  }
-
-  auto entry =
-      static_cast<NPObjWrapperHashEntry*>(sNPObjWrappers->Add(npobj, fallible));
-
-  if (!entry) {
-    return nullptr;
-  }
-
-  NS_ASSERTION(entry->mNpp, "Live NPObject entry w/o an NPP!");
-
-  return entry->mNpp;
-}
-
-static bool CreateNPObjectMember(NPP npp, JSContext* cx,
-                                 JS::Handle<JSObject*> aObj, NPObject* npobj,
-                                 JS::Handle<jsid> id,
-                                 NPVariant* getPropertyResult,
-                                 JS::MutableHandle<JS::Value> vp) {
-  if (!npobj || !npobj->_class || !npobj->_class->getProperty ||
-      !npobj->_class->invoke) {
-    ThrowJSExceptionASCII(cx, "Bad NPObject");
-
-    return false;
-  }
-
-  NPObjectMemberPrivate* memberPrivate = new NPObjectMemberPrivate;
-
-  JS::Rooted<JSObject*> obj(cx, aObj);
-
-  JS::Rooted<JSObject*> memobj(cx, ::JS_NewObject(cx, &sNPObjectMemberClass));
-  if (!memobj) {
-    delete memberPrivate;
-    return false;
-  }
-
-  vp.setObject(*memobj);
-
-  JS::SetPrivate(memobj, (void*)memberPrivate);
-
-  NPIdentifier identifier = JSIdToNPIdentifier(id);
-
-  JS::Rooted<JS::Value> fieldValue(cx);
-  NPVariant npv;
-
-  if (getPropertyResult) {
-    // Plugin has already handed us the value we want here.
-    npv = *getPropertyResult;
-  } else {
-    VOID_TO_NPVARIANT(npv);
-
-    NPBool hasProperty = npobj->_class->getProperty(npobj, identifier, &npv);
-    if (!ReportExceptionIfPending(cx) || !hasProperty) {
-      return false;
-    }
-  }
-
-  fieldValue = NPVariantToJSVal(npp, cx, &npv);
-
-  // npobjWrapper is the JSObject through which we make sure we don't
-  // outlive the underlying NPObject, so make sure it points to the
-  // real JSObject wrapper for the NPObject.
-  obj = GetNPObjectWrapper(cx, obj);
-
-  memberPrivate->npobjWrapper = obj;
-
-  memberPrivate->fieldValue = fieldValue;
-  memberPrivate->methodName = id;
-  memberPrivate->npp = npp;
-
-  // Finally, define the Symbol.toPrimitive property on |memobj|.
-
-  JS::Rooted<jsid> toPrimitiveId(cx);
-  toPrimitiveId =
-      SYMBOL_TO_JSID(JS::GetWellKnownSymbol(cx, JS::SymbolCode::toPrimitive));
-
-  JSFunction* fun = JS_NewFunction(cx, NPObjectMember_toPrimitive, 1, 0,
-                                   "Symbol.toPrimitive");
-  if (!fun) return false;
-
-  JS::Rooted<JSObject*> funObj(cx, JS_GetFunctionObject(fun));
-  if (!JS_DefinePropertyById(cx, memobj, toPrimitiveId, funObj, 0))
-    return false;
-
-  return true;
-}
-
-static void NPObjectMember_Finalize(JSFreeOp* fop, JSObject* obj) {
-  NPObjectMemberPrivate* memberPrivate;
-
-  memberPrivate = (NPObjectMemberPrivate*)JS::GetPrivate(obj);
-  if (!memberPrivate) return;
-
-  delete memberPrivate;
-}
-
-static bool NPObjectMember_Call(JSContext* cx, unsigned argc, JS::Value* vp) {
-  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
-  JS::Rooted<JSObject*> memobj(cx, &args.callee());
-  NS_ENSURE_TRUE(memobj, false);
-
-  NPObjectMemberPrivate* memberPrivate =
-      (NPObjectMemberPrivate*)::JS_GetInstancePrivate(
-          cx, memobj, &sNPObjectMemberClass, &args);
-  if (!memberPrivate || !memberPrivate->npobjWrapper) return false;
-
-  JS::Rooted<JSObject*> objWrapper(cx, memberPrivate->npobjWrapper);
-  NPObject* npobj = GetNPObject(cx, objWrapper);
-  if (!npobj) {
-    ThrowJSExceptionASCII(cx, "Call on invalid member object");
-
-    return false;
-  }
-
-  NPVariant npargs_buf[8];
-  NPVariant* npargs = npargs_buf;
-
-  if (args.length() > (sizeof(npargs_buf) / sizeof(NPVariant))) {
-    // Our stack buffer isn't large enough to hold all arguments,
-    // malloc a buffer.
-    npargs = (NPVariant*)malloc(args.length() * sizeof(NPVariant));
-
-    if (!npargs) {
-      ThrowJSExceptionASCII(cx, "Out of memory!");
-
-      return false;
-    }
-  }
-
-  // Convert arguments
-  for (uint32_t i = 0; i < args.length(); ++i) {
-    if (!JSValToNPVariant(memberPrivate->npp, cx, args[i], npargs + i)) {
-      ThrowJSExceptionASCII(cx, "Error converting jsvals to NPVariants!");
-
-      if (npargs != npargs_buf) {
-        free(npargs);
-      }
-
-      return false;
-    }
-  }
-
-  NPVariant npv;
-  bool ok = npobj->_class->invoke(npobj,
-                                  JSIdToNPIdentifier(memberPrivate->methodName),
-                                  npargs, args.length(), &npv);
-
-  // Release arguments.
-  for (uint32_t i = 0; i < args.length(); ++i) {
-    _releasevariantvalue(npargs + i);
-  }
-
-  if (npargs != npargs_buf) {
-    free(npargs);
-  }
-
-  if (!ok) {
-    // ReportExceptionIfPending returns a return value, which is true
-    // if no exception was thrown. In that case, throw our own.
-    if (ReportExceptionIfPending(cx))
-      ThrowJSExceptionASCII(cx, "Error calling method on NPObject!");
-
-    return false;
-  }
-
-  args.rval().set(NPVariantToJSVal(memberPrivate->npp, cx, &npv));
-
-  // *vp now owns the value, release our reference.
-  _releasevariantvalue(&npv);
-
-  return ReportExceptionIfPending(cx);
-}
-
-static void NPObjectMember_Trace(JSTracer* trc, JSObject* obj) {
-  auto* memberPrivate = (NPObjectMemberPrivate*)JS::GetPrivate(obj);
-  if (!memberPrivate) return;
-
-  // Our NPIdentifier is not always interned, so we must trace it.
-  JS::TraceEdge(trc, &memberPrivate->methodName,
-                "NPObjectMemberPrivate.methodName");
-
-  JS::TraceEdge(trc, &memberPrivate->fieldValue,
-                "NPObject Member => fieldValue");
-
-  // There's no strong reference from our private data to the
-  // NPObject, so make sure to mark the NPObject wrapper to keep the
-  // NPObject alive as long as this NPObjectMember is alive.
-  JS::TraceEdge(trc, &memberPrivate->npobjWrapper,
-                "NPObject Member => npobjWrapper");
-}
-
-static bool NPObjectMember_toPrimitive(JSContext* cx, unsigned argc,
-                                       JS::Value* vp) {
-  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
-  JS::RootedValue thisv(cx, args.thisv());
-  if (thisv.isPrimitive()) {
-    args.rval().set(thisv);
-    return true;
-  }
-
-  JS::RootedObject obj(cx, &thisv.toObject());
-  NPObjectMemberPrivate* memberPrivate =
-      (NPObjectMemberPrivate*)::JS_GetInstancePrivate(
-          cx, obj, &sNPObjectMemberClass, &args);
-  if (!memberPrivate) return false;
-
-  JSType hint;
-  if (!JS::GetFirstArgumentAsTypeHint(cx, args, &hint)) return false;
-
-  args.rval().set(memberPrivate->fieldValue);
-  if (args.rval().isObject()) {
-    JS::Rooted<JSObject*> objVal(cx, &args.rval().toObject());
-    return JS::ToPrimitive(cx, objVal, hint, args.rval());
-  }
-  return true;
-}
diff --git a/dom/plugins/base/nsJSNPRuntime.h b/dom/plugins/base/nsJSNPRuntime.h
deleted file mode 100644
index c1e877f859593..0000000000000
--- a/dom/plugins/base/nsJSNPRuntime.h
+++ /dev/null
@@ -1,99 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef nsJSNPRuntime_h_
-#define nsJSNPRuntime_h_
-
-#include "nscore.h"
-#include "npapi.h"
-#include "npruntime.h"
-#include "PLDHashTable.h"
-#include "js/RootingAPI.h"
-
-class nsJSNPRuntime {
- public:
-  static void OnPluginDestroy(NPP npp);
-  static void OnPluginDestroyPending(NPP npp);
-};
-
-class nsJSObjWrapperKey {
- public:
-  nsJSObjWrapperKey(JSObject* obj, NPP npp) : mJSObj(obj), mNpp(npp) {}
-
-  bool operator==(const nsJSObjWrapperKey& other) const {
-    return mJSObj == other.mJSObj && mNpp == other.mNpp;
-  }
-  bool operator!=(const nsJSObjWrapperKey& other) const {
-    return !(*this == other);
-  }
-
-  void trace(JSTracer* trc) {
-    JS::TraceEdge(trc, &mJSObj, "nsJSObjWrapperKey");
-  }
-
-  nsJSObjWrapperKey(nsJSObjWrapperKey&& other) = default;
-  nsJSObjWrapperKey& operator=(nsJSObjWrapperKey&& other) = default;
-
-  JS::Heap<JSObject*> mJSObj;
-  NPP mNpp;
-};
-
-class nsJSObjWrapper : public NPObject {
- public:
-  JS::Heap<JSObject*> mJSObj;
-  // Because mJSObj might be a cross-compartment wrapper, we can't use it to
-  // enter the target realm. We use this global instead (it's always
-  // same-compartment with mJSObj).
-  JS::Heap<JSObject*> mJSObjGlobal;
-  const NPP mNpp;
-  bool mDestroyPending;
-
-  static NPObject* GetNewOrUsed(NPP npp, JS::Handle<JSObject*> obj,
-                                JS::Handle<JSObject*> objGlobal);
-
-  void trace(JSTracer* trc) {
-    JS::TraceEdge(trc, &mJSObj, "nsJSObjWrapper::mJSObj");
-    JS::TraceEdge(trc, &mJSObjGlobal, "nsJSObjWrapper::mJSObjGlobal");
-  }
-
- protected:
-  explicit nsJSObjWrapper(NPP npp);
-  ~nsJSObjWrapper();
-
-  static NPObject* NP_Allocate(NPP npp, NPClass* aClass);
-  static void NP_Deallocate(NPObject* obj);
-  static void NP_Invalidate(NPObject* obj);
-  static bool NP_HasMethod(NPObject*, NPIdentifier identifier);
-  static bool NP_Invoke(NPObject* obj, NPIdentifier method,
-                        const NPVariant* args, uint32_t argCount,
-                        NPVariant* result);
-  static bool NP_InvokeDefault(NPObject* obj, const NPVariant* args,
-                               uint32_t argCount, NPVariant* result);
-  static bool NP_HasProperty(NPObject* obj, NPIdentifier property);
-  static bool NP_GetProperty(NPObject* obj, NPIdentifier property,
-                             NPVariant* result);
-  static bool NP_SetProperty(NPObject* obj, NPIdentifier property,
-                             const NPVariant* value);
-  static bool NP_RemoveProperty(NPObject* obj, NPIdentifier property);
-  static bool NP_Enumerate(NPObject* npobj, NPIdentifier** identifier,
-                           uint32_t* count);
-  static bool NP_Construct(NPObject* obj, const NPVariant* args,
-                           uint32_t argCount, NPVariant* result);
-
- public:
-  static NPClass sJSObjWrapperNPClass;
-};
-
-class nsNPObjWrapper {
- public:
-  static bool IsWrapper(JSObject* obj);
-  static void OnDestroy(NPObject* npobj);
-  static JSObject* GetNewOrUsed(NPP npp, JSContext* cx, NPObject* npobj);
-};
-
-bool JSValToNPVariant(NPP npp, JSContext* cx, const JS::Value& val,
-                      NPVariant* variant);
-
-#endif  // nsJSNPRuntime_h_
diff --git a/dom/plugins/base/nsNPAPIPlugin.cpp b/dom/plugins/base/nsNPAPIPlugin.cpp
deleted file mode 100644
index f5b469e819998..0000000000000
--- a/dom/plugins/base/nsNPAPIPlugin.cpp
+++ /dev/null
@@ -1,1886 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "base/basictypes.h"
-
-/* This must occur *after* layers/PLayerTransaction.h to avoid typedefs
- * conflicts. */
-#include "mozilla/ArrayUtils.h"
-
-#include "pratom.h"
-#include "prenv.h"
-
-#include "jsfriendapi.h"
-#include "js/friend/WindowProxy.h"  // js::ToWindowIfWindowProxy
-#include "js/Object.h"              // JS::GetCompartment
-
-#include "nsPluginHost.h"
-#include "nsNPAPIPlugin.h"
-#include "nsNPAPIPluginInstance.h"
-#include "nsNPAPIPluginStreamListener.h"
-#include "nsPluginStreamListenerPeer.h"
-#include "nsThreadUtils.h"
-#include "mozilla/CycleCollectedJSContext.h"  // for nsAutoMicroTask
-#include "mozilla/Preferences.h"
-#include "mozilla/ProfilerLabels.h"
-#include "nsPluginInstanceOwner.h"
-
-#include "nsPluginsDir.h"
-#include "nsPluginLogging.h"
-
-#include "nsPIDOMWindow.h"
-#include "nsGlobalWindow.h"
-#include "mozilla/dom/AutoEntryScript.h"
-#include "mozilla/dom/Document.h"
-#include "nsIContent.h"
-#include "nsIIDNService.h"
-#include "nsIScriptGlobalObject.h"
-#include "nsIScriptContext.h"
-#include "nsDOMJSUtils.h"
-#include "nsIPrincipal.h"
-#include "nsWildCard.h"
-#include "nsContentUtils.h"
-#include "mozilla/dom/Element.h"
-#include "mozilla/dom/JSExecutionContext.h"
-#include "mozilla/dom/ScriptSettings.h"
-#include "mozilla/dom/ToJSValue.h"
-#include "nsIXPConnect.h"
-#include "nsMemory.h"
-
-#include <prinrval.h>
-
-#ifdef MOZ_WIDGET_COCOA
-#  include <Carbon/Carbon.h>
-#  include <ApplicationServices/ApplicationServices.h>
-#  include <OpenGL/OpenGL.h>
-#  include "nsCocoaFeatures.h"
-#  include "PluginUtilsOSX.h"
-#endif
-
-// needed for nppdf plugin
-#if (MOZ_WIDGET_GTK)
-#  include <gdk/gdk.h>
-#  include <gdk/gdkx.h>
-#endif
-
-#include "nsJSUtils.h"
-#include "nsJSNPRuntime.h"
-
-#include "nsNetUtil.h"
-#include "nsNetCID.h"
-
-#include "mozilla/Mutex.h"
-#include "mozilla/PluginLibrary.h"
-using mozilla::PluginLibrary;
-
-#include "mozilla/plugins/PluginModuleParent.h"
-using mozilla::plugins::PluginModuleChromeParent;
-using mozilla::plugins::PluginModuleContentParent;
-
-#ifdef MOZ_X11
-#  include "mozilla/X11Util.h"
-#endif
-
-#ifdef XP_WIN
-#  include <windows.h>
-#  include "mozilla/WindowsVersion.h"
-#  ifdef ACCESSIBILITY
-#    include "mozilla/a11y/Compatibility.h"
-#  endif
-#endif
-
-#include "AudioChannelService.h"
-
-using namespace mozilla;
-using namespace mozilla::plugins::parent;
-using mozilla::dom::Document;
-using mozilla::dom::JSExecutionContext;
-
-// We should make this const...
-static NPNetscapeFuncs sBrowserFuncs = {
-    sizeof(sBrowserFuncs),
-    (NP_VERSION_MAJOR << 8) + NP_VERSION_MINOR,
-    _geturl,
-    _posturl,
-    _requestread,
-    nullptr,  // _newstream, unimplemented
-    nullptr,  // _write, unimplemented
-    nullptr,  // _destroystream, unimplemented
-    _status,
-    _useragent,
-    _memalloc,
-    _memfree,
-    _memflush,
-    _reloadplugins,
-    _getJavaEnv,
-    _getJavaPeer,
-    _geturlnotify,
-    _posturlnotify,
-    _getvalue,
-    _setvalue,
-    _invalidaterect,
-    _invalidateregion,
-    _forceredraw,
-    _getstringidentifier,
-    _getstringidentifiers,
-    _getintidentifier,
-    _identifierisstring,
-    _utf8fromidentifier,
-    _intfromidentifier,
-    _createobject,
-    _retainobject,
-    _releaseobject,
-    _invoke,
-    _invokeDefault,
-    _evaluate,
-    _getproperty,
-    _setproperty,
-    _removeproperty,
-    _hasproperty,
-    _hasmethod,
-    _releasevariantvalue,
-    _setexception,
-    _pushpopupsenabledstate,
-    _poppopupsenabledstate,
-    _enumerate,
-    nullptr,  // pluginthreadasynccall, not used
-    _construct,
-    _getvalueforurl,
-    _setvalueforurl,
-    nullptr,  // NPN GetAuthenticationInfo, not supported
-    _scheduletimer,
-    _unscheduletimer,
-    _popupcontextmenu,
-    _convertpoint,
-    nullptr,  // handleevent, unimplemented
-    nullptr,  // unfocusinstance, unimplemented
-    _urlredirectresponse,
-    _initasyncsurface,
-    _finalizeasyncsurface,
-    _setcurrentasyncsurface};
-
-// POST/GET stream type
-enum eNPPStreamTypeInternal {
-  eNPPStreamTypeInternal_Get,
-  eNPPStreamTypeInternal_Post
-};
-
-void NS_NotifyBeginPluginCall(NSPluginCallReentry aReentryState) {
-  nsNPAPIPluginInstance::BeginPluginCall(aReentryState);
-}
-
-void NS_NotifyPluginCall(NSPluginCallReentry aReentryState) {
-  nsNPAPIPluginInstance::EndPluginCall(aReentryState);
-}
-
-nsNPAPIPlugin::nsNPAPIPlugin() {
-  memset((void*)&mPluginFuncs, 0, sizeof(mPluginFuncs));
-  mPluginFuncs.size = sizeof(mPluginFuncs);
-  mPluginFuncs.version = (NP_VERSION_MAJOR << 8) | NP_VERSION_MINOR;
-
-  mLibrary = nullptr;
-}
-
-nsNPAPIPlugin::~nsNPAPIPlugin() {
-  delete mLibrary;
-  mLibrary = nullptr;
-}
-
-void nsNPAPIPlugin::PluginCrashed(const nsAString& aPluginDumpID,
-                                  const nsACString& aAdditionalMinidumps) {
-  RefPtr<nsPluginHost> host = nsPluginHost::GetInst();
-  host->PluginCrashed(this, aPluginDumpID, aAdditionalMinidumps);
-}
-
-inline PluginLibrary* GetNewPluginLibrary(nsPluginTag* aPluginTag) {
-  AUTO_PROFILER_LABEL("GetNewPluginLibrary", OTHER);
-
-  if (!aPluginTag) {
-    return nullptr;
-  }
-
-  if (XRE_IsContentProcess()) {
-    return PluginModuleContentParent::LoadModule(aPluginTag->mId, aPluginTag);
-  }
-
-  return PluginModuleChromeParent::LoadModule(aPluginTag->mFullPath.get(),
-                                              aPluginTag->mId, aPluginTag);
-}
-
-// Creates an nsNPAPIPlugin object. One nsNPAPIPlugin object exists per plugin
-// (not instance).
-nsresult nsNPAPIPlugin::CreatePlugin(nsPluginTag* aPluginTag,
-                                     nsNPAPIPlugin** aResult) {
-  AUTO_PROFILER_LABEL("nsNPAPIPlugin::CreatePlugin", OTHER);
-  *aResult = nullptr;
-
-  if (!aPluginTag) {
-    return NS_ERROR_FAILURE;
-  }
-
-  RefPtr<nsNPAPIPlugin> plugin = new nsNPAPIPlugin();
-
-  PluginLibrary* pluginLib = GetNewPluginLibrary(aPluginTag);
-  if (!pluginLib) {
-    return NS_ERROR_FAILURE;
-  }
-
-#if defined(XP_MACOSX)
-  if (!pluginLib->HasRequiredFunctions()) {
-    NS_WARNING(
-        "Not all necessary functions exposed by plugin, it will not load.");
-    delete pluginLib;
-    return NS_ERROR_FAILURE;
-  }
-#endif
-
-  plugin->mLibrary = pluginLib;
-  pluginLib->SetPlugin(plugin);
-
-// Exchange NPAPI entry points.
-#if defined(XP_WIN)
-  // NP_GetEntryPoints must be called before NP_Initialize on Windows.
-  NPError pluginCallError;
-  nsresult rv =
-      pluginLib->NP_GetEntryPoints(&plugin->mPluginFuncs, &pluginCallError);
-  if (rv != NS_OK || pluginCallError != NPERR_NO_ERROR) {
-    return NS_ERROR_FAILURE;
-  }
-
-  // NP_Initialize must be called after NP_GetEntryPoints on Windows.
-  rv = pluginLib->NP_Initialize(&sBrowserFuncs, &pluginCallError);
-  if (rv != NS_OK || pluginCallError != NPERR_NO_ERROR) {
-    return NS_ERROR_FAILURE;
-  }
-#elif defined(XP_MACOSX)
-  // NP_Initialize must be called before NP_GetEntryPoints on Mac OS X.
-  // We need to match WebKit's behavior.
-  NPError pluginCallError;
-  nsresult rv = pluginLib->NP_Initialize(&sBrowserFuncs, &pluginCallError);
-  if (rv != NS_OK || pluginCallError != NPERR_NO_ERROR) {
-    return NS_ERROR_FAILURE;
-  }
-
-  rv = pluginLib->NP_GetEntryPoints(&plugin->mPluginFuncs, &pluginCallError);
-  if (rv != NS_OK || pluginCallError != NPERR_NO_ERROR) {
-    return NS_ERROR_FAILURE;
-  }
-#else
-  NPError pluginCallError;
-  nsresult rv = pluginLib->NP_Initialize(&sBrowserFuncs, &plugin->mPluginFuncs,
-                                         &pluginCallError);
-  if (rv != NS_OK || pluginCallError != NPERR_NO_ERROR) {
-    return NS_ERROR_FAILURE;
-  }
-#endif
-
-  plugin.forget(aResult);
-  return NS_OK;
-}
-
-PluginLibrary* nsNPAPIPlugin::GetLibrary() { return mLibrary; }
-
-NPPluginFuncs* nsNPAPIPlugin::PluginFuncs() { return &mPluginFuncs; }
-
-nsresult nsNPAPIPlugin::Shutdown() {
-  NPP_PLUGIN_LOG(PLUGIN_LOG_BASIC,
-                 ("NPP Shutdown to be called: this=%p\n", this));
-
-  NPError shutdownError;
-  mLibrary->NP_Shutdown(&shutdownError);
-
-  return NS_OK;
-}
-
-nsresult nsNPAPIPlugin::RetainStream(NPStream* pstream,
-                                     nsISupports** aRetainedPeer) {
-  if (!aRetainedPeer) return NS_ERROR_NULL_POINTER;
-
-  *aRetainedPeer = nullptr;
-
-  if (!pstream || !pstream->ndata) return NS_ERROR_NULL_POINTER;
-
-  nsNPAPIStreamWrapper* streamWrapper =
-      static_cast<nsNPAPIStreamWrapper*>(pstream->ndata);
-  nsNPAPIPluginStreamListener* listener = streamWrapper->GetStreamListener();
-  if (!listener) {
-    return NS_ERROR_NULL_POINTER;
-  }
-
-  nsIStreamListener* streamListener = listener->GetStreamListenerPeer();
-  if (!streamListener) {
-    return NS_ERROR_NULL_POINTER;
-  }
-
-  *aRetainedPeer = streamListener;
-  NS_ADDREF(*aRetainedPeer);
-  return NS_OK;
-}
-
-// Create a new NPP GET or POST (given in the type argument) url
-// stream that may have a notify callback
-NPError MakeNewNPAPIStreamInternal(NPP npp, const char* relativeURL,
-                                   const char* target,
-                                   eNPPStreamTypeInternal type,
-                                   bool bDoNotify = false,
-                                   void* notifyData = nullptr, uint32_t len = 0,
-                                   const char* buf = nullptr) {
-  if (!npp) return NPERR_INVALID_INSTANCE_ERROR;
-
-  PluginDestructionGuard guard(npp);
-
-  nsNPAPIPluginInstance* inst = (nsNPAPIPluginInstance*)npp->ndata;
-  if (!inst || !inst->IsRunning()) return NPERR_INVALID_INSTANCE_ERROR;
-
-  nsCOMPtr<nsIPluginHost> pluginHostCOM =
-      do_GetService(MOZ_PLUGIN_HOST_CONTRACTID);
-  nsPluginHost* pluginHost = static_cast<nsPluginHost*>(pluginHostCOM.get());
-  if (!pluginHost) {
-    return NPERR_GENERIC_ERROR;
-  }
-
-  RefPtr<nsNPAPIPluginStreamListener> listener;
-  // Set aCallNotify here to false.  If pluginHost->GetURL or PostURL fail,
-  // the listener's destructor will do the notification while we are about to
-  // return a failure code.
-  // Call SetCallNotify(true) below after we are sure we cannot return a failure
-  // code.
-  if (!target) {
-    inst->NewStreamListener(relativeURL, notifyData, getter_AddRefs(listener));
-    if (listener) {
-      listener->SetCallNotify(false);
-    }
-  }
-
-  switch (type) {
-    case eNPPStreamTypeInternal_Get: {
-      if (NS_FAILED(pluginHost->GetURL(inst, relativeURL, target, listener,
-                                       nullptr, nullptr, false)))
-        return NPERR_GENERIC_ERROR;
-      break;
-    }
-    case eNPPStreamTypeInternal_Post: {
-      if (NS_FAILED(pluginHost->PostURL(inst, relativeURL, len, buf, target,
-                                        listener, nullptr, nullptr, false, 0,
-                                        nullptr)))
-        return NPERR_GENERIC_ERROR;
-      break;
-    }
-    default:
-      NS_ERROR("how'd I get here");
-  }
-
-  if (listener) {
-    // SetCallNotify(bDoNotify) here, see comment above.
-    listener->SetCallNotify(bDoNotify);
-  }
-
-  return NPERR_NO_ERROR;
-}
-
-#if defined(MOZ_MEMORY) && defined(XP_WIN)
-extern "C" size_t malloc_usable_size(const void* ptr);
-#endif
-
-namespace {
-
-static char* gNPPException;
-
-static Document* GetDocumentFromNPP(NPP npp) {
-  NS_ENSURE_TRUE(npp, nullptr);
-
-  nsNPAPIPluginInstance* inst = (nsNPAPIPluginInstance*)npp->ndata;
-  NS_ENSURE_TRUE(inst, nullptr);
-
-  PluginDestructionGuard guard(inst);
-
-  RefPtr<nsPluginInstanceOwner> owner = inst->GetOwner();
-  NS_ENSURE_TRUE(owner, nullptr);
-
-  nsCOMPtr<Document> doc;
-  owner->GetDocument(getter_AddRefs(doc));
-
-  return doc;
-}
-
-static NPIdentifier doGetIdentifier(JSContext* cx, const NPUTF8* name) {
-  NS_ConvertUTF8toUTF16 utf16name(name);
-
-  JSString* str =
-      ::JS_AtomizeAndPinUCStringN(cx, utf16name.get(), utf16name.Length());
-
-  if (!str) return nullptr;
-
-  return StringToNPIdentifier(cx, str);
-}
-
-#if defined(MOZ_MEMORY) && defined(XP_WIN)
-BOOL InHeap(HANDLE hHeap, LPVOID lpMem) {
-  BOOL success = FALSE;
-  PROCESS_HEAP_ENTRY he;
-  he.lpData = nullptr;
-  while (HeapWalk(hHeap, &he) != 0) {
-    if (he.lpData == lpMem) {
-      success = TRUE;
-      break;
-    }
-  }
-  HeapUnlock(hHeap);
-  return success;
-}
-#endif
-
-} /* anonymous namespace */
-
-NPPExceptionAutoHolder::NPPExceptionAutoHolder()
-    : mOldException(gNPPException) {
-  gNPPException = nullptr;
-}
-
-NPPExceptionAutoHolder::~NPPExceptionAutoHolder() {
-  NS_ASSERTION(!gNPPException, "NPP exception not properly cleared!");
-
-  gNPPException = mOldException;
-}
-
-NPP NPPStack::sCurrentNPP = nullptr;
-
-const char* PeekException() { return gNPPException; }
-
-void PopException() {
-  NS_ASSERTION(gNPPException, "Uh, no NPP exception to pop!");
-
-  if (gNPPException) {
-    free(gNPPException);
-
-    gNPPException = nullptr;
-  }
-}
-
-//
-// Static callbacks that get routed back through the new C++ API
-//
-
-namespace mozilla::plugins::parent {
-
-NPError _geturl(NPP npp, const char* relativeURL, const char* target) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_geturl called from the wrong thread\n"));
-    return NPERR_INVALID_PARAM;
-  }
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetURL: npp=%p, target=%s, url=%s\n",
-                                     (void*)npp, target, relativeURL));
-
-  PluginDestructionGuard guard(npp);
-
-  return MakeNewNPAPIStreamInternal(npp, relativeURL, target,
-                                    eNPPStreamTypeInternal_Get);
-}
-
-NPError _geturlnotify(NPP npp, const char* relativeURL, const char* target,
-                      void* notifyData) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_geturlnotify called from the wrong thread\n"));
-    return NPERR_INVALID_PARAM;
-  }
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                 ("NPN_GetURLNotify: npp=%p, target=%s, notify=%p, url=%s\n",
-                  (void*)npp, target, notifyData, relativeURL));
-
-  PluginDestructionGuard guard(npp);
-
-  return MakeNewNPAPIStreamInternal(
-      npp, relativeURL, target, eNPPStreamTypeInternal_Get, true, notifyData);
-}
-
-NPError _posturlnotify(NPP npp, const char* relativeURL, const char* target,
-                       uint32_t len, const char* buf, NPBool file,
-                       void* notifyData) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_posturlnotify called from the wrong thread\n"));
-    return NPERR_INVALID_PARAM;
-  }
-  if (!buf) return NPERR_INVALID_PARAM;
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                 ("NPN_PostURLNotify: npp=%p, target=%s, len=%d, file=%d, "
-                  "notify=%p, url=%s, buf=%s\n",
-                  (void*)npp, target, len, file, notifyData, relativeURL, buf));
-
-  PluginDestructionGuard guard(npp);
-
-  return MakeNewNPAPIStreamInternal(npp, relativeURL, target,
-                                    eNPPStreamTypeInternal_Post, true,
-                                    notifyData, len, buf);
-}
-
-NPError _posturl(NPP npp, const char* relativeURL, const char* target,
-                 uint32_t len, const char* buf, NPBool file) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_posturl called from the wrong thread\n"));
-    return NPERR_INVALID_PARAM;
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                 ("NPN_PostURL: npp=%p, target=%s, file=%d, len=%d, url=%s, "
-                  "buf=%s\n",
-                  (void*)npp, target, file, len, relativeURL, buf));
-
-  PluginDestructionGuard guard(npp);
-
-  return MakeNewNPAPIStreamInternal(npp, relativeURL, target,
-                                    eNPPStreamTypeInternal_Post, false, nullptr,
-                                    len, buf);
-}
-
-void _status(NPP npp, const char* message) {
-  // NPN_Status is no longer supported.
-}
-
-void _memfree(void* ptr) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_memfree called from the wrong thread\n"));
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemFree: ptr=%p\n", ptr));
-
-  if (ptr) free(ptr);
-}
-
-uint32_t _memflush(uint32_t size) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_memflush called from the wrong thread\n"));
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemFlush: size=%d\n", size));
-
-  nsMemory::HeapMinimize(true);
-  return 0;
-}
-
-void _reloadplugins(NPBool reloadPages) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_reloadplugins called from the wrong thread\n"));
-    return;
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                 ("NPN_ReloadPlugins: reloadPages=%d\n", reloadPages));
-
-  nsCOMPtr<nsIPluginHost> pluginHost(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID));
-  if (!pluginHost) return;
-
-  pluginHost->ReloadPlugins();
-}
-
-void _invalidaterect(NPP npp, NPRect* invalidRect) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_invalidaterect called from the wrong thread\n"));
-    return;
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                 ("NPN_InvalidateRect: npp=%p, top=%d, left=%d, bottom=%d, "
-                  "right=%d\n",
-                  (void*)npp, invalidRect->top, invalidRect->left,
-                  invalidRect->bottom, invalidRect->right));
-
-  if (!npp || !npp->ndata) {
-    NS_WARNING("_invalidaterect: npp or npp->ndata == 0");
-    return;
-  }
-
-  nsNPAPIPluginInstance* inst = (nsNPAPIPluginInstance*)npp->ndata;
-
-  PluginDestructionGuard guard(inst);
-
-  inst->InvalidateRect((NPRect*)invalidRect);
-}
-
-void _invalidateregion(NPP npp, NPRegion invalidRegion) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_invalidateregion called from the wrong thread\n"));
-    return;
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                 ("NPN_InvalidateRegion: npp=%p, region=%p\n", (void*)npp,
-                  (void*)invalidRegion));
-
-  if (!npp || !npp->ndata) {
-    NS_WARNING("_invalidateregion: npp or npp->ndata == 0");
-    return;
-  }
-
-  nsNPAPIPluginInstance* inst = (nsNPAPIPluginInstance*)npp->ndata;
-
-  PluginDestructionGuard guard(inst);
-
-  inst->InvalidateRegion((NPRegion)invalidRegion);
-}
-
-void _forceredraw(NPP npp) {}
-
-NPObject* _getwindowobject(NPP npp) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_getwindowobject called from the wrong thread\n"));
-    return nullptr;
-  }
-
-  // The window want to return here is the outer window, *not* the inner (since
-  // we don't know what the plugin will do with it).
-  Document* doc = GetDocumentFromNPP(npp);
-  NS_ENSURE_TRUE(doc, nullptr);
-  nsCOMPtr<nsPIDOMWindowOuter> outer = doc->GetWindow();
-  NS_ENSURE_TRUE(outer, nullptr);
-
-  JS::Rooted<JSObject*> windowProxy(
-      dom::RootingCx(), nsGlobalWindowOuter::Cast(outer)->GetGlobalJSObject());
-  JS::Rooted<JSObject*> global(dom::RootingCx(),
-                               JS::GetNonCCWObjectGlobal(windowProxy));
-  return nsJSObjWrapper::GetNewOrUsed(npp, windowProxy, global);
-}
-
-NPObject* _getpluginelement(NPP npp) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_getpluginelement called from the wrong thread\n"));
-    return nullptr;
-  }
-
-  nsNPAPIPluginInstance* inst = static_cast<nsNPAPIPluginInstance*>(npp->ndata);
-  if (!inst) return nullptr;
-
-  RefPtr<dom::Element> element;
-  inst->GetDOMElement(getter_AddRefs(element));
-
-  if (!element) return nullptr;
-
-  Document* doc = GetDocumentFromNPP(npp);
-  if (NS_WARN_IF(!doc)) {
-    return nullptr;
-  }
-
-  dom::AutoJSAPI jsapi;
-  if (NS_WARN_IF(!jsapi.Init(doc->GetInnerWindow()))) {
-    return nullptr;
-  }
-  JSContext* cx = jsapi.cx();
-
-  nsCOMPtr<nsIXPConnect> xpc(nsIXPConnect::XPConnect());
-  NS_ENSURE_TRUE(xpc, nullptr);
-
-  JS::RootedValue val(cx);
-  if (!ToJSValue(cx, element, &val)) {
-    return nullptr;
-  }
-
-  if (NS_WARN_IF(!val.isObject())) {
-    return nullptr;
-  }
-
-  JS::RootedObject obj(cx, &val.toObject());
-  JS::RootedObject global(cx, JS::CurrentGlobalOrNull(cx));
-  return nsJSObjWrapper::GetNewOrUsed(npp, obj, global);
-}
-
-NPIdentifier _getstringidentifier(const NPUTF8* name) {
-  if (!name) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_getstringidentifier: passed null name"));
-    return nullptr;
-  }
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_getstringidentifier called from the wrong thread\n"));
-  }
-
-  AutoSafeJSContext cx;
-  return doGetIdentifier(cx, name);
-}
-
-void _getstringidentifiers(const NPUTF8** names, int32_t nameCount,
-                           NPIdentifier* identifiers) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_getstringidentifiers called from the wrong thread\n"));
-  }
-
-  AutoSafeJSContext cx;
-
-  for (int32_t i = 0; i < nameCount; ++i) {
-    if (names[i]) {
-      identifiers[i] = doGetIdentifier(cx, names[i]);
-    } else {
-      NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                     ("NPN_getstringidentifiers: passed null name"));
-      identifiers[i] = nullptr;
-    }
-  }
-}
-
-NPIdentifier _getintidentifier(int32_t intid) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_getstringidentifier called from the wrong thread\n"));
-  }
-  return IntToNPIdentifier(intid);
-}
-
-NPUTF8* _utf8fromidentifier(NPIdentifier id) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_utf8fromidentifier called from the wrong thread\n"));
-  }
-  if (!id) return nullptr;
-
-  if (!NPIdentifierIsString(id)) {
-    return nullptr;
-  }
-
-  JSString* str = NPIdentifierToString(id);
-  nsAutoString autoStr;
-  AssignJSLinearString(autoStr, JS_ASSERT_STRING_IS_LINEAR(str));
-
-  return ToNewUTF8String(autoStr);
-}
-
-int32_t _intfromidentifier(NPIdentifier id) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_intfromidentifier called from the wrong thread\n"));
-  }
-
-  if (!NPIdentifierIsInt(id)) {
-    return INT32_MIN;
-  }
-
-  return NPIdentifierToInt(id);
-}
-
-bool _identifierisstring(NPIdentifier id) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_identifierisstring called from the wrong thread\n"));
-  }
-
-  return NPIdentifierIsString(id);
-}
-
-NPObject* _createobject(NPP npp, NPClass* aClass) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_createobject called from the wrong thread\n"));
-    return nullptr;
-  }
-  if (!npp) {
-    NS_ERROR("Null npp passed to _createobject()!");
-
-    return nullptr;
-  }
-
-  PluginDestructionGuard guard(npp);
-
-  if (!aClass) {
-    NS_ERROR("Null class passed to _createobject()!");
-
-    return nullptr;
-  }
-
-  NPPAutoPusher nppPusher(npp);
-
-  NPObject* npobj;
-
-  if (aClass->allocate) {
-    npobj = aClass->allocate(npp, aClass);
-  } else {
-    npobj = (NPObject*)malloc(sizeof(NPObject));
-  }
-
-  if (npobj) {
-    npobj->_class = aClass;
-    npobj->referenceCount = 1;
-    NS_LOG_ADDREF(npobj, 1, "BrowserNPObject", sizeof(NPObject));
-  }
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                 ("Created NPObject %p, NPClass %p\n", npobj, aClass));
-
-  return npobj;
-}
-
-NPObject* _retainobject(NPObject* npobj) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_retainobject called from the wrong thread\n"));
-  }
-  if (npobj) {
-#ifdef NS_BUILD_REFCNT_LOGGING
-    int32_t refCnt =
-#endif
-        PR_ATOMIC_INCREMENT((int32_t*)&npobj->referenceCount);
-    NS_LOG_ADDREF(npobj, refCnt, "BrowserNPObject", sizeof(NPObject));
-  }
-
-  return npobj;
-}
-
-void _releaseobject(NPObject* npobj) {
-  // If nothing is passed, just return, even if we're on the wrong thread.
-  if (!npobj) {
-    return;
-  }
-
-  int32_t refCnt = PR_ATOMIC_DECREMENT((int32_t*)&npobj->referenceCount);
-  NS_LOG_RELEASE(npobj, refCnt, "BrowserNPObject");
-
-  if (refCnt == 0) {
-    nsNPObjWrapper::OnDestroy(npobj);
-
-    NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                   ("Deleting NPObject %p, refcount hit 0\n", npobj));
-
-    if (npobj->_class && npobj->_class->deallocate) {
-      npobj->_class->deallocate(npobj);
-    } else {
-      free(npobj);
-    }
-  }
-}
-
-bool _invoke(NPP npp, NPObject* npobj, NPIdentifier method,
-             const NPVariant* args, uint32_t argCount, NPVariant* result) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_invoke called from the wrong thread\n"));
-    return false;
-  }
-  if (!npp || !npobj || !npobj->_class || !npobj->_class->invoke) return false;
-
-  PluginDestructionGuard guard(npp);
-
-  NPPExceptionAutoHolder nppExceptionHolder;
-  NPPAutoPusher nppPusher(npp);
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                 ("NPN_Invoke(npp %p, npobj %p, method %p, args %d\n", npp,
-                  npobj, method, argCount));
-
-  return npobj->_class->invoke(npobj, method, args, argCount, result);
-}
-
-bool _invokeDefault(NPP npp, NPObject* npobj, const NPVariant* args,
-                    uint32_t argCount, NPVariant* result) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_invokedefault called from the wrong thread\n"));
-    return false;
-  }
-  if (!npp || !npobj || !npobj->_class || !npobj->_class->invokeDefault)
-    return false;
-
-  NPPExceptionAutoHolder nppExceptionHolder;
-  NPPAutoPusher nppPusher(npp);
-
-  NPN_PLUGIN_LOG(
-      PLUGIN_LOG_NOISY,
-      ("NPN_InvokeDefault(npp %p, npobj %p, args %d\n", npp, npobj, argCount));
-
-  return npobj->_class->invokeDefault(npobj, args, argCount, result);
-}
-
-bool _evaluate(NPP npp, NPObject* npobj, NPString* script, NPVariant* result) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_evaluate called from the wrong thread\n"));
-    return false;
-  }
-  if (!npp) return false;
-
-  NPPAutoPusher nppPusher(npp);
-
-  Document* doc = GetDocumentFromNPP(npp);
-  NS_ENSURE_TRUE(doc, false);
-
-  nsGlobalWindowInner* win = nsGlobalWindowInner::Cast(doc->GetInnerWindow());
-  if (NS_WARN_IF(!win || !win->HasJSGlobal())) {
-    return false;
-  }
-
-  nsAutoMicroTask mt;
-  dom::AutoEntryScript aes(win, "NPAPI NPN_evaluate");
-  JSContext* cx = aes.cx();
-
-  JS::Rooted<JSObject*> obj(cx, nsNPObjWrapper::GetNewOrUsed(npp, cx, npobj));
-
-  if (!obj) {
-    return false;
-  }
-
-  obj = js::ToWindowIfWindowProxy(obj);
-  MOZ_ASSERT(obj, "ToWindowIfWindowProxy should never return null");
-
-  if (result) {
-    // Initialize the out param to void
-    VOID_TO_NPVARIANT(*result);
-  }
-
-  if (!script || !script->UTF8Length || !script->UTF8Characters) {
-    // Nothing to evaluate.
-
-    return true;
-  }
-
-  NS_ConvertUTF8toUTF16 utf16script(script->UTF8Characters, script->UTF8Length);
-
-  nsIPrincipal* principal = doc->NodePrincipal();
-
-  nsCString specStr;
-  const char* spec;
-
-  principal->GetAsciiSpec(specStr);
-  spec = specStr.get();
-
-  if (specStr.IsEmpty()) {
-    // No URI in a principal means it's the system principal. If the
-    // document URI is a chrome:// URI, pass that in as the URI of the
-    // script, else pass in null for the filename as there's no way to
-    // know where this document really came from. Passing in null here
-    // also means that the script gets treated by XPConnect as if it
-    // needs additional protection, which is what we want for unknown
-    // chrome code anyways.
-    nsCOMPtr<nsIURI> uri = doc->GetDocumentURI();
-    if (uri && uri->SchemeIs("chrome")) {
-      uri->GetSpec(specStr);
-      spec = specStr.get();
-    } else {
-      spec = nullptr;
-    }
-  }
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                 ("NPN_Evaluate(npp %p, npobj %p, script <<<%s>>>) called\n",
-                  npp, npobj, script->UTF8Characters));
-
-  JS::CompileOptions options(cx);
-  options.setFileAndLine(spec, 0);
-  JS::Rooted<JS::Value> rval(cx);
-  JS::RootedVector<JSObject*> scopeChain(cx);
-  if (!JS_IsGlobalObject(obj) && !scopeChain.append(obj)) {
-    return false;
-  }
-  // nsNPObjWrapper::GetNewOrUsed returns an object in the current compartment
-  // of the JSContext (it might be a CCW).
-  MOZ_RELEASE_ASSERT(JS::GetCompartment(obj) == js::GetContextCompartment(cx),
-                     "nsNPObjWrapper::GetNewOrUsed must wrap its return value");
-  obj = JS::CurrentGlobalOrNull(cx);
-  MOZ_ASSERT(obj);
-  nsresult rv = NS_OK;
-  {
-    JSExecutionContext exec(cx, obj);
-    exec.SetScopeChain(scopeChain);
-    exec.Compile(options, utf16script);
-    rv = exec.ExecScript(&rval);
-  }
-
-  if (!JS_WrapValue(cx, &rval)) {
-    return false;
-  }
-
-  return NS_SUCCEEDED(rv) &&
-         (!result || JSValToNPVariant(npp, cx, rval, result));
-}
-
-bool _getproperty(NPP npp, NPObject* npobj, NPIdentifier property,
-                  NPVariant* result) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_getproperty called from the wrong thread\n"));
-    return false;
-  }
-  if (!npp || !npobj || !npobj->_class || !npobj->_class->getProperty)
-    return false;
-
-  NPPExceptionAutoHolder nppExceptionHolder;
-  NPPAutoPusher nppPusher(npp);
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                 ("NPN_GetProperty(npp %p, npobj %p, property %p) called\n",
-                  npp, npobj, property));
-
-  if (!npobj->_class->getProperty(npobj, property, result)) return false;
-
-  return true;
-}
-
-bool _setproperty(NPP npp, NPObject* npobj, NPIdentifier property,
-                  const NPVariant* value) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_setproperty called from the wrong thread\n"));
-    return false;
-  }
-  if (!npp || !npobj || !npobj->_class || !npobj->_class->setProperty)
-    return false;
-
-  NPPExceptionAutoHolder nppExceptionHolder;
-  NPPAutoPusher nppPusher(npp);
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                 ("NPN_SetProperty(npp %p, npobj %p, property %p) called\n",
-                  npp, npobj, property));
-
-  return npobj->_class->setProperty(npobj, property, value);
-}
-
-bool _removeproperty(NPP npp, NPObject* npobj, NPIdentifier property) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_removeproperty called from the wrong thread\n"));
-    return false;
-  }
-  if (!npp || !npobj || !npobj->_class || !npobj->_class->removeProperty)
-    return false;
-
-  NPPExceptionAutoHolder nppExceptionHolder;
-  NPPAutoPusher nppPusher(npp);
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                 ("NPN_RemoveProperty(npp %p, npobj %p, property %p) called\n",
-                  npp, npobj, property));
-
-  return npobj->_class->removeProperty(npobj, property);
-}
-
-bool _hasproperty(NPP npp, NPObject* npobj, NPIdentifier propertyName) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_hasproperty called from the wrong thread\n"));
-    return false;
-  }
-  if (!npp || !npobj || !npobj->_class || !npobj->_class->hasProperty)
-    return false;
-
-  NPPExceptionAutoHolder nppExceptionHolder;
-  NPPAutoPusher nppPusher(npp);
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                 ("NPN_HasProperty(npp %p, npobj %p, property %p) called\n",
-                  npp, npobj, propertyName));
-
-  return npobj->_class->hasProperty(npobj, propertyName);
-}
-
-bool _hasmethod(NPP npp, NPObject* npobj, NPIdentifier methodName) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_hasmethod called from the wrong thread\n"));
-    return false;
-  }
-  if (!npp || !npobj || !npobj->_class || !npobj->_class->hasMethod)
-    return false;
-
-  NPPExceptionAutoHolder nppExceptionHolder;
-  NPPAutoPusher nppPusher(npp);
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                 ("NPN_HasMethod(npp %p, npobj %p, property %p) called\n", npp,
-                  npobj, methodName));
-
-  return npobj->_class->hasMethod(npobj, methodName);
-}
-
-bool _enumerate(NPP npp, NPObject* npobj, NPIdentifier** identifier,
-                uint32_t* count) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_enumerate called from the wrong thread\n"));
-    return false;
-  }
-  if (!npp || !npobj || !npobj->_class) return false;
-
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
-                 ("NPN_Enumerate(npp %p, npobj %p) called\n", npp, npobj));
-
-  if (!NP_CLASS_STRUCT_VERSION_HAS_ENUM(npobj->_class) ||
-      !npobj->_class->enumerate) {
-    *identifier = 0;
-    *count = 0;
-    return true;
-  }
-
-  NPPExceptionAutoHolder nppExceptionHolder;
-  NPPAutoPusher nppPusher(npp);
-
-  return npobj->_class->enumerate(npobj, identifier, count);
-}
-
-bool _construct(NPP npp, NPObject* npobj, const NPVariant* args,
-                uint32_t argCount, NPVariant* result) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_construct called from the wrong thread\n"));
-    return false;
-  }
-  if (!npp || !npobj || !npobj->_class ||
-      !NP_CLASS_STRUCT_VERSION_HAS_CTOR(npobj->_class) ||
-      !npobj->_class->construct) {
-    return false;
-  }
-
-  NPPExceptionAutoHolder nppExceptionHolder;
-  NPPAutoPusher nppPusher(npp);
-
-  return npobj->_class->construct(npobj, args, argCount, result);
-}
-
-void _releasevariantvalue(NPVariant* variant) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_releasevariantvalue called from the wrong thread\n"));
-  }
-  switch (variant->type) {
-    case NPVariantType_Void:
-    case NPVariantType_Null:
-    case NPVariantType_Bool:
-    case NPVariantType_Int32:
-    case NPVariantType_Double:
-      break;
-    case NPVariantType_String: {
-      const NPString* s = &NPVARIANT_TO_STRING(*variant);
-
-      if (s->UTF8Characters) {
-#if defined(MOZ_MEMORY) && defined(XP_WIN)
-        if (malloc_usable_size((void*)s->UTF8Characters) != 0) {
-          free((void*)s->UTF8Characters);
-        } else {
-          void* p = (void*)s->UTF8Characters;
-          DWORD nheaps = 0;
-          AutoTArray<HANDLE, 50> heaps;
-          nheaps = GetProcessHeaps(0, heaps.Elements());
-          heaps.AppendElements(nheaps);
-          GetProcessHeaps(nheaps, heaps.Elements());
-          for (DWORD i = 0; i < nheaps; i++) {
-            if (InHeap(heaps[i], p)) {
-              HeapFree(heaps[i], 0, p);
-              break;
-            }
-          }
-        }
-#else
-        free((void*)s->UTF8Characters);
-#endif
-      }
-      break;
-    }
-    case NPVariantType_Object: {
-      NPObject* npobj = NPVARIANT_TO_OBJECT(*variant);
-
-      if (npobj) _releaseobject(npobj);
-
-      break;
-    }
-    default:
-      NS_ERROR("Unknown NPVariant type!");
-  }
-
-  VOID_TO_NPVARIANT(*variant);
-}
-
-void _setexception(NPObject* npobj, const NPUTF8* message) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_setexception called from the wrong thread\n"));
-    return;
-  }
-
-  if (!message) return;
-
-  if (gNPPException) {
-    // If a plugin throws multiple exceptions, we'll only report the
-    // last one for now.
-    free(gNPPException);
-  }
-
-  gNPPException = strdup(message);
-}
-
-NPError _getvalue(NPP npp, NPNVariable variable, void* result) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_getvalue called from the wrong thread\n"));
-    return NPERR_INVALID_PARAM;
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                 ("NPN_GetValue: npp=%p, var=%d\n", (void*)npp, (int)variable));
-
-  nsresult res;
-
-  PluginDestructionGuard guard(npp);
-
-  // Cast NPNVariable enum to int to avoid warnings about including switch
-  // cases for android_npapi.h's non-standard ANPInterface values.
-  switch (static_cast<int>(variable)) {
-#if defined(XP_UNIX) && !defined(XP_MACOSX)
-    case NPNVxDisplay: {
-#  if defined(MOZ_X11)
-      if (npp) {
-        nsNPAPIPluginInstance* inst = (nsNPAPIPluginInstance*)npp->ndata;
-        bool windowless = false;
-        inst->IsWindowless(&windowless);
-        // The documentation on the types for many variables in NP(N|P)_GetValue
-        // is vague.  Often boolean values are NPBool (1 byte), but
-        // https://developer.mozilla.org/en/XEmbed_Extension_for_Mozilla_Plugins
-        // treats NPPVpluginNeedsXEmbed as PRBool (int), and
-        // on x86/32-bit, flash stores to this using |movl 0x1,&needsXEmbed|.
-        // thus we can't use NPBool for needsXEmbed, or the three bytes above
-        // it on the stack would get clobbered. so protect with the larger bool.
-        int needsXEmbed = 0;
-        if (!windowless) {
-          res = inst->GetValueFromPlugin(NPPVpluginNeedsXEmbed, &needsXEmbed);
-          // If the call returned an error code make sure we still use our
-          // default value.
-          if (NS_FAILED(res)) {
-            needsXEmbed = 0;
-          }
-        }
-        if (windowless || needsXEmbed) {
-          (*(Display**)result) = mozilla::DefaultXDisplay();
-          return NPERR_NO_ERROR;
-        }
-      }
-#  endif
-      return NPERR_GENERIC_ERROR;
-    }
-
-    case NPNVxtAppContext:
-      return NPERR_GENERIC_ERROR;
-#endif
-
-#if defined(XP_WIN) || defined(MOZ_WIDGET_GTK)
-    case NPNVnetscapeWindow: {
-      if (!npp || !npp->ndata) return NPERR_INVALID_INSTANCE_ERROR;
-
-      nsNPAPIPluginInstance* inst = (nsNPAPIPluginInstance*)npp->ndata;
-
-      RefPtr<nsPluginInstanceOwner> owner = inst->GetOwner();
-      NS_ENSURE_TRUE(owner, NPERR_NO_ERROR);
-
-      if (NS_SUCCEEDED(owner->GetNetscapeWindow(result))) {
-        return NPERR_NO_ERROR;
-      }
-      return NPERR_GENERIC_ERROR;
-    }
-#endif
-
-    case NPNVjavascriptEnabledBool: {
-      *(NPBool*)result = false;
-      bool js = false;
-      res = Preferences::GetBool("javascript.enabled", &js);
-      if (NS_SUCCEEDED(res)) {
-        *(NPBool*)result = js;
-      }
-      return NPERR_NO_ERROR;
-    }
-
-    case NPNVasdEnabledBool:
-      *(NPBool*)result = false;
-      return NPERR_NO_ERROR;
-
-    case NPNVisOfflineBool: {
-      bool offline = false;
-      nsCOMPtr<nsIIOService> ioservice =
-          do_GetService(NS_IOSERVICE_CONTRACTID, &res);
-      if (NS_SUCCEEDED(res)) res = ioservice->GetOffline(&offline);
-      if (NS_FAILED(res)) return NPERR_GENERIC_ERROR;
-
-      *(NPBool*)result = offline;
-      return NPERR_NO_ERROR;
-    }
-
-    case NPNVToolkit: {
-#ifdef MOZ_WIDGET_GTK
-      *((NPNToolkitType*)result) = NPNVGtk2;
-#endif
-
-      if (*(NPNToolkitType*)result) return NPERR_NO_ERROR;
-
-      return NPERR_GENERIC_ERROR;
-    }
-
-    case NPNVSupportsXEmbedBool: {
-#ifdef MOZ_WIDGET_GTK
-      *(NPBool*)result = true;
-#else
-      *(NPBool*)result = false;
-#endif
-      return NPERR_NO_ERROR;
-    }
-
-    case NPNVWindowNPObject: {
-      *(NPObject**)result = _getwindowobject(npp);
-
-      return *(NPObject**)result ? NPERR_NO_ERROR : NPERR_GENERIC_ERROR;
-    }
-
-    case NPNVPluginElementNPObject: {
-      *(NPObject**)result = _getpluginelement(npp);
-
-      return *(NPObject**)result ? NPERR_NO_ERROR : NPERR_GENERIC_ERROR;
-    }
-
-    case NPNVSupportsWindowless: {
-#if defined(XP_WIN) || defined(XP_MACOSX) || \
-    (defined(MOZ_X11) && defined(MOZ_WIDGET_GTK))
-      *(NPBool*)result = true;
-#else
-      *(NPBool*)result = false;
-#endif
-      return NPERR_NO_ERROR;
-    }
-
-    case NPNVprivateModeBool: {
-      bool privacy;
-      nsNPAPIPluginInstance* inst =
-          static_cast<nsNPAPIPluginInstance*>(npp->ndata);
-      if (!inst) return NPERR_GENERIC_ERROR;
-
-      nsresult rv = inst->IsPrivateBrowsing(&privacy);
-      if (NS_FAILED(rv)) return NPERR_GENERIC_ERROR;
-      *(NPBool*)result = (NPBool)privacy;
-      return NPERR_NO_ERROR;
-    }
-
-    case NPNVdocumentOrigin: {
-      nsNPAPIPluginInstance* inst = (nsNPAPIPluginInstance*)npp->ndata;
-      if (!inst) {
-        return NPERR_GENERIC_ERROR;
-      }
-
-      RefPtr<dom::Element> element;
-      inst->GetDOMElement(getter_AddRefs(element));
-      if (!element) {
-        return NPERR_GENERIC_ERROR;
-      }
-
-      nsIPrincipal* principal = element->NodePrincipal();
-
-      nsAutoString utf16Origin;
-      res = nsContentUtils::GetUTFOrigin(principal, utf16Origin);
-      if (NS_FAILED(res)) {
-        return NPERR_GENERIC_ERROR;
-      }
-
-      nsCOMPtr<nsIIDNService> idnService =
-          do_GetService(NS_IDNSERVICE_CONTRACTID);
-      if (!idnService) {
-        return NPERR_GENERIC_ERROR;
-      }
-
-      // This is a bit messy: we convert to UTF-8 here, but then
-      // nsIDNService::Normalize will convert back to UTF-16 for processing,
-      // and back to UTF-8 again to return the result.
-      // Alternative: perhaps we should add a NormalizeUTF16 version of the API,
-      // and just convert to UTF-8 for the final return (resulting in one
-      // encoding form conversion instead of three).
-      NS_ConvertUTF16toUTF8 utf8Origin(utf16Origin);
-      nsAutoCString normalizedUTF8Origin;
-      res = idnService->Normalize(utf8Origin, normalizedUTF8Origin);
-      if (NS_FAILED(res)) {
-        return NPERR_GENERIC_ERROR;
-      }
-
-      *(char**)result = ToNewCString(normalizedUTF8Origin);
-      return *(char**)result ? NPERR_NO_ERROR : NPERR_GENERIC_ERROR;
-    }
-
-#ifdef XP_MACOSX
-    case NPNVpluginDrawingModel: {
-      if (npp) {
-        nsNPAPIPluginInstance* inst = (nsNPAPIPluginInstance*)npp->ndata;
-        if (inst) {
-          NPDrawingModel drawingModel;
-          inst->GetDrawingModel((int32_t*)&drawingModel);
-          *(NPDrawingModel*)result = drawingModel;
-          return NPERR_NO_ERROR;
-        }
-      }
-      return NPERR_GENERIC_ERROR;
-    }
-
-#  ifndef NP_NO_QUICKDRAW
-    case NPNVsupportsQuickDrawBool: {
-      *(NPBool*)result = false;
-
-      return NPERR_NO_ERROR;
-    }
-#  endif
-
-    case NPNVsupportsCoreGraphicsBool: {
-      *(NPBool*)result = true;
-
-      return NPERR_NO_ERROR;
-    }
-
-    case NPNVsupportsCoreAnimationBool: {
-      *(NPBool*)result = true;
-
-      return NPERR_NO_ERROR;
-    }
-
-    case NPNVsupportsInvalidatingCoreAnimationBool: {
-      *(NPBool*)result = true;
-
-      return NPERR_NO_ERROR;
-    }
-
-    case NPNVsupportsCompositingCoreAnimationPluginsBool: {
-      *(NPBool*)result = PR_TRUE;
-
-      return NPERR_NO_ERROR;
-    }
-
-#  ifndef NP_NO_CARBON
-    case NPNVsupportsCarbonBool: {
-      *(NPBool*)result = false;
-
-      return NPERR_NO_ERROR;
-    }
-#  endif
-    case NPNVsupportsCocoaBool: {
-      *(NPBool*)result = true;
-
-      return NPERR_NO_ERROR;
-    }
-
-    case NPNVsupportsUpdatedCocoaTextInputBool: {
-      *(NPBool*)result = true;
-      return NPERR_NO_ERROR;
-    }
-#endif
-
-#if defined(XP_MACOSX) || defined(XP_WIN)
-    case NPNVcontentsScaleFactor: {
-      nsNPAPIPluginInstance* inst =
-          (nsNPAPIPluginInstance*)(npp ? npp->ndata : nullptr);
-      double scaleFactor = inst ? inst->GetContentsScaleFactor() : 1.0;
-      *(double*)result = scaleFactor;
-      return NPERR_NO_ERROR;
-    }
-#endif
-
-    case NPNVCSSZoomFactor: {
-      nsNPAPIPluginInstance* inst =
-          (nsNPAPIPluginInstance*)(npp ? npp->ndata : nullptr);
-      double scaleFactor = inst ? inst->GetCSSZoomFactor() : 1.0;
-      *(double*)result = scaleFactor;
-      return NPERR_NO_ERROR;
-    }
-
-    // we no longer hand out any XPCOM objects
-    case NPNVDOMElement:
-    case NPNVDOMWindow:
-    case NPNVserviceManager:
-      // old XPCOM objects, no longer supported, but null out the out
-      // param to avoid crashing plugins that still try to use this.
-      *(nsISupports**)result = nullptr;
-      [[fallthrough]];
-
-    default:
-      NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                     ("NPN_getvalue unhandled get value: %d\n", variable));
-      return NPERR_GENERIC_ERROR;
-  }
-}
-
-NPError _setvalue(NPP npp, NPPVariable variable, void* result) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_setvalue called from the wrong thread\n"));
-    return NPERR_INVALID_PARAM;
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                 ("NPN_SetValue: npp=%p, var=%d\n", (void*)npp, (int)variable));
-
-  if (!npp) return NPERR_INVALID_INSTANCE_ERROR;
-
-  nsNPAPIPluginInstance* inst = (nsNPAPIPluginInstance*)npp->ndata;
-
-  NS_ASSERTION(inst, "null instance");
-
-  if (!inst) return NPERR_INVALID_INSTANCE_ERROR;
-
-  PluginDestructionGuard guard(inst);
-
-  // Cast NPNVariable enum to int to avoid warnings about including switch
-  // cases for android_npapi.h's non-standard ANPInterface values.
-  switch (static_cast<int>(variable)) {
-    // we should keep backward compatibility with NPAPI where the
-    // actual pointer value is checked rather than its content
-    // when passing booleans
-    case NPPVpluginWindowBool: {
-#ifdef XP_MACOSX
-      // This setting doesn't apply to OS X (only to Windows and Unix/Linux).
-      // See https://developer.mozilla.org/En/NPN_SetValue#section_5.  Return
-      // NPERR_NO_ERROR here to conform to other browsers' behavior on OS X
-      // (e.g. Safari and Opera).
-      return NPERR_NO_ERROR;
-#else
-      NPBool bWindowless = (result == nullptr);
-      return inst->SetWindowless(bWindowless);
-#endif
-    }
-    case NPPVpluginTransparentBool: {
-      NPBool bTransparent = (result != nullptr);
-      return inst->SetTransparent(bTransparent);
-    }
-
-    case NPPVjavascriptPushCallerBool: {
-      return NPERR_NO_ERROR;
-    }
-
-    case NPPVpluginKeepLibraryInMemory: {
-      NPBool bCached = (result != nullptr);
-      inst->SetCached(bCached);
-      return NPERR_NO_ERROR;
-    }
-
-    case NPPVpluginUsesDOMForCursorBool: {
-      bool useDOMForCursor = (result != nullptr);
-      return inst->SetUsesDOMForCursor(useDOMForCursor);
-    }
-
-    case NPPVpluginIsPlayingAudio: {
-      const bool isPlaying = result;
-
-      nsNPAPIPluginInstance* inst = (nsNPAPIPluginInstance*)npp->ndata;
-      MOZ_ASSERT(inst);
-
-      if (!isPlaying && !inst->HasAudioChannelAgent()) {
-        return NPERR_NO_ERROR;
-      }
-
-      if (isPlaying) {
-        inst->NotifyStartedPlaying();
-      } else {
-        inst->NotifyStoppedPlaying();
-      }
-
-      return NPERR_NO_ERROR;
-    }
-
-    case NPPVpluginDrawingModel: {
-      if (inst) {
-        inst->SetDrawingModel((NPDrawingModel)NS_PTR_TO_INT32(result));
-        return NPERR_NO_ERROR;
-      }
-      return NPERR_GENERIC_ERROR;
-    }
-
-#ifdef XP_MACOSX
-    case NPPVpluginEventModel: {
-      if (inst) {
-        inst->SetEventModel((NPEventModel)NS_PTR_TO_INT32(result));
-        return NPERR_NO_ERROR;
-      } else {
-        return NPERR_GENERIC_ERROR;
-      }
-    }
-#endif
-    default:
-      return NPERR_GENERIC_ERROR;
-  }
-}
-
-NPError _requestread(NPStream* pstream, NPByteRange* rangeList) {
-  return NPERR_STREAM_NOT_SEEKABLE;
-}
-
-// Deprecated, only stubbed out
-void* /* OJI type: JRIEnv* */
-_getJavaEnv() {
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetJavaEnv\n"));
-  return nullptr;
-}
-
-const char* _useragent(NPP npp) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_useragent called from the wrong thread\n"));
-    return nullptr;
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_UserAgent: npp=%p\n", (void*)npp));
-
-  nsCOMPtr<nsIPluginHost> pluginHostCOM(
-      do_GetService(MOZ_PLUGIN_HOST_CONTRACTID));
-  nsPluginHost* pluginHost = static_cast<nsPluginHost*>(pluginHostCOM.get());
-  if (!pluginHost) {
-    return nullptr;
-  }
-
-  const char* retstr;
-  nsresult rv = pluginHost->UserAgent(&retstr);
-  if (NS_FAILED(rv)) return nullptr;
-
-  return retstr;
-}
-
-void* _memalloc(uint32_t size) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                   ("NPN_memalloc called from the wrong thread\n"));
-  }
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY, ("NPN_MemAlloc: size=%d\n", size));
-  return moz_xmalloc(size);
-}
-
-// Deprecated, only stubbed out
-void* /* OJI type: jref */
-_getJavaPeer(NPP npp) {
-  NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetJavaPeer: npp=%p\n", (void*)npp));
-  return nullptr;
-}
-
-void _pushpopupsenabledstate(NPP npp, NPBool enabled) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(
-        PLUGIN_LOG_ALWAYS,
-        ("NPN_pushpopupsenabledstate called from the wrong thread\n"));
-    return;
-  }
-  nsNPAPIPluginInstance* inst =
-      npp ? (nsNPAPIPluginInstance*)npp->ndata : nullptr;
-  if (!inst) return;
-
-  inst->PushPopupsEnabledState(enabled);
-}
-
-void _poppopupsenabledstate(NPP npp) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(
-        PLUGIN_LOG_ALWAYS,
-        ("NPN_poppopupsenabledstate called from the wrong thread\n"));
-    return;
-  }
-  nsNPAPIPluginInstance* inst =
-      npp ? (nsNPAPIPluginInstance*)npp->ndata : nullptr;
-  if (!inst) return;
-
-  inst->PopPopupsEnabledState();
-}
-
-NPError _getvalueforurl(NPP instance, NPNURLVariable variable, const char* url,
-                        char** value, uint32_t* len) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_getvalueforurl called from the wrong thread\n"));
-    return NPERR_GENERIC_ERROR;
-  }
-
-  if (!instance) {
-    return NPERR_INVALID_PARAM;
-  }
-
-  if (!url || !*url || !len) {
-    return NPERR_INVALID_URL;
-  }
-
-  *len = 0;
-
-  switch (variable) {
-    case NPNURLVProxy:
-      // NPNURLVProxy is no longer supported.
-      *value = nullptr;
-      return NPERR_GENERIC_ERROR;
-
-    case NPNURLVCookie:
-      // NPNURLVCookie is no longer supported.
-      *value = nullptr;
-      return NPERR_GENERIC_ERROR;
-
-    default:
-        // Fall through and return an error...
-        ;
-  }
-
-  return NPERR_GENERIC_ERROR;
-}
-
-NPError _setvalueforurl(NPP instance, NPNURLVariable variable, const char* url,
-                        const char* value, uint32_t len) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_setvalueforurl called from the wrong thread\n"));
-    return NPERR_GENERIC_ERROR;
-  }
-
-  if (!instance) {
-    return NPERR_INVALID_PARAM;
-  }
-
-  if (!url || !*url) {
-    return NPERR_INVALID_URL;
-  }
-
-  switch (variable) {
-    case NPNURLVCookie:
-      // NPNURLVCookie is no longer supported.
-      return NPERR_GENERIC_ERROR;
-
-    case NPNURLVProxy:
-      // We don't support setting proxy values, fall through...
-    default:
-        // Fall through and return an error...
-        ;
-  }
-
-  return NPERR_GENERIC_ERROR;
-}
-
-uint32_t _scheduletimer(NPP instance, uint32_t interval, NPBool repeat,
-                        PluginTimerFunc timerFunc) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_scheduletimer called from the wrong thread\n"));
-    return 0;
-  }
-
-  nsNPAPIPluginInstance* inst = (nsNPAPIPluginInstance*)instance->ndata;
-  if (!inst) return 0;
-
-  return inst->ScheduleTimer(interval, repeat, timerFunc);
-}
-
-void _unscheduletimer(NPP instance, uint32_t timerID) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_unscheduletimer called from the wrong thread\n"));
-    return;
-  }
-
-  nsNPAPIPluginInstance* inst = (nsNPAPIPluginInstance*)instance->ndata;
-  if (!inst) return;
-
-  inst->UnscheduleTimer(timerID);
-}
-
-NPError _popupcontextmenu(NPP instance, NPMenu* menu) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_popupcontextmenu called from the wrong thread\n"));
-    return 0;
-  }
-
-#ifdef MOZ_WIDGET_COCOA
-  nsNPAPIPluginInstance* inst = (nsNPAPIPluginInstance*)instance->ndata;
-
-  double pluginX, pluginY;
-  double screenX, screenY;
-
-  const NPCocoaEvent* currentEvent =
-      static_cast<NPCocoaEvent*>(inst->GetCurrentEvent());
-  if (!currentEvent) {
-    return NPERR_GENERIC_ERROR;
-  }
-
-  // Ensure that the events has an x/y value.
-  if (currentEvent->type != NPCocoaEventMouseDown &&
-      currentEvent->type != NPCocoaEventMouseUp &&
-      currentEvent->type != NPCocoaEventMouseMoved &&
-      currentEvent->type != NPCocoaEventMouseEntered &&
-      currentEvent->type != NPCocoaEventMouseExited &&
-      currentEvent->type != NPCocoaEventMouseDragged) {
-    return NPERR_GENERIC_ERROR;
-  }
-
-  pluginX = currentEvent->data.mouse.pluginX;
-  pluginY = currentEvent->data.mouse.pluginY;
-
-  if ((pluginX < 0.0) || (pluginY < 0.0)) return NPERR_GENERIC_ERROR;
-
-  NPBool success =
-      _convertpoint(instance, pluginX, pluginY, NPCoordinateSpacePlugin,
-                    &screenX, &screenY, NPCoordinateSpaceScreen);
-
-  if (success) {
-    return mozilla::plugins::PluginUtilsOSX::ShowCocoaContextMenu(
-        menu, screenX, screenY, nullptr, nullptr);
-  } else {
-    NS_WARNING("Convertpoint failed, could not created contextmenu.");
-    return NPERR_GENERIC_ERROR;
-  }
-#else
-  NS_WARNING("Not supported on this platform!");
-  return NPERR_GENERIC_ERROR;
-#endif
-}
-
-NPBool _convertpoint(NPP instance, double sourceX, double sourceY,
-                     NPCoordinateSpace sourceSpace, double* destX,
-                     double* destY, NPCoordinateSpace destSpace) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_convertpoint called from the wrong thread\n"));
-    return 0;
-  }
-
-  nsNPAPIPluginInstance* inst = (nsNPAPIPluginInstance*)instance->ndata;
-  if (!inst) return false;
-
-  return inst->ConvertPoint(sourceX, sourceY, sourceSpace, destX, destY,
-                            destSpace);
-}
-
-void _urlredirectresponse(NPP instance, void* notifyData, NPBool allow) {
-  if (!NS_IsMainThread()) {
-    NPN_PLUGIN_LOG(PLUGIN_LOG_ALWAYS,
-                   ("NPN_convertpoint called from the wrong thread\n"));
-    return;
-  }
-
-  nsNPAPIPluginInstance* inst = (nsNPAPIPluginInstance*)instance->ndata;
-  if (!inst) {
-    return;
-  }
-
-  inst->URLRedirectResponse(notifyData, allow);
-}
-
-NPError _initasyncsurface(NPP instance, NPSize* size, NPImageFormat format,
-                          void* initData, NPAsyncSurface* surface) {
-  nsNPAPIPluginInstance* inst = (nsNPAPIPluginInstance*)instance->ndata;
-  if (!inst) {
-    return NPERR_GENERIC_ERROR;
-  }
-
-  return inst->InitAsyncSurface(size, format, initData, surface);
-}
-
-NPError _finalizeasyncsurface(NPP instance, NPAsyncSurface* surface) {
-  nsNPAPIPluginInstance* inst = (nsNPAPIPluginInstance*)instance->ndata;
-  if (!inst) {
-    return NPERR_GENERIC_ERROR;
-  }
-
-  return inst->FinalizeAsyncSurface(surface);
-}
-
-void _setcurrentasyncsurface(NPP instance, NPAsyncSurface* surface,
-                             NPRect* changed) {
-  nsNPAPIPluginInstance* inst = (nsNPAPIPluginInstance*)instance->ndata;
-  if (!inst) {
-    return;
-  }
-
-  inst->SetCurrentAsyncSurface(surface, changed);
-}
-
-}  // namespace mozilla::plugins::parent
diff --git a/dom/plugins/base/nsNPAPIPlugin.h b/dom/plugins/base/nsNPAPIPlugin.h
deleted file mode 100644
index ebc0404932567..0000000000000
--- a/dom/plugins/base/nsNPAPIPlugin.h
+++ /dev/null
@@ -1,288 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef nsNPAPIPlugin_h_
-#define nsNPAPIPlugin_h_
-
-#include "prlink.h"
-#include "npfunctions.h"
-#include "nsPluginHost.h"
-
-#include "mozilla/dom/ScriptSettings.h"
-#include "mozilla/PluginLibrary.h"
-#include "mozilla/RefCounted.h"
-
-// nsNPAPIPlugin is held alive both by active nsPluginTag instances and
-// by active nsNPAPIPluginInstance.
-class nsNPAPIPlugin final {
- private:
-  typedef mozilla::PluginLibrary PluginLibrary;
-
- public:
-  nsNPAPIPlugin();
-
-  NS_INLINE_DECL_REFCOUNTING(nsNPAPIPlugin)
-
-  // Constructs and initializes an nsNPAPIPlugin object. A nullptr file path
-  // will prevent this from calling NP_Initialize.
-  static nsresult CreatePlugin(nsPluginTag* aPluginTag,
-                               nsNPAPIPlugin** aResult);
-
-  PluginLibrary* GetLibrary();
-  // PluginFuncs() can't fail but results are only valid if GetLibrary()
-  // succeeds
-  NPPluginFuncs* PluginFuncs();
-
-#if defined(XP_MACOSX) && !defined(__LP64__)
-  void SetPluginRefNum(short aRefNum);
-#endif
-
-  // The IPC mechanism notifies the nsNPAPIPlugin if the plugin
-  // crashes and is no longer usable. pluginDumpID is the ID of the minidump
-  // that was written, or empty if no minidump was written.
-  void PluginCrashed(const nsAString& aPluginDumpID,
-                     const nsACString& aAdditionalMinidumps);
-
-  nsresult Shutdown();
-
-  static nsresult RetainStream(NPStream* pstream, nsISupports** aRetainedPeer);
-
- private:
-  ~nsNPAPIPlugin();
-
-  NPPluginFuncs mPluginFuncs;
-  PluginLibrary* mLibrary;
-};
-
-namespace mozilla {
-namespace plugins {
-namespace parent {
-
-static_assert(sizeof(NPIdentifier) == sizeof(jsid),
-              "NPIdentifier must be binary compatible with jsid.");
-
-inline jsid NPIdentifierToJSId(NPIdentifier id) {
-  jsid tmp;
-  JSID_BITS(tmp) = (size_t)id;
-  return tmp;
-}
-
-inline NPIdentifier JSIdToNPIdentifier(jsid id) {
-  return (NPIdentifier)JSID_BITS(id);
-}
-
-inline bool NPIdentifierIsString(NPIdentifier id) {
-  return JSID_IS_STRING(NPIdentifierToJSId(id));
-}
-
-inline JSString* NPIdentifierToString(NPIdentifier id) {
-  return JSID_TO_STRING(NPIdentifierToJSId(id));
-}
-
-inline NPIdentifier StringToNPIdentifier(JSContext* cx, JSString* str) {
-  return JSIdToNPIdentifier(JS::PropertyKey::fromPinnedString(str));
-}
-
-inline bool NPIdentifierIsInt(NPIdentifier id) {
-  return JSID_IS_INT(NPIdentifierToJSId(id));
-}
-
-inline int NPIdentifierToInt(NPIdentifier id) {
-  return JSID_TO_INT(NPIdentifierToJSId(id));
-}
-
-inline NPIdentifier IntToNPIdentifier(int i) {
-  return JSIdToNPIdentifier(INT_TO_JSID(i));
-}
-
-JSContext* GetJSContext(NPP npp);
-
-inline bool NPStringIdentifierIsPermanent(NPIdentifier id) {
-  AutoSafeJSContext cx;
-  return JS_StringHasBeenPinned(cx, NPIdentifierToString(id));
-}
-
-#define NPIdentifier_VOID (JSIdToNPIdentifier(JSID_VOID))
-
-NPObject* _getwindowobject(NPP npp);
-
-NPObject* _getpluginelement(NPP npp);
-
-NPIdentifier _getstringidentifier(const NPUTF8* name);
-
-void _getstringidentifiers(const NPUTF8** names, int32_t nameCount,
-                           NPIdentifier* identifiers);
-
-bool _identifierisstring(NPIdentifier identifiers);
-
-NPIdentifier _getintidentifier(int32_t intid);
-
-NPUTF8* _utf8fromidentifier(NPIdentifier identifier);
-
-int32_t _intfromidentifier(NPIdentifier identifier);
-
-NPObject* _createobject(NPP npp, NPClass* aClass);
-
-NPObject* _retainobject(NPObject* npobj);
-
-void _releaseobject(NPObject* npobj);
-
-bool _invoke(NPP npp, NPObject* npobj, NPIdentifier method,
-             const NPVariant* args, uint32_t argCount, NPVariant* result);
-
-bool _invokeDefault(NPP npp, NPObject* npobj, const NPVariant* args,
-                    uint32_t argCount, NPVariant* result);
-
-bool _evaluate(NPP npp, NPObject* npobj, NPString* script, NPVariant* result);
-
-bool _getproperty(NPP npp, NPObject* npobj, NPIdentifier property,
-                  NPVariant* result);
-
-bool _setproperty(NPP npp, NPObject* npobj, NPIdentifier property,
-                  const NPVariant* value);
-
-bool _removeproperty(NPP npp, NPObject* npobj, NPIdentifier property);
-
-bool _hasproperty(NPP npp, NPObject* npobj, NPIdentifier propertyName);
-
-bool _hasmethod(NPP npp, NPObject* npobj, NPIdentifier methodName);
-
-bool _enumerate(NPP npp, NPObject* npobj, NPIdentifier** identifier,
-                uint32_t* count);
-
-bool _construct(NPP npp, NPObject* npobj, const NPVariant* args,
-                uint32_t argCount, NPVariant* result);
-
-void _releasevariantvalue(NPVariant* variant);
-
-void _setexception(NPObject* npobj, const NPUTF8* message);
-
-void _pushpopupsenabledstate(NPP npp, NPBool enabled);
-
-void _poppopupsenabledstate(NPP npp);
-
-NPError _getvalueforurl(NPP instance, NPNURLVariable variable, const char* url,
-                        char** value, uint32_t* len);
-
-NPError _setvalueforurl(NPP instance, NPNURLVariable variable, const char* url,
-                        const char* value, uint32_t len);
-
-typedef void (*PluginTimerFunc)(NPP npp, uint32_t timerID);
-
-uint32_t _scheduletimer(NPP instance, uint32_t interval, NPBool repeat,
-                        PluginTimerFunc timerFunc);
-
-void _unscheduletimer(NPP instance, uint32_t timerID);
-
-NPError _popupcontextmenu(NPP instance, NPMenu* menu);
-
-NPBool _convertpoint(NPP instance, double sourceX, double sourceY,
-                     NPCoordinateSpace sourceSpace, double* destX,
-                     double* destY, NPCoordinateSpace destSpace);
-
-NPError _requestread(NPStream* pstream, NPByteRange* rangeList);
-
-NPError _geturlnotify(NPP npp, const char* relativeURL, const char* target,
-                      void* notifyData);
-
-NPError _getvalue(NPP npp, NPNVariable variable, void* r_value);
-
-NPError _setvalue(NPP npp, NPPVariable variable, void* r_value);
-
-NPError _geturl(NPP npp, const char* relativeURL, const char* target);
-
-NPError _posturlnotify(NPP npp, const char* relativeURL, const char* target,
-                       uint32_t len, const char* buf, NPBool file,
-                       void* notifyData);
-
-NPError _posturl(NPP npp, const char* relativeURL, const char* target,
-                 uint32_t len, const char* buf, NPBool file);
-
-void _status(NPP npp, const char* message);
-
-void _memfree(void* ptr);
-
-uint32_t _memflush(uint32_t size);
-
-void _reloadplugins(NPBool reloadPages);
-
-void _invalidaterect(NPP npp, NPRect* invalidRect);
-
-void _invalidateregion(NPP npp, NPRegion invalidRegion);
-
-void _forceredraw(NPP npp);
-
-const char* _useragent(NPP npp);
-
-void* _memalloc(uint32_t size);
-
-// Deprecated entry points for the old Java plugin.
-void* /* OJI type: JRIEnv* */
-_getJavaEnv();
-
-void* /* OJI type: jref */
-_getJavaPeer(NPP npp);
-
-void _urlredirectresponse(NPP instance, void* notifyData, NPBool allow);
-
-NPError _initasyncsurface(NPP instance, NPSize* size, NPImageFormat format,
-                          void* initData, NPAsyncSurface* surface);
-
-NPError _finalizeasyncsurface(NPP instance, NPAsyncSurface* surface);
-
-void _setcurrentasyncsurface(NPP instance, NPAsyncSurface* surface,
-                             NPRect* changed);
-
-} /* namespace parent */
-} /* namespace plugins */
-} /* namespace mozilla */
-
-const char* PeekException();
-
-void PopException();
-
-class NPPStack {
- public:
-  static NPP Peek() { return sCurrentNPP; }
-
- protected:
-  static NPP sCurrentNPP;
-};
-
-// XXXjst: The NPPAutoPusher stack is a bit redundant now that
-// PluginDestructionGuard exists, and could thus be replaced by code
-// that uses the PluginDestructionGuard list of plugins on the
-// stack. But they're not identical, and to minimize code changes
-// we're keeping both for the moment, and making NPPAutoPusher inherit
-// the PluginDestructionGuard class to avoid having to keep two
-// separate objects on the stack since we always want a
-// PluginDestructionGuard where we use an NPPAutoPusher.
-
-class MOZ_STACK_CLASS NPPAutoPusher : public NPPStack,
-                                      protected PluginDestructionGuard {
- public:
-  explicit NPPAutoPusher(NPP aNpp)
-      : PluginDestructionGuard(aNpp), mOldNPP(sCurrentNPP) {
-    NS_ASSERTION(aNpp, "Uh, null aNpp passed to NPPAutoPusher!");
-
-    sCurrentNPP = aNpp;
-  }
-
-  ~NPPAutoPusher() { sCurrentNPP = mOldNPP; }
-
- private:
-  NPP mOldNPP;
-};
-
-class NPPExceptionAutoHolder {
- public:
-  NPPExceptionAutoHolder();
-  ~NPPExceptionAutoHolder();
-
- protected:
-  char* mOldException;
-};
-
-#endif  // nsNPAPIPlugin_h_
diff --git a/dom/plugins/base/nsNPAPIPluginInstance.cpp b/dom/plugins/base/nsNPAPIPluginInstance.cpp
index dddf9b0124b5d..451ac227cd852 100644
--- a/dom/plugins/base/nsNPAPIPluginInstance.cpp
+++ b/dom/plugins/base/nsNPAPIPluginInstance.cpp
@@ -10,12 +10,9 @@
 #include "prenv.h"
 
 #include "nsNPAPIPluginInstance.h"
-#include "nsNPAPIPlugin.h"
-#include "nsNPAPIPluginStreamListener.h"
 #include "nsPluginHost.h"
 #include "nsPluginLogging.h"
 #include "nsContentUtils.h"
-#include "nsPluginInstanceOwner.h"
 
 #include "nsThreadUtils.h"
 #include "mozilla/dom/Document.h"
@@ -23,8 +20,6 @@
 #include "nsIScriptGlobalObject.h"
 #include "nsIScriptContext.h"
 #include "nsDirectoryServiceDefs.h"
-#include "nsJSNPRuntime.h"
-#include "nsPluginStreamListenerPeer.h"
 #include "nsSize.h"
 #include "nsNetCID.h"
 #include "nsIContent.h"
@@ -41,7 +36,6 @@ using namespace mozilla;
 using namespace mozilla::dom;
 
 using namespace mozilla;
-using namespace mozilla::plugins::parent;
 using namespace mozilla::layers;
 
 NS_IMPL_ISUPPORTS(nsNPAPIPluginInstance, nsIAudioChannelAgentCallback)
@@ -54,9 +48,7 @@ nsNPAPIPluginInstance::nsNPAPIPluginInstance()
       mCached(false),
       mUsesDOMForCursor(false),
       mInPluginInitCall(false),
-      mPlugin(nullptr),
-      mMIMEType(nullptr),
-      mOwner(nullptr)
+      mMIMEType(nullptr)
 #ifdef XP_MACOSX
       ,
       mCurrentPluginEvent(nullptr)
@@ -106,395 +98,37 @@ uint32_t nsNPAPIPluginInstance::gInUnsafePluginCalls = 0;
 
 void nsNPAPIPluginInstance::Destroy() {
   Stop();
-  mPlugin = nullptr;
   mAudioChannelAgent = nullptr;
 }
 
 TimeStamp nsNPAPIPluginInstance::StopTime() { return mStopTime; }
 
-nsresult nsNPAPIPluginInstance::Initialize(nsNPAPIPlugin* aPlugin,
-                                           nsPluginInstanceOwner* aOwner,
-                                           const nsACString& aMIMEType) {
-  AUTO_PROFILER_LABEL("nsNPAPIPlugin::Initialize", OTHER);
-  PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-             ("nsNPAPIPluginInstance::Initialize this=%p\n", this));
-
-  NS_ENSURE_ARG_POINTER(aPlugin);
-  NS_ENSURE_ARG_POINTER(aOwner);
-
-  mPlugin = aPlugin;
-  mOwner = aOwner;
-
-  if (!aMIMEType.IsEmpty()) {
-    mMIMEType = ToNewCString(aMIMEType);
-  }
-
-  return Start();
-}
-
-nsresult nsNPAPIPluginInstance::Stop() {
-  PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-             ("nsNPAPIPluginInstance::Stop this=%p\n", this));
-
-  // Make sure the plugin didn't leave popups enabled.
-  if (mPopupStates.Length() > 0) {
-    PopupBlocker::PopPopupControlState(PopupBlocker::openAbused);
-  }
-
-  if (RUNNING != mRunning) {
-    return NS_OK;
-  }
-
-  // clean up all outstanding timers
-  for (uint32_t i = mTimers.Length(); i > 0; i--)
-    UnscheduleTimer(mTimers[i - 1]->id);
-
-  // If there's code from this plugin instance on the stack, delay the
-  // destroy.
-  if (PluginDestructionGuard::DelayDestroy(this)) {
-    return NS_OK;
-  }
-
-  mRunning = DESTROYING;
-  mStopTime = TimeStamp::Now();
-
-  // clean up open streams
-  while (mStreamListeners.Length() > 0) {
-    RefPtr<nsNPAPIPluginStreamListener> currentListener(mStreamListeners[0]);
-    currentListener->CleanUpStream(NPRES_USER_BREAK);
-    mStreamListeners.RemoveElement(currentListener);
-  }
-
-  if (!mPlugin || !mPlugin->GetLibrary()) return NS_ERROR_FAILURE;
-
-  NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
-
-  NPError error = NPERR_GENERIC_ERROR;
-  if (pluginFunctions->destroy) {
-    NPSavedData* sdata = 0;
-
-    NS_TRY_SAFE_CALL_RETURN(error, (*pluginFunctions->destroy)(&mNPP, &sdata),
-                            this, NS_PLUGIN_CALL_UNSAFE_TO_REENTER_GECKO);
-
-    NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                   ("NPP Destroy called: this=%p, npp=%p, return=%d\n", this,
-                    &mNPP, error));
-  }
-  mRunning = DESTROYED;
-
-  nsJSNPRuntime::OnPluginDestroy(&mNPP);
-
-  if (error != NPERR_NO_ERROR)
-    return NS_ERROR_FAILURE;
-  else
-    return NS_OK;
-}
+nsresult nsNPAPIPluginInstance::Stop() { return NS_ERROR_FAILURE; }
 
 already_AddRefed<nsPIDOMWindowOuter> nsNPAPIPluginInstance::GetDOMWindow() {
-  if (!mOwner) return nullptr;
-
-  RefPtr<nsPluginInstanceOwner> kungFuDeathGrip(mOwner);
-
-  nsCOMPtr<Document> doc;
-  kungFuDeathGrip->GetDocument(getter_AddRefs(doc));
-  if (!doc) return nullptr;
-
-  RefPtr<nsPIDOMWindowOuter> window = doc->GetWindow();
-
-  return window.forget();
-}
-
-nsresult nsNPAPIPluginInstance::GetTagType(nsPluginTagType* result) {
-  if (!mOwner) {
-    return NS_ERROR_FAILURE;
-  }
-
-  return mOwner->GetTagType(result);
-}
-
-nsTArray<nsNPAPIPluginStreamListener*>*
-nsNPAPIPluginInstance::StreamListeners() {
-  return &mStreamListeners;
-}
-
-nsTArray<nsPluginStreamListenerPeer*>*
-nsNPAPIPluginInstance::FileCachedStreamListeners() {
-  return &mFileCachedStreamListeners;
+  return nullptr;
 }
 
-nsresult nsNPAPIPluginInstance::Start() {
-  if (mRunning == RUNNING) {
-    return NS_OK;
-  }
-
-  if (!mOwner) {
-    MOZ_ASSERT(false, "Should not be calling Start() on unowned plugin.");
-    return NS_ERROR_FAILURE;
-  }
-
-  PluginDestructionGuard guard(this);
-
-  nsTArray<MozPluginParameter> attributes;
-  nsTArray<MozPluginParameter> params;
-
-  nsPluginTagType tagtype;
-  nsresult rv = GetTagType(&tagtype);
-  if (NS_SUCCEEDED(rv)) {
-    mOwner->GetAttributes(attributes);
-    mOwner->GetParameters(params);
-  } else {
-    MOZ_ASSERT(false, "Failed to get tag type.");
-  }
-
-  mCachedParamLength = attributes.Length() + 1 + params.Length();
-
-  // We add an extra entry "PARAM" as a separator between the attribute
-  // and param values, but we don't count it if there are no <param> entries.
-  // Legacy behavior quirk.
-  uint32_t quirkParamLength =
-      params.Length() ? mCachedParamLength : attributes.Length();
-
-  mCachedParamNames = (char**)moz_xmalloc(sizeof(char*) * mCachedParamLength);
-  mCachedParamValues = (char**)moz_xmalloc(sizeof(char*) * mCachedParamLength);
-
-  for (uint32_t i = 0; i < attributes.Length(); i++) {
-    mCachedParamNames[i] = ToNewUTF8String(attributes[i].mName);
-    mCachedParamValues[i] = ToNewUTF8String(attributes[i].mValue);
-  }
-
-  mCachedParamNames[attributes.Length()] = ToNewUTF8String(u"PARAM"_ns);
-  mCachedParamValues[attributes.Length()] = nullptr;
-
-  for (uint32_t i = 0, pos = attributes.Length() + 1; i < params.Length();
-       i++) {
-    mCachedParamNames[pos] = ToNewUTF8String(params[i].mName);
-    mCachedParamValues[pos] = ToNewUTF8String(params[i].mValue);
-    pos++;
-  }
-
-  const char* mimetype;
-  NPError error = NPERR_GENERIC_ERROR;
-
-  GetMIMEType(&mimetype);
-
-  bool oldVal = mInPluginInitCall;
-  mInPluginInitCall = true;
-
-  // Need this on the stack before calling NPP_New otherwise some callbacks that
-  // the plugin may make could fail (NPN_HasProperty, for example).
-  NPPAutoPusher autopush(&mNPP);
-
-  if (!mPlugin) return NS_ERROR_FAILURE;
-
-  PluginLibrary* library = mPlugin->GetLibrary();
-  if (!library) return NS_ERROR_FAILURE;
-
-  // Mark this instance as running before calling NPP_New because the plugin may
-  // call other NPAPI functions, like NPN_GetURLNotify, that assume this is set
-  // before returning. If the plugin returns failure, we'll clear it out below.
-  mRunning = RUNNING;
-
-  nsresult newResult =
-      library->NPP_New((char*)mimetype, &mNPP, quirkParamLength,
-                       mCachedParamNames, mCachedParamValues, nullptr, &error);
-  mInPluginInitCall = oldVal;
-
-  NPP_PLUGIN_LOG(
-      PLUGIN_LOG_NORMAL,
-      ("NPP New called: this=%p, npp=%p, mime=%s, argc=%d, return=%d\n", this,
-       &mNPP, mimetype, quirkParamLength, error));
-
-  if (NS_FAILED(newResult) || error != NPERR_NO_ERROR) {
-    mRunning = DESTROYED;
-    nsJSNPRuntime::OnPluginDestroy(&mNPP);
-    return NS_ERROR_FAILURE;
-  }
-
-  return newResult;
-}
+nsresult nsNPAPIPluginInstance::Start() { return NS_ERROR_FAILURE; }
 
 nsresult nsNPAPIPluginInstance::SetWindow(NPWindow* window) {
-  // NPAPI plugins don't want a SetWindow(nullptr).
-  if (!window || RUNNING != mRunning) return NS_OK;
-
-#if MOZ_WIDGET_GTK
-  // bug 108347, flash plugin on linux doesn't like window->width <= 0
-  return NS_OK;
-#endif
-
-  if (!mPlugin || !mPlugin->GetLibrary()) return NS_ERROR_FAILURE;
-
-  NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
-
-  if (pluginFunctions->setwindow) {
-    PluginDestructionGuard guard(this);
-
-    // XXX Turns out that NPPluginWindow and NPWindow are structurally
-    // identical (on purpose!), so there's no need to make a copy.
-
-    PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-               ("nsNPAPIPluginInstance::SetWindow (about to call it) this=%p\n",
-                this));
-
-    bool oldVal = mInPluginInitCall;
-    mInPluginInitCall = true;
-
-    NPPAutoPusher nppPusher(&mNPP);
-
-    NPError error;
-    NS_TRY_SAFE_CALL_RETURN(
-        error, (*pluginFunctions->setwindow)(&mNPP, (NPWindow*)window), this,
-        NS_PLUGIN_CALL_UNSAFE_TO_REENTER_GECKO);
-    // 'error' is only used if this is a logging-enabled build.
-    // That is somewhat complex to check, so we just use "unused"
-    // to suppress any compiler warnings in build configurations
-    // where the logging is a no-op.
-    mozilla::Unused << error;
-
-    mInPluginInitCall = oldVal;
-
-    NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                   ("NPP SetWindow called: this=%p, [x=%d,y=%d,w=%d,h=%d], "
-                    "clip[t=%d,b=%d,l=%d,r=%d], return=%d\n",
-                    this, window->x, window->y, window->width, window->height,
-                    window->clipRect.top, window->clipRect.bottom,
-                    window->clipRect.left, window->clipRect.right, error));
-  }
-  return NS_OK;
-}
-
-nsresult nsNPAPIPluginInstance::NewStreamListener(
-    const char* aURL, void* notifyData,
-    nsNPAPIPluginStreamListener** listener) {
-  RefPtr<nsNPAPIPluginStreamListener> sl =
-      new nsNPAPIPluginStreamListener(this, notifyData, aURL);
-
-  mStreamListeners.AppendElement(sl);
-
-  sl.forget(listener);
-
-  return NS_OK;
+  return NS_ERROR_FAILURE;
 }
 
 nsresult nsNPAPIPluginInstance::Print(NPPrint* platformPrint) {
-  NS_ENSURE_TRUE(platformPrint, NS_ERROR_NULL_POINTER);
-
-  PluginDestructionGuard guard(this);
-
-  if (!mPlugin || !mPlugin->GetLibrary()) return NS_ERROR_FAILURE;
-
-  NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
-
-  NPPrint* thePrint = (NPPrint*)platformPrint;
-
-  // to be compatible with the older SDK versions and to match what
-  // NPAPI and other browsers do, overwrite |window.type| field with one
-  // more copy of |platformPrint|. See bug 113264
-  uint16_t sdkmajorversion = (pluginFunctions->version & 0xff00) >> 8;
-  uint16_t sdkminorversion = pluginFunctions->version & 0x00ff;
-  if ((sdkmajorversion == 0) && (sdkminorversion < 11)) {
-    // Let's copy platformPrint bytes over to where it was supposed to be
-    // in older versions -- four bytes towards the beginning of the struct
-    // but we should be careful about possible misalignments
-    if (sizeof(NPWindowType) >= sizeof(void*)) {
-      void* source = thePrint->print.embedPrint.platformPrint;
-      void** destination = (void**)&(thePrint->print.embedPrint.window.type);
-      *destination = source;
-    } else {
-      NS_ERROR("Incompatible OS for assignment");
-    }
-  }
-
-  if (pluginFunctions->print)
-    NS_TRY_SAFE_CALL_VOID((*pluginFunctions->print)(&mNPP, thePrint), this,
-                          NS_PLUGIN_CALL_UNSAFE_TO_REENTER_GECKO);
-
-  NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                 ("NPP PrintProc called: this=%p, pDC=%p, "
-                  "[x=%d,y=%d,w=%d,h=%d], clip[t=%d,b=%d,l=%d,r=%d]\n",
-                  this, platformPrint->print.embedPrint.platformPrint,
-                  platformPrint->print.embedPrint.window.x,
-                  platformPrint->print.embedPrint.window.y,
-                  platformPrint->print.embedPrint.window.width,
-                  platformPrint->print.embedPrint.window.height,
-                  platformPrint->print.embedPrint.window.clipRect.top,
-                  platformPrint->print.embedPrint.window.clipRect.bottom,
-                  platformPrint->print.embedPrint.window.clipRect.left,
-                  platformPrint->print.embedPrint.window.clipRect.right));
-
-  return NS_OK;
+  return NS_ERROR_FAILURE;
 }
 
 nsresult nsNPAPIPluginInstance::HandleEvent(
     void* event, int16_t* result, NSPluginCallReentry aSafeToReenterGecko) {
-  if (RUNNING != mRunning) return NS_OK;
-
-  AUTO_PROFILER_LABEL("nsNPAPIPluginInstance::HandleEvent", OTHER);
-
-  if (!event) return NS_ERROR_FAILURE;
-
-  PluginDestructionGuard guard(this);
-
-  if (!mPlugin || !mPlugin->GetLibrary()) return NS_ERROR_FAILURE;
-
-  NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
-
-  int16_t tmpResult = kNPEventNotHandled;
-
-  if (pluginFunctions->event) {
-#ifdef XP_MACOSX
-    mCurrentPluginEvent = event;
-#endif
-#if defined(XP_WIN)
-    NS_TRY_SAFE_CALL_RETURN(tmpResult, (*pluginFunctions->event)(&mNPP, event),
-                            this, aSafeToReenterGecko);
-#else
-    tmpResult = (*pluginFunctions->event)(&mNPP, event);
-#endif
-    NPP_PLUGIN_LOG(
-        PLUGIN_LOG_NOISY,
-        ("NPP HandleEvent called: this=%p, npp=%p, event=%p, return=%d\n", this,
-         &mNPP, event, tmpResult));
-
-    if (result) *result = tmpResult;
-#ifdef XP_MACOSX
-    mCurrentPluginEvent = nullptr;
-#endif
-  }
-
-  return NS_OK;
+  return NS_ERROR_FAILURE;
 }
 
 nsresult nsNPAPIPluginInstance::GetValueFromPlugin(NPPVariable variable,
                                                    void* value) {
-  if (!mPlugin || !mPlugin->GetLibrary()) return NS_ERROR_FAILURE;
-
-  NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
-
-  nsresult rv = NS_ERROR_FAILURE;
-
-  if (pluginFunctions->getvalue && RUNNING == mRunning) {
-    PluginDestructionGuard guard(this);
-
-    NPError pluginError = NPERR_GENERIC_ERROR;
-    NS_TRY_SAFE_CALL_RETURN(
-        pluginError, (*pluginFunctions->getvalue)(&mNPP, variable, value), this,
-        NS_PLUGIN_CALL_UNSAFE_TO_REENTER_GECKO);
-    NPP_PLUGIN_LOG(
-        PLUGIN_LOG_NORMAL,
-        ("NPP GetValue called: this=%p, npp=%p, var=%d, value=%p, return=%d\n",
-         this, &mNPP, variable, value, pluginError));
-
-    if (pluginError == NPERR_NO_ERROR) {
-      rv = NS_OK;
-    }
-  }
-
-  return rv;
+  return NS_ERROR_FAILURE;
 }
 
-nsNPAPIPlugin* nsNPAPIPluginInstance::GetPlugin() { return mPlugin; }
-
 nsresult nsNPAPIPluginInstance::GetNPP(NPP* aNPP) {
   if (aNPP)
     *aNPP = &mNPP;
@@ -525,18 +159,10 @@ void nsNPAPIPluginInstance::SetDrawingModel(NPDrawingModel aModel) {
   mDrawingModel = aModel;
 }
 
-void nsNPAPIPluginInstance::RedrawPlugin() { mOwner->RedrawPlugin(); }
+void nsNPAPIPluginInstance::RedrawPlugin() {}
 
 #if defined(XP_MACOSX)
-void nsNPAPIPluginInstance::SetEventModel(NPEventModel aModel) {
-  // the event model needs to be set for the object frame immediately
-  if (!mOwner) {
-    NS_WARNING("Trying to set event model without a plugin instance owner!");
-    return;
-  }
-
-  mOwner->SetEventModel(aModel);
-}
+void nsNPAPIPluginInstance::SetEventModel(NPEventModel aModel) {}
 #endif
 
 nsresult nsNPAPIPluginInstance::GetDrawingModel(int32_t* aModel) {
@@ -545,69 +171,21 @@ nsresult nsNPAPIPluginInstance::GetDrawingModel(int32_t* aModel) {
 }
 
 nsresult nsNPAPIPluginInstance::IsRemoteDrawingCoreAnimation(bool* aDrawing) {
-#ifdef XP_MACOSX
-  if (!mPlugin) return NS_ERROR_FAILURE;
-
-  PluginLibrary* library = mPlugin->GetLibrary();
-  if (!library) return NS_ERROR_FAILURE;
-
-  return library->IsRemoteDrawingCoreAnimation(&mNPP, aDrawing);
-#else
   return NS_ERROR_FAILURE;
-#endif
 }
 
 nsresult nsNPAPIPluginInstance::ContentsScaleFactorChanged(
     double aContentsScaleFactor) {
-#if defined(XP_MACOSX) || defined(XP_WIN)
-  if (!mPlugin) return NS_ERROR_FAILURE;
-
-  PluginLibrary* library = mPlugin->GetLibrary();
-  if (!library) return NS_ERROR_FAILURE;
-
-  // We only need to call this if the plugin is running OOP.
-  if (!library->IsOOP()) return NS_OK;
-
-  return library->ContentsScaleFactorChanged(&mNPP, aContentsScaleFactor);
-#else
   return NS_ERROR_FAILURE;
-#endif
 }
 
 nsresult nsNPAPIPluginInstance::CSSZoomFactorChanged(float aCSSZoomFactor) {
-  if (RUNNING != mRunning) return NS_OK;
-
-  PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance informing plugin of "
-                                 "CSS Zoom Factor change this=%p\n",
-                                 this));
-
-  if (!mPlugin || !mPlugin->GetLibrary()) return NS_ERROR_FAILURE;
-
-  NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
-
-  if (!pluginFunctions->setvalue) return NS_ERROR_FAILURE;
-
-  PluginDestructionGuard guard(this);
-
-  NPError error;
-  double value = static_cast<double>(aCSSZoomFactor);
-  NS_TRY_SAFE_CALL_RETURN(
-      error, (*pluginFunctions->setvalue)(&mNPP, NPNVCSSZoomFactor, &value),
-      this, NS_PLUGIN_CALL_UNSAFE_TO_REENTER_GECKO);
-  return (error == NPERR_NO_ERROR) ? NS_OK : NS_ERROR_FAILURE;
+  return NS_ERROR_FAILURE;
 }
 
 nsresult nsNPAPIPluginInstance::GetJSObject(JSContext* cx,
                                             JSObject** outObject) {
-  NPObject* npobj = nullptr;
-  nsresult rv = GetValueFromPlugin(NPPVpluginScriptableNPObject, &npobj);
-  if (NS_FAILED(rv) || !npobj) return NS_ERROR_FAILURE;
-
-  *outObject = nsNPObjWrapper::GetNewOrUsed(&mNPP, cx, npobj);
-
-  _releaseobject(npobj);
-
-  return NS_OK;
+  return NS_ERROR_FAILURE;
 }
 
 void nsNPAPIPluginInstance::SetCached(bool aCache) { mCached = aCache; }
@@ -624,109 +202,62 @@ nsresult nsNPAPIPluginInstance::IsWindowless(bool* isWindowless) {
   return NS_OK;
 }
 
-class MOZ_STACK_CLASS AutoPluginLibraryCall {
- public:
-  explicit AutoPluginLibraryCall(nsNPAPIPluginInstance* aThis)
-      : mThis(aThis), mGuard(aThis), mLibrary(nullptr) {
-    nsNPAPIPlugin* plugin = mThis->GetPlugin();
-    if (plugin) mLibrary = plugin->GetLibrary();
-  }
-  explicit operator bool() { return !!mLibrary; }
-  PluginLibrary* operator->() { return mLibrary; }
-
- private:
-  nsNPAPIPluginInstance* mThis;
-  PluginDestructionGuard mGuard;
-  PluginLibrary* mLibrary;
-};
-
 nsresult nsNPAPIPluginInstance::AsyncSetWindow(NPWindow* window) {
-  if (RUNNING != mRunning) return NS_OK;
-
-  AutoPluginLibraryCall library(this);
-  if (!library) return NS_ERROR_FAILURE;
-
-  return library->AsyncSetWindow(&mNPP, window);
+  return NS_ERROR_FAILURE;
 }
 
 nsresult nsNPAPIPluginInstance::GetImageContainer(ImageContainer** aContainer) {
-  *aContainer = nullptr;
-
-  if (RUNNING != mRunning) return NS_OK;
-
-  AutoPluginLibraryCall library(this);
-  return !library ? NS_ERROR_FAILURE
-                  : library->GetImageContainer(&mNPP, aContainer);
+  return NS_ERROR_FAILURE;
 }
 
 nsresult nsNPAPIPluginInstance::GetImageSize(nsIntSize* aSize) {
-  *aSize = nsIntSize(0, 0);
-
-  if (RUNNING != mRunning) return NS_OK;
-
-  AutoPluginLibraryCall library(this);
-  return !library ? NS_ERROR_FAILURE : library->GetImageSize(&mNPP, aSize);
+  return NS_ERROR_FAILURE;
 }
 
 #if defined(XP_WIN)
 nsresult nsNPAPIPluginInstance::GetScrollCaptureContainer(
     ImageContainer** aContainer) {
-  *aContainer = nullptr;
-
-  if (RUNNING != mRunning) return NS_OK;
-
-  AutoPluginLibraryCall library(this);
-  return !library ? NS_ERROR_FAILURE
-                  : library->GetScrollCaptureContainer(&mNPP, aContainer);
+  return NS_ERROR_FAILURE;
 }
 #endif
 
-void nsNPAPIPluginInstance::DidComposite() {
-  if (RUNNING != mRunning) return;
+nsresult nsNPAPIPluginInstance::HandledWindowedPluginKeyEvent(
+    const NativeEventData& aKeyEventData, bool aIsConsumed) {
+  if (NS_WARN_IF(!mPlugin)) {
+    return NS_ERROR_FAILURE;
+  }
 
-  AutoPluginLibraryCall library(this);
-  library->DidComposite(&mNPP);
+  PluginLibrary* library = mPlugin->GetLibrary();
+  if (NS_WARN_IF(!library)) {
+    return NS_ERROR_FAILURE;
+  }
+  return library->HandledWindowedPluginKeyEvent(&mNPP, aKeyEventData,
+                                                aIsConsumed);
+  return NS_ERROR_FAILURE;
 }
 
+void nsNPAPIPluginInstance::DidComposite() {}
+
 nsresult nsNPAPIPluginInstance::NotifyPainted(void) {
   MOZ_ASSERT_UNREACHABLE("Dead code, shouldn't be called.");
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 nsresult nsNPAPIPluginInstance::GetIsOOP(bool* aIsAsync) {
-  AutoPluginLibraryCall library(this);
-  if (!library) return NS_ERROR_FAILURE;
-
-  *aIsAsync = library->IsOOP();
-  return NS_OK;
+  return NS_ERROR_FAILURE;
 }
 
 nsresult nsNPAPIPluginInstance::SetBackgroundUnknown() {
-  if (RUNNING != mRunning) return NS_OK;
-
-  AutoPluginLibraryCall library(this);
-  if (!library) return NS_ERROR_FAILURE;
-
-  return library->SetBackgroundUnknown(&mNPP);
+  return NS_ERROR_FAILURE;
 }
 
 nsresult nsNPAPIPluginInstance::BeginUpdateBackground(
     nsIntRect* aRect, DrawTarget** aDrawTarget) {
-  if (RUNNING != mRunning) return NS_OK;
-
-  AutoPluginLibraryCall library(this);
-  if (!library) return NS_ERROR_FAILURE;
-
-  return library->BeginUpdateBackground(&mNPP, *aRect, aDrawTarget);
+  return NS_ERROR_FAILURE;
 }
 
 nsresult nsNPAPIPluginInstance::EndUpdateBackground(nsIntRect* aRect) {
-  if (RUNNING != mRunning) return NS_OK;
-
-  AutoPluginLibraryCall library(this);
-  if (!library) return NS_ERROR_FAILURE;
-
-  return library->EndUpdateBackground(&mNPP, *aRect);
+  return NS_ERROR_FAILURE;
 }
 
 nsresult nsNPAPIPluginInstance::IsTransparent(bool* isTransparent) {
@@ -781,56 +312,15 @@ nsresult nsNPAPIPluginInstance::PopPopupsEnabledState() {
 }
 
 nsresult nsNPAPIPluginInstance::GetPluginAPIVersion(uint16_t* version) {
-  NS_ENSURE_ARG_POINTER(version);
-
-  if (!mPlugin) return NS_ERROR_FAILURE;
-
-  if (!mPlugin->GetLibrary()) return NS_ERROR_FAILURE;
-
-  NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
-
-  *version = pluginFunctions->version;
-
-  return NS_OK;
+  return NS_ERROR_FAILURE;
 }
 
 nsresult nsNPAPIPluginInstance::PrivateModeStateChanged(bool enabled) {
-  if (RUNNING != mRunning) return NS_OK;
-
-  PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance informing plugin of "
-                                 "private mode state change this=%p\n",
-                                 this));
-
-  if (!mPlugin || !mPlugin->GetLibrary()) return NS_ERROR_FAILURE;
-
-  NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
-
-  if (!pluginFunctions->setvalue) return NS_ERROR_FAILURE;
-
-  PluginDestructionGuard guard(this);
-
-  NPError error;
-  NPBool value = static_cast<NPBool>(enabled);
-  NS_TRY_SAFE_CALL_RETURN(
-      error, (*pluginFunctions->setvalue)(&mNPP, NPNVprivateModeBool, &value),
-      this, NS_PLUGIN_CALL_UNSAFE_TO_REENTER_GECKO);
-  return (error == NPERR_NO_ERROR) ? NS_OK : NS_ERROR_FAILURE;
+  return NS_ERROR_FAILURE;
 }
 
 nsresult nsNPAPIPluginInstance::IsPrivateBrowsing(bool* aEnabled) {
-  if (!mOwner) return NS_ERROR_FAILURE;
-
-  nsCOMPtr<Document> doc;
-  mOwner->GetDocument(getter_AddRefs(doc));
-  NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
-
-  nsCOMPtr<nsPIDOMWindowOuter> domwindow = doc->GetWindow();
-  NS_ENSURE_TRUE(domwindow, NS_ERROR_FAILURE);
-
-  nsCOMPtr<nsIDocShell> docShell = domwindow->GetDocShell();
-  nsCOMPtr<nsILoadContext> loadContext = do_QueryInterface(docShell);
-  *aEnabled = (loadContext && loadContext->UsePrivateBrowsing());
-  return NS_OK;
+  return NS_ERROR_FAILURE;
 }
 
 static void PluginTimerCallback(nsITimer* aTimer, void* aClosure) {
@@ -932,37 +422,19 @@ NPBool nsNPAPIPluginInstance::ConvertPoint(double sourceX, double sourceY,
                                            NPCoordinateSpace sourceSpace,
                                            double* destX, double* destY,
                                            NPCoordinateSpace destSpace) {
-  if (mOwner) {
-    return mOwner->ConvertPoint(sourceX, sourceY, sourceSpace, destX, destY,
-                                destSpace);
-  }
-
   return false;
 }
 
 nsresult nsNPAPIPluginInstance::GetDOMElement(Element** result) {
-  if (!mOwner) {
-    *result = nullptr;
-    return NS_ERROR_FAILURE;
-  }
-
-  return mOwner->GetDOMElement(result);
+  return NS_ERROR_FAILURE;
 }
 
 nsresult nsNPAPIPluginInstance::InvalidateRect(NPRect* invalidRect) {
-  if (RUNNING != mRunning) return NS_OK;
-
-  if (!mOwner) return NS_ERROR_FAILURE;
-
-  return mOwner->InvalidateRect(invalidRect);
+  return NS_ERROR_FAILURE;
 }
 
 nsresult nsNPAPIPluginInstance::InvalidateRegion(NPRegion invalidRegion) {
-  if (RUNNING != mRunning) return NS_OK;
-
-  if (!mOwner) return NS_ERROR_FAILURE;
-
-  return mOwner->InvalidateRegion(invalidRegion);
+  return NS_ERROR_FAILURE;
 }
 
 nsresult nsNPAPIPluginInstance::GetMIMEType(const char** result) {
@@ -974,88 +446,33 @@ nsresult nsNPAPIPluginInstance::GetMIMEType(const char** result) {
   return NS_OK;
 }
 
-nsPluginInstanceOwner* nsNPAPIPluginInstance::GetOwner() { return mOwner; }
-
-void nsNPAPIPluginInstance::SetOwner(nsPluginInstanceOwner* aOwner) {
-  mOwner = aOwner;
-}
-
 nsresult nsNPAPIPluginInstance::AsyncSetWindow(NPWindow& window) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 void nsNPAPIPluginInstance::URLRedirectResponse(void* notifyData,
-                                                NPBool allow) {
-  if (!notifyData) {
-    return;
-  }
-
-  uint32_t listenerCount = mStreamListeners.Length();
-  for (uint32_t i = 0; i < listenerCount; i++) {
-    nsNPAPIPluginStreamListener* currentListener = mStreamListeners[i];
-    if (currentListener->GetNotifyData() == notifyData) {
-      currentListener->URLRedirectResponse(allow);
-    }
-  }
-}
+                                                NPBool allow) {}
 
 NPError nsNPAPIPluginInstance::InitAsyncSurface(NPSize* size,
                                                 NPImageFormat format,
                                                 void* initData,
                                                 NPAsyncSurface* surface) {
-  if (mOwner) {
-    return mOwner->InitAsyncSurface(size, format, initData, surface);
-  }
-
   return NPERR_GENERIC_ERROR;
 }
 
 NPError nsNPAPIPluginInstance::FinalizeAsyncSurface(NPAsyncSurface* surface) {
-  if (mOwner) {
-    return mOwner->FinalizeAsyncSurface(surface);
-  }
-
   return NPERR_GENERIC_ERROR;
 }
 
 void nsNPAPIPluginInstance::SetCurrentAsyncSurface(NPAsyncSurface* surface,
-                                                   NPRect* changed) {
-  if (mOwner) {
-    mOwner->SetCurrentAsyncSurface(surface, changed);
-  }
-}
+                                                   NPRect* changed) {}
 
-double nsNPAPIPluginInstance::GetContentsScaleFactor() {
-  double scaleFactor = 1.0;
-  if (mOwner) {
-    mOwner->GetContentsScaleFactor(&scaleFactor);
-  }
-  return scaleFactor;
-}
+double nsNPAPIPluginInstance::GetContentsScaleFactor() { return -1.0; }
 
-float nsNPAPIPluginInstance::GetCSSZoomFactor() {
-  float zoomFactor = 1.0;
-  if (mOwner) {
-    mOwner->GetCSSZoomFactor(&zoomFactor);
-  }
-  return zoomFactor;
-}
+float nsNPAPIPluginInstance::GetCSSZoomFactor() { return -1.0f; }
 
 nsresult nsNPAPIPluginInstance::GetRunID(uint32_t* aRunID) {
-  if (NS_WARN_IF(!aRunID)) {
-    return NS_ERROR_INVALID_POINTER;
-  }
-
-  if (NS_WARN_IF(!mPlugin)) {
-    return NS_ERROR_FAILURE;
-  }
-
-  PluginLibrary* library = mPlugin->GetLibrary();
-  if (!library) {
-    return NS_ERROR_FAILURE;
-  }
-
-  return library->GetRunID(aRunID);
+  return NS_ERROR_FAILURE;
 }
 
 nsresult nsNPAPIPluginInstance::CreateAudioChannelAgentIfNeeded() {
@@ -1165,25 +582,5 @@ nsresult nsNPAPIPluginInstance::UpdateMutedIfNeeded() {
 }
 
 nsresult nsNPAPIPluginInstance::SetMuted(bool aIsMuted) {
-  if (RUNNING != mRunning) return NS_OK;
-
-  PLUGIN_LOG(
-      PLUGIN_LOG_NORMAL,
-      ("nsNPAPIPluginInstance informing plugin of mute state change this=%p\n",
-       this));
-
-  if (!mPlugin || !mPlugin->GetLibrary()) return NS_ERROR_FAILURE;
-
-  NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
-
-  if (!pluginFunctions->setvalue) return NS_ERROR_FAILURE;
-
-  PluginDestructionGuard guard(this);
-
-  NPError error;
-  NPBool value = static_cast<NPBool>(aIsMuted);
-  NS_TRY_SAFE_CALL_RETURN(
-      error, (*pluginFunctions->setvalue)(&mNPP, NPNVmuteAudioBool, &value),
-      this, NS_PLUGIN_CALL_UNSAFE_TO_REENTER_GECKO);
-  return (error == NPERR_NO_ERROR) ? NS_OK : NS_ERROR_FAILURE;
+  return NS_ERROR_FAILURE;
 }
diff --git a/dom/plugins/base/nsNPAPIPluginInstance.h b/dom/plugins/base/nsNPAPIPluginInstance.h
index 2045105ab8632..d12511246aa6b 100644
--- a/dom/plugins/base/nsNPAPIPluginInstance.h
+++ b/dom/plugins/base/nsNPAPIPluginInstance.h
@@ -11,29 +11,27 @@
 #include "nsTArray.h"
 #include "nsPIDOMWindow.h"
 #include "nsITimer.h"
-#include "nsIPluginInstanceOwner.h"
 #include "nsHashKeys.h"
 #include <prinrval.h>
 #include "js/TypeDecls.h"
 #include "AudioChannelAgent.h"
+#include "npapi.h"
 
 #include "mozilla/EventForwards.h"
 #include "mozilla/TimeStamp.h"
-#include "mozilla/PluginLibrary.h"
 #include "mozilla/RefPtr.h"
 #include "mozilla/WeakPtr.h"
 #include "mozilla/dom/PopupBlocker.h"
 
-class nsPluginStreamListenerPeer;   // browser-initiated stream class
-class nsNPAPIPluginStreamListener;  // plugin-initiated stream class
-class nsIPluginInstanceOwner;
 class nsIOutputStream;
-class nsPluginInstanceOwner;
 
 namespace mozilla {
 namespace dom {
 class Element;
 }  // namespace dom
+namespace layers {
+class ImageContainer;
+}  // namespace layers
 }  // namespace mozilla
 
 #if defined(OS_WIN)
@@ -79,17 +77,12 @@ class nsNPAPITimer {
 
 class nsNPAPIPluginInstance final : public nsIAudioChannelAgentCallback,
                                     public mozilla::SupportsWeakPtr {
- private:
-  typedef mozilla::PluginLibrary PluginLibrary;
-
  public:
   typedef mozilla::gfx::DrawTarget DrawTarget;
 
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIAUDIOCHANNELAGENTCALLBACK
 
-  nsresult Initialize(nsNPAPIPlugin* aPlugin, nsPluginInstanceOwner* aOwner,
-                      const nsACString& aMIMEType);
   nsresult Start();
   nsresult Stop();
   nsresult SetWindow(NPWindow* window);
@@ -127,8 +120,6 @@ class nsNPAPIPluginInstance final : public nsIAudioChannelAgentCallback,
   nsresult GetScrollCaptureContainer(
       mozilla::layers::ImageContainer** aContainer);
 #endif
-  nsPluginInstanceOwner* GetOwner();
-  void SetOwner(nsPluginInstanceOwner* aOwner);
   void DidComposite();
 
   bool HasAudioChannelAgent() const { return !!mAudioChannelAgent; }
@@ -138,8 +129,6 @@ class nsNPAPIPluginInstance final : public nsIAudioChannelAgentCallback,
 
   nsresult SetMuted(bool aIsMuted);
 
-  nsNPAPIPlugin* GetPlugin();
-
   nsresult GetNPP(NPP* aNPP);
 
   NPError SetWindowless(bool aWindowless);
@@ -159,9 +148,6 @@ class nsNPAPIPluginInstance final : public nsIAudioChannelAgentCallback,
   void* GetCurrentEvent() { return mCurrentPluginEvent; }
 #endif
 
-  nsresult NewStreamListener(const char* aURL, void* notifyData,
-                             nsNPAPIPluginStreamListener** listener);
-
   nsNPAPIPluginInstance();
 
   // To be called when an instance becomes orphaned, when
@@ -199,10 +185,6 @@ class nsNPAPIPluginInstance final : public nsIAudioChannelAgentCallback,
                       NPCoordinateSpace sourceSpace, double* destX,
                       double* destY, NPCoordinateSpace destSpace);
 
-  nsTArray<nsNPAPIPluginStreamListener*>* StreamListeners();
-
-  nsTArray<nsPluginStreamListenerPeer*>* FileCachedStreamListeners();
-
   nsresult AsyncSetWindow(NPWindow& window);
 
   void URLRedirectResponse(void* notifyData, NPBool allow);
@@ -238,8 +220,6 @@ class nsNPAPIPluginInstance final : public nsIAudioChannelAgentCallback,
  protected:
   virtual ~nsNPAPIPluginInstance();
 
-  nsresult GetTagType(nsPluginTagType* result);
-
   nsresult CreateAudioChannelAgentIfNeeded();
 
   void NotifyAudibleStateChanged() const;
@@ -266,20 +246,10 @@ class nsNPAPIPluginInstance final : public nsIAudioChannelAgentCallback,
   bool mInPluginInitCall;
 
  private:
-  RefPtr<nsNPAPIPlugin> mPlugin;
-
-  nsTArray<nsNPAPIPluginStreamListener*> mStreamListeners;
-
-  nsTArray<nsPluginStreamListenerPeer*> mFileCachedStreamListeners;
-
   nsTArray<mozilla::dom::PopupBlocker::PopupControlState> mPopupStates;
 
   char* mMIMEType;
 
-  // Weak pointer to the owner. The owner nulls this out (by calling
-  // InvalidateOwner()) when it's no longer our owner.
-  nsPluginInstanceOwner* mOwner;
-
   nsTArray<nsNPAPITimer*> mTimers;
 
 #ifdef XP_MACOSX
diff --git a/dom/plugins/base/nsNPAPIPluginStreamListener.cpp b/dom/plugins/base/nsNPAPIPluginStreamListener.cpp
deleted file mode 100644
index 760da72e8574a..0000000000000
--- a/dom/plugins/base/nsNPAPIPluginStreamListener.cpp
+++ /dev/null
@@ -1,776 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "nsNPAPIPluginStreamListener.h"
-#include "plstr.h"
-#include "nsDirectoryServiceDefs.h"
-#include "nsDirectoryServiceUtils.h"
-#include "nsIHttpChannel.h"
-#include "nsNetUtil.h"
-#include "nsPluginHost.h"
-#include "nsNPAPIPlugin.h"
-#include "nsPluginLogging.h"
-#include "nsPluginStreamListenerPeer.h"
-#include "mozilla/ProfilerLabels.h"
-
-#include <stdint.h>
-#include <algorithm>
-
-nsNPAPIStreamWrapper::nsNPAPIStreamWrapper(
-    nsIOutputStream* outputStream,
-    nsNPAPIPluginStreamListener* streamListener) {
-  mOutputStream = outputStream;
-  mStreamListener = streamListener;
-
-  memset(&mNPStream, 0, sizeof(mNPStream));
-  mNPStream.ndata = static_cast<void*>(this);
-}
-
-nsNPAPIStreamWrapper::~nsNPAPIStreamWrapper() {
-  if (mOutputStream) {
-    mOutputStream->Close();
-  }
-}
-
-// nsNPAPIPluginStreamListener Methods
-NS_IMPL_ISUPPORTS(nsNPAPIPluginStreamListener, nsITimerCallback,
-                  nsIHTTPHeaderListener, nsINamed)
-
-nsNPAPIPluginStreamListener::nsNPAPIPluginStreamListener(
-    nsNPAPIPluginInstance* inst, void* notifyData, const char* aURL)
-    : mStreamBuffer(nullptr),
-      mNotifyURL(aURL ? PL_strdup(aURL) : nullptr),
-      mInst(inst),
-      mStreamBufferSize(0),
-      mStreamBufferByteCount(0),
-      mStreamState(eStreamStopped),
-      mStreamCleanedUp(false),
-      mCallNotify(notifyData ? true : false),
-      mIsSuspended(false),
-      mIsPluginInitJSStream(
-          mInst->mInPluginInitCall && aURL &&
-          strncmp(aURL, "javascript:", sizeof("javascript:") - 1) == 0),
-      mRedirectDenied(false),
-      mResponseHeaderBuf(nullptr),
-      mStreamStopMode(eNormalStop),
-      mPendingStopBindingStatus(NS_OK) {
-  mNPStreamWrapper = new nsNPAPIStreamWrapper(nullptr, this);
-  mNPStreamWrapper->mNPStream.notifyData = notifyData;
-}
-
-nsNPAPIPluginStreamListener::~nsNPAPIPluginStreamListener() {
-  // remove this from the plugin instance's stream list
-  nsTArray<nsNPAPIPluginStreamListener*>* streamListeners =
-      mInst->StreamListeners();
-  streamListeners->RemoveElement(this);
-
-  // For those cases when NewStream is never called, we still may need
-  // to fire a notification callback. Return network error as fallback
-  // reason because for other cases, notify should have already been
-  // called for other reasons elsewhere.
-  CallURLNotify(NPRES_NETWORK_ERR);
-
-  // lets get rid of the buffer
-  if (mStreamBuffer) {
-    free(mStreamBuffer);
-    mStreamBuffer = nullptr;
-  }
-
-  if (mNotifyURL) PL_strfree(mNotifyURL);
-
-  if (mResponseHeaderBuf) PL_strfree(mResponseHeaderBuf);
-
-  if (mNPStreamWrapper) {
-    delete mNPStreamWrapper;
-  }
-}
-
-nsresult nsNPAPIPluginStreamListener::CleanUpStream(NPReason reason) {
-  nsresult rv = NS_ERROR_FAILURE;
-
-  // Various bits of code in the rest of this method may result in the
-  // deletion of this object. Use a KungFuDeathGrip to keep ourselves
-  // alive during cleanup.
-  RefPtr<nsNPAPIPluginStreamListener> kungFuDeathGrip(this);
-
-  if (mStreamCleanedUp) return NS_OK;
-
-  mStreamCleanedUp = true;
-
-  StopDataPump();
-
-  // Release any outstanding redirect callback.
-  if (mHTTPRedirectCallback) {
-    mHTTPRedirectCallback->OnRedirectVerifyCallback(NS_ERROR_FAILURE);
-    mHTTPRedirectCallback = nullptr;
-  }
-
-  if (mStreamListenerPeer) {
-    mStreamListenerPeer->CancelRequests(NS_BINDING_ABORTED);
-    mStreamListenerPeer = nullptr;
-  }
-
-  if (!mInst || !mInst->CanFireNotifications()) return rv;
-
-  PluginDestructionGuard guard(mInst);
-
-  nsNPAPIPlugin* plugin = mInst->GetPlugin();
-  if (!plugin || !plugin->GetLibrary()) return rv;
-
-  NPPluginFuncs* pluginFunctions = plugin->PluginFuncs();
-
-  NPP npp;
-  mInst->GetNPP(&npp);
-
-  if (mStreamState >= eNewStreamCalled && pluginFunctions->destroystream) {
-    NPPAutoPusher nppPusher(npp);
-
-    NPError error;
-    NS_TRY_SAFE_CALL_RETURN(error,
-                            (*pluginFunctions->destroystream)(
-                                npp, &mNPStreamWrapper->mNPStream, reason),
-                            mInst, NS_PLUGIN_CALL_UNSAFE_TO_REENTER_GECKO);
-
-    NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                   ("NPP DestroyStream called: this=%p, npp=%p, reason=%d, "
-                    "return=%d, url=%s\n",
-                    this, npp, reason, error, mNPStreamWrapper->mNPStream.url));
-
-    if (error == NPERR_NO_ERROR) rv = NS_OK;
-  }
-
-  mStreamState = eStreamStopped;
-
-  // fire notification back to plugin, just like before
-  CallURLNotify(reason);
-
-  return rv;
-}
-
-void nsNPAPIPluginStreamListener::CallURLNotify(NPReason reason) {
-  if (!mCallNotify || !mInst || !mInst->CanFireNotifications()) return;
-
-  PluginDestructionGuard guard(mInst);
-
-  mCallNotify = false;  // only do this ONCE and prevent recursion
-
-  nsNPAPIPlugin* plugin = mInst->GetPlugin();
-  if (!plugin || !plugin->GetLibrary()) return;
-
-  NPPluginFuncs* pluginFunctions = plugin->PluginFuncs();
-
-  if (pluginFunctions->urlnotify) {
-    NPP npp;
-    mInst->GetNPP(&npp);
-
-    NS_TRY_SAFE_CALL_VOID(
-        (*pluginFunctions->urlnotify)(npp, mNotifyURL, reason,
-                                      mNPStreamWrapper->mNPStream.notifyData),
-        mInst, NS_PLUGIN_CALL_UNSAFE_TO_REENTER_GECKO);
-
-    NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                   ("NPP URLNotify called: this=%p, npp=%p, notify=%p, "
-                    "reason=%d, url=%s\n",
-                    this, npp, mNPStreamWrapper->mNPStream.notifyData, reason,
-                    mNotifyURL));
-  }
-}
-
-nsresult nsNPAPIPluginStreamListener::OnStartBinding(
-    nsPluginStreamListenerPeer* streamPeer) {
-  AUTO_PROFILER_LABEL("nsNPAPIPluginStreamListener::OnStartBinding", OTHER);
-  if (!mInst || !mInst->CanFireNotifications() || mStreamCleanedUp)
-    return NS_ERROR_FAILURE;
-
-  PluginDestructionGuard guard(mInst);
-
-  nsNPAPIPlugin* plugin = mInst->GetPlugin();
-  if (!plugin || !plugin->GetLibrary()) return NS_ERROR_FAILURE;
-
-  NPPluginFuncs* pluginFunctions = plugin->PluginFuncs();
-
-  if (!pluginFunctions->newstream) return NS_ERROR_FAILURE;
-
-  NPP npp;
-  mInst->GetNPP(&npp);
-
-  char* contentType;
-  uint16_t streamType = NP_NORMAL;
-  NPError error;
-
-  streamPeer->GetURL(&mNPStreamWrapper->mNPStream.url);
-  streamPeer->GetLength((uint32_t*)&(mNPStreamWrapper->mNPStream.end));
-  streamPeer->GetLastModified(
-      (uint32_t*)&(mNPStreamWrapper->mNPStream.lastmodified));
-  streamPeer->GetContentType(&contentType);
-
-  if (!mResponseHeaders.IsEmpty()) {
-    mResponseHeaderBuf = PL_strdup(mResponseHeaders.get());
-    mNPStreamWrapper->mNPStream.headers = mResponseHeaderBuf;
-  }
-
-  mStreamListenerPeer = streamPeer;
-
-  NPPAutoPusher nppPusher(npp);
-
-  NS_TRY_SAFE_CALL_RETURN(error,
-                          (*pluginFunctions->newstream)(
-                              npp, (char*)contentType,
-                              &mNPStreamWrapper->mNPStream, false, &streamType),
-                          mInst, NS_PLUGIN_CALL_UNSAFE_TO_REENTER_GECKO);
-
-  NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                 ("NPP NewStream called: this=%p, npp=%p, mime=%s, seek=%d, "
-                  "type=%d, return=%d, url=%s\n",
-                  this, npp, (char*)contentType, false, streamType, error,
-                  mNPStreamWrapper->mNPStream.url));
-
-  if (error != NPERR_NO_ERROR) return NS_ERROR_FAILURE;
-
-  mStreamState = eNewStreamCalled;
-
-  if (streamType != NP_NORMAL) {
-    return NS_ERROR_FAILURE;
-  }
-
-  return NS_OK;
-}
-
-void nsNPAPIPluginStreamListener::SuspendRequest() {
-  NS_ASSERTION(!mIsSuspended, "Suspending a request that's already suspended!");
-
-  nsresult rv = StartDataPump();
-  if (NS_FAILED(rv)) return;
-
-  mIsSuspended = true;
-
-  if (mStreamListenerPeer) {
-    mStreamListenerPeer->SuspendRequests();
-  }
-}
-
-void nsNPAPIPluginStreamListener::ResumeRequest() {
-  if (mStreamListenerPeer) {
-    mStreamListenerPeer->ResumeRequests();
-  }
-  mIsSuspended = false;
-}
-
-nsresult nsNPAPIPluginStreamListener::StartDataPump() {
-  // Start pumping data to the plugin every 100ms until it obeys and
-  // eats the data.
-  return NS_NewTimerWithCallback(getter_AddRefs(mDataPumpTimer), this, 100,
-                                 nsITimer::TYPE_REPEATING_SLACK);
-}
-
-void nsNPAPIPluginStreamListener::StopDataPump() {
-  if (mDataPumpTimer) {
-    mDataPumpTimer->Cancel();
-    mDataPumpTimer = nullptr;
-  }
-}
-
-// Return true if a javascript: load that was started while the plugin
-// was being initialized is still in progress.
-bool nsNPAPIPluginStreamListener::PluginInitJSLoadInProgress() {
-  if (!mInst) return false;
-
-  nsTArray<nsNPAPIPluginStreamListener*>* streamListeners =
-      mInst->StreamListeners();
-  for (unsigned int i = 0; i < streamListeners->Length(); i++) {
-    if (streamListeners->ElementAt(i)->mIsPluginInitJSStream) {
-      return true;
-    }
-  }
-
-  return false;
-}
-
-// This method is called when there's more data available off the
-// network, but it's also called from our data pump when we're feeding
-// the plugin data that we already got off the network, but the plugin
-// was unable to consume it at the point it arrived. In the case when
-// the plugin pump calls this method, the input argument will be null,
-// and the length will be the number of bytes available in our
-// internal buffer.
-nsresult nsNPAPIPluginStreamListener::OnDataAvailable(
-    nsPluginStreamListenerPeer* streamPeer, nsIInputStream* input,
-    uint32_t length) {
-  if (!length || !mInst || !mInst->CanFireNotifications())
-    return NS_ERROR_FAILURE;
-
-  PluginDestructionGuard guard(mInst);
-
-  // Just in case the caller switches plugin info on us.
-  mStreamListenerPeer = streamPeer;
-
-  nsNPAPIPlugin* plugin = mInst->GetPlugin();
-  if (!plugin || !plugin->GetLibrary()) return NS_ERROR_FAILURE;
-
-  NPPluginFuncs* pluginFunctions = plugin->PluginFuncs();
-
-  // check out if plugin implements NPP_Write call
-  if (!pluginFunctions->write)
-    return NS_ERROR_FAILURE;  // it'll cancel necko transaction
-
-  if (!mStreamBuffer) {
-    // To optimize the mem usage & performance we have to allocate
-    // mStreamBuffer here in first ODA when length of data available
-    // in input stream is known.  mStreamBuffer will be freed in DTOR.
-    // we also have to remember the size of that buff to make safe
-    // consecutive Read() calls form input stream into our buff.
-
-    uint32_t contentLength;
-    streamPeer->GetLength(&contentLength);
-
-    mStreamBufferSize = std::max(length, contentLength);
-
-    // Limit the size of the initial buffer to MAX_PLUGIN_NECKO_BUFFER
-    // (16k). This buffer will grow if needed, as in the case where
-    // we're getting data faster than the plugin can process it.
-    mStreamBufferSize =
-        std::min(mStreamBufferSize, uint32_t(MAX_PLUGIN_NECKO_BUFFER));
-
-    mStreamBuffer = (char*)malloc(mStreamBufferSize);
-    if (!mStreamBuffer) return NS_ERROR_OUT_OF_MEMORY;
-  }
-
-  // prepare NPP_ calls params
-  NPP npp;
-  mInst->GetNPP(&npp);
-
-  int32_t streamPosition;
-  streamPeer->GetStreamOffset(&streamPosition);
-  int32_t streamOffset = streamPosition;
-
-  if (input) {
-    streamOffset += length;
-
-    // Set new stream offset for the next ODA call regardless of how
-    // following NPP_Write call will behave we pretend to consume all
-    // data from the input stream.  It's possible that current steam
-    // position will be overwritten from NPP_RangeRequest call made
-    // from NPP_Write, so we cannot call SetStreamOffset after
-    // NPP_Write.
-    //
-    // Note: there is a special case when data flow should be
-    // temporarily stopped if NPP_WriteReady returns 0 (bug #89270)
-    streamPeer->SetStreamOffset(streamOffset);
-
-    // set new end in case the content is compressed
-    // initial end is less than end of decompressed stream
-    // and some plugins (e.g. acrobat) can fail.
-    if ((int32_t)mNPStreamWrapper->mNPStream.end < streamOffset)
-      mNPStreamWrapper->mNPStream.end = streamOffset;
-  }
-
-  nsresult rv = NS_OK;
-  while (NS_SUCCEEDED(rv) && length > 0) {
-    if (input && length) {
-      if (mStreamBufferSize < mStreamBufferByteCount + length) {
-        // We're in the ::OnDataAvailable() call that we might get
-        // after suspending a request, or we suspended the request
-        // from within this ::OnDataAvailable() call while there's
-        // still data in the input, or we have resumed a previously
-        // suspended request and our buffer is already full, and we
-        // don't have enough space to store what we got off the network.
-        // Reallocate our internal buffer.
-        mStreamBufferSize = mStreamBufferByteCount + length;
-        char* buf = (char*)realloc(mStreamBuffer, mStreamBufferSize);
-        if (!buf) return NS_ERROR_OUT_OF_MEMORY;
-
-        mStreamBuffer = buf;
-      }
-
-      uint32_t bytesToRead =
-          std::min(length, mStreamBufferSize - mStreamBufferByteCount);
-      MOZ_ASSERT(bytesToRead > 0);
-
-      uint32_t amountRead = 0;
-      rv = input->Read(mStreamBuffer + mStreamBufferByteCount, bytesToRead,
-                       &amountRead);
-      NS_ENSURE_SUCCESS(rv, rv);
-
-      if (amountRead == 0) {
-        MOZ_ASSERT_UNREACHABLE(
-            "input->Read() returns no data, it's almost "
-            "impossible to get here");
-
-        break;
-      }
-
-      mStreamBufferByteCount += amountRead;
-      length -= amountRead;
-    } else {
-      // No input, nothing to read. Set length to 0 so that we don't
-      // keep iterating through this outer loop any more.
-
-      length = 0;
-    }
-
-    // Temporary pointer to the beginning of the data we're writing as
-    // we loop and feed the plugin data.
-    char* ptrStreamBuffer = mStreamBuffer;
-
-    // it is possible plugin's NPP_Write() returns 0 byte consumed. We
-    // use zeroBytesWriteCount to count situation like this and break
-    // the loop
-    int32_t zeroBytesWriteCount = 0;
-
-    // mStreamBufferByteCount tells us how many bytes there are in the
-    // buffer. WriteReady returns to us how many bytes the plugin is
-    // ready to handle.
-    while (mStreamBufferByteCount > 0) {
-      int32_t numtowrite;
-      if (pluginFunctions->writeready) {
-        NPPAutoPusher nppPusher(npp);
-
-        NS_TRY_SAFE_CALL_RETURN(
-            numtowrite,
-            (*pluginFunctions->writeready)(npp, &mNPStreamWrapper->mNPStream),
-            mInst, NS_PLUGIN_CALL_UNSAFE_TO_REENTER_GECKO);
-        NPP_PLUGIN_LOG(
-            PLUGIN_LOG_NOISY,
-            ("NPP WriteReady called: this=%p, npp=%p, "
-             "return(towrite)=%d, url=%s\n",
-             this, npp, numtowrite, mNPStreamWrapper->mNPStream.url));
-
-        if (mStreamState == eStreamStopped) {
-          // The plugin called NPN_DestroyStream() from within
-          // NPP_WriteReady(), kill the stream.
-
-          return NS_BINDING_ABORTED;
-        }
-
-        // if WriteReady returned 0, the plugin is not ready to handle
-        // the data, suspend the stream (if it isn't already
-        // suspended).
-        //
-        // Also suspend the stream if the stream we're loading is not
-        // a javascript: URL load that was initiated during plugin
-        // initialization and there currently is such a stream
-        // loading. This is done to work around a Windows Media Player
-        // plugin bug where it can't deal with being fed data for
-        // other streams while it's waiting for data from the
-        // javascript: URL loads it requests during
-        // initialization. See bug 386493 for more details.
-
-        if (numtowrite <= 0 ||
-            (!mIsPluginInitJSStream && PluginInitJSLoadInProgress())) {
-          if (!mIsSuspended) {
-            SuspendRequest();
-          }
-
-          // Break out of the inner loop, but keep going through the
-          // outer loop in case there's more data to read from the
-          // input stream.
-
-          break;
-        }
-
-        numtowrite = std::min(numtowrite, mStreamBufferByteCount);
-      } else {
-        // if WriteReady is not supported by the plugin, just write
-        // the whole buffer
-        numtowrite = mStreamBufferByteCount;
-      }
-
-      NPPAutoPusher nppPusher(npp);
-
-      int32_t writeCount = 0;  // bytes consumed by plugin instance
-      NS_TRY_SAFE_CALL_RETURN(writeCount,
-                              (*pluginFunctions->write)(
-                                  npp, &mNPStreamWrapper->mNPStream,
-                                  streamPosition, numtowrite, ptrStreamBuffer),
-                              mInst, NS_PLUGIN_CALL_UNSAFE_TO_REENTER_GECKO);
-
-      NPP_PLUGIN_LOG(
-          PLUGIN_LOG_NOISY,
-          ("NPP Write called: this=%p, npp=%p, pos=%d, len=%d, "
-           "buf=%.*s, return(written)=%d,  url=%s\n",
-           this, npp, streamPosition, numtowrite, numtowrite, ptrStreamBuffer,
-           writeCount, mNPStreamWrapper->mNPStream.url));
-
-      if (mStreamState == eStreamStopped) {
-        // The plugin called NPN_DestroyStream() from within
-        // NPP_Write(), kill the stream.
-        return NS_BINDING_ABORTED;
-      }
-
-      if (writeCount > 0) {
-        NS_ASSERTION(writeCount <= mStreamBufferByteCount,
-                     "Plugin read past the end of the available data!");
-
-        writeCount = std::min(writeCount, mStreamBufferByteCount);
-        mStreamBufferByteCount -= writeCount;
-
-        streamPosition += writeCount;
-
-        zeroBytesWriteCount = 0;
-
-        if (mStreamBufferByteCount > 0) {
-          // This alignment code is most likely bogus, but we'll leave
-          // it in for now in case it matters for some plugins on some
-          // architectures. Who knows...
-          if (writeCount % sizeof(intptr_t)) {
-            // memmove will take care  about alignment
-            memmove(mStreamBuffer, ptrStreamBuffer + writeCount,
-                    mStreamBufferByteCount);
-            ptrStreamBuffer = mStreamBuffer;
-          } else {
-            // if aligned we can use ptrStreamBuffer += to eliminate
-            // memmove()
-            ptrStreamBuffer += writeCount;
-          }
-        }
-      } else if (writeCount == 0) {
-        // if NPP_Write() returns writeCount == 0 lets say 3 times in
-        // a row, suspend the request and continue feeding the plugin
-        // the data we got so far. Once that data is consumed, we'll
-        // resume the request.
-        if (mIsSuspended || ++zeroBytesWriteCount == 3) {
-          if (!mIsSuspended) {
-            SuspendRequest();
-          }
-
-          // Break out of the for loop, but keep going through the
-          // while loop in case there's more data to read from the
-          // input stream.
-
-          break;
-        }
-      } else {
-        // Something's really wrong, kill the stream.
-        rv = NS_ERROR_FAILURE;
-
-        break;
-      }
-    }  // end of inner while loop
-
-    if (mStreamBufferByteCount && mStreamBuffer != ptrStreamBuffer) {
-      memmove(mStreamBuffer, ptrStreamBuffer, mStreamBufferByteCount);
-    }
-  }
-
-  if (streamPosition != streamOffset) {
-    // The plugin didn't consume all available data, or consumed some
-    // of our cached data while we're pumping cached data. Adjust the
-    // plugin info's stream offset to match reality, except if the
-    // plugin info's stream offset was set by a re-entering
-    // NPN_RequestRead() call.
-
-    int32_t postWriteStreamPosition;
-    streamPeer->GetStreamOffset(&postWriteStreamPosition);
-
-    if (postWriteStreamPosition == streamOffset) {
-      streamPeer->SetStreamOffset(streamPosition);
-    }
-  }
-
-  return rv;
-}
-
-nsresult nsNPAPIPluginStreamListener::OnFileAvailable(
-    nsPluginStreamListenerPeer* streamPeer, const char* fileName) {
-  if (!mInst || !mInst->CanFireNotifications()) return NS_ERROR_FAILURE;
-
-  PluginDestructionGuard guard(mInst);
-
-  nsNPAPIPlugin* plugin = mInst->GetPlugin();
-  if (!plugin || !plugin->GetLibrary()) return NS_ERROR_FAILURE;
-
-  NPPluginFuncs* pluginFunctions = plugin->PluginFuncs();
-
-  if (!pluginFunctions->asfile) return NS_ERROR_FAILURE;
-
-  NPP npp;
-  mInst->GetNPP(&npp);
-
-  NS_TRY_SAFE_CALL_VOID(
-      (*pluginFunctions->asfile)(npp, &mNPStreamWrapper->mNPStream, fileName),
-      mInst, NS_PLUGIN_CALL_UNSAFE_TO_REENTER_GECKO);
-
-  NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-                 ("NPP StreamAsFile called: this=%p, npp=%p, url=%s, file=%s\n",
-                  this, npp, mNPStreamWrapper->mNPStream.url, fileName));
-
-  return NS_OK;
-}
-
-nsresult nsNPAPIPluginStreamListener::OnStopBinding(
-    nsPluginStreamListenerPeer* streamPeer, nsresult status) {
-  if (NS_FAILED(status)) {
-    // The stream was destroyed, or died for some reason. Make sure we
-    // cancel the underlying request.
-    if (mStreamListenerPeer) {
-      mStreamListenerPeer->CancelRequests(status);
-    }
-  }
-
-  if (!mInst || !mInst->CanFireNotifications()) {
-    StopDataPump();
-    return NS_ERROR_FAILURE;
-  }
-
-  // We need to detect that the stop is due to async stream init completion.
-  if (mStreamStopMode == eDoDeferredStop) {
-    // We shouldn't be delivering this until async init is done
-    mStreamStopMode = eStopPending;
-    mPendingStopBindingStatus = status;
-    if (!mDataPumpTimer) {
-      StartDataPump();
-    }
-    return NS_OK;
-  }
-
-  StopDataPump();
-
-  NPReason reason = NS_FAILED(status) ? NPRES_NETWORK_ERR : NPRES_DONE;
-  if (mRedirectDenied || status == NS_BINDING_ABORTED) {
-    reason = NPRES_USER_BREAK;
-  }
-
-  // The following code can result in the deletion of 'this'. Don't
-  // assume we are alive after this!
-  return CleanUpStream(reason);
-}
-
-bool nsNPAPIPluginStreamListener::MaybeRunStopBinding() {
-  if (mIsSuspended || mStreamStopMode != eStopPending) {
-    return false;
-  }
-  OnStopBinding(mStreamListenerPeer, mPendingStopBindingStatus);
-  mStreamStopMode = eNormalStop;
-  return true;
-}
-
-NS_IMETHODIMP
-nsNPAPIPluginStreamListener::Notify(nsITimer* aTimer) {
-  NS_ASSERTION(aTimer == mDataPumpTimer, "Uh, wrong timer?");
-
-  int32_t oldStreamBufferByteCount = mStreamBufferByteCount;
-
-  nsresult rv =
-      OnDataAvailable(mStreamListenerPeer, nullptr, mStreamBufferByteCount);
-
-  if (NS_FAILED(rv)) {
-    // We ran into an error, no need to keep firing this timer then.
-    StopDataPump();
-    MaybeRunStopBinding();
-    return NS_OK;
-  }
-
-  if (mStreamBufferByteCount != oldStreamBufferByteCount &&
-      ((mStreamState == eStreamTypeSet && mStreamBufferByteCount < 1024) ||
-       mStreamBufferByteCount == 0)) {
-    // The plugin read some data and we've got less than 1024 bytes in
-    // our buffer (or its empty and the stream is already
-    // done). Resume the request so that we get more data off the
-    // network.
-    ResumeRequest();
-    // Necko will pump data now that we've resumed the request.
-    StopDataPump();
-  }
-
-  MaybeRunStopBinding();
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsNPAPIPluginStreamListener::GetName(nsACString& aName) {
-  aName.AssignLiteral("nsNPAPIPluginStreamListener");
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsNPAPIPluginStreamListener::StatusLine(const char* line) {
-  mResponseHeaders.Append(line);
-  mResponseHeaders.Append('\n');
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsNPAPIPluginStreamListener::NewResponseHeader(const char* headerName,
-                                               const char* headerValue) {
-  mResponseHeaders.Append(headerName);
-  mResponseHeaders.AppendLiteral(": ");
-  mResponseHeaders.Append(headerValue);
-  mResponseHeaders.Append('\n');
-  return NS_OK;
-}
-
-bool nsNPAPIPluginStreamListener::HandleRedirectNotification(
-    nsIChannel* oldChannel, nsIChannel* newChannel,
-    nsIAsyncVerifyRedirectCallback* callback) {
-  nsCOMPtr<nsIHttpChannel> oldHttpChannel = do_QueryInterface(oldChannel);
-  nsCOMPtr<nsIHttpChannel> newHttpChannel = do_QueryInterface(newChannel);
-  if (!oldHttpChannel || !newHttpChannel) {
-    return false;
-  }
-
-  if (!mInst || !mInst->CanFireNotifications()) {
-    return false;
-  }
-
-  nsNPAPIPlugin* plugin = mInst->GetPlugin();
-  if (!plugin || !plugin->GetLibrary()) {
-    return false;
-  }
-
-  NPPluginFuncs* pluginFunctions = plugin->PluginFuncs();
-  if (!pluginFunctions->urlredirectnotify) {
-    return false;
-  }
-
-  // A non-null closure is required for redirect handling support.
-  if (mNPStreamWrapper->mNPStream.notifyData) {
-    uint32_t status;
-    if (NS_SUCCEEDED(oldHttpChannel->GetResponseStatus(&status))) {
-      nsCOMPtr<nsIURI> uri;
-      if (NS_SUCCEEDED(newHttpChannel->GetURI(getter_AddRefs(uri))) && uri) {
-        nsAutoCString spec;
-        if (NS_SUCCEEDED(uri->GetAsciiSpec(spec))) {
-          // At this point the plugin will be responsible for making the
-          // callback so save the callback object.
-          mHTTPRedirectCallback = callback;
-
-          NPP npp;
-          mInst->GetNPP(&npp);
-#if defined(XP_WIN)
-          NS_TRY_SAFE_CALL_VOID(
-              (*pluginFunctions->urlredirectnotify)(
-                  npp, spec.get(), static_cast<int32_t>(status),
-                  mNPStreamWrapper->mNPStream.notifyData),
-              mInst, NS_PLUGIN_CALL_UNSAFE_TO_REENTER_GECKO);
-#else
-          (*pluginFunctions->urlredirectnotify)(
-              npp, spec.get(), static_cast<int32_t>(status),
-              mNPStreamWrapper->mNPStream.notifyData);
-#endif
-          return true;
-        }
-      }
-    }
-  }
-
-  callback->OnRedirectVerifyCallback(NS_ERROR_FAILURE);
-  return true;
-}
-
-void nsNPAPIPluginStreamListener::URLRedirectResponse(NPBool allow) {
-  if (mHTTPRedirectCallback) {
-    mHTTPRedirectCallback->OnRedirectVerifyCallback(allow ? NS_OK
-                                                          : NS_ERROR_FAILURE);
-    mRedirectDenied = !allow;
-    mHTTPRedirectCallback = nullptr;
-  }
-}
-
-void* nsNPAPIPluginStreamListener::GetNotifyData() {
-  if (mNPStreamWrapper) {
-    return mNPStreamWrapper->mNPStream.notifyData;
-  }
-  return nullptr;
-}
diff --git a/dom/plugins/base/nsNPAPIPluginStreamListener.h b/dom/plugins/base/nsNPAPIPluginStreamListener.h
deleted file mode 100644
index 93e70b515ae13..0000000000000
--- a/dom/plugins/base/nsNPAPIPluginStreamListener.h
+++ /dev/null
@@ -1,126 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef nsNPAPIPluginStreamListener_h_
-#define nsNPAPIPluginStreamListener_h_
-
-#include "nscore.h"
-#include "nsIHTTPHeaderListener.h"
-#include "nsINamed.h"
-#include "nsITimer.h"
-#include "nsCOMArray.h"
-#include "nsIOutputStream.h"
-#include "nsString.h"
-#include "nsIAsyncVerifyRedirectCallback.h"
-#include "mozilla/PluginLibrary.h"
-
-#define MAX_PLUGIN_NECKO_BUFFER 16384
-
-class nsPluginStreamListenerPeer;
-class nsNPAPIPluginStreamListener;
-class nsNPAPIPluginInstance;
-class nsIChannel;
-
-class nsNPAPIStreamWrapper {
- public:
-  nsNPAPIStreamWrapper(nsIOutputStream* outputStream,
-                       nsNPAPIPluginStreamListener* streamListener);
-  ~nsNPAPIStreamWrapper();
-
-  nsIOutputStream* GetOutputStream() { return mOutputStream.get(); }
-  nsNPAPIPluginStreamListener* GetStreamListener() { return mStreamListener; }
-
-  NPStream mNPStream;
-
- protected:
-  nsCOMPtr<nsIOutputStream>
-      mOutputStream;  // only valid if not browser initiated
-  nsNPAPIPluginStreamListener*
-      mStreamListener;  // only valid if browser initiated
-};
-
-class nsNPAPIPluginStreamListener : public nsITimerCallback,
-                                    public nsIHTTPHeaderListener,
-                                    public nsINamed {
- private:
-  typedef mozilla::PluginLibrary PluginLibrary;
-
- public:
-  NS_DECL_ISUPPORTS
-  NS_DECL_NSITIMERCALLBACK
-  NS_DECL_NSIHTTPHEADERLISTENER
-  NS_DECL_NSINAMED
-
-  nsNPAPIPluginStreamListener(nsNPAPIPluginInstance* inst, void* notifyData,
-                              const char* aURL);
-
-  nsresult OnStartBinding(nsPluginStreamListenerPeer* streamPeer);
-  nsresult OnDataAvailable(nsPluginStreamListenerPeer* streamPeer,
-                           nsIInputStream* input, uint32_t length);
-  nsresult OnFileAvailable(nsPluginStreamListenerPeer* streamPeer,
-                           const char* fileName);
-  nsresult OnStopBinding(nsPluginStreamListenerPeer* streamPeer,
-                         nsresult status);
-
-  bool IsStarted();
-  nsresult CleanUpStream(NPReason reason);
-  void CallURLNotify(NPReason reason);
-  void SetCallNotify(bool aCallNotify) { mCallNotify = aCallNotify; }
-  void SuspendRequest();
-  void ResumeRequest();
-  nsresult StartDataPump();
-  void StopDataPump();
-  bool PluginInitJSLoadInProgress();
-
-  void* GetNotifyData();
-  nsPluginStreamListenerPeer* GetStreamListenerPeer() {
-    return mStreamListenerPeer;
-  }
-  void SetStreamListenerPeer(nsPluginStreamListenerPeer* aPeer) {
-    mStreamListenerPeer = aPeer;
-  }
-
-  // Returns true if the redirect will be handled by NPAPI, false otherwise.
-  bool HandleRedirectNotification(nsIChannel* oldChannel,
-                                  nsIChannel* newChannel,
-                                  nsIAsyncVerifyRedirectCallback* callback);
-  void URLRedirectResponse(NPBool allow);
-
- protected:
-  enum StreamState {
-    eStreamStopped = 0,  // The stream is stopped
-    eNewStreamCalled,    // NPP_NewStream was called but has not completed yet
-    eStreamTypeSet       // The stream is fully initialized
-  };
-
-  enum StreamStopMode { eNormalStop = 0, eDoDeferredStop, eStopPending };
-
-  virtual ~nsNPAPIPluginStreamListener();
-  bool MaybeRunStopBinding();
-
-  char* mStreamBuffer;
-  char* mNotifyURL;
-  RefPtr<nsNPAPIPluginInstance> mInst;
-  nsNPAPIStreamWrapper* mNPStreamWrapper;
-  uint32_t mStreamBufferSize;
-  int32_t mStreamBufferByteCount;
-  StreamState mStreamState;
-  bool mStreamCleanedUp;
-  bool mCallNotify;
-  bool mIsSuspended;
-  bool mIsPluginInitJSStream;
-  bool mRedirectDenied;
-  nsCString mResponseHeaders;
-  char* mResponseHeaderBuf;
-  nsCOMPtr<nsITimer> mDataPumpTimer;
-  nsCOMPtr<nsIAsyncVerifyRedirectCallback> mHTTPRedirectCallback;
-  StreamStopMode mStreamStopMode;
-  nsresult mPendingStopBindingStatus;
-
- public:
-  RefPtr<nsPluginStreamListenerPeer> mStreamListenerPeer;
-};
-
-#endif  // nsNPAPIPluginStreamListener_h_
diff --git a/dom/plugins/base/nsPluginHost.cpp b/dom/plugins/base/nsPluginHost.cpp
index 0cb7647fb535f..3deb587458416 100644
--- a/dom/plugins/base/nsPluginHost.cpp
+++ b/dom/plugins/base/nsPluginHost.cpp
@@ -89,7 +89,6 @@
 #include "nsPluginInstanceOwner.h"
 #include "nsPluginLogging.h"
 #include "nsPluginNativeWindow.h"
-#include "nsPluginStreamListenerPeer.h"
 #include "nsPluginTags.h"
 #include "nsServiceManagerUtils.h"
 #include "nsString.h"
@@ -122,8 +121,6 @@ using mozilla::dom::Document;
 using mozilla::dom::FakePluginMimeEntry;
 using mozilla::dom::FakePluginTagInit;
 using mozilla::dom::Promise;
-using mozilla::plugins::FakePluginTag;
-using mozilla::plugins::PluginTag;
 
 // Null out a strong ref to a linked list iteratively to avoid
 // exhausting the stack (bug 486349).
@@ -352,25 +349,7 @@ already_AddRefed<nsPluginHost> nsPluginHost::GetInst() {
   return do_AddRef(sInst);
 }
 
-bool nsPluginHost::IsRunningPlugin(nsPluginTag* aPluginTag) {
-  if (!aPluginTag || !aPluginTag->mPlugin) {
-    return false;
-  }
-
-  if (aPluginTag->mContentProcessRunningCount) {
-    return true;
-  }
-
-  for (uint32_t i = 0; i < mInstances.Length(); i++) {
-    nsNPAPIPluginInstance* instance = mInstances[i].get();
-    if (instance && instance->GetPlugin() == aPluginTag->mPlugin &&
-        instance->IsRunning()) {
-      return true;
-    }
-  }
-
-  return false;
-}
+bool nsPluginHost::IsRunningPlugin(nsPluginTag* aPluginTag) { return false; }
 
 nsresult nsPluginHost::ReloadPlugins() {
   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsPluginHost::ReloadPlugins\n"));
@@ -466,98 +445,6 @@ nsresult nsPluginHost::UserAgent(const char** retstring) {
   return res;
 }
 
-nsresult nsPluginHost::GetURL(nsISupports* pluginInst, const char* url,
-                              const char* target,
-                              nsNPAPIPluginStreamListener* streamListener,
-                              const char* altHost, const char* referrer,
-                              bool forceJSEnabled) {
-  return GetURLWithHeaders(static_cast<nsNPAPIPluginInstance*>(pluginInst), url,
-                           target, streamListener, altHost, referrer,
-                           forceJSEnabled, 0, nullptr);
-}
-
-nsresult nsPluginHost::GetURLWithHeaders(
-    nsNPAPIPluginInstance* pluginInst, const char* url, const char* target,
-    nsNPAPIPluginStreamListener* streamListener, const char* altHost,
-    const char* referrer, bool forceJSEnabled, uint32_t getHeadersLength,
-    const char* getHeaders) {
-  // we can only send a stream back to the plugin (as specified by a
-  // null target) if we also have a nsNPAPIPluginStreamListener to talk to
-  if (!target && !streamListener) {
-    return NS_ERROR_ILLEGAL_VALUE;
-  }
-
-  nsresult rv = NS_OK;
-
-  if (target) {
-    RefPtr<nsPluginInstanceOwner> owner = pluginInst->GetOwner();
-    if (owner) {
-      rv = owner->GetURL(url, target, nullptr, nullptr, 0, true);
-    }
-  }
-
-  if (streamListener) {
-    rv = NewPluginURLStream(NS_ConvertUTF8toUTF16(url), pluginInst,
-                            streamListener, nullptr, getHeaders,
-                            getHeadersLength);
-  }
-  return rv;
-}
-
-nsresult nsPluginHost::PostURL(nsISupports* pluginInst, const char* url,
-                               uint32_t postDataLen, const char* postData,
-                               const char* target,
-                               nsNPAPIPluginStreamListener* streamListener,
-                               const char* altHost, const char* referrer,
-                               bool forceJSEnabled, uint32_t postHeadersLength,
-                               const char* postHeaders) {
-  nsresult rv;
-
-  // we can only send a stream back to the plugin (as specified
-  // by a null target) if we also have a nsNPAPIPluginStreamListener
-  // to talk to also
-  if (!target && !streamListener) return NS_ERROR_ILLEGAL_VALUE;
-
-  nsNPAPIPluginInstance* instance =
-      static_cast<nsNPAPIPluginInstance*>(pluginInst);
-
-  nsCOMPtr<nsIInputStream> postStream;
-  char* dataToPost;
-  uint32_t newDataToPostLen;
-  ParsePostBufferToFixHeaders(postData, postDataLen, &dataToPost,
-                              &newDataToPostLen);
-  if (!dataToPost) return NS_ERROR_UNEXPECTED;
-
-  nsCOMPtr<nsIStringInputStream> sis =
-      do_CreateInstance("@mozilla.org/io/string-input-stream;1", &rv);
-  if (!sis) {
-    free(dataToPost);
-    return rv;
-  }
-
-  // data allocated by ParsePostBufferToFixHeaders() is managed and
-  // freed by the string stream.
-  postDataLen = newDataToPostLen;
-  sis->AdoptData(dataToPost, postDataLen);
-  postStream = sis;
-
-  if (target) {
-    RefPtr<nsPluginInstanceOwner> owner = instance->GetOwner();
-    if (owner) {
-      rv = owner->GetURL(url, target, postStream, (void*)postHeaders,
-                         postHeadersLength, true);
-    }
-  }
-
-  // if we don't have a target, just create a stream.
-  if (streamListener) {
-    rv =
-        NewPluginURLStream(NS_ConvertUTF8toUTF16(url), instance, streamListener,
-                           postStream, postHeaders, postHeadersLength);
-  }
-  return rv;
-}
-
 nsresult nsPluginHost::UnloadPlugins() {
   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsPluginHost::UnloadPlugins Called\n"));
 
@@ -579,104 +466,13 @@ nsresult nsPluginHost::UnloadPlugins() {
     sPluginTempDir->Remove(true);
     NS_RELEASE(sPluginTempDir);
   }
-  mSerializablePlugins.Clear();
-  mSerializableFakePlugins.Clear();
 
   mPluginsLoaded = false;
 
   return NS_OK;
 }
 
-void nsPluginHost::OnPluginInstanceDestroyed(nsPluginTag* aPluginTag) {
-  bool hasInstance = false;
-  for (uint32_t i = 0; i < mInstances.Length(); i++) {
-    if (TagForPlugin(mInstances[i]->GetPlugin()) == aPluginTag) {
-      hasInstance = true;
-      break;
-    }
-  }
-
-  if (!hasInstance) {
-    aPluginTag->TryUnloadPlugin(false);
-  }
-}
-
-nsresult nsPluginHost::InstantiatePluginInstance(
-    const nsACString& aMimeType, nsIURI* aURL, nsObjectLoadingContent* aContent,
-    nsPluginInstanceOwner** aOwner) {
-  NS_ENSURE_ARG_POINTER(aOwner);
-
-#ifdef PLUGIN_LOGGING
-  nsAutoCString urlSpec;
-  if (aURL) aURL->GetAsciiSpec(urlSpec);
-
-  MOZ_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
-          ("nsPluginHost::InstantiatePlugin Begin mime=%s, url=%s\n",
-           PromiseFlatCString(aMimeType).get(), urlSpec.get()));
-
-  PR_LogFlush();
-#endif
-
-  if (aMimeType.IsEmpty()) {
-    MOZ_ASSERT_UNREACHABLE("Attempting to spawn a plugin with no mime type");
-    return NS_ERROR_FAILURE;
-  }
-
-  RefPtr<nsPluginInstanceOwner> instanceOwner = new nsPluginInstanceOwner();
-  if (!instanceOwner) {
-    return NS_ERROR_OUT_OF_MEMORY;
-  }
-
-  nsCOMPtr<nsIContent> ourContent =
-      do_QueryInterface(static_cast<nsIImageLoadingContent*>(aContent));
-  nsresult rv = instanceOwner->Init(ourContent);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  nsPluginTagType tagType;
-  rv = instanceOwner->GetTagType(&tagType);
-  if (NS_FAILED(rv)) {
-    instanceOwner->Destroy();
-    return rv;
-  }
-
-  if (tagType != nsPluginTagType_Embed && tagType != nsPluginTagType_Object) {
-    instanceOwner->Destroy();
-    return NS_ERROR_FAILURE;
-  }
-
-  rv = SetUpPluginInstance(aMimeType, aURL, instanceOwner);
-  if (NS_FAILED(rv)) {
-    instanceOwner->Destroy();
-    return NS_ERROR_FAILURE;
-  }
-
-  RefPtr<nsNPAPIPluginInstance> instance = instanceOwner->GetInstance();
-
-  if (instance) {
-    CreateWidget(instanceOwner);
-  }
-
-  // At this point we consider instantiation to be successful. Do not return an
-  // error.
-  instanceOwner.forget(aOwner);
-
-#ifdef PLUGIN_LOGGING
-  nsAutoCString urlSpec2;
-  if (aURL != nullptr) aURL->GetAsciiSpec(urlSpec2);
-
-  MOZ_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
-          ("nsPluginHost::InstantiatePlugin Finished mime=%s, rv=%" PRIu32
-           ", url=%s\n",
-           PromiseFlatCString(aMimeType).get(), static_cast<uint32_t>(rv),
-           urlSpec2.get()));
-
-  PR_LogFlush();
-#endif
-
-  return NS_OK;
-}
+void nsPluginHost::OnPluginInstanceDestroyed(nsPluginTag* aPluginTag) {}
 
 nsPluginTag* nsPluginHost::FindTagForLibrary(PRLibrary* aLibrary) {
   nsPluginTag* pluginTag;
@@ -688,125 +484,6 @@ nsPluginTag* nsPluginHost::FindTagForLibrary(PRLibrary* aLibrary) {
   return nullptr;
 }
 
-nsPluginTag* nsPluginHost::TagForPlugin(nsNPAPIPlugin* aPlugin) {
-  nsPluginTag* pluginTag;
-  for (pluginTag = mPlugins; pluginTag; pluginTag = pluginTag->mNext) {
-    if (pluginTag->mPlugin == aPlugin) {
-      return pluginTag;
-    }
-  }
-  // a plugin should never exist without a corresponding tag
-  NS_ERROR("TagForPlugin has failed");
-  return nullptr;
-}
-
-nsresult nsPluginHost::SetUpPluginInstance(const nsACString& aMimeType,
-                                           nsIURI* aURL,
-                                           nsPluginInstanceOwner* aOwner) {
-  NS_ENSURE_ARG_POINTER(aOwner);
-
-  nsresult rv = TrySetUpPluginInstance(aMimeType, aURL, aOwner);
-  if (NS_SUCCEEDED(rv)) {
-    return rv;
-  }
-
-  // If we failed to load a plugin instance we'll try again after
-  // reloading our plugin list. Only do that once per document to
-  // avoid redundant high resource usage on pages with multiple
-  // unkown instance types. We'll do that by caching the document.
-  nsCOMPtr<Document> document;
-  aOwner->GetDocument(getter_AddRefs(document));
-
-  nsCOMPtr<Document> currentdocument = do_QueryReferent(mCurrentDocument);
-  if (document == currentdocument) {
-    return rv;
-  }
-
-  mCurrentDocument = do_GetWeakReference(document);
-
-  // Don't try to set up an instance again if nothing changed.
-  if (ReloadPlugins() == NS_ERROR_PLUGINS_PLUGINSNOTCHANGED) {
-    return rv;
-  }
-
-  return TrySetUpPluginInstance(aMimeType, aURL, aOwner);
-}
-
-nsresult nsPluginHost::TrySetUpPluginInstance(const nsACString& aMimeType,
-                                              nsIURI* aURL,
-                                              nsPluginInstanceOwner* aOwner) {
-#ifdef PLUGIN_LOGGING
-  MOZ_LOG(
-      nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
-      ("nsPluginHost::TrySetupPluginInstance Begin mime=%s, owner=%p, url=%s\n",
-       PromiseFlatCString(aMimeType).get(), aOwner,
-       aURL ? aURL->GetSpecOrDefault().get() : ""));
-
-  PR_LogFlush();
-#endif
-
-#ifdef XP_WIN
-  bool changed;
-  if ((mRegKeyHKLM && NS_SUCCEEDED(mRegKeyHKLM->HasChanged(&changed)) &&
-       changed) ||
-      (mRegKeyHKCU && NS_SUCCEEDED(mRegKeyHKCU->HasChanged(&changed)) &&
-       changed)) {
-    ReloadPlugins();
-  }
-#endif
-
-  RefPtr<nsNPAPIPlugin> plugin;
-  GetPlugin(aMimeType, getter_AddRefs(plugin));
-  if (!plugin) {
-    return NS_ERROR_FAILURE;
-  }
-
-  nsPluginTag* pluginTag = FindNativePluginForType(aMimeType, true);
-
-  NS_ASSERTION(pluginTag, "Must have plugin tag here!");
-
-  plugin->GetLibrary()->SetHasLocalInstance();
-
-  RefPtr<nsNPAPIPluginInstance> instance = new nsNPAPIPluginInstance();
-
-  // This will create the owning reference. The connection must be made between
-  // the instance and the instance owner before initialization. Plugins can call
-  // into the browser during initialization.
-  aOwner->SetInstance(instance.get());
-
-  // Add the instance to the instances list before we call NPP_New so that
-  // it is "in play" before NPP_New happens. Take it out if NPP_New fails.
-  mInstances.AppendElement(instance.get());
-
-  // this should not addref the instance or owner
-  // except in some cases not Java, see bug 140931
-  // our COM pointer will free the peer
-  nsresult rv = instance->Initialize(plugin.get(), aOwner, aMimeType);
-  if (NS_FAILED(rv)) {
-    mInstances.RemoveElement(instance.get());
-    aOwner->SetInstance(nullptr);
-    return rv;
-  }
-
-  // Cancel the plugin unload timer since we are creating
-  // an instance for it.
-  if (pluginTag->mUnloadTimer) {
-    pluginTag->mUnloadTimer->Cancel();
-  }
-
-#ifdef PLUGIN_LOGGING
-  MOZ_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_BASIC,
-          ("nsPluginHost::TrySetupPluginInstance Finished mime=%s, rv=%" PRIu32
-           ", owner=%p, url=%s\n",
-           PromiseFlatCString(aMimeType).get(), static_cast<uint32_t>(rv),
-           aOwner, aURL ? aURL->GetSpecOrDefault().get() : ""));
-
-  PR_LogFlush();
-#endif
-
-  return rv;
-}
-
 bool nsPluginHost::HavePluginForType(const nsACString& aMimeType,
                                      PluginFilter aFilter) {
   bool checkEnabled = aFilter & eExcludeDisabled;
@@ -1090,57 +767,7 @@ nsPluginTag* nsPluginHost::FindNativePluginForExtension(
   return preferredPlugin;
 }
 
-static nsresult CreateNPAPIPlugin(nsPluginTag* aPluginTag,
-                                  nsNPAPIPlugin** aOutNPAPIPlugin) {
-  nsresult rv;
-  rv = nsNPAPIPlugin::CreatePlugin(aPluginTag, aOutNPAPIPlugin);
-
-  return rv;
-}
-
 nsresult nsPluginHost::EnsurePluginLoaded(nsPluginTag* aPluginTag) {
-  RefPtr<nsNPAPIPlugin> plugin = aPluginTag->mPlugin;
-  if (!plugin) {
-    nsresult rv = CreateNPAPIPlugin(aPluginTag, getter_AddRefs(plugin));
-    if (NS_FAILED(rv)) {
-      return rv;
-    }
-    aPluginTag->mPlugin = plugin;
-  }
-  return NS_OK;
-}
-
-nsresult nsPluginHost::GetPluginForContentProcess(uint32_t aPluginId,
-                                                  nsNPAPIPlugin** aPlugin) {
-  AUTO_PROFILER_LABEL("nsPluginHost::GetPluginForContentProcess", OTHER);
-  MOZ_ASSERT(XRE_IsParentProcess());
-
-  // If plugins haven't been scanned yet, do so now
-  LoadPlugins();
-
-  nsPluginTag* pluginTag = PluginWithId(aPluginId);
-  if (pluginTag) {
-    // When setting up a bridge, double check with chrome to see if this plugin
-    // is blocked hard. Note this does not protect against vulnerable plugins
-    // that the user has explicitly allowed. :(
-    if (pluginTag->IsBlocklisted()) {
-      return NS_ERROR_PLUGIN_BLOCKLISTED;
-    }
-
-    nsresult rv = EnsurePluginLoaded(pluginTag);
-    if (NS_FAILED(rv)) {
-      return rv;
-    }
-
-    // We only get here if a content process doesn't have a PluginModuleParent
-    // for the given plugin already. Therefore, this counter is counting the
-    // number of outstanding PluginModuleParents for the plugin, excluding the
-    // one from the chrome process.
-    pluginTag->mContentProcessRunningCount++;
-    NS_ADDREF(*aPlugin = pluginTag->mPlugin);
-    return NS_OK;
-  }
-
   return NS_ERROR_FAILURE;
 }
 
@@ -1184,47 +811,6 @@ void nsPluginHost::NotifyContentModuleDestroyed(uint32_t aPluginId) {
   NS_DispatchToMainThread(runnable);
 }
 
-nsresult nsPluginHost::GetPlugin(const nsACString& aMimeType,
-                                 nsNPAPIPlugin** aPlugin) {
-  nsresult rv = NS_ERROR_FAILURE;
-  *aPlugin = nullptr;
-
-  // If plugins haven't been scanned yet, do so now
-  LoadPlugins();
-
-  nsPluginTag* pluginTag = FindNativePluginForType(aMimeType, true);
-  if (pluginTag) {
-    rv = NS_OK;
-    PLUGIN_LOG(
-        PLUGIN_LOG_BASIC,
-        ("nsPluginHost::GetPlugin Begin mime=%s, plugin=%s\n",
-         PromiseFlatCString(aMimeType).get(), pluginTag->FileName().get()));
-
-#ifdef DEBUG
-    if (!pluginTag->FileName().IsEmpty())
-      printf("For %s found plugin %s\n", PromiseFlatCString(aMimeType).get(),
-             pluginTag->FileName().get());
-#endif
-
-    rv = EnsurePluginLoaded(pluginTag);
-    if (NS_FAILED(rv)) {
-      return rv;
-    }
-
-    NS_ADDREF(*aPlugin = pluginTag->mPlugin);
-    return NS_OK;
-  }
-
-  PLUGIN_LOG(
-      PLUGIN_LOG_NORMAL,
-      ("nsPluginHost::GetPlugin End mime=%s, rv=%" PRIu32
-       ", plugin=%p name=%s\n",
-       PromiseFlatCString(aMimeType).get(), static_cast<uint32_t>(rv), *aPlugin,
-       (pluginTag ? pluginTag->FileName().get() : "(not found)")));
-
-  return rv;
-}
-
 // Normalize 'host' to ACE.
 nsresult nsPluginHost::NormalizeHostname(nsCString& host) {
   if (IsAscii(host)) {
@@ -1422,231 +1008,20 @@ nsPluginHost::GetFakePlugin(const nsACString& aMimeType,
   return NS_ERROR_NOT_AVAILABLE;
 }
 
-#define ClearDataFromSitesClosure_CID                \
-  {                                                  \
-    0x9fb21761, 0x2403, 0x41ad, {                    \
-      0x9e, 0xfd, 0x36, 0x7e, 0xc4, 0x4f, 0xa4, 0x5e \
-    }                                                \
-  }
-
-// Class to hold all the data we need need for IterateMatchesAndClear and
-// ClearDataFromSites
-class ClearDataFromSitesClosure : public nsIClearSiteDataCallback,
-                                  public nsIGetSitesWithDataCallback {
- public:
-  ClearDataFromSitesClosure(nsIPluginTag* plugin, const nsACString& domain,
-                            uint64_t flags, int64_t maxAge,
-                            nsCOMPtr<nsIClearSiteDataCallback> callback,
-                            nsPluginHost* host)
-      : domain(domain),
-        callback(callback),
-        tag(plugin),
-        flags(flags),
-        maxAge(maxAge),
-        host(host) {}
-  NS_DECL_ISUPPORTS
-
-  // Callback from NPP_ClearSiteData, continue to iterate the matches and clear
-  NS_IMETHOD Callback(nsresult rv) override {
-    if (NS_FAILED(rv)) {
-      callback->Callback(rv);
-      return NS_OK;
-    }
-    if (!matches.Length()) {
-      callback->Callback(NS_OK);
-      return NS_OK;
-    }
-
-    const nsCString match(matches[0]);
-    matches.RemoveElement(match);
-    PluginLibrary* library =
-        static_cast<nsPluginTag*>(tag)->mPlugin->GetLibrary();
-    rv = library->NPP_ClearSiteData(match.get(), flags, maxAge, this);
-    if (NS_FAILED(rv)) {
-      callback->Callback(rv);
-      return NS_OK;
-    }
-    return NS_OK;
-  }
-
-  // Callback from NPP_GetSitesWithData, kick the iteration off to clear the
-  // data
-  NS_IMETHOD SitesWithData(nsTArray<nsCString>& sites) override {
-    // Enumerate the sites and build a list of matches.
-    nsresult rv = host->EnumerateSiteData(domain, sites, matches, false);
-    Callback(rv);
-    return NS_OK;
-  }
-
-  nsCString domain;
-  nsCOMPtr<nsIClearSiteDataCallback> callback;
-  nsTArray<nsCString> matches;
-  nsIPluginTag* tag;
-  uint64_t flags;
-  int64_t maxAge;
-  nsPluginHost* host;
-  NS_DECLARE_STATIC_IID_ACCESSOR(ClearDataFromSitesClosure_CID)
- private:
-  virtual ~ClearDataFromSitesClosure() = default;
-};
-
-NS_DEFINE_STATIC_IID_ACCESSOR(ClearDataFromSitesClosure,
-                              ClearDataFromSitesClosure_CID)
-
-NS_IMPL_ADDREF(ClearDataFromSitesClosure)
-NS_IMPL_RELEASE(ClearDataFromSitesClosure)
-
-NS_INTERFACE_MAP_BEGIN(ClearDataFromSitesClosure)
-  NS_INTERFACE_MAP_ENTRY(nsIClearSiteDataCallback)
-  NS_INTERFACE_MAP_ENTRY(nsIGetSitesWithDataCallback)
-  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIClearSiteDataCallback)
-NS_INTERFACE_MAP_END
-
 // FIXME-jsplugins what should this do for fake plugins?
 NS_IMETHODIMP
 nsPluginHost::ClearSiteData(nsIPluginTag* plugin, const nsACString& domain,
                             uint64_t flags, int64_t maxAge,
                             nsIClearSiteDataCallback* callbackFunc) {
-  nsCOMPtr<nsIClearSiteDataCallback> callback(callbackFunc);
-  // maxAge must be either a nonnegative integer or -1.
-  NS_ENSURE_ARG(maxAge >= 0 || maxAge == -1);
-
-  // Caller may give us a tag object that is no longer live.
-  if (!IsLiveTag(plugin)) {
-    return NS_ERROR_NOT_AVAILABLE;
-  }
-
-  nsPluginTag* tag = static_cast<nsPluginTag*>(plugin);
-
-  if (!tag->IsEnabled()) {
-    return NS_ERROR_NOT_AVAILABLE;
-  }
-
-  // We only ensure support for clearing Flash site data for now.
-  // We will also attempt to clear data for any plugin that happens
-  // to be loaded already.
-  if (!tag->mIsFlashPlugin && !tag->mPlugin) {
-    return NS_ERROR_FAILURE;
-  }
-
-  // Make sure the plugin is loaded.
-  nsresult rv = EnsurePluginLoaded(tag);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  PluginLibrary* library = tag->mPlugin->GetLibrary();
-
-  // If 'domain' is the null string, clear everything.
-  if (domain.IsVoid()) {
-    return library->NPP_ClearSiteData(nullptr, flags, maxAge, callback);
-  }
-  nsCOMPtr<nsIGetSitesWithDataCallback> closure(new ClearDataFromSitesClosure(
-      plugin, domain, flags, maxAge, callback, this));
-  rv = library->NPP_GetSitesWithData(closure);
-  NS_ENSURE_SUCCESS(rv, rv);
-  return NS_OK;
+  return NS_ERROR_FAILURE;
 }
 
-#define GetSitesClosure_CID                          \
-  {                                                  \
-    0x4c9268ac, 0x2fd1, 0x4f2a, {                    \
-      0x9a, 0x10, 0x7a, 0x09, 0xf1, 0xb7, 0x60, 0x3a \
-    }                                                \
-  }
-
-// Closure to contain the data needed to handle the callback from
-// NPP_GetSitesWithData
-class GetSitesClosure : public nsIGetSitesWithDataCallback {
- public:
-  NS_DECL_ISUPPORTS
-  GetSitesClosure(const nsACString& domain, nsPluginHost* host)
-      : domain(domain),
-        host(host),
-        result{false},
-        keepWaiting(true),
-        retVal(NS_ERROR_NOT_INITIALIZED) {}
-
-  NS_IMETHOD SitesWithData(nsTArray<nsCString>& sites) override {
-    retVal = HandleGetSites(sites);
-    keepWaiting = false;
-    return NS_OK;
-  }
-
-  nsresult HandleGetSites(nsTArray<nsCString>& sites) {
-    // If there's no data, we're done.
-    if (sites.IsEmpty()) {
-      result = false;
-      return NS_OK;
-    }
-
-    // If 'domain' is the null string, and there's data for at least one site,
-    // we're done.
-    if (domain.IsVoid()) {
-      result = true;
-      return NS_OK;
-    }
-
-    // Enumerate the sites and determine if there's a match.
-    nsTArray<nsCString> matches;
-    nsresult rv = host->EnumerateSiteData(domain, sites, matches, true);
-    NS_ENSURE_SUCCESS(rv, rv);
-
-    result = !matches.IsEmpty();
-    return NS_OK;
-  }
-
-  nsCString domain;
-  RefPtr<nsPluginHost> host;
-  bool result;
-  bool keepWaiting;
-  nsresult retVal;
-  NS_DECLARE_STATIC_IID_ACCESSOR(GetSitesClosure_CID)
- private:
-  virtual ~GetSitesClosure() = default;
-};
-
-NS_DEFINE_STATIC_IID_ACCESSOR(GetSitesClosure, GetSitesClosure_CID)
-
-NS_IMPL_ISUPPORTS(GetSitesClosure, GetSitesClosure, nsIGetSitesWithDataCallback)
-
 // This will spin the event loop while waiting on an async
 // call to GetSitesWithData
 NS_IMETHODIMP
 nsPluginHost::SiteHasData(nsIPluginTag* plugin, const nsACString& domain,
                           bool* result) {
-  // Caller may give us a tag object that is no longer live.
-  if (!IsLiveTag(plugin)) {
-    return NS_ERROR_NOT_AVAILABLE;
-  }
-
-  // FIXME-jsplugins audit casts
-  nsPluginTag* tag = static_cast<nsPluginTag*>(plugin);
-
-  // We only ensure support for clearing Flash site data for now.
-  // We will also attempt to clear data for any plugin that happens
-  // to be loaded already.
-  if (!tag->mIsFlashPlugin && !tag->mPlugin) {
-    return NS_ERROR_FAILURE;
-  }
-
-  // Make sure the plugin is loaded.
-  nsresult rv = EnsurePluginLoaded(tag);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  PluginLibrary* library = tag->mPlugin->GetLibrary();
-
-  // Get the list of sites from the plugin
-  nsCOMPtr<GetSitesClosure> closure(new GetSitesClosure(domain, this));
-  rv = library->NPP_GetSitesWithData(
-      nsCOMPtr<nsIGetSitesWithDataCallback>(closure));
-  NS_ENSURE_SUCCESS(rv, rv);
-  // Spin the event loop while we wait for the async call to GetSitesWithData
-  SpinEventLoopUntil([&]() { return !closure->keepWaiting; });
-  *result = closure->result;
-  return closure->retVal;
+  return NS_ERROR_FAILURE;
 }
 
 nsPluginHost::SpecialType nsPluginHost::GetSpecialType(
@@ -1718,8 +1093,6 @@ void nsPluginHost::AddPluginTag(nsPluginTag* aPluginTag) {
   }
 }
 
-typedef NS_NPAPIPLUGIN_CALLBACK(char*, NP_GETMIMEDESCRIPTION)(void);
-
 void nsPluginHost::UpdatePluginBlocklistState(nsPluginTag* aPluginTag,
                                               bool aShouldSoftblock) {
   nsCOMPtr<nsIBlocklistService> blocklist =
@@ -1779,154 +1152,14 @@ nsresult nsPluginHost::LoadPlugins() { return NS_OK; }
 
 void nsPluginHost::FindingFinished() {}
 
-nsresult nsPluginHost::SetPluginsInContent(
-    uint32_t aPluginEpoch, nsTArray<mozilla::plugins::PluginTag>& aPlugins,
-    nsTArray<mozilla::plugins::FakePluginTag>& aFakePlugins) {
-  MOZ_ASSERT(XRE_IsContentProcess());
-
-  nsTArray<PluginTag> plugins;
-
-  nsTArray<FakePluginTag> fakePlugins;
-
-  if (aPluginEpoch != ChromeEpochForContent()) {
-    // Since we know we're going to be repopulating the lists anyways,
-    // clear out all old entries.
-    ClearNonRunningPlugins();
-
-    SetChromeEpochForContent(aPluginEpoch);
-
-    for (auto tag : aPlugins) {
-      // Don't add the same plugin again.
-      if (nsPluginTag* existing = PluginWithId(tag.id())) {
-        UpdateInMemoryPluginInfo(existing);
-        existing->SetBlocklistState(tag.blocklistState());
-        continue;
-      }
-
-      nsPluginTag* pluginTag = new nsPluginTag(
-          tag.id(), tag.name().get(), tag.description().get(),
-          tag.filename().get(),
-          "",  // aFullPath
-          tag.version().get(), tag.mimeTypes().Clone(),
-          tag.mimeDescriptions().Clone(), tag.extensions().Clone(),
-          tag.isFlashPlugin(), tag.supportsAsyncRender(),
-          tag.lastModifiedTime(), tag.sandboxLevel(), tag.blocklistState());
-      AddPluginTag(pluginTag);
-    }
-
-    for (const auto& tag : aFakePlugins) {
-      // Don't add the same plugin again.
-      for (const auto& existingTag : mFakePlugins) {
-        if (existingTag->Id() == tag.id()) {
-          continue;
-        }
-      }
-
-      RefPtr<nsFakePluginTag> pluginTag =
-          *mFakePlugins.AppendElement(new nsFakePluginTag(
-              tag.id(), mozilla::ipc::DeserializeURI(tag.handlerURI()),
-              tag.name().get(), tag.description().get(), tag.mimeTypes(),
-              tag.mimeDescriptions(), tag.extensions(), tag.niceName(),
-              tag.sandboxScript()));
-      nsAutoCString disableFullPage;
-      Preferences::GetCString(kPrefDisableFullPage, disableFullPage);
-      for (uint32_t i = 0; i < pluginTag->MimeTypes().Length(); i++) {
-        if (!IsTypeInList(pluginTag->MimeTypes()[i], disableFullPage)) {
-          RegisterWithCategoryManager(pluginTag->MimeTypes()[i],
-                                      ePluginRegister);
-        }
-      }
-    }
-
-    nsCOMPtr<nsIObserverService> obsService =
-        mozilla::services::GetObserverService();
-    if (obsService) {
-      obsService->NotifyObservers(nullptr, "plugins-list-updated", nullptr);
-    }
-  }
-
-  mPluginsLoaded = true;
-  return NS_OK;
-}
-
 nsresult nsPluginHost::UpdateCachedSerializablePluginList() {
-  nsTArray<nsCOMPtr<nsIInternalPluginTag>> plugins;
-  GetPlugins(plugins, true);
-  mSerializablePlugins.Clear();
-  mSerializableFakePlugins.Clear();
-
-  for (size_t i = 0; i < plugins.Length(); i++) {
-    nsCOMPtr<nsIInternalPluginTag> basetag = plugins[i];
-
-    nsCOMPtr<nsIFakePluginTag> faketag = do_QueryInterface(basetag);
-    if (faketag) {
-      /// FIXME-jsplugins - We need to add a nsIInternalPluginTag->AsNative() to
-      /// avoid this hacky static cast
-      nsFakePluginTag* tag = static_cast<nsFakePluginTag*>(basetag.get());
-      mozilla::ipc::URIParams handlerURI;
-      SerializeURI(tag->HandlerURI(), handlerURI);
-      mSerializableFakePlugins.AppendElement(FakePluginTag(
-          tag->Id(), handlerURI, tag->Name(), tag->Description(),
-          tag->MimeTypes(), tag->MimeDescriptions(), tag->Extensions(),
-          tag->GetNiceFileName(), tag->SandboxScript()));
-      continue;
-    }
-
-    /// FIXME-jsplugins - We need to cleanup the various plugintag classes
-    /// to be more sane and avoid this dance
-    nsPluginTag* tag = static_cast<nsPluginTag*>(basetag.get());
-
-    uint32_t blocklistState;
-    if (NS_WARN_IF(NS_FAILED(tag->GetBlocklistState(&blocklistState)))) {
-      return NS_ERROR_FAILURE;
-    }
-
-    mSerializablePlugins.AppendElement(PluginTag(
-        tag->mId, tag->Name(), tag->Description(), tag->MimeTypes(),
-        tag->MimeDescriptions(), tag->Extensions(), tag->mIsFlashPlugin,
-        tag->mSupportsAsyncRender, tag->FileName(), tag->Version(),
-        tag->mLastModifiedTime, tag->mSandboxLevel, blocklistState));
-  }
-  return NS_OK;
+  return NS_ERROR_FAILURE;
 }
 
-nsresult nsPluginHost::BroadcastPluginsToContent() {
-  MOZ_ASSERT(XRE_IsParentProcess());
-
-  // Load plugins so that the epoch is correct.
-  nsresult rv = LoadPlugins();
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  rv = UpdateCachedSerializablePluginList();
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  uint32_t newPluginEpoch = ChromeEpoch();
-
-  nsTArray<dom::ContentParent*> parents;
-  dom::ContentParent::GetAll(parents);
-  for (auto p : parents) {
-    Unused << p->SendSetPluginList(newPluginEpoch, mSerializablePlugins,
-                                   mSerializableFakePlugins);
-  }
-  return NS_OK;
-}
+nsresult nsPluginHost::BroadcastPluginsToContent() { return NS_ERROR_FAILURE; }
 
 nsresult nsPluginHost::SendPluginsToContent(dom::ContentParent* parent) {
-  MOZ_ASSERT(XRE_IsParentProcess());
-  MOZ_ASSERT(parent);
-  // Load plugins so that the epoch is correct.
-  nsresult rv = LoadPlugins();
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  Unused << parent->SendSetPluginList(ChromeEpoch(), mSerializablePlugins,
-                                      mSerializableFakePlugins);
-  return NS_OK;
+  return NS_ERROR_FAILURE;
 }
 
 void nsPluginHost::UpdateInMemoryPluginInfo(nsPluginTag* aPluginTag) {
@@ -2006,121 +1239,6 @@ void nsPluginHost::RegisterWithCategoryManager(const nsCString& aMimeType,
   }
 }
 
-nsresult nsPluginHost::NewPluginURLStream(
-    const nsString& aURL, nsNPAPIPluginInstance* aInstance,
-    nsNPAPIPluginStreamListener* aListener, nsIInputStream* aPostStream,
-    const char* aHeadersData, uint32_t aHeadersDataLen) {
-  nsCOMPtr<nsIURI> url;
-  nsAutoString absUrl;
-
-  if (aURL.Length() <= 0) return NS_OK;
-
-  // get the base URI for the plugin to create an absolute url
-  // in case aURL is relative
-  RefPtr<nsPluginInstanceOwner> owner = aInstance->GetOwner();
-  if (owner) {
-    NS_MakeAbsoluteURI(absUrl, aURL, owner->GetBaseURI());
-  }
-
-  if (absUrl.IsEmpty()) absUrl.Assign(aURL);
-
-  nsresult rv = NS_NewURI(getter_AddRefs(url), absUrl);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  RefPtr<nsPluginStreamListenerPeer> listenerPeer =
-      new nsPluginStreamListenerPeer();
-  NS_ENSURE_TRUE(listenerPeer, NS_ERROR_OUT_OF_MEMORY);
-
-  rv = listenerPeer->Initialize(url, aInstance, aListener);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  RefPtr<dom::Element> element;
-  nsCOMPtr<Document> doc;
-  if (owner) {
-    owner->GetDOMElement(getter_AddRefs(element));
-    owner->GetDocument(getter_AddRefs(doc));
-  }
-
-  NS_ENSURE_TRUE(element, NS_ERROR_FAILURE);
-
-  nsCOMPtr<nsIChannel> channel;
-  // @arg loadgroup:
-  // do not add this internal plugin's channel on the
-  // load group otherwise this channel could be canceled
-  // form |nsDocShell::OnLinkClickSync| bug 166613
-  rv = NS_NewChannel(
-      getter_AddRefs(channel), url, element,
-      nsILoadInfo::SEC_ALLOW_CROSS_ORIGIN_INHERITS_SEC_CONTEXT |
-          nsILoadInfo::SEC_FORCE_INHERIT_PRINCIPAL,
-      nsIContentPolicy::TYPE_OBJECT_SUBREQUEST,
-      nullptr,  // aPerformanceStorage
-      nullptr,  // aLoadGroup
-      listenerPeer,
-      nsIRequest::LOAD_NORMAL | nsIChannel::LOAD_BYPASS_SERVICE_WORKER);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  if (doc) {
-    // And if it's a script allow it to execute against the
-    // document's script context.
-    nsCOMPtr<nsIScriptChannel> scriptChannel(do_QueryInterface(channel));
-    if (scriptChannel) {
-      scriptChannel->SetExecutionPolicy(nsIScriptChannel::EXECUTE_NORMAL);
-      // Plug-ins seem to depend on javascript: URIs running synchronously
-      scriptChannel->SetExecuteAsync(false);
-    }
-  }
-
-  // deal with headers and post data
-  nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
-  if (httpChannel) {
-    if (!aPostStream) {
-      // Only set the Referer header for GET requests because IIS throws
-      // errors about malformed requests if we include it in POSTs. See
-      // bug 724465.
-      nsCOMPtr<nsIURI> referer;
-      dom::ReferrerPolicy referrerPolicy = dom::ReferrerPolicy::_empty;
-
-      nsCOMPtr<nsIObjectLoadingContent> olc = do_QueryInterface(element);
-      if (olc) olc->GetSrcURI(getter_AddRefs(referer));
-
-      if (!referer) {
-        if (!doc) {
-          return NS_ERROR_FAILURE;
-        }
-        referer = doc->GetDocumentURIAsReferrer();
-        referrerPolicy = doc->GetReferrerPolicy();
-      }
-      nsCOMPtr<nsIReferrerInfo> referrerInfo =
-          new dom::ReferrerInfo(referer, referrerPolicy);
-      rv = httpChannel->SetReferrerInfoWithoutClone(referrerInfo);
-      NS_ENSURE_SUCCESS(rv, rv);
-    }
-
-    if (aPostStream) {
-      // XXX it's a bit of a hack to rewind the postdata stream
-      // here but it has to be done in case the post data is
-      // being reused multiple times.
-      nsCOMPtr<nsISeekableStream> postDataSeekable(
-          do_QueryInterface(aPostStream));
-      if (postDataSeekable)
-        postDataSeekable->Seek(nsISeekableStream::NS_SEEK_SET, 0);
-
-      nsCOMPtr<nsIUploadChannel> uploadChannel(do_QueryInterface(httpChannel));
-      NS_ASSERTION(uploadChannel, "http must support nsIUploadChannel");
-
-      uploadChannel->SetUploadStream(aPostStream, ""_ns, -1);
-    }
-
-    if (aHeadersData) {
-      rv = AddHeadersToChannel(aHeadersData, aHeadersDataLen, httpChannel);
-      NS_ENSURE_SUCCESS(rv, rv);
-    }
-  }
-  rv = channel->AsyncOpen(listenerPeer);
-  if (NS_SUCCEEDED(rv)) listenerPeer->TrackRequest(channel);
-  return rv;
-}
-
 nsresult nsPluginHost::AddHeadersToChannel(const char* aHeadersData,
                                            uint32_t aHeadersDataLen,
                                            nsIChannel* aGenericChannel) {
@@ -2173,76 +1291,13 @@ nsresult nsPluginHost::AddHeadersToChannel(const char* aHeadersData,
 }
 
 nsresult nsPluginHost::StopPluginInstance(nsNPAPIPluginInstance* aInstance) {
-  AUTO_PROFILER_LABEL("nsPluginHost::StopPluginInstance", OTHER);
-  if (PluginDestructionGuard::DelayDestroy(aInstance)) {
-    return NS_OK;
-  }
-
-  PLUGIN_LOG(
-      PLUGIN_LOG_NORMAL,
-      ("nsPluginHost::StopPluginInstance called instance=%p\n", aInstance));
-
-  if (aInstance->HasStartedDestroying()) {
-    return NS_OK;
-  }
-
-  Telemetry::AutoTimer<Telemetry::PLUGIN_SHUTDOWN_MS> timer;
-  aInstance->Stop();
-
-  // if the instance does not want to be 'cached' just remove it
-  bool doCache = aInstance->ShouldCache();
-  if (doCache) {
-    // try to get the max cached instances from a pref or use default
-    uint32_t cachedInstanceLimit = Preferences::GetUint(
-        NS_PREF_MAX_NUM_CACHED_INSTANCES, DEFAULT_NUMBER_OF_STOPPED_INSTANCES);
-    if (StoppedInstanceCount() >= cachedInstanceLimit) {
-      nsNPAPIPluginInstance* oldestInstance = FindOldestStoppedInstance();
-      if (oldestInstance) {
-        nsPluginTag* pluginTag = TagForPlugin(oldestInstance->GetPlugin());
-        oldestInstance->Destroy();
-        mInstances.RemoveElement(oldestInstance);
-        // TODO: Remove this check once bug 752422 was investigated
-        if (pluginTag) {
-          OnPluginInstanceDestroyed(pluginTag);
-        }
-      }
-    }
-  } else {
-    nsPluginTag* pluginTag = TagForPlugin(aInstance->GetPlugin());
-    aInstance->Destroy();
-    mInstances.RemoveElement(aInstance);
-    // TODO: Remove this check once bug 752422 was investigated
-    if (pluginTag) {
-      OnPluginInstanceDestroyed(pluginTag);
-    }
-  }
-
-  return NS_OK;
+  return NS_ERROR_FAILURE;
 }
 
 nsresult nsPluginHost::NewPluginStreamListener(
     nsIURI* aURI, nsNPAPIPluginInstance* aInstance,
     nsIStreamListener** aStreamListener) {
-  NS_ENSURE_ARG_POINTER(aURI);
-  NS_ENSURE_ARG_POINTER(aStreamListener);
-
-  RefPtr<nsPluginStreamListenerPeer> listener =
-      new nsPluginStreamListenerPeer();
-  nsresult rv = listener->Initialize(aURI, aInstance, nullptr);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  listener.forget(aStreamListener);
-
-  return NS_OK;
-}
-
-void nsPluginHost::CreateWidget(nsPluginInstanceOwner* aOwner) {
-  aOwner->CreateWidget();
-
-  // If we've got a native window, the let the plugin know about it.
-  aOwner->CallSetWindow();
+  return NS_ERROR_FAILURE;
 }
 
 NS_IMETHODIMP nsPluginHost::Observe(nsISupports* aSubject, const char* aTopic,
@@ -2426,37 +1481,14 @@ nsresult nsPluginHost::ParsePostBufferToFixHeaders(const char* inPostData,
   return NS_OK;
 }
 
-nsresult nsPluginHost::NewPluginNativeWindow(
-    nsPluginNativeWindow** aPluginNativeWindow) {
-  return PLUG_NewPluginNativeWindow(aPluginNativeWindow);
-}
-
 nsresult nsPluginHost::GetPluginName(nsNPAPIPluginInstance* aPluginInstance,
                                      const char** aPluginName) {
-  nsNPAPIPluginInstance* instance =
-      static_cast<nsNPAPIPluginInstance*>(aPluginInstance);
-  if (!instance) return NS_ERROR_FAILURE;
-
-  nsNPAPIPlugin* plugin = instance->GetPlugin();
-  if (!plugin) return NS_ERROR_FAILURE;
-
-  *aPluginName = TagForPlugin(plugin)->Name().get();
-
-  return NS_OK;
+  return NS_ERROR_FAILURE;
 }
 
 nsresult nsPluginHost::GetPluginTagForInstance(
     nsNPAPIPluginInstance* aPluginInstance, nsIPluginTag** aPluginTag) {
-  NS_ENSURE_ARG_POINTER(aPluginInstance);
-  NS_ENSURE_ARG_POINTER(aPluginTag);
-
-  nsNPAPIPlugin* plugin = aPluginInstance->GetPlugin();
-  if (!plugin) return NS_ERROR_FAILURE;
-
-  *aPluginTag = TagForPlugin(plugin);
-
-  NS_ADDREF(*aPluginTag);
-  return NS_OK;
+  return NS_ERROR_FAILURE;
 }
 
 NS_IMETHODIMP nsPluginHost::Notify(nsITimer* timer) {
@@ -2522,77 +1554,6 @@ static void CheckForDisabledWindows() {
 }
 #endif
 
-void nsPluginHost::PluginCrashed(nsNPAPIPlugin* aPlugin,
-                                 const nsAString& aPluginDumpID,
-                                 const nsACString& aAdditionalMinidumps) {
-  nsPluginTag* crashedPluginTag = TagForPlugin(aPlugin);
-  MOZ_ASSERT(crashedPluginTag);
-
-  // Notify the app's observer that a plugin crashed so it can submit
-  // a crashreport.
-  bool submittedCrashReport = false;
-  nsCOMPtr<nsIObserverService> obsService =
-      mozilla::services::GetObserverService();
-  nsCOMPtr<nsIWritablePropertyBag2> propbag =
-      do_CreateInstance("@mozilla.org/hash-property-bag;1");
-  if (obsService && propbag) {
-    uint32_t runID = 0;
-    PluginLibrary* library = aPlugin->GetLibrary();
-
-    if (!NS_WARN_IF(!library)) {
-      library->GetRunID(&runID);
-    }
-    propbag->SetPropertyAsUint32(u"runID"_ns, runID);
-
-    nsCString pluginName;
-    crashedPluginTag->GetName(pluginName);
-    propbag->SetPropertyAsAString(u"pluginName"_ns,
-                                  NS_ConvertUTF8toUTF16(pluginName));
-    propbag->SetPropertyAsAString(u"pluginDumpID"_ns, aPluginDumpID);
-    propbag->SetPropertyAsACString(u"additionalMinidumps"_ns,
-                                   aAdditionalMinidumps);
-    propbag->SetPropertyAsBool(u"submittedCrashReport"_ns,
-                               submittedCrashReport);
-    obsService->NotifyObservers(propbag, "plugin-crashed", nullptr);
-    // see if an observer submitted a crash report.
-    propbag->GetPropertyAsBool(u"submittedCrashReport"_ns,
-                               &submittedCrashReport);
-  }
-
-  // Invalidate each nsPluginInstanceTag for the crashed plugin
-
-  for (uint32_t i = mInstances.Length(); i > 0; i--) {
-    nsNPAPIPluginInstance* instance = mInstances[i - 1];
-    if (instance->GetPlugin() == aPlugin) {
-      // notify the content node (nsIObjectLoadingContent) that the
-      // plugin has crashed
-      RefPtr<dom::Element> domElement;
-      instance->GetDOMElement(getter_AddRefs(domElement));
-      nsCOMPtr<nsIObjectLoadingContent> objectContent(
-          do_QueryInterface(domElement));
-      if (objectContent) {
-        objectContent->PluginCrashed(crashedPluginTag, aPluginDumpID,
-                                     submittedCrashReport);
-      }
-
-      instance->Destroy();
-      mInstances.RemoveElement(instance);
-      OnPluginInstanceDestroyed(crashedPluginTag);
-    }
-  }
-
-  // Only after all instances have been invalidated is it safe to null
-  // out nsPluginTag.mPlugin. The next time we try to create an
-  // instance of this plugin we reload it (launch a new plugin process).
-
-  crashedPluginTag->mPlugin = nullptr;
-  crashedPluginTag->mContentProcessRunningCount = 0;
-
-#ifdef XP_WIN
-  CheckForDisabledWindows();
-#endif
-}
-
 nsNPAPIPluginInstance* nsPluginHost::FindInstance(const char* mimetype) {
   for (uint32_t i = 0; i < mInstances.Length(); i++) {
     nsNPAPIPluginInstance* instance = mInstances[i];
@@ -2637,35 +1598,7 @@ nsTArray<RefPtr<nsNPAPIPluginInstance>>* nsPluginHost::InstanceArray() {
   return &mInstances;
 }
 
-void nsPluginHost::DestroyRunningInstances(nsPluginTag* aPluginTag) {
-  for (int32_t i = mInstances.Length(); i > 0; i--) {
-    nsNPAPIPluginInstance* instance = mInstances[i - 1];
-    if (instance->IsRunning() &&
-        (!aPluginTag || aPluginTag == TagForPlugin(instance->GetPlugin()))) {
-      instance->SetWindow(nullptr);
-      instance->Stop();
-
-      // Get rid of all the instances without the possibility of caching.
-      nsPluginTag* pluginTag = TagForPlugin(instance->GetPlugin());
-      instance->SetWindow(nullptr);
-
-      RefPtr<dom::Element> domElement;
-      instance->GetDOMElement(getter_AddRefs(domElement));
-      nsCOMPtr<nsIObjectLoadingContent> objectContent =
-          do_QueryInterface(domElement);
-
-      instance->Destroy();
-
-      mInstances.RemoveElement(instance);
-      OnPluginInstanceDestroyed(pluginTag);
-
-      // Notify owning content that we destroyed its plugin out from under it
-      if (objectContent) {
-        objectContent->PluginDestroyed();
-      }
-    }
-  }
-}
+void nsPluginHost::DestroyRunningInstances(nsPluginTag* aPluginTag) {}
 
 /* static */
 bool nsPluginHost::CanUsePluginForMIMEType(const nsACString& aMIMEType) {
diff --git a/dom/plugins/base/nsPluginHost.h b/dom/plugins/base/nsPluginHost.h
index e5b98b57056b4..94f8088c66c28 100644
--- a/dom/plugins/base/nsPluginHost.h
+++ b/dom/plugins/base/nsPluginHost.h
@@ -14,7 +14,6 @@
 #include "nsCOMPtr.h"
 #include "prlink.h"
 #include "nsIPluginTag.h"
-#include "nsPluginsDir.h"
 #include "nsWeakReference.h"
 #include "MainThreadUtils.h"
 #include "nsTArray.h"
@@ -26,7 +25,6 @@
 #include "nsIIDNService.h"
 #include "nsCRT.h"
 #include "mozilla/dom/PromiseNativeHandler.h"
-#include "mozilla/plugins/PluginTypes.h"
 
 #ifdef XP_WIN
 #  include <minwindef.h>
@@ -42,16 +40,11 @@ class ContentParent;
 }  // namespace dom
 }  // namespace mozilla
 
-class nsNPAPIPlugin;
 class nsIFile;
 class nsIChannel;
-class nsPluginNativeWindow;
 class nsObjectLoadingContent;
-class nsPluginInstanceOwner;
 class nsPluginUnloadRunnable;
 class nsNPAPIPluginInstance;
-class nsNPAPIPluginStreamListener;
-class nsIPluginInstanceOwner;
 class nsIInputStream;
 class nsIStreamListener;
 #ifndef npapi_h_
@@ -97,27 +90,11 @@ class nsPluginHost final : public nsIPluginHost,
   void GetPlugins(nsTArray<nsCOMPtr<nsIInternalPluginTag>>& aPluginArray,
                   bool aIncludeDisabled = false);
 
-  nsresult GetURL(nsISupports* pluginInst, const char* url, const char* target,
-                  nsNPAPIPluginStreamListener* streamListener,
-                  const char* altHost, const char* referrer,
-                  bool forceJSEnabled);
-  nsresult PostURL(nsISupports* pluginInst, const char* url,
-                   uint32_t postDataLen, const char* postData,
-                   const char* target,
-                   nsNPAPIPluginStreamListener* streamListener,
-                   const char* altHost, const char* referrer,
-                   bool forceJSEnabled, uint32_t postHeadersLength,
-                   const char* postHeaders);
-
   nsresult UserAgent(const char** retstring);
   nsresult ParsePostBufferToFixHeaders(const char* inPostData,
                                        uint32_t inPostDataLen,
                                        char** outPostData,
                                        uint32_t* outPostDataLen);
-  nsresult NewPluginNativeWindow(nsPluginNativeWindow** aPluginNativeWindow);
-
-  void AddIdleTimeTarget(nsIPluginInstanceOwner* objectFrame, bool isVisible);
-  void RemoveIdleTimeTarget(nsIPluginInstanceOwner* objectFrame);
 
   nsresult GetPluginName(nsNPAPIPluginInstance* aPluginInstance,
                          const char** aPluginName);
@@ -125,21 +102,6 @@ class nsPluginHost final : public nsIPluginHost,
   nsresult GetPluginTagForInstance(nsNPAPIPluginInstance* aPluginInstance,
                                    nsIPluginTag** aPluginTag);
 
-  nsresult NewPluginURLStream(const nsString& aURL,
-                              nsNPAPIPluginInstance* aInstance,
-                              nsNPAPIPluginStreamListener* aListener,
-                              nsIInputStream* aPostStream = nullptr,
-                              const char* aHeadersData = nullptr,
-                              uint32_t aHeadersDataLen = 0);
-
-  nsresult GetURLWithHeaders(
-      nsNPAPIPluginInstance* pluginInst, const char* url,
-      const char* target = nullptr,
-      nsNPAPIPluginStreamListener* streamListener = nullptr,
-      const char* altHost = nullptr, const char* referrer = nullptr,
-      bool forceJSEnabled = false, uint32_t getHeadersLength = 0,
-      const char* getHeaders = nullptr);
-
   nsresult AddHeadersToChannel(const char* aHeadersData,
                                uint32_t aHeadersDataLen,
                                nsIChannel* aGenericChannel);
@@ -166,9 +128,6 @@ class nsPluginHost final : public nsIPluginHost,
 
   static nsresult PostPluginUnloadEvent(PRLibrary* aLibrary);
 
-  void PluginCrashed(nsNPAPIPlugin* aPlugin, const nsAString& aPluginDumpID,
-                     const nsACString& aAdditionalMinidumps);
-
   nsNPAPIPluginInstance* FindInstance(const char* mimetype);
   nsNPAPIPluginInstance* FindOldestStoppedInstance();
   uint32_t StoppedInstanceCount();
@@ -178,37 +137,20 @@ class nsPluginHost final : public nsIPluginHost,
   // Return the tag for |aLibrary| if found, nullptr if not.
   nsPluginTag* FindTagForLibrary(PRLibrary* aLibrary);
 
-  // The last argument should be false if we already have an in-flight stream
-  // and don't need to set up a new stream.
-  nsresult InstantiatePluginInstance(const nsACString& aMimeType, nsIURI* aURL,
-                                     nsObjectLoadingContent* aContent,
-                                     nsPluginInstanceOwner** aOwner);
-
-  // Does not accept nullptr and should never fail.
-  nsPluginTag* TagForPlugin(nsNPAPIPlugin* aPlugin);
-
   nsPluginTag* PluginWithId(uint32_t aId);
 
-  nsresult GetPlugin(const nsACString& aMimeType, nsNPAPIPlugin** aPlugin);
-  nsresult GetPluginForContentProcess(uint32_t aPluginId,
-                                      nsNPAPIPlugin** aPlugin);
   void NotifyContentModuleDestroyed(uint32_t aPluginId);
 
   nsresult NewPluginStreamListener(nsIURI* aURL,
                                    nsNPAPIPluginInstance* aInstance,
                                    nsIStreamListener** aStreamListener);
 
-  void CreateWidget(nsPluginInstanceOwner* aOwner);
-
   nsresult EnumerateSiteData(const nsACString& domain,
                              const nsTArray<nsCString>& sites,
                              nsTArray<nsCString>& result, bool firstMatchOnly);
 
   nsresult UpdateCachedSerializablePluginList();
   nsresult SendPluginsToContent(mozilla::dom::ContentParent* parent);
-  nsresult SetPluginsInContent(
-      uint32_t aPluginEpoch, nsTArray<mozilla::plugins::PluginTag>& aPlugins,
-      nsTArray<mozilla::plugins::FakePluginTag>& aFakePlugins);
 
   void UpdatePluginBlocklistState(nsPluginTag* aPluginTag,
                                   bool aShouldSoftblock = false);
@@ -217,9 +159,6 @@ class nsPluginHost final : public nsIPluginHost,
   nsresult LoadPlugins();
   nsresult UnloadPlugins();
 
-  nsresult SetUpPluginInstance(const nsACString& aMimeType, nsIURI* aURL,
-                               nsPluginInstanceOwner* aOwner);
-
   friend class nsPluginUnloadRunnable;
   friend class mozilla::plugins::BlocklistPromiseHandler;
 
@@ -229,9 +168,6 @@ class nsPluginHost final : public nsIPluginHost,
   // if it is now disabled. Should only be called by the plugin tag in question
   void UpdatePluginInfo(nsPluginTag* aPluginTag);
 
-  nsresult TrySetUpPluginInstance(const nsACString& aMimeType, nsIURI* aURL,
-                                  nsPluginInstanceOwner* aOwner);
-
   // FIXME-jsplugins comment here about when things may be fake
   nsPluginTag* FindPreferredPlugin(const nsTArray<nsPluginTag*>& matches);
 
@@ -266,9 +202,6 @@ class nsPluginHost final : public nsIPluginHost,
                                             /* out */ nsACString& aMimeType,
                                             bool aCheckEnabled);
 
-  nsresult FindStoppedPluginForURL(nsIURI* aURL,
-                                   nsIPluginInstanceOwner* aOwner);
-
   nsresult BroadcastPluginsToContent();
 
   // FIXME revisit, no ns prefix
@@ -318,9 +251,6 @@ class nsPluginHost final : public nsIPluginHost,
 
   nsTArray<RefPtr<nsFakePluginTag>> mFakePlugins;
 
-  AutoTArray<mozilla::plugins::PluginTag, 1> mSerializablePlugins;
-  nsTArray<mozilla::plugins::FakePluginTag> mSerializableFakePlugins;
-
   bool mPluginsLoaded;
 
   // set by pref plugin.override_internal_types
diff --git a/dom/plugins/base/nsPluginInstanceOwner.cpp b/dom/plugins/base/nsPluginInstanceOwner.cpp
deleted file mode 100644
index 5f3bd03dee30c..0000000000000
--- a/dom/plugins/base/nsPluginInstanceOwner.cpp
+++ /dev/null
@@ -1,1724 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-// vim:set ts=2 sts=2 sw=2 et cin:
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifdef MOZ_X11
-#  include <cairo-xlib.h>
-#  include "gfxXlibSurface.h"
-/* X headers suck */
-enum { XKeyPress = KeyPress };
-#  include "mozilla/X11Util.h"
-using mozilla::DefaultXDisplay;
-#endif
-
-#include "nsPluginInstanceOwner.h"
-
-#include "gfxUtils.h"
-#include "nsIRunnable.h"
-#include "nsContentUtils.h"
-#include "nsRect.h"
-#include "nsSize.h"
-#include "nsDisplayList.h"
-#include "ImageLayers.h"
-#include "GLImages.h"
-#include "nsIPluginDocument.h"
-#include "nsIStringStream.h"
-#include "nsNetUtil.h"
-#include "mozilla/Preferences.h"
-#include "nsLayoutUtils.h"
-#include "nsViewManager.h"
-#include "nsIAppShell.h"
-#include "nsIObjectLoadingContent.h"
-#include "nsObjectLoadingContent.h"
-#include "nsAttrName.h"
-#include "nsIFocusManager.h"
-#include "nsFocusManager.h"
-#include "nsIProtocolHandler.h"
-#include "nsIScrollableFrame.h"
-#include "nsIDocShell.h"
-#include "ImageContainer.h"
-#include "GLContext.h"
-#include "nsIContentInlines.h"
-#include "mozilla/MiscEvents.h"
-#include "mozilla/MouseEvents.h"
-#include "mozilla/NullPrincipal.h"
-#include "mozilla/PresShell.h"
-#include "mozilla/ProfilerLabels.h"
-#include "mozilla/TextEvents.h"
-#include "mozilla/dom/DocumentInlines.h"
-#include "mozilla/dom/DragEvent.h"
-#include "mozilla/dom/Element.h"
-#include "mozilla/dom/Event.h"
-#include "mozilla/dom/HTMLObjectElementBinding.h"
-#include "mozilla/dom/BrowserChild.h"
-#include "mozilla/dom/WheelEventBinding.h"
-#include "nsFrameSelection.h"
-#include "PuppetWidget.h"
-#include "nsPIWindowRoot.h"
-#include "mozilla/IMEStateManager.h"
-#include "mozilla/TextComposition.h"
-#include "mozilla/AutoRestore.h"
-
-#include "nsContentCID.h"
-#include "nsWidgetsCID.h"
-static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
-
-#ifdef XP_WIN
-#  include <wtypes.h>
-#  include <winuser.h>
-#  include "mozilla/widget/WinMessages.h"
-#endif  // #ifdef XP_WIN
-
-#ifdef MOZ_WIDGET_GTK
-#  include <gdk/gdk.h>
-#  include <gtk/gtk.h>
-#endif
-
-using namespace mozilla;
-using namespace mozilla::dom;
-using namespace mozilla::layers;
-
-// special class for handeling DOM context menu events because for
-// some reason it starves other mouse events if implemented on the
-// same class
-class nsPluginDOMContextMenuListener : public nsIDOMEventListener {
-  virtual ~nsPluginDOMContextMenuListener();
-
- public:
-  explicit nsPluginDOMContextMenuListener(nsIContent* aContent);
-
-  NS_DECL_ISUPPORTS
-  NS_DECL_NSIDOMEVENTLISTENER
-
-  void Destroy(nsIContent* aContent);
-
-  nsEventStatus ProcessEvent(const WidgetGUIEvent& anEvent) {
-    return nsEventStatus_eConsumeNoDefault;
-  }
-};
-
-class AsyncPaintWaitEvent : public Runnable {
- public:
-  AsyncPaintWaitEvent(nsIContent* aContent, bool aFinished)
-      : Runnable("AsyncPaintWaitEvent"),
-        mContent(aContent),
-        mFinished(aFinished) {}
-
-  NS_IMETHOD Run() override {
-    nsContentUtils::DispatchEventOnlyToChrome(
-        mContent->OwnerDoc(), mContent,
-        mFinished ? u"MozPaintWaitFinished"_ns : u"MozPaintWait"_ns,
-        CanBubble::eYes, Cancelable::eYes);
-    return NS_OK;
-  }
-
- private:
-  nsCOMPtr<nsIContent> mContent;
-  bool mFinished;
-};
-
-void nsPluginInstanceOwner::NotifyPaintWaiter(nsDisplayListBuilder* aBuilder) {
-  // This is notification for reftests about async plugin paint start
-  if (!mWaitingForPaint && !IsUpToDate() &&
-      aBuilder->ShouldSyncDecodeImages()) {
-    nsCOMPtr<nsIContent> content = do_QueryReferent(mContent);
-    nsCOMPtr<nsIRunnable> event = new AsyncPaintWaitEvent(content, false);
-    // Run this event as soon as it's safe to do so, since listeners need to
-    // receive it immediately
-    nsContentUtils::AddScriptRunner(event);
-    mWaitingForPaint = true;
-  }
-}
-
-bool nsPluginInstanceOwner::NeedsScrollImageLayer() {
-#if defined(XP_WIN)
-  // If this is a windowed plugin and we're doing layout in the content
-  // process, force the creation of an image layer for the plugin. We'll
-  // paint to this when scrolling.
-  return XRE_IsContentProcess() && mPluginWindow &&
-         mPluginWindow->type == NPWindowTypeWindow;
-#else
-  return false;
-#endif
-}
-
-already_AddRefed<ImageContainer> nsPluginInstanceOwner::GetImageContainer() {
-  if (!mInstance) return nullptr;
-
-  RefPtr<ImageContainer> container;
-
-  if (NeedsScrollImageLayer()) {
-    // windowed plugin under e10s
-#if defined(XP_WIN)
-    mInstance->GetScrollCaptureContainer(getter_AddRefs(container));
-#endif
-  } else {
-    // async windowless rendering
-    mInstance->GetImageContainer(getter_AddRefs(container));
-  }
-
-  return container.forget();
-}
-
-void nsPluginInstanceOwner::DidComposite() {
-  if (mInstance) {
-    mInstance->DidComposite();
-  }
-}
-
-void nsPluginInstanceOwner::SetBackgroundUnknown() {
-  if (mInstance) {
-    mInstance->SetBackgroundUnknown();
-  }
-}
-
-already_AddRefed<mozilla::gfx::DrawTarget>
-nsPluginInstanceOwner::BeginUpdateBackground(const nsIntRect& aRect) {
-  nsIntRect rect = aRect;
-  RefPtr<DrawTarget> dt;
-  if (mInstance && NS_SUCCEEDED(mInstance->BeginUpdateBackground(
-                       &rect, getter_AddRefs(dt)))) {
-    return dt.forget();
-  }
-  return nullptr;
-}
-
-void nsPluginInstanceOwner::EndUpdateBackground(const nsIntRect& aRect) {
-  nsIntRect rect = aRect;
-  if (mInstance) {
-    mInstance->EndUpdateBackground(&rect);
-  }
-}
-
-bool nsPluginInstanceOwner::UseAsyncRendering() {
-#ifdef XP_MACOSX
-  if (mUseAsyncRendering) {
-    return true;
-  }
-#endif
-
-  bool isOOP;
-  bool result =
-      (mInstance && NS_SUCCEEDED(mInstance->GetIsOOP(&isOOP)) && isOOP
-#ifndef XP_MACOSX
-       && (!mPluginWindow || mPluginWindow->type == NPWindowTypeDrawable)
-#endif
-      );
-
-#ifdef XP_MACOSX
-  if (result) {
-    mUseAsyncRendering = true;
-  }
-#endif
-
-  return result;
-}
-
-nsIntSize nsPluginInstanceOwner::GetCurrentImageSize() {
-  nsIntSize size(0, 0);
-  if (mInstance) {
-    mInstance->GetImageSize(&size);
-  }
-  return size;
-}
-
-nsPluginInstanceOwner::nsPluginInstanceOwner()
-    : mPluginWindow(nullptr), mLastEventloopNestingLevel(0) {
-  // create nsPluginNativeWindow object, it is derived from NPWindow
-  // struct and allows to manipulate native window procedure
-  nsCOMPtr<nsIPluginHost> pluginHostCOM =
-      do_GetService(MOZ_PLUGIN_HOST_CONTRACTID);
-  mPluginHost = static_cast<nsPluginHost*>(pluginHostCOM.get());
-  if (mPluginHost) mPluginHost->NewPluginNativeWindow(&mPluginWindow);
-
-  mWidgetCreationComplete = false;
-#ifdef XP_MACOSX
-  mSentInitialTopLevelWindowEvent = false;
-  mLastWindowIsActive = false;
-  mLastContentFocused = false;
-  mLastScaleFactor = 1.0;
-  mShouldBlurOnActivate = false;
-#endif
-  mLastCSSZoomFactor = 1.0;
-  mContentFocused = false;
-  mWidgetVisible = true;
-  mPluginWindowVisible = false;
-  mPluginDocumentActiveState = true;
-  mLastMouseDownButtonType = -1;
-
-#ifdef XP_MACOSX
-#  ifndef NP_NO_CARBON
-  // We don't support Carbon, but it is still the default model for i386 NPAPI.
-  mEventModel = NPEventModelCarbon;
-#  else
-  mEventModel = NPEventModelCocoa;
-#  endif
-  mUseAsyncRendering = false;
-#endif
-
-  mWaitingForPaint = false;
-
-#ifdef XP_WIN
-  mGotCompositionData = false;
-  mSentStartComposition = false;
-  mPluginDidNotHandleIMEComposition = false;
-  // 3 is the Windows default for these values.
-  mWheelScrollLines = 3;
-  mWheelScrollChars = 3;
-#endif
-}
-
-nsPluginInstanceOwner::~nsPluginInstanceOwner() {
-  if (mWaitingForPaint) {
-    nsCOMPtr<nsIContent> content = do_QueryReferent(mContent);
-    if (content) {
-      // We don't care when the event is dispatched as long as it's "soon",
-      // since whoever needs it will be waiting for it.
-      nsCOMPtr<nsIRunnable> event = new AsyncPaintWaitEvent(content, true);
-      NS_DispatchToMainThread(event);
-    }
-  }
-
-  PLUG_DeletePluginNativeWindow(mPluginWindow);
-  mPluginWindow = nullptr;
-
-  if (mInstance) {
-    mInstance->SetOwner(nullptr);
-  }
-}
-
-NS_IMPL_ISUPPORTS(nsPluginInstanceOwner, nsIPluginInstanceOwner,
-                  nsIDOMEventListener, nsIPrivacyTransitionObserver,
-                  nsISupportsWeakReference)
-
-nsresult nsPluginInstanceOwner::SetInstance(nsNPAPIPluginInstance* aInstance) {
-  NS_ASSERTION(!mInstance || !aInstance,
-               "mInstance should only be set or unset!");
-
-  // If we're going to null out mInstance after use, be sure to call
-  // mInstance->SetOwner(nullptr) here, since it now won't be called
-  // from our destructor.  This fixes bug 613376.
-  if (mInstance && !aInstance) {
-    mInstance->SetOwner(nullptr);
-  }
-
-  mInstance = aInstance;
-
-  nsCOMPtr<Document> doc;
-  GetDocument(getter_AddRefs(doc));
-  if (doc) {
-    if (nsCOMPtr<nsPIDOMWindowOuter> domWindow = doc->GetWindow()) {
-      nsCOMPtr<nsIDocShell> docShell = domWindow->GetDocShell();
-      if (docShell) docShell->AddWeakPrivacyTransitionObserver(this);
-    }
-  }
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP nsPluginInstanceOwner::GetWindow(NPWindow*& aWindow) {
-  NS_ASSERTION(mPluginWindow,
-               "the plugin window object being returned is null");
-  aWindow = mPluginWindow;
-  return NS_OK;
-}
-
-NS_IMETHODIMP nsPluginInstanceOwner::GetMode(int32_t* aMode) {
-  nsCOMPtr<Document> doc;
-  nsresult rv = GetDocument(getter_AddRefs(doc));
-  nsCOMPtr<nsIPluginDocument> pDoc(do_QueryInterface(doc));
-
-  if (pDoc) {
-    *aMode = NP_FULL;
-  } else {
-    *aMode = NP_EMBED;
-  }
-
-  return rv;
-}
-
-void nsPluginInstanceOwner::GetAttributes(
-    nsTArray<MozPluginParameter>& attributes) {
-  nsCOMPtr<nsIObjectLoadingContent> content = do_QueryReferent(mContent);
-  nsObjectLoadingContent* loadingContent =
-      static_cast<nsObjectLoadingContent*>(content.get());
-
-  loadingContent->GetPluginAttributes(attributes);
-}
-
-NS_IMETHODIMP nsPluginInstanceOwner::GetDOMElement(Element** result) {
-  return CallQueryReferent(mContent.get(), result);
-}
-
-nsNPAPIPluginInstance* nsPluginInstanceOwner::GetInstance() {
-  return mInstance;
-}
-
-NS_IMETHODIMP nsPluginInstanceOwner::GetURL(
-    const char* aURL, const char* aTarget, nsIInputStream* aPostStream,
-    void* aHeadersData, uint32_t aHeadersDataLen, bool aDoCheckLoadURIChecks) {
-  nsCOMPtr<nsIContent> content = do_QueryReferent(mContent);
-  if (!content) {
-    return NS_ERROR_NULL_POINTER;
-  }
-
-  if (content->IsEditable()) {
-    return NS_OK;
-  }
-
-  Document* doc = content->GetComposedDoc();
-  if (!doc) {
-    return NS_ERROR_FAILURE;
-  }
-
-  nsPresContext* presContext = doc->GetPresContext();
-  if (!presContext) {
-    return NS_ERROR_FAILURE;
-  }
-
-  // the container of the pres context will give us the link handler
-  nsCOMPtr<nsIDocShell> container = presContext->GetDocShell();
-  NS_ENSURE_TRUE(container, NS_ERROR_FAILURE);
-
-  nsAutoString unitarget;
-  if ((0 == PL_strcmp(aTarget, "newwindow")) ||
-      (0 == PL_strcmp(aTarget, "_new"))) {
-    unitarget.AssignLiteral("_blank");
-  } else if (0 == PL_strcmp(aTarget, "_current")) {
-    unitarget.AssignLiteral("_self");
-  } else {
-    unitarget.AssignASCII(aTarget);  // XXX could this be nonascii?
-  }
-
-  // Create an absolute URL
-  nsCOMPtr<nsIURI> uri;
-  nsresult rv = NS_NewURI(getter_AddRefs(uri), aURL, GetBaseURI());
-  NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
-
-  nsCOMPtr<nsIInputStream> headersDataStream;
-  if (aPostStream && aHeadersData) {
-    if (!aHeadersDataLen) return NS_ERROR_UNEXPECTED;
-
-    nsCOMPtr<nsIStringInputStream> sis =
-        do_CreateInstance("@mozilla.org/io/string-input-stream;1");
-    if (!sis) return NS_ERROR_OUT_OF_MEMORY;
-
-    rv = sis->SetData((char*)aHeadersData, aHeadersDataLen);
-    NS_ENSURE_SUCCESS(rv, rv);
-    headersDataStream = sis;
-  }
-
-  int32_t blockPopups =
-      Preferences::GetInt("privacy.popups.disable_from_plugins");
-  AutoPopupStatePusher popupStatePusher(
-      (PopupBlocker::PopupControlState)blockPopups);
-
-  // if security checks (in particular CheckLoadURIWithPrincipal) needs
-  // to be skipped we are creating a contentPrincipal from the target URI
-  // to make sure that security checks succeed.
-  // Please note that we do not want to fall back to using the
-  // systemPrincipal, because that would also bypass ContentPolicy checks
-  // which should still be enforced.
-  nsCOMPtr<nsIPrincipal> triggeringPrincipal;
-  if (!aDoCheckLoadURIChecks) {
-    mozilla::OriginAttributes attrs =
-        BasePrincipal::Cast(content->NodePrincipal())->OriginAttributesRef();
-    triggeringPrincipal = BasePrincipal::CreateContentPrincipal(uri, attrs);
-  } else {
-    bool useParentContentPrincipal = false;
-    nsCOMPtr<nsINetUtil> netUtil = do_GetNetUtil();
-    // For protocols loadable by anyone, it doesn't matter what principal
-    // we use for the security check. However, for external URIs, we check
-    // whether the browsing context in which they load can be accessed by
-    // the triggering principal that is doing the loading, to avoid certain
-    // types of spoofing attacks. In this case, the load would never be
-    // allowed with the newly minted null principal, when all the plugin is
-    // trying to do is load a URL in its own browsing context. So we use
-    // the content principal of the plugin's node in this case.
-    netUtil->ProtocolHasFlags(uri,
-                              nsIProtocolHandler::URI_LOADABLE_BY_ANYONE |
-                                  nsIProtocolHandler::URI_DOES_NOT_RETURN_DATA,
-                              &useParentContentPrincipal);
-    if (useParentContentPrincipal) {
-      triggeringPrincipal = content->NodePrincipal();
-    } else {
-      triggeringPrincipal = NullPrincipal::CreateWithInheritedAttributes(
-          content->NodePrincipal());
-    }
-  }
-
-  nsCOMPtr<nsIContentSecurityPolicy> csp = content->GetCsp();
-
-  rv = nsDocShell::Cast(container)->OnLinkClick(
-      content, uri, unitarget, VoidString(), aPostStream, headersDataStream,
-      /* isUserTriggered */ false, /* isTrusted */ true, triggeringPrincipal,
-      csp);
-
-  return rv;
-}
-
-NS_IMETHODIMP nsPluginInstanceOwner::GetDocument(Document** aDocument) {
-  nsCOMPtr<nsIContent> content = do_QueryReferent(mContent);
-  if (!aDocument || !content) {
-    return NS_ERROR_NULL_POINTER;
-  }
-
-  // XXX sXBL/XBL2 issue: current doc or owner doc?
-  // But keep in mind bug 322414 comment 33
-  NS_ADDREF(*aDocument = content->OwnerDoc());
-  return NS_OK;
-}
-
-NS_IMETHODIMP nsPluginInstanceOwner::InvalidateRect(NPRect* invalidRect) {
-  // If our object frame has gone away, we won't be able to determine
-  // up-to-date-ness, so just fire off the event.
-  if (mWaitingForPaint) {
-    nsCOMPtr<nsIContent> content = do_QueryReferent(mContent);
-    // We don't care when the event is dispatched as long as it's "soon",
-    // since whoever needs it will be waiting for it.
-    nsCOMPtr<nsIRunnable> event = new AsyncPaintWaitEvent(content, true);
-    NS_DispatchToMainThread(event);
-    mWaitingForPaint = false;
-  }
-
-  return NS_ERROR_FAILURE;
-}
-
-NS_IMETHODIMP nsPluginInstanceOwner::InvalidateRegion(NPRegion invalidRegion) {
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-NS_IMETHODIMP
-nsPluginInstanceOwner::RedrawPlugin() { return NS_OK; }
-
-#if defined(XP_WIN)
-nsIWidget* nsPluginInstanceOwner::GetContainingWidgetIfOffset() {
-  return nullptr;
-}
-
-#endif
-
-NS_IMETHODIMP nsPluginInstanceOwner::GetNetscapeWindow(void* value) {
-  NS_WARNING("plugin owner has no owner in getting doc's window handle");
-  return NS_ERROR_FAILURE;
-}
-
-#if defined(XP_WIN)
-void nsPluginInstanceOwner::SetWidgetWindowAsParent(HWND aWindowToAdopt) {
-  if (!mWidget) {
-    NS_ERROR("mWidget should exist before this gets called.");
-    return;
-  }
-
-  mWidget->SetNativeData(NS_NATIVE_CHILD_WINDOW,
-                         reinterpret_cast<uintptr_t>(aWindowToAdopt));
-}
-
-nsresult nsPluginInstanceOwner::SetNetscapeWindowAsParent(HWND aWindowToAdopt) {
-  NS_WARNING("Plugin owner has no plugin frame.");
-  return NS_ERROR_FAILURE;
-}
-
-bool nsPluginInstanceOwner::GetCompositionString(uint32_t aType,
-                                                 nsTArray<uint8_t>* aDist,
-                                                 int32_t* aLength) {
-  // Mark pkugin calls ImmGetCompositionStringW correctly
-  mGotCompositionData = true;
-
-  RefPtr<TextComposition> composition = GetTextComposition();
-  if (NS_WARN_IF(!composition)) {
-    return false;
-  }
-
-  switch (aType) {
-    case GCS_COMPSTR: {
-      if (!composition->IsComposing()) {
-        *aLength = 0;
-        return true;
-      }
-
-      uint32_t len = composition->LastData().Length() * sizeof(char16_t);
-      if (len) {
-        aDist->SetLength(len);
-        memcpy(aDist->Elements(), composition->LastData().get(), len);
-      }
-      *aLength = len;
-      return true;
-    }
-
-    case GCS_RESULTSTR: {
-      if (composition->IsComposing()) {
-        *aLength = 0;
-        return true;
-      }
-
-      uint32_t len = composition->LastData().Length() * sizeof(char16_t);
-      if (len) {
-        aDist->SetLength(len);
-        memcpy(aDist->Elements(), composition->LastData().get(), len);
-      }
-      *aLength = len;
-      return true;
-    }
-
-    case GCS_CURSORPOS: {
-      *aLength = 0;
-      TextRangeArray* ranges = composition->GetLastRanges();
-      if (!ranges) {
-        return true;
-      }
-      *aLength = ranges->GetCaretPosition();
-      if (*aLength < 0) {
-        return false;
-      }
-      return true;
-    }
-
-    case GCS_COMPATTR: {
-      TextRangeArray* ranges = composition->GetLastRanges();
-      if (!ranges || ranges->IsEmpty()) {
-        *aLength = 0;
-        return true;
-      }
-
-      aDist->SetLength(composition->LastData().Length());
-      memset(aDist->Elements(), ATTR_INPUT, aDist->Length());
-
-      for (TextRange& range : *ranges) {
-        uint8_t type = ATTR_INPUT;
-        switch (range.mRangeType) {
-          case TextRangeType::eRawClause:
-            type = ATTR_INPUT;
-            break;
-          case TextRangeType::eSelectedRawClause:
-            type = ATTR_TARGET_NOTCONVERTED;
-            break;
-          case TextRangeType::eConvertedClause:
-            type = ATTR_CONVERTED;
-            break;
-          case TextRangeType::eSelectedClause:
-            type = ATTR_TARGET_CONVERTED;
-            break;
-          default:
-            continue;
-        }
-
-        size_t minLen = std::min<size_t>(range.mEndOffset, aDist->Length());
-        for (size_t i = range.mStartOffset; i < minLen; i++) {
-          (*aDist)[i] = type;
-        }
-      }
-      *aLength = aDist->Length();
-      return true;
-    }
-
-    case GCS_COMPCLAUSE: {
-      RefPtr<TextRangeArray> ranges = composition->GetLastRanges();
-      if (!ranges || ranges->IsEmpty()) {
-        aDist->SetLength(sizeof(uint32_t));
-        memset(aDist->Elements(), 0, sizeof(uint32_t));
-        *aLength = aDist->Length();
-        return true;
-      }
-      AutoTArray<uint32_t, 16> clauses;
-      clauses.AppendElement(0);
-      for (TextRange& range : *ranges) {
-        if (!range.IsClause()) {
-          continue;
-        }
-        clauses.AppendElement(range.mEndOffset);
-      }
-
-      aDist->SetLength(clauses.Length() * sizeof(uint32_t));
-      memcpy(aDist->Elements(), clauses.Elements(), aDist->Length());
-      *aLength = aDist->Length();
-      return true;
-    }
-
-    case GCS_RESULTREADSTR: {
-      // When returning error causes unexpected error, so we return 0 instead.
-      *aLength = 0;
-      return true;
-    }
-
-    case GCS_RESULTCLAUSE: {
-      // When returning error causes unexpected error, so we return 0 instead.
-      *aLength = 0;
-      return true;
-    }
-
-    default:
-      NS_WARNING(
-          nsPrintfCString(
-              "Unsupported type %x of ImmGetCompositionStringW hook", aType)
-              .get());
-      break;
-  }
-
-  return false;
-}
-
-bool nsPluginInstanceOwner::RequestCommitOrCancel(bool aCommitted) {
-  nsCOMPtr<nsIWidget> widget = GetContainingWidgetIfOffset();
-  if (NS_WARN_IF(!widget)) {
-    return false;
-  }
-
-  // Retrieve TextComposition for the widget with IMEStateManager instead of
-  // using GetTextComposition() because we cannot know whether the method
-  // failed due to no widget or no composition.
-  RefPtr<TextComposition> composition =
-      IMEStateManager::GetTextCompositionFor(widget);
-  if (!composition) {
-    // If there is composition, we should just ignore this request since
-    // the composition may have been committed after the plugin process
-    // sent this request.
-    return true;
-  }
-
-  nsCOMPtr<nsIContent> content = do_QueryReferent(mContent);
-  if (content != composition->GetEventTargetNode()) {
-    // If the composition is handled in different node, that means that
-    // the composition for the plugin has gone and new composition has
-    // already started.  So, request from the plugin should be ignored
-    // since user inputs different text now.
-    return true;
-  }
-
-  // If active composition is being handled in the plugin, let's request to
-  // commit/cancel the composition via both IMEStateManager and TextComposition
-  // for avoid breaking the status management of composition.  I.e., don't
-  // call nsIWidget::NotifyIME() directly from here.
-  IMEStateManager::NotifyIME(aCommitted ? widget::REQUEST_TO_COMMIT_COMPOSITION
-                                        : widget::REQUEST_TO_CANCEL_COMPOSITION,
-                             widget, composition->GetBrowserParent());
-  // FYI: This instance may have been destroyed.  Be careful if you need to
-  //      access members of this class.
-  return true;
-}
-
-#endif  // #ifdef XP_WIN
-
-NS_IMETHODIMP nsPluginInstanceOwner::SetEventModel(int32_t eventModel) {
-#ifdef XP_MACOSX
-  mEventModel = static_cast<NPEventModel>(eventModel);
-  return NS_OK;
-#else
-  return NS_ERROR_NOT_IMPLEMENTED;
-#endif
-}
-
-NPBool nsPluginInstanceOwner::ConvertPoint(double sourceX, double sourceY,
-                                           NPCoordinateSpace sourceSpace,
-                                           double* destX, double* destY,
-                                           NPCoordinateSpace destSpace) {
-  return false;
-}
-
-NPError nsPluginInstanceOwner::InitAsyncSurface(NPSize* size,
-                                                NPImageFormat format,
-                                                void* initData,
-                                                NPAsyncSurface* surface) {
-  return NPERR_INCOMPATIBLE_VERSION_ERROR;
-}
-
-NPError nsPluginInstanceOwner::FinalizeAsyncSurface(NPAsyncSurface*) {
-  return NPERR_INCOMPATIBLE_VERSION_ERROR;
-}
-
-void nsPluginInstanceOwner::SetCurrentAsyncSurface(NPAsyncSurface*, NPRect*) {}
-
-NS_IMETHODIMP nsPluginInstanceOwner::GetTagType(nsPluginTagType* result) {
-  NS_ENSURE_ARG_POINTER(result);
-
-  *result = nsPluginTagType_Unknown;
-
-  nsCOMPtr<nsIContent> content = do_QueryReferent(mContent);
-  if (content->IsHTMLElement(nsGkAtoms::embed))
-    *result = nsPluginTagType_Embed;
-  else if (content->IsHTMLElement(nsGkAtoms::object))
-    *result = nsPluginTagType_Object;
-
-  return NS_OK;
-}
-
-void nsPluginInstanceOwner::GetParameters(
-    nsTArray<MozPluginParameter>& parameters) {
-  nsCOMPtr<nsIObjectLoadingContent> content = do_QueryReferent(mContent);
-  nsObjectLoadingContent* loadingContent =
-      static_cast<nsObjectLoadingContent*>(content.get());
-
-  loadingContent->GetPluginParameters(parameters);
-}
-
-#ifdef XP_MACOSX
-
-static void InitializeNPCocoaEvent(NPCocoaEvent* event) {
-  memset(event, 0, sizeof(NPCocoaEvent));
-}
-
-NPDrawingModel nsPluginInstanceOwner::GetDrawingModel() {
-#  ifndef NP_NO_QUICKDRAW
-  // We don't support the Quickdraw drawing model any more but it's still
-  // the default model for i386 per NPAPI.
-  NPDrawingModel drawingModel = NPDrawingModelQuickDraw;
-#  else
-  NPDrawingModel drawingModel = NPDrawingModelCoreGraphics;
-#  endif
-
-  if (!mInstance) return drawingModel;
-
-  mInstance->GetDrawingModel((int32_t*)&drawingModel);
-  return drawingModel;
-}
-
-bool nsPluginInstanceOwner::IsRemoteDrawingCoreAnimation() {
-  if (!mInstance) return false;
-
-  bool coreAnimation;
-  if (!NS_SUCCEEDED(mInstance->IsRemoteDrawingCoreAnimation(&coreAnimation)))
-    return false;
-
-  return coreAnimation;
-}
-
-NPEventModel nsPluginInstanceOwner::GetEventModel() { return mEventModel; }
-
-#  define DEFAULT_REFRESH_RATE 20  // 50 FPS
-StaticRefPtr<nsITimer> nsPluginInstanceOwner::sCATimer;
-nsTArray<nsPluginInstanceOwner*>* nsPluginInstanceOwner::sCARefreshListeners =
-    nullptr;
-
-void nsPluginInstanceOwner::CARefresh(nsITimer* aTimer, void* aClosure) {
-  if (!sCARefreshListeners) {
-    return;
-  }
-  for (size_t i = 0; i < sCARefreshListeners->Length(); i++) {
-    nsPluginInstanceOwner* instanceOwner = (*sCARefreshListeners)[i];
-    NPWindow* window;
-    instanceOwner->GetWindow(window);
-    if (!window) {
-      continue;
-    }
-    NPRect r;
-    r.left = 0;
-    r.top = 0;
-    r.right = window->width;
-    r.bottom = window->height;
-    instanceOwner->InvalidateRect(&r);
-  }
-}
-
-void nsPluginInstanceOwner::AddToCARefreshTimer() {
-  if (!mInstance) {
-    return;
-  }
-
-  // Flash invokes InvalidateRect for us.
-  const char* mime = nullptr;
-  if (NS_SUCCEEDED(mInstance->GetMIMEType(&mime)) && mime &&
-      nsPluginHost::GetSpecialType(nsDependentCString(mime)) ==
-          nsPluginHost::eSpecialType_Flash) {
-    return;
-  }
-
-  if (!sCARefreshListeners) {
-    sCARefreshListeners = new nsTArray<nsPluginInstanceOwner*>();
-  }
-
-  if (sCARefreshListeners->Contains(this)) {
-    return;
-  }
-
-  sCARefreshListeners->AppendElement(this);
-
-  if (sCARefreshListeners->Length() == 1) {
-    nsCOMPtr<nsITimer> timer;
-    NS_NewTimerWithFuncCallback(
-        getter_AddRefs(timer), CARefresh, nullptr, DEFAULT_REFRESH_RATE,
-        nsITimer::TYPE_REPEATING_SLACK, "nsPluginInstanceOwner::CARefresh");
-    sCATimer = timer.forget();
-  }
-}
-
-void nsPluginInstanceOwner::RemoveFromCARefreshTimer() {
-  if (!sCARefreshListeners || sCARefreshListeners->Contains(this) == false) {
-    return;
-  }
-
-  sCARefreshListeners->RemoveElement(this);
-
-  if (sCARefreshListeners->Length() == 0) {
-    if (sCATimer) {
-      sCATimer->Cancel();
-      sCATimer = nullptr;
-    }
-    delete sCARefreshListeners;
-    sCARefreshListeners = nullptr;
-  }
-}
-
-void nsPluginInstanceOwner::SetPluginPort() {
-  void* pluginPort = GetPluginPort();
-  if (!pluginPort || !mPluginWindow) return;
-  mPluginWindow->window = pluginPort;
-}
-#endif
-#if defined(XP_MACOSX) || defined(XP_WIN)
-nsresult nsPluginInstanceOwner::ContentsScaleFactorChanged(
-    double aContentsScaleFactor) {
-  if (!mInstance) {
-    return NS_ERROR_NULL_POINTER;
-  }
-  return mInstance->ContentsScaleFactorChanged(aContentsScaleFactor);
-}
-#endif
-
-// static
-uint32_t nsPluginInstanceOwner::GetEventloopNestingLevel() {
-  nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
-  uint32_t currentLevel = 0;
-  if (appShell) {
-    appShell->GetEventloopNestingLevel(&currentLevel);
-#ifdef XP_MACOSX
-    // Cocoa widget code doesn't process UI events through the normal
-    // appshell event loop, so it needs an additional count here.
-    currentLevel++;
-#endif
-  }
-
-  // No idea how this happens... but Linux doesn't consistently
-  // process UI events through the appshell event loop. If we get a 0
-  // here on any platform we increment the level just in case so that
-  // we make sure we always tear the plugin down eventually.
-  if (!currentLevel) {
-    currentLevel++;
-  }
-
-  return currentLevel;
-}
-
-nsresult nsPluginInstanceOwner::DispatchFocusToPlugin(Event* aFocusEvent) {
-#ifndef XP_MACOSX
-  if (!mPluginWindow || (mPluginWindow->type == NPWindowTypeWindow)) {
-    // continue only for cases without child window
-    aFocusEvent->PreventDefault();  // consume event
-    return NS_OK;
-  }
-#endif
-
-  WidgetEvent* theEvent = aFocusEvent->WidgetEventPtr();
-  if (theEvent) {
-    WidgetGUIEvent focusEvent(theEvent->IsTrusted(), theEvent->mMessage,
-                              nullptr);
-    nsEventStatus rv = ProcessEvent(focusEvent);
-    if (nsEventStatus_eConsumeNoDefault == rv) {
-      aFocusEvent->PreventDefault();
-      aFocusEvent->StopPropagation();
-    }
-  }
-
-  return NS_OK;
-}
-
-nsresult nsPluginInstanceOwner::ProcessKeyPress(Event* aKeyEvent) {
-  // ProcessKeyPress() may be called twice with same eKeyPress event.  One is
-  // by the event listener in the default event group and the other is by the
-  // event listener in the system event group.  When this is called in the
-  // latter case and the event must be fired in the default event group too,
-  // we don't need to do nothing anymore.
-  // XXX Do we need to check whether the document is in chrome?  In strictly
-  //     speaking, it must be yes.  However, our UI must not use plugin in
-  //     chrome.
-  if (!aKeyEvent->WidgetEventPtr()->mFlags.mOnlySystemGroupDispatchInContent &&
-      aKeyEvent->WidgetEventPtr()->mFlags.mInSystemGroup) {
-    return NS_OK;
-  }
-
-#ifdef XP_MACOSX
-  return DispatchKeyToPlugin(aKeyEvent);
-#else
-  if (SendNativeEvents()) DispatchKeyToPlugin(aKeyEvent);
-
-  if (mInstance) {
-    // If this event is going to the plugin, we want to kill it.
-    // Not actually sending keypress to the plugin, since we didn't before.
-    aKeyEvent->PreventDefault();
-    aKeyEvent->StopPropagation();
-  }
-  return NS_OK;
-#endif
-}
-
-nsresult nsPluginInstanceOwner::DispatchKeyToPlugin(Event* aKeyEvent) {
-#if !defined(XP_MACOSX)
-  if (!mPluginWindow || (mPluginWindow->type == NPWindowTypeWindow)) {
-    aKeyEvent->PreventDefault();  // consume event
-    return NS_OK;
-  }
-  // continue only for cases without child window
-#endif
-
-  if (mInstance) {
-    WidgetKeyboardEvent* keyEvent =
-        aKeyEvent->WidgetEventPtr()->AsKeyboardEvent();
-    if (keyEvent && keyEvent->mClass == eKeyboardEventClass) {
-      nsEventStatus rv = ProcessEvent(*keyEvent);
-      if (nsEventStatus_eConsumeNoDefault == rv) {
-        aKeyEvent->PreventDefault();
-        aKeyEvent->StopPropagation();
-      }
-    }
-  }
-
-  return NS_OK;
-}
-
-nsresult nsPluginInstanceOwner::ProcessMouseDown(Event* aMouseEvent) {
-  return NS_OK;
-}
-
-nsresult nsPluginInstanceOwner::DispatchMouseToPlugin(Event* aMouseEvent,
-                                                      bool aAllowPropagate) {
-#if !defined(XP_MACOSX)
-  if (!mPluginWindow || (mPluginWindow->type == NPWindowTypeWindow)) {
-    aMouseEvent->PreventDefault();  // consume event
-    return NS_OK;
-  }
-  // continue only for cases without child window
-#endif
-  // don't send mouse events if we are hidden
-  if (!mWidgetVisible) return NS_OK;
-
-  WidgetMouseEvent* mouseEvent = aMouseEvent->WidgetEventPtr()->AsMouseEvent();
-  if (mouseEvent && mouseEvent->mClass == eMouseEventClass) {
-    nsEventStatus rv = ProcessEvent(*mouseEvent);
-    if (nsEventStatus_eConsumeNoDefault == rv) {
-      aMouseEvent->PreventDefault();
-      if (!aAllowPropagate) {
-        aMouseEvent->StopPropagation();
-      }
-    }
-    if (mouseEvent->mMessage == eMouseUp) {
-      mLastMouseDownButtonType = -1;
-    }
-  }
-  return NS_OK;
-}
-
-#ifdef XP_WIN
-already_AddRefed<TextComposition> nsPluginInstanceOwner::GetTextComposition() {
-  return nullptr;
-}
-
-void nsPluginInstanceOwner::HandleNoConsumedCompositionMessage(
-    WidgetCompositionEvent* aCompositionEvent, const NPEvent* aPluginEvent) {
-  nsCOMPtr<nsIWidget> widget = GetContainingWidgetIfOffset();
-  if (NS_WARN_IF(!widget)) {
-    return;
-  }
-
-  if (aPluginEvent->lParam & GCS_RESULTSTR) {
-    return;
-  }
-  if (!mSentStartComposition) {
-    mSentStartComposition = true;
-  }
-}
-#endif
-
-nsresult nsPluginInstanceOwner::DispatchCompositionToPlugin(Event* aEvent) {
-#ifdef XP_WIN
-  if (!mPluginWindow) {
-    // CompositionEvent isn't cancellable.  So it is unnecessary to call
-    // PreventDefaults() to consume event
-    return NS_OK;
-  }
-  WidgetCompositionEvent* compositionEvent =
-      aEvent->WidgetEventPtr()->AsCompositionEvent();
-  if (NS_WARN_IF(!compositionEvent)) {
-    return NS_ERROR_INVALID_ARG;
-  }
-
-  if (compositionEvent->mMessage == eCompositionChange) {
-    RefPtr<TextComposition> composition = GetTextComposition();
-    if (NS_WARN_IF(!composition)) {
-      return NS_ERROR_FAILURE;
-    }
-    TextComposition::CompositionChangeEventHandlingMarker
-        compositionChangeEventHandlingMarker(composition, compositionEvent);
-  }
-
-  const NPEvent* pPluginEvent =
-      static_cast<const NPEvent*>(compositionEvent->mPluginEvent);
-  if (pPluginEvent && pPluginEvent->event == WM_IME_COMPOSITION &&
-      mPluginDidNotHandleIMEComposition) {
-    // This is a workaround when running windowed and windowless Flash on
-    // same process.
-    // Flash with protected mode calls IMM APIs on own render process.  This
-    // is a bug of Flash's protected mode.
-    // ImmGetCompositionString with GCS_RESULTSTR returns *LAST* committed
-    // string.  So when windowed mode Flash handles IME composition,
-    // windowless plugin can get windowed mode's commited string by that API.
-    // So we never post WM_IME_COMPOSITION when plugin doesn't call
-    // ImmGetCompositionString() during WM_IME_COMPOSITION correctly.
-    HandleNoConsumedCompositionMessage(compositionEvent, pPluginEvent);
-    aEvent->StopImmediatePropagation();
-    return NS_OK;
-  }
-
-  // Protected mode Flash returns noDefault by NPP_HandleEvent, but
-  // composition information into plugin is invalid because plugin's bug.
-  // So if plugin doesn't get composition data by WM_IME_COMPOSITION, we
-  // recongnize it isn't handled
-  AutoRestore<bool> restore(mGotCompositionData);
-  mGotCompositionData = false;
-
-  nsEventStatus status = ProcessEvent(*compositionEvent);
-  aEvent->StopImmediatePropagation();
-
-  // Composition event isn't handled by plugin, so we have to call default proc.
-
-  if (NS_WARN_IF(!pPluginEvent)) {
-    return NS_OK;
-  }
-
-  if (pPluginEvent->event == WM_IME_STARTCOMPOSITION) {
-    if (nsEventStatus_eConsumeNoDefault != status) {
-      mSentStartComposition = true;
-    } else {
-      mSentStartComposition = false;
-    }
-    mPluginDidNotHandleIMEComposition = false;
-    return NS_OK;
-  }
-
-  if (pPluginEvent->event == WM_IME_ENDCOMPOSITION) {
-    return NS_OK;
-  }
-
-  if (pPluginEvent->event == WM_IME_COMPOSITION && !mGotCompositionData) {
-    // If plugin doesn't handle WM_IME_COMPOSITION correctly, we don't send
-    // composition event until end composition.
-    mPluginDidNotHandleIMEComposition = true;
-
-    HandleNoConsumedCompositionMessage(compositionEvent, pPluginEvent);
-  }
-#endif  // #ifdef XP_WIN
-  return NS_OK;
-}
-
-nsresult nsPluginInstanceOwner::HandleEvent(Event* aEvent) {
-  NS_ASSERTION(mInstance,
-               "Should have a valid plugin instance or not receive events.");
-
-  nsAutoString eventType;
-  aEvent->GetType(eventType);
-
-#ifdef XP_MACOSX
-  if (eventType.EqualsLiteral("activate") ||
-      eventType.EqualsLiteral("deactivate")) {
-    WindowFocusMayHaveChanged();
-    return NS_OK;
-  }
-  if (eventType.EqualsLiteral("MozPerformDelayedBlur")) {
-    if (mShouldBlurOnActivate) {
-      WidgetGUIEvent blurEvent(true, eBlur, nullptr);
-      ProcessEvent(blurEvent);
-      mShouldBlurOnActivate = false;
-    }
-    return NS_OK;
-  }
-#endif
-
-  if (eventType.EqualsLiteral("focus")) {
-    mContentFocused = true;
-    return DispatchFocusToPlugin(aEvent);
-  }
-  if (eventType.EqualsLiteral("blur")) {
-    mContentFocused = false;
-    return DispatchFocusToPlugin(aEvent);
-  }
-  if (eventType.EqualsLiteral("mousedown")) {
-    return ProcessMouseDown(aEvent);
-  }
-  if (eventType.EqualsLiteral("mouseup")) {
-    return DispatchMouseToPlugin(aEvent);
-  }
-  if (eventType.EqualsLiteral("mousemove")) {
-    return DispatchMouseToPlugin(aEvent, true);
-  }
-  if (eventType.EqualsLiteral("click") || eventType.EqualsLiteral("dblclick") ||
-      eventType.EqualsLiteral("mouseover") ||
-      eventType.EqualsLiteral("mouseout")) {
-    return DispatchMouseToPlugin(aEvent);
-  }
-  if (eventType.EqualsLiteral("keydown") || eventType.EqualsLiteral("keyup")) {
-    return DispatchKeyToPlugin(aEvent);
-  }
-  if (eventType.EqualsLiteral("keypress")) {
-    return ProcessKeyPress(aEvent);
-  }
-  if (eventType.EqualsLiteral("compositionstart") ||
-      eventType.EqualsLiteral("compositionend") ||
-      eventType.EqualsLiteral("text")) {
-    return DispatchCompositionToPlugin(aEvent);
-  }
-
-  DragEvent* dragEvent = aEvent->AsDragEvent();
-  if (dragEvent && mInstance) {
-    WidgetEvent* ievent = aEvent->WidgetEventPtr();
-    if (ievent && ievent->IsTrusted() && ievent->mMessage != eDragEnter &&
-        ievent->mMessage != eDragOver) {
-      aEvent->PreventDefault();
-    }
-
-    // Let the plugin handle drag events.
-    aEvent->StopPropagation();
-  }
-  return NS_OK;
-}
-
-#ifdef XP_MACOSX
-
-void nsPluginInstanceOwner::PerformDelayedBlurs() {
-  nsCOMPtr<nsIContent> content = do_QueryReferent(mContent);
-  nsCOMPtr<EventTarget> windowRoot =
-      content->OwnerDoc()->GetWindow()->GetTopWindowRoot();
-  nsContentUtils::DispatchEventOnlyToChrome(
-      content->OwnerDoc(), windowRoot, u"MozPerformDelayedBlur"_ns,
-      CanBubble::eNo, Cancelable::eNo, nullptr);
-}
-
-#endif
-
-nsEventStatus nsPluginInstanceOwner::ProcessEvent(
-    const WidgetGUIEvent& anEvent) {
-  return nsEventStatus_eIgnore;
-}
-
-nsresult nsPluginInstanceOwner::Destroy() {
-#ifdef XP_MACOSX
-  RemoveFromCARefreshTimer();
-#endif
-
-  nsCOMPtr<nsIContent> content = do_QueryReferent(mContent);
-
-  // unregister context menu listener
-  if (mCXMenuListener) {
-    mCXMenuListener->Destroy(content);
-    mCXMenuListener = nullptr;
-  }
-
-  content->RemoveEventListener(u"focus"_ns, this, false);
-  content->RemoveEventListener(u"blur"_ns, this, false);
-  content->RemoveEventListener(u"mouseup"_ns, this, false);
-  content->RemoveEventListener(u"mousedown"_ns, this, false);
-  content->RemoveEventListener(u"mousemove"_ns, this, false);
-  content->RemoveEventListener(u"click"_ns, this, false);
-  content->RemoveEventListener(u"dblclick"_ns, this, false);
-  content->RemoveEventListener(u"mouseover"_ns, this, false);
-  content->RemoveEventListener(u"mouseout"_ns, this, false);
-  content->RemoveEventListener(u"keypress"_ns, this, true);
-  content->RemoveSystemEventListener(u"keypress"_ns, this, true);
-  content->RemoveEventListener(u"keydown"_ns, this, true);
-  content->RemoveEventListener(u"keyup"_ns, this, true);
-  content->RemoveEventListener(u"drop"_ns, this, true);
-  content->RemoveEventListener(u"drag"_ns, this, true);
-  content->RemoveEventListener(u"dragenter"_ns, this, true);
-  content->RemoveEventListener(u"dragover"_ns, this, true);
-  content->RemoveEventListener(u"dragleave"_ns, this, true);
-  content->RemoveEventListener(u"dragexit"_ns, this, true);
-  content->RemoveEventListener(u"dragstart"_ns, this, true);
-  content->RemoveEventListener(u"dragend"_ns, this, true);
-  content->RemoveSystemEventListener(u"compositionstart"_ns, this, true);
-  content->RemoveSystemEventListener(u"compositionend"_ns, this, true);
-  content->RemoveSystemEventListener(u"text"_ns, this, true);
-
-  if (mWidget) {
-    if (mPluginWindow) {
-      mPluginWindow->SetPluginWidget(nullptr);
-    }
-
-    mWidget->Destroy();
-  }
-
-  return NS_OK;
-}
-
-// Paints are handled differently, so we just simulate an update event.
-
-#ifdef XP_MACOSX
-void nsPluginInstanceOwner::Paint(const gfxRect& aDirtyRect,
-                                  CGContextRef cgContext) {
-  return;
-}
-
-void nsPluginInstanceOwner::DoCocoaEventDrawRect(const gfxRect& aDrawRect,
-                                                 CGContextRef cgContext) {
-  return;
-}
-#endif
-
-#ifdef XP_WIN
-void nsPluginInstanceOwner::Paint(const RECT& aDirty, HDC aDC) { return; }
-#endif
-
-#if defined(MOZ_X11)
-void nsPluginInstanceOwner::Paint(gfxContext* aContext,
-                                  const gfxRect& aFrameRect,
-                                  const gfxRect& aDirtyRect) {
-  return;
-}
-nsresult nsPluginInstanceOwner::Renderer::DrawWithXlib(
-    cairo_surface_t* xsurface, nsIntPoint offset, nsIntRect* clipRects,
-    uint32_t numClipRects) {
-  Screen* screen = cairo_xlib_surface_get_screen(xsurface);
-  Colormap colormap;
-  Visual* visual;
-  if (!gfxXlibSurface::GetColormapAndVisual(xsurface, &colormap, &visual)) {
-    NS_ERROR("Failed to get visual and colormap");
-    return NS_ERROR_UNEXPECTED;
-  }
-
-  nsNPAPIPluginInstance* instance = mInstanceOwner->mInstance;
-  if (!instance) return NS_ERROR_FAILURE;
-
-  // See if the plugin must be notified of new window parameters.
-  bool doupdatewindow = false;
-
-  if (mWindow->x != offset.x || mWindow->y != offset.y) {
-    mWindow->x = offset.x;
-    mWindow->y = offset.y;
-    doupdatewindow = true;
-  }
-
-  if (nsIntSize(mWindow->width, mWindow->height) != mPluginSize) {
-    mWindow->width = mPluginSize.width;
-    mWindow->height = mPluginSize.height;
-    doupdatewindow = true;
-  }
-
-  // The clip rect is relative to drawable top-left.
-  NS_ASSERTION(numClipRects <= 1, "We don't support multiple clip rectangles!");
-  nsIntRect clipRect;
-  if (numClipRects) {
-    clipRect.x = clipRects[0].x;
-    clipRect.y = clipRects[0].y;
-    clipRect.width = clipRects[0].width;
-    clipRect.height = clipRects[0].height;
-    // NPRect members are unsigned, but clip rectangles should be contained by
-    // the surface.
-    NS_ASSERTION(clipRect.x >= 0 && clipRect.y >= 0,
-                 "Clip rectangle offsets are negative!");
-  } else {
-    clipRect.x = offset.x;
-    clipRect.y = offset.y;
-    clipRect.width = mWindow->width;
-    clipRect.height = mWindow->height;
-    // Don't ask the plugin to draw outside the drawable.
-    // This also ensures that the unsigned clip rectangle offsets won't be -ve.
-    clipRect.IntersectRect(
-        clipRect, nsIntRect(0, 0, cairo_xlib_surface_get_width(xsurface),
-                            cairo_xlib_surface_get_height(xsurface)));
-  }
-
-  NPRect newClipRect;
-  newClipRect.left = clipRect.x;
-  newClipRect.top = clipRect.y;
-  newClipRect.right = clipRect.XMost();
-  newClipRect.bottom = clipRect.YMost();
-  if (mWindow->clipRect.left != newClipRect.left ||
-      mWindow->clipRect.top != newClipRect.top ||
-      mWindow->clipRect.right != newClipRect.right ||
-      mWindow->clipRect.bottom != newClipRect.bottom) {
-    mWindow->clipRect = newClipRect;
-    doupdatewindow = true;
-  }
-
-  NPSetWindowCallbackStruct* ws_info =
-      static_cast<NPSetWindowCallbackStruct*>(mWindow->ws_info);
-#  ifdef MOZ_X11
-  if (ws_info->visual != visual || ws_info->colormap != colormap) {
-    ws_info->visual = visual;
-    ws_info->colormap = colormap;
-    ws_info->depth = gfxXlibSurface::DepthOfVisual(screen, visual);
-    doupdatewindow = true;
-  }
-#  endif
-
-  {
-    if (doupdatewindow) instance->SetWindow(mWindow);
-  }
-
-  // Translate the dirty rect to drawable coordinates.
-  nsIntRect dirtyRect = mDirtyRect + offset;
-  if (mInstanceOwner->mFlash10Quirks) {
-    // Work around a bug in Flash up to 10.1 d51 at least, where expose event
-    // top left coordinates within the plugin-rect and not at the drawable
-    // origin are misinterpreted.  (We can move the top left coordinate
-    // provided it is within the clipRect.)
-    dirtyRect.SetRect(offset.x, offset.y, mDirtyRect.XMost(),
-                      mDirtyRect.YMost());
-  }
-  // Intersect the dirty rect with the clip rect to ensure that it lies within
-  // the drawable.
-  if (!dirtyRect.IntersectRect(dirtyRect, clipRect)) return NS_OK;
-
-  {
-    XEvent pluginEvent = XEvent();
-    XGraphicsExposeEvent& exposeEvent = pluginEvent.xgraphicsexpose;
-    // set the drawing info
-    exposeEvent.type = GraphicsExpose;
-    exposeEvent.display = DisplayOfScreen(screen);
-    exposeEvent.drawable = cairo_xlib_surface_get_drawable(xsurface);
-    exposeEvent.x = dirtyRect.x;
-    exposeEvent.y = dirtyRect.y;
-    exposeEvent.width = dirtyRect.width;
-    exposeEvent.height = dirtyRect.height;
-    exposeEvent.count = 0;
-    // information not set:
-    exposeEvent.serial = 0;
-    exposeEvent.send_event = X11False;
-    exposeEvent.major_code = 0;
-    exposeEvent.minor_code = 0;
-
-    instance->HandleEvent(&pluginEvent, nullptr);
-  }
-  return NS_OK;
-}
-#endif
-
-nsresult nsPluginInstanceOwner::Init(nsIContent* aContent) {
-  mLastEventloopNestingLevel = GetEventloopNestingLevel();
-
-  mContent = do_GetWeakReference(aContent);
-
-  MOZ_ASSERT_UNREACHABLE("Should not be initializing plugin without a frame");
-  return NS_ERROR_FAILURE;
-}
-
-void* nsPluginInstanceOwner::GetPluginPort() {
-  void* result = nullptr;
-  return result;
-}
-
-void nsPluginInstanceOwner::ReleasePluginPort(void* pluginPort) {}
-
-NS_IMETHODIMP nsPluginInstanceOwner::CreateWidget(void) {
-  NS_ENSURE_TRUE(mPluginWindow, NS_ERROR_NULL_POINTER);
-
-  // Can't call this twice!
-  if (mWidget) {
-    NS_WARNING("Trying to create a plugin widget twice!");
-    return NS_ERROR_FAILURE;
-  }
-
-  bool windowless = false;
-  mInstance->IsWindowless(&windowless);
-  if (!windowless) {
-#ifndef XP_WIN
-    // Only Windows supports windowed mode!
-    MOZ_ASSERT_UNREACHABLE();
-    return NS_ERROR_FAILURE;
-#else
-    // Try to get a parent widget, on some platforms widget creation will fail
-    // without a parent.
-    nsresult rv = NS_ERROR_FAILURE;
-
-    nsCOMPtr<nsIWidget> parentWidget;
-
-    // A failure here is terminal since we can't fall back on the non-e10s code
-    // path below.
-    if (!mWidget && XRE_IsContentProcess()) {
-      return NS_ERROR_UNEXPECTED;
-    }
-
-    if (!mWidget) {
-      // native (single process)
-      mWidget = nsIWidget::CreateChildWindow();
-      nsWidgetInitData initData;
-      initData.mWindowType = eWindowType_plugin;
-      initData.clipChildren = true;
-      initData.clipSiblings = true;
-      rv = mWidget->Create(parentWidget.get(), nullptr,
-                           LayoutDeviceIntRect(0, 0, 0, 0), &initData);
-      if (NS_FAILED(rv)) {
-        mWidget->Destroy();
-        mWidget = nullptr;
-        return rv;
-      }
-    }
-
-    mWidget->EnableDragDrop(true);
-    mWidget->Show(false);
-    mWidget->Enable(false);
-#endif  // XP_WIN
-  }
-
-  if (windowless) {
-    mPluginWindow->type = NPWindowTypeDrawable;
-
-    // this needs to be a HDC according to the spec, but I do
-    // not see the right way to release it so let's postpone
-    // passing HDC till paint event when it is really
-    // needed. Change spec?
-    mPluginWindow->window = nullptr;
-#ifdef MOZ_X11
-    // Fill in the display field.
-    NPSetWindowCallbackStruct* ws_info =
-        static_cast<NPSetWindowCallbackStruct*>(mPluginWindow->ws_info);
-    ws_info->display = DefaultXDisplay();
-
-    nsAutoCString description;
-    GetPluginDescription(description);
-    constexpr auto flash10Head = "Shockwave Flash 10."_ns;
-    mFlash10Quirks = StringBeginsWith(description, flash10Head);
-#endif
-  } else if (mWidget) {
-    // mPluginWindow->type is used in |GetPluginPort| so it must
-    // be initialized first
-    mPluginWindow->type = NPWindowTypeWindow;
-    mPluginWindow->window = GetPluginPort();
-    // tell the plugin window about the widget
-    mPluginWindow->SetPluginWidget(mWidget);
-  }
-
-#ifdef XP_MACOSX
-  if (GetDrawingModel() == NPDrawingModelCoreAnimation) {
-    AddToCARefreshTimer();
-  }
-#endif
-
-  mWidgetCreationComplete = true;
-
-  return NS_OK;
-}
-
-// Mac specific code to fix up the port location and clipping region
-#ifdef XP_MACOSX
-
-void nsPluginInstanceOwner::FixUpPluginWindow(int32_t inPaintState) { return; }
-
-void nsPluginInstanceOwner::WindowFocusMayHaveChanged() {
-  if (!mSentInitialTopLevelWindowEvent) {
-    return;
-  }
-
-  bool isActive = WindowIsActive();
-  if (isActive != mLastWindowIsActive) {
-    SendWindowFocusChanged(isActive);
-    mLastWindowIsActive = isActive;
-  }
-}
-
-bool nsPluginInstanceOwner::WindowIsActive() { return false; }
-
-void nsPluginInstanceOwner::SendWindowFocusChanged(bool aIsActive) {
-  if (!mInstance) {
-    return;
-  }
-
-  NPCocoaEvent cocoaEvent;
-  InitializeNPCocoaEvent(&cocoaEvent);
-  cocoaEvent.type = NPCocoaEventWindowFocusChanged;
-  cocoaEvent.data.focus.hasFocus = aIsActive;
-  mInstance->HandleEvent(&cocoaEvent, nullptr,
-                         NS_PLUGIN_CALL_SAFE_TO_REENTER_GECKO);
-}
-
-void nsPluginInstanceOwner::HidePluginWindow() {
-  if (!mPluginWindow || !mInstance) {
-    return;
-  }
-
-  mPluginWindow->clipRect.bottom = mPluginWindow->clipRect.top;
-  mPluginWindow->clipRect.right = mPluginWindow->clipRect.left;
-  mWidgetVisible = false;
-  if (UseAsyncRendering()) {
-    mInstance->AsyncSetWindow(mPluginWindow);
-  } else {
-    mInstance->SetWindow(mPluginWindow);
-  }
-}
-
-#else   // XP_MACOSX
-
-void nsPluginInstanceOwner::UpdateWindowPositionAndClipRect(bool aSetWindow) {
-  return;
-}
-
-void nsPluginInstanceOwner::UpdateWindowVisibility(bool aVisible) {
-  mPluginWindowVisible = aVisible;
-  UpdateWindowPositionAndClipRect(true);
-}
-#endif  // XP_MACOSX
-
-void nsPluginInstanceOwner::ResolutionMayHaveChanged() {
-#if defined(XP_MACOSX) || defined(XP_WIN)
-  double scaleFactor = 1.0;
-  GetContentsScaleFactor(&scaleFactor);
-  if (scaleFactor != mLastScaleFactor) {
-    ContentsScaleFactorChanged(scaleFactor);
-    mLastScaleFactor = scaleFactor;
-  }
-#endif
-  float zoomFactor = 1.0;
-  GetCSSZoomFactor(&zoomFactor);
-  if (zoomFactor != mLastCSSZoomFactor) {
-    if (mInstance) {
-      mInstance->CSSZoomFactorChanged(zoomFactor);
-    }
-    mLastCSSZoomFactor = zoomFactor;
-  }
-}
-
-void nsPluginInstanceOwner::UpdateDocumentActiveState(bool aIsActive) {
-  AUTO_PROFILER_LABEL("nsPluginInstanceOwner::UpdateDocumentActiveState",
-                      OTHER);
-
-  mPluginDocumentActiveState = aIsActive;
-#ifndef XP_MACOSX
-  UpdateWindowPositionAndClipRect(true);
-
-  // We don't have a connection to PluginWidgetParent in the chrome
-  // process when dealing with tab visibility changes, so this needs
-  // to be forwarded over after the active state is updated. If we
-  // don't hide plugin widgets in hidden tabs, the native child window
-  // in chrome will remain visible after a tab switch.
-  if (mWidget && XRE_IsContentProcess()) {
-    mWidget->Show(aIsActive);
-    mWidget->Enable(aIsActive);
-  }
-#endif  // #ifndef XP_MACOSX
-}
-
-NS_IMETHODIMP
-nsPluginInstanceOwner::CallSetWindow() {
-  if (!mWidgetCreationComplete) {
-    // No widget yet, we can't run this code
-    return NS_OK;
-  }
-  if (mInstance) {
-    if (UseAsyncRendering()) {
-      mInstance->AsyncSetWindow(mPluginWindow);
-    } else {
-      mInstance->SetWindow(mPluginWindow);
-    }
-  }
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsPluginInstanceOwner::GetContentsScaleFactor(double* result) {
-  NS_ENSURE_ARG_POINTER(result);
-  double scaleFactor = 1.0;
-  // On Mac, device pixels need to be translated to (and from) "display pixels"
-  // for plugins. On other platforms, plugin coordinates are always in device
-  // pixels.
-#if defined(XP_MACOSX) || defined(XP_WIN)
-  nsCOMPtr<nsIContent> content = do_QueryReferent(mContent);
-  PresShell* presShell =
-      nsContentUtils::FindPresShellForDocument(content->OwnerDoc());
-  if (presShell) {
-    scaleFactor = double(AppUnitsPerCSSPixel()) /
-                  presShell->GetPresContext()
-                      ->DeviceContext()
-                      ->AppUnitsPerDevPixelAtUnitFullZoom();
-  }
-#endif
-  *result = scaleFactor;
-  return NS_OK;
-}
-
-void nsPluginInstanceOwner::GetCSSZoomFactor(float* result) {
-  nsCOMPtr<nsIContent> content = do_QueryReferent(mContent);
-  PresShell* presShell =
-      nsContentUtils::FindPresShellForDocument(content->OwnerDoc());
-  if (presShell) {
-    *result = presShell->GetPresContext()->DeviceContext()->GetFullZoom();
-  } else {
-    *result = 1.0;
-  }
-}
-
-NS_IMETHODIMP nsPluginInstanceOwner::PrivateModeChanged(bool aEnabled) {
-  return mInstance ? mInstance->PrivateModeStateChanged(aEnabled) : NS_OK;
-}
-
-nsIURI* nsPluginInstanceOwner::GetBaseURI() const {
-  nsCOMPtr<nsIContent> content = do_QueryReferent(mContent);
-  if (!content) {
-    return nullptr;
-  }
-  return content->GetBaseURI();
-}
-
-// static
-void nsPluginInstanceOwner::GeneratePluginEvent(
-    const WidgetCompositionEvent* aSrcCompositionEvent,
-    WidgetCompositionEvent* aDistCompositionEvent) {
-#ifdef XP_WIN
-  NPEvent newEvent;
-  switch (aDistCompositionEvent->mMessage) {
-    case eCompositionChange: {
-      newEvent.event = WM_IME_COMPOSITION;
-      newEvent.wParam = 0;
-      if (aSrcCompositionEvent &&
-          (aSrcCompositionEvent->mMessage == eCompositionCommit ||
-           aSrcCompositionEvent->mMessage == eCompositionCommitAsIs)) {
-        newEvent.lParam = GCS_RESULTSTR;
-      } else {
-        newEvent.lParam = GCS_COMPSTR | GCS_COMPATTR | GCS_COMPCLAUSE;
-      }
-      TextRangeArray* ranges = aDistCompositionEvent->mRanges;
-      if (ranges && ranges->HasCaret()) {
-        newEvent.lParam |= GCS_CURSORPOS;
-      }
-      break;
-    }
-
-    case eCompositionStart:
-      newEvent.event = WM_IME_STARTCOMPOSITION;
-      newEvent.wParam = 0;
-      newEvent.lParam = 0;
-      break;
-
-    case eCompositionEnd:
-      newEvent.event = WM_IME_ENDCOMPOSITION;
-      newEvent.wParam = 0;
-      newEvent.lParam = 0;
-      break;
-
-    default:
-      return;
-  }
-  aDistCompositionEvent->mPluginEvent.Copy(newEvent);
-#endif
-}
-
-// nsPluginDOMContextMenuListener class implementation
-
-nsPluginDOMContextMenuListener::nsPluginDOMContextMenuListener(
-    nsIContent* aContent) {
-  aContent->AddEventListener(u"contextmenu"_ns, this, true);
-}
-
-nsPluginDOMContextMenuListener::~nsPluginDOMContextMenuListener() = default;
-
-NS_IMPL_ISUPPORTS(nsPluginDOMContextMenuListener, nsIDOMEventListener)
-
-NS_IMETHODIMP
-nsPluginDOMContextMenuListener::HandleEvent(Event* aEvent) {
-  aEvent->PreventDefault();  // consume event
-
-  return NS_OK;
-}
-
-void nsPluginDOMContextMenuListener::Destroy(nsIContent* aContent) {
-  // Unregister context menu listener
-  aContent->RemoveEventListener(u"contextmenu"_ns, this, true);
-}
diff --git a/dom/plugins/base/nsPluginInstanceOwner.h b/dom/plugins/base/nsPluginInstanceOwner.h
deleted file mode 100644
index 1c54b70a2c2b7..0000000000000
--- a/dom/plugins/base/nsPluginInstanceOwner.h
+++ /dev/null
@@ -1,365 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-// vim:set ts=2 sts=2 sw=2 et cin:
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef nsPluginInstanceOwner_h_
-#define nsPluginInstanceOwner_h_
-
-#include "mozilla/Attributes.h"
-#include "mozilla/StaticPtr.h"
-#include "mozilla/dom/HTMLObjectElementBinding.h"
-#include "npapi.h"
-#include "nsCOMPtr.h"
-#include "nsIPluginInstanceOwner.h"
-#include "nsIPrivacyTransitionObserver.h"
-#include "nsIDOMEventListener.h"
-#include "nsPluginHost.h"
-#include "nsPluginNativeWindow.h"
-#include "nsWeakReference.h"
-#include "gfxRect.h"
-
-#ifdef XP_MACOSX
-#  include "mozilla/gfx/QuartzSupport.h"
-#  include <ApplicationServices/ApplicationServices.h>
-#endif
-
-class nsIInputStream;
-class nsPluginDOMContextMenuListener;
-class nsDisplayListBuilder;
-
-#if defined(MOZ_X11)
-class gfxContext;
-#endif
-
-namespace mozilla {
-class TextComposition;
-namespace dom {
-class Element;
-class Event;
-}  // namespace dom
-namespace widget {
-class PuppetWidget;
-}  // namespace widget
-}  // namespace mozilla
-
-using mozilla::widget::PuppetWidget;
-
-#ifdef MOZ_X11
-#  include "gfxXlibNativeRenderer.h"
-#endif
-
-class nsPluginInstanceOwner final : public nsIPluginInstanceOwner,
-                                    public nsIDOMEventListener,
-                                    public nsIPrivacyTransitionObserver,
-                                    public nsSupportsWeakReference {
- public:
-  typedef mozilla::gfx::DrawTarget DrawTarget;
-
-  nsPluginInstanceOwner();
-
-  NS_DECL_ISUPPORTS
-  NS_DECL_NSIPLUGININSTANCEOWNER
-  NS_DECL_NSIPRIVACYTRANSITIONOBSERVER
-
-  NS_IMETHOD GetURL(const char* aURL, const char* aTarget,
-                    nsIInputStream* aPostStream, void* aHeadersData,
-                    uint32_t aHeadersDataLen,
-                    bool aDoCheckLoadURIChecks) override;
-
-  NPBool ConvertPoint(double sourceX, double sourceY,
-                      NPCoordinateSpace sourceSpace, double* destX,
-                      double* destY, NPCoordinateSpace destSpace) override;
-
-  NPError InitAsyncSurface(NPSize* size, NPImageFormat format, void* initData,
-                           NPAsyncSurface* surface) override;
-  NPError FinalizeAsyncSurface(NPAsyncSurface* surface) override;
-  void SetCurrentAsyncSurface(NPAsyncSurface* surface,
-                              NPRect* changed) override;
-
-  /**
-   * Get the type of the HTML tag that was used to instantiate this
-   * plugin.  Currently supported tags are EMBED or OBJECT.
-   */
-  NS_IMETHOD GetTagType(nsPluginTagType* aResult);
-
-  void GetParameters(nsTArray<mozilla::dom::MozPluginParameter>& parameters);
-  void GetAttributes(nsTArray<mozilla::dom::MozPluginParameter>& attributes);
-
-  /**
-   * Returns the DOM element corresponding to the tag which references
-   * this plugin in the document.
-   *
-   * @param aDOMElement - resulting DOM element
-   * @result - NS_OK if this operation was successful
-   */
-  NS_IMETHOD GetDOMElement(mozilla::dom::Element** aResult);
-
-  // nsIDOMEventListener interfaces
-  NS_DECL_NSIDOMEVENTLISTENER
-
-  MOZ_CAN_RUN_SCRIPT_BOUNDARY nsresult
-  ProcessMouseDown(mozilla::dom::Event* aMouseEvent);
-  nsresult ProcessKeyPress(mozilla::dom::Event* aKeyEvent);
-  nsresult Destroy();
-
-#ifdef XP_WIN
-  void Paint(const RECT& aDirty, HDC aDC);
-#elif defined(XP_MACOSX)
-  void Paint(const gfxRect& aDirtyRect, CGContextRef cgContext);
-  void RenderCoreAnimation(CGContextRef aCGContext, int aWidth, int aHeight);
-  void DoCocoaEventDrawRect(const gfxRect& aDrawRect, CGContextRef cgContext);
-#elif defined(MOZ_X11)
-  void Paint(gfxContext* aContext, const gfxRect& aFrameRect,
-             const gfxRect& aDirtyRect);
-#endif
-
-  // locals
-
-  nsresult Init(nsIContent* aContent);
-
-  void* GetPluginPort();
-  void ReleasePluginPort(void* pluginPort);
-
-  nsEventStatus ProcessEvent(const mozilla::WidgetGUIEvent& anEvent);
-
-  static void GeneratePluginEvent(
-      const mozilla::WidgetCompositionEvent* aSrcCompositionEvent,
-      mozilla::WidgetCompositionEvent* aDistCompositionEvent);
-
-#if defined(XP_WIN)
-  void SetWidgetWindowAsParent(HWND aWindowToAdopt);
-  nsresult SetNetscapeWindowAsParent(HWND aWindowToAdopt);
-#endif
-
-#ifdef XP_MACOSX
-  enum {ePluginPaintEnable, ePluginPaintDisable};
-
-  void WindowFocusMayHaveChanged();
-
-  bool WindowIsActive();
-  void SendWindowFocusChanged(bool aIsActive);
-  NPDrawingModel GetDrawingModel();
-  bool IsRemoteDrawingCoreAnimation();
-
-  NPEventModel GetEventModel();
-  static void CARefresh(nsITimer* aTimer, void* aClosure);
-  void AddToCARefreshTimer();
-  void RemoveFromCARefreshTimer();
-  // This calls into the plugin (NPP_SetWindow) and can run script.
-  void FixUpPluginWindow(int32_t inPaintState);
-  void HidePluginWindow();
-  // Set plugin port info in the plugin (in the 'window' member of the
-  // NPWindow structure passed to the plugin by SetWindow()).
-  void SetPluginPort();
-#else   // XP_MACOSX
-  void UpdateWindowPositionAndClipRect(bool aSetWindow);
-  void UpdateWindowVisibility(bool aVisible);
-#endif  // XP_MACOSX
-
-  void ResolutionMayHaveChanged();
-#if defined(XP_MACOSX) || defined(XP_WIN)
-  nsresult ContentsScaleFactorChanged(double aContentsScaleFactor);
-#endif
-
-  void UpdateDocumentActiveState(bool aIsActive);
-
-  uint32_t GetLastEventloopNestingLevel() const {
-    return mLastEventloopNestingLevel;
-  }
-
-  static uint32_t GetEventloopNestingLevel();
-
-  void ConsiderNewEventloopNestingLevel() {
-    uint32_t currentLevel = GetEventloopNestingLevel();
-
-    if (currentLevel < mLastEventloopNestingLevel) {
-      mLastEventloopNestingLevel = currentLevel;
-    }
-  }
-
-  const char* GetPluginName() {
-    if (mInstance && mPluginHost) {
-      const char* name = nullptr;
-      if (NS_SUCCEEDED(mPluginHost->GetPluginName(mInstance, &name)) && name)
-        return name;
-    }
-    return "";
-  }
-
-#ifdef MOZ_X11
-  void GetPluginDescription(nsACString& aDescription) {
-    aDescription.Truncate();
-    if (mInstance && mPluginHost) {
-      nsCOMPtr<nsIPluginTag> pluginTag;
-
-      mPluginHost->GetPluginTagForInstance(mInstance,
-                                           getter_AddRefs(pluginTag));
-      if (pluginTag) {
-        pluginTag->GetDescription(aDescription);
-      }
-    }
-  }
-#endif
-
-  bool SendNativeEvents() {
-#ifdef XP_WIN
-    // XXX we should remove the plugin name check
-    return mPluginWindow->type == NPWindowTypeDrawable &&
-           (MatchPluginName("Shockwave Flash") ||
-            MatchPluginName("Test Plug-in"));
-#elif defined(MOZ_X11) || defined(XP_MACOSX)
-    return true;
-#else
-    return false;
-#endif
-  }
-
-  bool MatchPluginName(const char* aPluginName) {
-    return strncmp(GetPluginName(), aPluginName, strlen(aPluginName)) == 0;
-  }
-
-  void NotifyPaintWaiter(nsDisplayListBuilder* aBuilder);
-
-  // Returns the image container that has our currently displayed image.
-  already_AddRefed<mozilla::layers::ImageContainer> GetImageContainer();
-  // Returns true if this is windowed plugin that can return static captures
-  // for scroll operations.
-  bool NeedsScrollImageLayer();
-
-  void DidComposite();
-
-  /**
-   * Returns the bounds of the current async-rendered surface. This can only
-   * change in response to messages received by the event loop (i.e. not during
-   * painting).
-   */
-  nsIntSize GetCurrentImageSize();
-
-  // Methods to update the background image we send to async plugins.
-  // The eventual target of these operations is PluginInstanceParent,
-  // but it takes several hops to get there.
-  void SetBackgroundUnknown();
-  already_AddRefed<DrawTarget> BeginUpdateBackground(const nsIntRect& aRect);
-  void EndUpdateBackground(const nsIntRect& aRect);
-
-  bool UseAsyncRendering();
-
-  nsIURI* GetBaseURI() const;
-
-  bool GetCompositionString(uint32_t aIndex, nsTArray<uint8_t>* aString,
-                            int32_t* aLength);
-  bool RequestCommitOrCancel(bool aCommitted);
-
-  void GetCSSZoomFactor(float* result);
-
- private:
-  virtual ~nsPluginInstanceOwner();
-
-  // return FALSE if LayerSurface dirty (newly created and don't have valid
-  // plugin content yet)
-  bool IsUpToDate() {
-    nsIntSize size;
-    return NS_SUCCEEDED(mInstance->GetImageSize(&size)) &&
-           size == nsIntSize(mPluginWindow->width, mPluginWindow->height);
-  }
-
-#if defined(XP_WIN)
-  nsIWidget* GetContainingWidgetIfOffset();
-  already_AddRefed<mozilla::TextComposition> GetTextComposition();
-  void HandleNoConsumedCompositionMessage(
-      mozilla::WidgetCompositionEvent* aCompositionEvent,
-      const NPEvent* aPluginEvent);
-  bool mGotCompositionData;
-  bool mSentStartComposition;
-  bool mPluginDidNotHandleIMEComposition;
-  uint32_t mWheelScrollLines;
-  uint32_t mWheelScrollChars;
-#endif
-
-  nsPluginNativeWindow* mPluginWindow;
-  RefPtr<nsNPAPIPluginInstance> mInstance;
-  nsWeakPtr mContent;  // WEAK, content owns us
-  nsCString mDocumentBase;
-  bool mWidgetCreationComplete;
-  nsCOMPtr<nsIWidget> mWidget;
-  RefPtr<nsPluginHost> mPluginHost;
-
-#ifdef XP_MACOSX
-  static mozilla::StaticRefPtr<nsITimer> sCATimer;
-  static nsTArray<nsPluginInstanceOwner*>* sCARefreshListeners;
-  bool mSentInitialTopLevelWindowEvent;
-  bool mLastWindowIsActive;
-  bool mLastContentFocused;
-  // True if, the next time the window is activated, we should blur ourselves.
-  bool mShouldBlurOnActivate;
-#endif
-  double mLastScaleFactor;
-  double mLastCSSZoomFactor;
-  // Initially, the event loop nesting level we were created on, it's updated
-  // if we detect the appshell is on a lower level as long as we're not stopped.
-  // We delay DoStopPlugin() until the appshell reaches this level or lower.
-  uint32_t mLastEventloopNestingLevel;
-  bool mContentFocused;
-  bool mWidgetVisible;  // used on Mac to store our widget's visible state
-#ifdef MOZ_X11
-  // Used with windowless plugins only, initialized in CreateWidget().
-  bool mFlash10Quirks;
-#endif
-  bool mPluginWindowVisible;
-  bool mPluginDocumentActiveState;
-
-#ifdef XP_MACOSX
-  NPEventModel mEventModel;
-  // This is a hack! UseAsyncRendering() can incorrectly return false
-  // when we don't have an object frame (possible as of bug 90268).
-  // We hack around this by always returning true if we've ever
-  // returned true.
-  bool mUseAsyncRendering;
-#endif
-
-  // pointer to wrapper for nsIDOMContextMenuListener
-  RefPtr<nsPluginDOMContextMenuListener> mCXMenuListener;
-
-  nsresult DispatchKeyToPlugin(mozilla::dom::Event* aKeyEvent);
-  nsresult DispatchMouseToPlugin(mozilla::dom::Event* aMouseEvent,
-                                 bool aAllowPropagate = false);
-  nsresult DispatchFocusToPlugin(mozilla::dom::Event* aFocusEvent);
-  nsresult DispatchCompositionToPlugin(mozilla::dom::Event* aEvent);
-
-#ifdef XP_WIN
-  void CallDefaultProc(const mozilla::WidgetGUIEvent* aEvent);
-#endif
-
-#ifdef XP_MACOSX
-  void PerformDelayedBlurs();
-#endif  // XP_MACOSX
-
-  int mLastMouseDownButtonType;
-
-#ifdef MOZ_X11
-  class Renderer : public gfxXlibNativeRenderer {
-   public:
-    Renderer(NPWindow* aWindow, nsPluginInstanceOwner* aInstanceOwner,
-             const nsIntSize& aPluginSize, const nsIntRect& aDirtyRect)
-        : mWindow(aWindow),
-          mInstanceOwner(aInstanceOwner),
-          mPluginSize(aPluginSize),
-          mDirtyRect(aDirtyRect) {}
-    virtual nsresult DrawWithXlib(cairo_surface_t* surface, nsIntPoint offset,
-                                  nsIntRect* clipRects,
-                                  uint32_t numClipRects) override;
-
-   private:
-    NPWindow* mWindow;
-    nsPluginInstanceOwner* mInstanceOwner;
-    const nsIntSize& mPluginSize;
-    const nsIntRect& mDirtyRect;
-  };
-#endif
-
-  bool mWaitingForPaint;
-};
-
-#endif  // nsPluginInstanceOwner_h_
diff --git a/dom/plugins/base/nsPluginManifestLineReader.h b/dom/plugins/base/nsPluginManifestLineReader.h
deleted file mode 100644
index 4e2f6f3d54dfd..0000000000000
--- a/dom/plugins/base/nsPluginManifestLineReader.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef nsPluginManifestLineReader_h_
-#define nsPluginManifestLineReader_h_
-
-#include "nspr.h"
-#include "nsDebug.h"
-
-#ifdef XP_WIN
-#  define PLUGIN_REGISTRY_FIELD_DELIMITER '|'
-#else
-#  define PLUGIN_REGISTRY_FIELD_DELIMITER ':'
-#endif
-
-#define PLUGIN_REGISTRY_END_OF_LINE_MARKER '$'
-
-class nsPluginManifestLineReader {
- public:
-  nsPluginManifestLineReader() : mLength(0) {
-    mBase = mCur = mNext = mLimit = 0;
-  }
-  ~nsPluginManifestLineReader() {
-    if (mBase) delete[] mBase;
-    mBase = 0;
-  }
-
-  char* Init(uint32_t flen) {
-    mBase = mCur = mNext = new char[flen + 1];
-    if (mBase) {
-      mLimit = mBase + flen;
-      *mLimit = 0;
-    }
-    mLength = 0;
-    return mBase;
-  }
-
-  bool NextLine() {
-    if (mNext >= mLimit) return false;
-
-    mCur = mNext;
-    mLength = 0;
-
-    char* lastDelimiter = 0;
-    while (mNext < mLimit) {
-      if (IsEOL(*mNext)) {
-        if (lastDelimiter) {
-          if (lastDelimiter &&
-              *(mNext - 1) != PLUGIN_REGISTRY_END_OF_LINE_MARKER)
-            return false;
-          *lastDelimiter = '\0';
-        } else {
-          *mNext = '\0';
-        }
-
-        for (++mNext; mNext < mLimit; ++mNext) {
-          if (!IsEOL(*mNext)) break;
-        }
-        return true;
-      }
-      if (*mNext == PLUGIN_REGISTRY_FIELD_DELIMITER) lastDelimiter = mNext;
-      ++mNext;
-      ++mLength;
-    }
-    return false;
-  }
-
-  int ParseLine(char** chunks, int maxChunks) {
-    NS_ASSERTION(mCur && maxChunks && chunks, "bad call to ParseLine");
-    int found = 0;
-    chunks[found++] = mCur;
-
-    if (found < maxChunks) {
-      for (char* cur = mCur; *cur; cur++) {
-        if (*cur == PLUGIN_REGISTRY_FIELD_DELIMITER) {
-          *cur = 0;
-          chunks[found++] = cur + 1;
-          if (found == maxChunks) break;
-        }
-      }
-    }
-    return found;
-  }
-
-  char* LinePtr() { return mCur; }
-  uint32_t LineLength() { return mLength; }
-
-  bool IsEOL(char c) { return c == '\n' || c == '\r'; }
-
-  char* mBase;
-
- private:
-  char* mCur;
-  uint32_t mLength;
-  char* mNext;
-  char* mLimit;
-};
-
-#endif
diff --git a/dom/plugins/base/nsPluginNativeWindow.cpp b/dom/plugins/base/nsPluginNativeWindow.cpp
deleted file mode 100644
index 73da098cd48f6..0000000000000
--- a/dom/plugins/base/nsPluginNativeWindow.cpp
+++ /dev/null
@@ -1,61 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-/**
- *  This file is the default implementation of plugin native window
- *  empty stubs, it should be replaced with real platform implementation
- *  for every platform
- */
-
-#include "nsDebug.h"
-#include "nsPluginNativeWindow.h"
-
-class nsPluginNativeWindowImpl : public nsPluginNativeWindow {
- public:
-  nsPluginNativeWindowImpl();
-  virtual ~nsPluginNativeWindowImpl();
-
-#if defined(MOZ_WIDGET_GTK) && defined(MOZ_X11)
-  NPSetWindowCallbackStruct mWsInfo;
-#endif
-};
-
-nsPluginNativeWindowImpl::nsPluginNativeWindowImpl() : nsPluginNativeWindow() {
-  // initialize the struct fields
-  window = nullptr;
-  x = 0;
-  y = 0;
-  width = 0;
-  height = 0;
-  memset(&clipRect, 0, sizeof(clipRect));
-  type = NPWindowTypeWindow;
-
-#if defined(MOZ_WIDGET_GTK) && defined(MOZ_X11)
-  ws_info = &mWsInfo;
-  mWsInfo.type = 0;
-  mWsInfo.display = nullptr;
-  mWsInfo.visual = nullptr;
-  mWsInfo.colormap = 0;
-  mWsInfo.depth = 0;
-#elif defined(XP_UNIX) && !defined(XP_MACOSX)
-  ws_info = nullptr;
-#endif
-}
-
-nsPluginNativeWindowImpl::~nsPluginNativeWindowImpl() = default;
-
-nsresult PLUG_NewPluginNativeWindow(
-    nsPluginNativeWindow** aPluginNativeWindow) {
-  NS_ENSURE_ARG_POINTER(aPluginNativeWindow);
-  *aPluginNativeWindow = new nsPluginNativeWindowImpl();
-  return NS_OK;
-}
-
-nsresult PLUG_DeletePluginNativeWindow(
-    nsPluginNativeWindow* aPluginNativeWindow) {
-  NS_ENSURE_ARG_POINTER(aPluginNativeWindow);
-  delete static_cast<nsPluginNativeWindowImpl*>(aPluginNativeWindow);
-  return NS_OK;
-}
diff --git a/dom/plugins/base/nsPluginNativeWindow.h b/dom/plugins/base/nsPluginNativeWindow.h
deleted file mode 100644
index b880a74535ce5..0000000000000
--- a/dom/plugins/base/nsPluginNativeWindow.h
+++ /dev/null
@@ -1,76 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef _nsPluginNativeWindow_h_
-#define _nsPluginNativeWindow_h_
-
-#include "nscore.h"
-#include "nsCOMPtr.h"
-#include "nsISupportsImpl.h"
-#include "nsNPAPIPluginInstance.h"
-#include "npapi.h"
-#include "nsIWidget.h"
-
-/**
- * base class for native plugin window implementations
- */
-class nsPluginNativeWindow : public NPWindow {
- public:
-  nsPluginNativeWindow() : NPWindow() { MOZ_COUNT_CTOR(nsPluginNativeWindow); }
-
-  MOZ_COUNTED_DTOR_VIRTUAL(nsPluginNativeWindow)
-
-  /**
-   *   !!! CAUTION !!!
-   *
-   * The base class |nsPluginWindow| is defined as a struct in nsplugindefs.h,
-   * thus it does not have a destructor of its own.
-   * One should never attempt to delete |nsPluginNativeWindow| object instance
-   * (or derivatives) using a pointer of |nsPluginWindow *| type. Should such
-   * necessity occur it must be properly casted first.
-   */
-
- public:
-  nsresult GetPluginInstance(RefPtr<nsNPAPIPluginInstance>& aPluginInstance) {
-    aPluginInstance = mPluginInstance;
-    return NS_OK;
-  }
-  nsresult SetPluginInstance(nsNPAPIPluginInstance* aPluginInstance) {
-    if (mPluginInstance != aPluginInstance) mPluginInstance = aPluginInstance;
-    return NS_OK;
-  }
-
-  nsresult GetPluginWidget(nsIWidget** aWidget) const {
-    NS_IF_ADDREF(*aWidget = mWidget);
-    return NS_OK;
-  }
-  nsresult SetPluginWidget(nsIWidget* aWidget) {
-    mWidget = aWidget;
-    return NS_OK;
-  }
-
- public:
-  virtual nsresult CallSetWindow(
-      RefPtr<nsNPAPIPluginInstance>& aPluginInstance) {
-    // null aPluginInstance means that we want to call SetWindow(null)
-    if (aPluginInstance)
-      aPluginInstance->SetWindow(this);
-    else if (mPluginInstance)
-      mPluginInstance->SetWindow(nullptr);
-
-    SetPluginInstance(aPluginInstance);
-    return NS_OK;
-  }
-
- protected:
-  RefPtr<nsNPAPIPluginInstance> mPluginInstance;
-  nsCOMPtr<nsIWidget> mWidget;
-};
-
-nsresult PLUG_NewPluginNativeWindow(nsPluginNativeWindow** aPluginNativeWindow);
-nsresult PLUG_DeletePluginNativeWindow(
-    nsPluginNativeWindow* aPluginNativeWindow);
-
-#endif  //_nsPluginNativeWindow_h_
diff --git a/dom/plugins/base/nsPluginNativeWindowWin.cpp b/dom/plugins/base/nsPluginNativeWindowWin.cpp
deleted file mode 100644
index 9444b52530983..0000000000000
--- a/dom/plugins/base/nsPluginNativeWindowWin.cpp
+++ /dev/null
@@ -1,633 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "mozilla/BasicEvents.h"
-#include "mozilla/DebugOnly.h"
-#include "mozilla/WeakPtr.h"
-
-#include "windows.h"
-#include "windowsx.h"
-
-// XXXbz windowsx.h defines GetFirstChild, GetNextSibling,
-// GetPrevSibling are macros, apparently... Eeevil.  We have functions
-// called that on some classes, so undef them.
-#undef GetFirstChild
-#undef GetNextSibling
-#undef GetPrevSibling
-
-#include "nsDebug.h"
-
-#include "nsWindowsDllInterceptor.h"
-#include "nsPluginNativeWindow.h"
-#include "nsThreadUtils.h"
-#include "nsCrashOnException.h"
-
-using namespace mozilla;
-
-#define NP_POPUP_API_VERSION 16
-
-#define nsMajorVersion(v) (((int32_t)(v) >> 16) & 0xffff)
-#define nsMinorVersion(v) ((int32_t)(v)&0xffff)
-#define versionOK(suppliedV, requiredV)                      \
-  (nsMajorVersion(suppliedV) == nsMajorVersion(requiredV) && \
-   nsMinorVersion(suppliedV) >= nsMinorVersion(requiredV))
-
-#define NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION \
-  TEXT("MozillaPluginWindowPropertyAssociation")
-#define NS_PLUGIN_CUSTOM_MSG_ID TEXT("MozFlashUserRelay")
-#define WM_USER_FLASH WM_USER + 1
-static UINT sWM_FLASHBOUNCEMSG = 0;
-
-class nsPluginNativeWindowWin;
-
-/**
- *  PLEvent handling code
- */
-class PluginWindowEvent : public Runnable {
- public:
-  PluginWindowEvent();
-  void Init(WeakPtr<nsPluginNativeWindowWin> aRef, HWND aWnd, UINT aMsg,
-            WPARAM aParam, LPARAM aLParam);
-  void Clear();
-  HWND GetWnd() { return mWnd; };
-  UINT GetMsg() { return mMsg; };
-  WPARAM GetWParam() { return mWParam; };
-  LPARAM GetLParam() { return mLParam; };
-  bool InUse() { return mWnd != nullptr; };
-
-  NS_DECL_NSIRUNNABLE
-
- protected:
-  WeakPtr<nsPluginNativeWindowWin> mPluginWindowRef;
-  HWND mWnd;
-  UINT mMsg;
-  WPARAM mWParam;
-  LPARAM mLParam;
-};
-
-PluginWindowEvent::PluginWindowEvent() : Runnable("PluginWindowEvent") {
-  Clear();
-}
-
-void PluginWindowEvent::Clear() {
-  mWnd = nullptr;
-  mMsg = 0;
-  mWParam = 0;
-  mLParam = 0;
-}
-
-void PluginWindowEvent::Init(WeakPtr<nsPluginNativeWindowWin> aRef, HWND aWnd,
-                             UINT aMsg, WPARAM aWParam, LPARAM aLParam) {
-  NS_ASSERTION(aWnd != nullptr, "invalid plugin event value");
-  NS_ASSERTION(mWnd == nullptr, "event already in use");
-  mPluginWindowRef = aRef;
-  mWnd = aWnd;
-  mMsg = aMsg;
-  mWParam = aWParam;
-  mLParam = aLParam;
-}
-
-/**
- *  nsPluginNativeWindow Windows specific class declaration
- */
-
-class nsPluginNativeWindowWin : public nsPluginNativeWindow,
-                                public SupportsWeakPtr {
- public:
-  nsPluginNativeWindowWin();
-
-  virtual nsresult CallSetWindow(
-      RefPtr<nsNPAPIPluginInstance>& aPluginInstance);
-
- private:
-  nsresult SubclassAndAssociateWindow();
-  nsresult UndoSubclassAndAssociateWindow();
-
- public:
-  // locals
-  WNDPROC GetPrevWindowProc();
-  void SetPrevWindowProc(WNDPROC proc) { mPluginWinProc = proc; }
-  WNDPROC GetWindowProc();
-  PluginWindowEvent* GetPluginWindowEvent(HWND aWnd, UINT aMsg, WPARAM aWParam,
-                                          LPARAM aLParam);
-
- private:
-  WNDPROC mPluginWinProc;
-  WNDPROC mPrevWinProc;
-  WeakPtr<nsPluginNativeWindowWin> mWeakRef;
-  RefPtr<PluginWindowEvent> mCachedPluginWindowEvent;
-
-  HWND mParentWnd;
-  LONG_PTR mParentProc;
-
- public:
-  nsPluginHost::SpecialType mPluginType;
-};
-
-static bool sInPreviousMessageDispatch = false;
-
-static bool ProcessFlashMessageDelayed(nsPluginNativeWindowWin* aWin,
-                                       nsNPAPIPluginInstance* aInst, HWND hWnd,
-                                       UINT msg, WPARAM wParam, LPARAM lParam) {
-  NS_ENSURE_TRUE(aWin, false);
-  NS_ENSURE_TRUE(aInst, false);
-
-  if (msg == sWM_FLASHBOUNCEMSG) {
-    // See PluginWindowEvent::Run() below.
-    NS_ASSERTION((sWM_FLASHBOUNCEMSG != 0),
-                 "RegisterWindowMessage failed in flash plugin WM_USER message "
-                 "handling!");
-    ::CallWindowProc((WNDPROC)aWin->GetWindowProc(), hWnd, WM_USER_FLASH,
-                     wParam, lParam);
-    return true;
-  }
-
-  if (msg != WM_USER_FLASH) return false;  // no need to delay
-
-  // do stuff
-  nsCOMPtr<nsIRunnable> pwe =
-      aWin->GetPluginWindowEvent(hWnd, msg, wParam, lParam);
-  if (pwe) {
-    NS_DispatchToCurrentThread(pwe);
-    return true;
-  }
-  return false;
-}
-
-class nsDelayedPopupsEnabledEvent : public Runnable {
- public:
-  explicit nsDelayedPopupsEnabledEvent(nsNPAPIPluginInstance* inst)
-      : Runnable("nsDelayedPopupsEnabledEvent"), mInst(inst) {}
-
-  NS_DECL_NSIRUNNABLE
-
- private:
-  RefPtr<nsNPAPIPluginInstance> mInst;
-};
-
-NS_IMETHODIMP nsDelayedPopupsEnabledEvent::Run() {
-  mInst->PushPopupsEnabledState(false);
-  return NS_OK;
-}
-
-static LRESULT CALLBACK PluginWndProc(HWND hWnd, UINT msg, WPARAM wParam,
-                                      LPARAM lParam);
-
-/**
- * New plugin window procedure
- *
- * e10s note - this subclass, and the hooks we set below using
- * WindowsDllInterceptor are currently not in use when running with e10s.
- * (Utility calls like CallSetWindow are still in use in the content process.)
- * We would like to keep things this away, essentially making all the hacks here
- * obsolete. Some of the mitigation work here has already been supplanted by
- * code in PluginInstanceChild. The rest we eventually want to rip out.
- */
-static LRESULT CALLBACK PluginWndProcInternal(HWND hWnd, UINT msg,
-                                              WPARAM wParam, LPARAM lParam) {
-  nsPluginNativeWindowWin* win = (nsPluginNativeWindowWin*)::GetProp(
-      hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
-  if (!win) return TRUE;
-
-  // The DispatchEvent(ePluginActivate) below can trigger a reentrant focus
-  // event which might destroy us.  Hold a strong ref on the plugin instance
-  // to prevent that, bug 374229.
-  RefPtr<nsNPAPIPluginInstance> inst;
-  win->GetPluginInstance(inst);
-
-  bool enablePopups = false;
-
-  // Activate/deactivate mouse capture on the plugin widget
-  // here, before we pass the Windows event to the plugin
-  // because its possible our widget won't get paired events
-  // (see bug 131007) and we'll look frozen. Note that this
-  // is also done in ChildWindow::DispatchMouseEvent.
-  switch (msg) {
-    case WM_LBUTTONDOWN:
-    case WM_MBUTTONDOWN:
-    case WM_RBUTTONDOWN: {
-      nsCOMPtr<nsIWidget> widget;
-      win->GetPluginWidget(getter_AddRefs(widget));
-      if (widget) widget->CaptureMouse(true);
-      break;
-    }
-    case WM_LBUTTONUP:
-      enablePopups = true;
-
-      // fall through
-    case WM_MBUTTONUP:
-    case WM_RBUTTONUP: {
-      nsCOMPtr<nsIWidget> widget;
-      win->GetPluginWidget(getter_AddRefs(widget));
-      if (widget) widget->CaptureMouse(false);
-      break;
-    }
-    case WM_KEYDOWN:
-      // Ignore repeating keydown messages...
-      if ((lParam & 0x40000000) != 0) {
-        break;
-      }
-
-      // fall through
-    case WM_KEYUP:
-      enablePopups = true;
-
-      break;
-
-    case WM_SETFOCUS:
-    case WM_KILLFOCUS: {
-      // Make sure setfocus and killfocus get through to the widget procedure
-      // even if they are eaten by the plugin. Also make sure we aren't calling
-      // recursively.
-      WNDPROC prevWndProc = win->GetPrevWindowProc();
-      if (prevWndProc && !sInPreviousMessageDispatch) {
-        sInPreviousMessageDispatch = true;
-        ::CallWindowProc(prevWndProc, hWnd, msg, wParam, lParam);
-        sInPreviousMessageDispatch = false;
-      }
-      break;
-    }
-  }
-
-  // Macromedia Flash plugin may flood the message queue with some special
-  // messages (WM_USER+1) causing 100% CPU consumption and GUI freeze, see
-  // mozilla bug 132759; we can prevent this from happening by delaying the
-  // processing such messages;
-  if (win->mPluginType == nsPluginHost::eSpecialType_Flash) {
-    if (ProcessFlashMessageDelayed(win, inst, hWnd, msg, wParam, lParam))
-      return TRUE;
-  }
-
-  if (enablePopups && inst) {
-    uint16_t apiVersion;
-    if (NS_SUCCEEDED(inst->GetPluginAPIVersion(&apiVersion)) &&
-        !versionOK(apiVersion, NP_POPUP_API_VERSION)) {
-      inst->PushPopupsEnabledState(true);
-    }
-  }
-
-  LRESULT res;
-  WNDPROC proc = (WNDPROC)win->GetWindowProc();
-  if (PluginWndProc == proc) {
-    NS_WARNING(
-        "Previous plugin window procedure references PluginWndProc! "
-        "Report this bug!");
-    res = CallWindowProc(DefWindowProc, hWnd, msg, wParam, lParam);
-  } else {
-    res = CallWindowProc(proc, hWnd, msg, wParam, lParam);
-  }
-
-  if (inst) {
-    // Popups are enabled (were enabled before the call to
-    // CallWindowProc()). Some plugins (at least the flash player)
-    // post messages from their key handlers etc that delay the actual
-    // processing, so we need to delay the disabling of popups so that
-    // popups remain enabled when the flash player ends up processing
-    // the actual key handlers. We do this by posting an event that
-    // does the disabling, this way our disabling will happen after
-    // the handlers in the plugin are done.
-
-    // Note that it's not fatal if any of this fails (which won't
-    // happen unless we're out of memory anyways) since the plugin
-    // code will pop any popup state pushed by this plugin on
-    // destruction.
-
-    nsCOMPtr<nsIRunnable> event = new nsDelayedPopupsEnabledEvent(inst);
-    if (event) NS_DispatchToCurrentThread(event);
-  }
-
-  return res;
-}
-
-static LRESULT CALLBACK PluginWndProc(HWND hWnd, UINT msg, WPARAM wParam,
-                                      LPARAM lParam) {
-  return mozilla::CallWindowProcCrashProtected(PluginWndProcInternal, hWnd, msg,
-                                               wParam, lParam);
-}
-
-/*
- * Flash will reset the subclass of our widget at various times.
- * (Notably when entering and exiting full screen mode.) This
- * occurs independent of the main plugin window event procedure.
- * We trap these subclass calls to prevent our subclass hook from
- * getting dropped.
- * Note, ascii versions can be nixed once flash versions < 10.1
- * are considered obsolete.
- */
-static WindowsDllInterceptor sUser32Intercept;
-
-#ifdef _WIN64
-typedef LONG_PTR(WINAPI* User32SetWindowLongPtrA)(HWND hWnd, int nIndex,
-                                                  LONG_PTR dwNewLong);
-typedef LONG_PTR(WINAPI* User32SetWindowLongPtrW)(HWND hWnd, int nIndex,
-                                                  LONG_PTR dwNewLong);
-static WindowsDllInterceptor::FuncHookType<User32SetWindowLongPtrA>
-    sUser32SetWindowLongAHookStub;
-static WindowsDllInterceptor::FuncHookType<User32SetWindowLongPtrW>
-    sUser32SetWindowLongWHookStub;
-#else
-typedef LONG(WINAPI* User32SetWindowLongA)(HWND hWnd, int nIndex,
-                                           LONG dwNewLong);
-typedef LONG(WINAPI* User32SetWindowLongW)(HWND hWnd, int nIndex,
-                                           LONG dwNewLong);
-static WindowsDllInterceptor::FuncHookType<User32SetWindowLongA>
-    sUser32SetWindowLongAHookStub;
-static WindowsDllInterceptor::FuncHookType<User32SetWindowLongW>
-    sUser32SetWindowLongWHookStub;
-#endif
-static inline bool SetWindowLongHookCheck(HWND hWnd, int nIndex,
-                                          LONG_PTR newLong) {
-  nsPluginNativeWindowWin* win = (nsPluginNativeWindowWin*)GetProp(
-      hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
-  if (!win || (win && win->mPluginType != nsPluginHost::eSpecialType_Flash) ||
-      (nIndex == GWLP_WNDPROC &&
-       newLong == reinterpret_cast<LONG_PTR>(PluginWndProc)))
-    return true;
-  return false;
-}
-
-#ifdef _WIN64
-LONG_PTR WINAPI SetWindowLongPtrAHook(HWND hWnd, int nIndex, LONG_PTR newLong)
-#else
-LONG WINAPI SetWindowLongAHook(HWND hWnd, int nIndex, LONG newLong)
-#endif
-{
-  if (SetWindowLongHookCheck(hWnd, nIndex, newLong))
-    return sUser32SetWindowLongAHookStub(hWnd, nIndex, newLong);
-
-  // Set flash's new subclass to get the result.
-  LONG_PTR proc = sUser32SetWindowLongAHookStub(hWnd, nIndex, newLong);
-
-  // We already checked this in SetWindowLongHookCheck
-  nsPluginNativeWindowWin* win = (nsPluginNativeWindowWin*)GetProp(
-      hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
-
-  // Hook our subclass back up, just like we do on setwindow.
-  win->SetPrevWindowProc(
-      reinterpret_cast<WNDPROC>(sUser32SetWindowLongWHookStub(
-          hWnd, nIndex, reinterpret_cast<LONG_PTR>(PluginWndProc))));
-  return proc;
-}
-
-#ifdef _WIN64
-LONG_PTR WINAPI SetWindowLongPtrWHook(HWND hWnd, int nIndex, LONG_PTR newLong)
-#else
-LONG WINAPI SetWindowLongWHook(HWND hWnd, int nIndex, LONG newLong)
-#endif
-{
-  if (SetWindowLongHookCheck(hWnd, nIndex, newLong))
-    return sUser32SetWindowLongWHookStub(hWnd, nIndex, newLong);
-
-  // Set flash's new subclass to get the result.
-  LONG_PTR proc = sUser32SetWindowLongWHookStub(hWnd, nIndex, newLong);
-
-  // We already checked this in SetWindowLongHookCheck
-  nsPluginNativeWindowWin* win = (nsPluginNativeWindowWin*)GetProp(
-      hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
-
-  // Hook our subclass back up, just like we do on setwindow.
-  win->SetPrevWindowProc(
-      reinterpret_cast<WNDPROC>(sUser32SetWindowLongWHookStub(
-          hWnd, nIndex, reinterpret_cast<LONG_PTR>(PluginWndProc))));
-  return proc;
-}
-
-static void HookSetWindowLongPtr() {
-  sUser32Intercept.Init("user32.dll");
-#ifdef _WIN64
-  sUser32SetWindowLongAHookStub.Set(sUser32Intercept, "SetWindowLongPtrA",
-                                    &SetWindowLongPtrAHook);
-  sUser32SetWindowLongWHookStub.Set(sUser32Intercept, "SetWindowLongPtrW",
-                                    &SetWindowLongPtrWHook);
-#else
-  sUser32SetWindowLongAHookStub.Set(sUser32Intercept, "SetWindowLongA",
-                                    &SetWindowLongAHook);
-  sUser32SetWindowLongWHookStub.Set(sUser32Intercept, "SetWindowLongW",
-                                    &SetWindowLongWHook);
-#endif
-}
-
-/**
- *   nsPluginNativeWindowWin implementation
- */
-nsPluginNativeWindowWin::nsPluginNativeWindowWin() : nsPluginNativeWindow() {
-  // initialize the struct fields
-  window = nullptr;
-  x = 0;
-  y = 0;
-  width = 0;
-  height = 0;
-  type = NPWindowTypeWindow;
-
-  mPrevWinProc = nullptr;
-  mPluginWinProc = nullptr;
-  mPluginType = nsPluginHost::eSpecialType_None;
-
-  mParentWnd = nullptr;
-  mParentProc = 0;
-}
-
-WNDPROC nsPluginNativeWindowWin::GetPrevWindowProc() { return mPrevWinProc; }
-
-WNDPROC nsPluginNativeWindowWin::GetWindowProc() { return mPluginWinProc; }
-
-NS_IMETHODIMP PluginWindowEvent::Run() {
-  nsPluginNativeWindowWin* win = mPluginWindowRef;
-  if (!win) return NS_OK;
-
-  HWND hWnd = GetWnd();
-  if (!hWnd) return NS_OK;
-
-  RefPtr<nsNPAPIPluginInstance> inst;
-  win->GetPluginInstance(inst);
-
-  if (GetMsg() == WM_USER_FLASH) {
-    // XXX Unwind issues related to runnable event callback depth for this
-    // event and destruction of the plugin. (Bug 493601)
-    ::PostMessage(hWnd, sWM_FLASHBOUNCEMSG, GetWParam(), GetLParam());
-  } else {
-    // Currently not used, but added so that processing events here
-    // is more generic.
-    ::CallWindowProc(win->GetWindowProc(), hWnd, GetMsg(), GetWParam(),
-                     GetLParam());
-  }
-
-  Clear();
-  return NS_OK;
-}
-
-PluginWindowEvent* nsPluginNativeWindowWin::GetPluginWindowEvent(
-    HWND aWnd, UINT aMsg, WPARAM aWParam, LPARAM aLParam) {
-  if (!mWeakRef) {
-    mWeakRef = this;
-    if (!mWeakRef) return nullptr;
-  }
-
-  PluginWindowEvent* event;
-
-  // We have the ability to alloc if needed in case in the future some plugin
-  // should post multiple PostMessages. However, this could lead to many
-  // alloc's per second which could become a performance issue. See bug 169247.
-  if (!mCachedPluginWindowEvent) {
-    event = new PluginWindowEvent();
-    mCachedPluginWindowEvent = event;
-  } else if (mCachedPluginWindowEvent->InUse()) {
-    event = new PluginWindowEvent();
-  } else {
-    event = mCachedPluginWindowEvent;
-  }
-
-  event->Init(mWeakRef, aWnd, aMsg, aWParam, aLParam);
-  return event;
-}
-
-nsresult nsPluginNativeWindowWin::CallSetWindow(
-    RefPtr<nsNPAPIPluginInstance>& aPluginInstance) {
-  // Note, 'window' can be null
-
-  // check the incoming instance, null indicates that window is going away and
-  // we are not interested in subclassing business any more, undo and don't
-  // subclass
-  if (!aPluginInstance) {
-    UndoSubclassAndAssociateWindow();
-    // release plugin instance
-    SetPluginInstance(nullptr);
-    nsPluginNativeWindow::CallSetWindow(aPluginInstance);
-    return NS_OK;
-  }
-
-  // check plugin mime type and cache it if it will need special treatment later
-  if (mPluginType == nsPluginHost::eSpecialType_None) {
-    const char* mimetype = nullptr;
-    if (NS_SUCCEEDED(aPluginInstance->GetMIMEType(&mimetype)) && mimetype) {
-      mPluginType = nsPluginHost::GetSpecialType(nsDependentCString(mimetype));
-    }
-  }
-
-  // With e10s we execute in the content process and as such we don't
-  // have access to native widgets. CallSetWindow and skip native widget
-  // subclassing.
-  if (!XRE_IsParentProcess()) {
-    nsPluginNativeWindow::CallSetWindow(aPluginInstance);
-    return NS_OK;
-  }
-
-  if (!sWM_FLASHBOUNCEMSG) {
-    sWM_FLASHBOUNCEMSG = ::RegisterWindowMessage(NS_PLUGIN_CUSTOM_MSG_ID);
-  }
-
-  if (window) {
-    // grab the widget procedure before the plug-in does a subclass in
-    // setwindow. We'll use this in PluginWndProc for forwarding focus
-    // events to the widget.
-    WNDPROC currentWndProc =
-        (WNDPROC)::GetWindowLongPtr((HWND)window, GWLP_WNDPROC);
-    if (!mPrevWinProc && currentWndProc != PluginWndProc)
-      mPrevWinProc = currentWndProc;
-  }
-
-  nsPluginNativeWindow::CallSetWindow(aPluginInstance);
-
-  SubclassAndAssociateWindow();
-
-  if (window && mPluginType == nsPluginHost::eSpecialType_Flash &&
-      !GetPropW((HWND)window, L"PluginInstanceParentProperty")) {
-    HookSetWindowLongPtr();
-  }
-
-  return NS_OK;
-}
-
-nsresult nsPluginNativeWindowWin::SubclassAndAssociateWindow() {
-  if (type != NPWindowTypeWindow || !window) return NS_ERROR_FAILURE;
-
-  HWND hWnd = (HWND)window;
-
-  // check if we need to subclass
-  WNDPROC currentWndProc = (WNDPROC)::GetWindowLongPtr(hWnd, GWLP_WNDPROC);
-  if (currentWndProc == PluginWndProc) return NS_OK;
-
-  // If the plugin reset the subclass, set it back.
-  if (mPluginWinProc) {
-#ifdef DEBUG
-    NS_WARNING("A plugin cleared our subclass - resetting.");
-    if (currentWndProc != mPluginWinProc) {
-      NS_WARNING("Procedures do not match up, discarding old subclass value.");
-    }
-    if (mPrevWinProc && currentWndProc == mPrevWinProc) {
-      NS_WARNING("The new procedure is our widget procedure?");
-    }
-#endif
-    SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)PluginWndProc);
-    return NS_OK;
-  }
-
-  LONG_PTR style = GetWindowLongPtr(hWnd, GWL_STYLE);
-  // Out of process plugins must not have the WS_CLIPCHILDREN style set on their
-  // parent windows or else synchronous paints (via UpdateWindow() and others)
-  // will cause deadlocks.
-  if (::GetPropW(hWnd, L"PluginInstanceParentProperty"))
-    style &= ~WS_CLIPCHILDREN;
-  else
-    style |= WS_CLIPCHILDREN;
-  SetWindowLongPtr(hWnd, GWL_STYLE, style);
-
-  mPluginWinProc =
-      (WNDPROC)SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)PluginWndProc);
-  if (!mPluginWinProc) return NS_ERROR_FAILURE;
-
-  DebugOnly<nsPluginNativeWindowWin*> win = (nsPluginNativeWindowWin*)::GetProp(
-      hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
-  NS_ASSERTION(!win || (win == this),
-               "plugin window already has property and this is not us");
-
-  if (!::SetProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION, (HANDLE)this))
-    return NS_ERROR_FAILURE;
-
-  return NS_OK;
-}
-
-nsresult nsPluginNativeWindowWin::UndoSubclassAndAssociateWindow() {
-  // remove window property
-  HWND hWnd = (HWND)window;
-  if (IsWindow(hWnd)) ::RemoveProp(hWnd, NS_PLUGIN_WINDOW_PROPERTY_ASSOCIATION);
-
-  // restore the original win proc
-  // but only do this if this were us last time
-  if (mPluginWinProc) {
-    WNDPROC currentWndProc = (WNDPROC)::GetWindowLongPtr(hWnd, GWLP_WNDPROC);
-    if (currentWndProc == PluginWndProc)
-      SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)mPluginWinProc);
-    mPluginWinProc = nullptr;
-
-    LONG_PTR style = GetWindowLongPtr(hWnd, GWL_STYLE);
-    style &= ~WS_CLIPCHILDREN;
-    SetWindowLongPtr(hWnd, GWL_STYLE, style);
-  }
-
-  if (mPluginType == nsPluginHost::eSpecialType_Flash && mParentWnd) {
-    ::SetWindowLongPtr(mParentWnd, GWLP_WNDPROC, mParentProc);
-    mParentWnd = nullptr;
-    mParentProc = 0;
-  }
-
-  return NS_OK;
-}
-
-nsresult PLUG_NewPluginNativeWindow(
-    nsPluginNativeWindow** aPluginNativeWindow) {
-  NS_ENSURE_ARG_POINTER(aPluginNativeWindow);
-
-  *aPluginNativeWindow = new nsPluginNativeWindowWin();
-  return NS_OK;
-}
-
-nsresult PLUG_DeletePluginNativeWindow(
-    nsPluginNativeWindow* aPluginNativeWindow) {
-  NS_ENSURE_ARG_POINTER(aPluginNativeWindow);
-  nsPluginNativeWindowWin* p = (nsPluginNativeWindowWin*)aPluginNativeWindow;
-  delete p;
-  return NS_OK;
-}
diff --git a/dom/plugins/base/nsPluginStreamListenerPeer.cpp b/dom/plugins/base/nsPluginStreamListenerPeer.cpp
deleted file mode 100644
index d4104298dcd51..0000000000000
--- a/dom/plugins/base/nsPluginStreamListenerPeer.cpp
+++ /dev/null
@@ -1,605 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "nsPluginStreamListenerPeer.h"
-#include "nsIContentPolicy.h"
-#include "nsContentPolicyUtils.h"
-#include "nsIHttpChannel.h"
-#include "nsIHttpChannelInternal.h"
-#include "nsIFileChannel.h"
-#include "nsMimeTypes.h"
-#include "nsNetCID.h"
-#include "nsPluginInstanceOwner.h"
-#include "nsPluginLogging.h"
-#include "nsIURI.h"
-#include "nsPluginHost.h"
-#include "nsIMultiPartChannel.h"
-#include "nsPrintfCString.h"
-#include "nsIScriptGlobalObject.h"
-#include "mozilla/dom/Document.h"
-#include "nsIWebNavigation.h"
-#include "nsContentUtils.h"
-#include "nsNetUtil.h"
-#include "nsPluginNativeWindow.h"
-#include "nsPluginInstanceOwner.h"
-#include "mozilla/NullPrincipal.h"
-#include "mozilla/ProfilerLabels.h"
-
-// nsPluginStreamListenerPeer
-
-NS_IMPL_ISUPPORTS(nsPluginStreamListenerPeer, nsIStreamListener,
-                  nsIRequestObserver, nsIHttpHeaderVisitor,
-                  nsISupportsWeakReference, nsIInterfaceRequestor,
-                  nsIChannelEventSink)
-
-nsPluginStreamListenerPeer::nsPluginStreamListenerPeer() : mLength(0) {
-  mStreamType = NP_NORMAL;
-  mStartBinding = false;
-  mRequestFailed = false;
-
-  mPendingRequests = 0;
-  mHaveFiredOnStartRequest = false;
-
-  mUseLocalCache = false;
-  mModified = 0;
-  mStreamOffset = 0;
-  mStreamComplete = 0;
-}
-
-nsPluginStreamListenerPeer::~nsPluginStreamListenerPeer() {
-#ifdef PLUGIN_LOGGING
-  MOZ_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
-          ("nsPluginStreamListenerPeer::dtor this=%p, url=%s\n", this,
-           mURLSpec.get()));
-#endif
-
-  if (mPStreamListener) {
-    mPStreamListener->SetStreamListenerPeer(nullptr);
-  }
-}
-
-// Called as a result of GetURL and PostURL, or by the host in the case of the
-// initial plugin stream.
-nsresult nsPluginStreamListenerPeer::Initialize(
-    nsIURI* aURL, nsNPAPIPluginInstance* aInstance,
-    nsNPAPIPluginStreamListener* aListener) {
-#ifdef PLUGIN_LOGGING
-  MOZ_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NORMAL,
-          ("nsPluginStreamListenerPeer::Initialize instance=%p, url=%s\n",
-           aInstance, aURL ? aURL->GetSpecOrDefault().get() : ""));
-
-  PR_LogFlush();
-#endif
-
-  // Not gonna work out
-  if (!aInstance) {
-    return NS_ERROR_FAILURE;
-  }
-
-  mURL = aURL;
-
-  NS_ASSERTION(
-      mPluginInstance == nullptr,
-      "nsPluginStreamListenerPeer::Initialize mPluginInstance != nullptr");
-  mPluginInstance = aInstance;
-
-  // If the plugin did not request this stream, e.g. the initial stream, we wont
-  // have a nsNPAPIPluginStreamListener yet - this will be handled by
-  // SetUpStreamListener
-  if (aListener) {
-    mPStreamListener = aListener;
-    mPStreamListener->SetStreamListenerPeer(this);
-  }
-
-  mPendingRequests = 1;
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsPluginStreamListenerPeer::OnStartRequest(nsIRequest* request) {
-  nsresult rv = NS_OK;
-  AUTO_PROFILER_LABEL("nsPluginStreamListenerPeer::OnStartRequest", OTHER);
-
-  if (mRequests.IndexOfObject(request) == -1) {
-    NS_ASSERTION(mRequests.Count() == 0,
-                 "Only our initial stream should be unknown!");
-    TrackRequest(request);
-  }
-
-  if (mHaveFiredOnStartRequest) {
-    return NS_OK;
-  }
-
-  mHaveFiredOnStartRequest = true;
-
-  nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
-  NS_ENSURE_TRUE(channel, NS_ERROR_FAILURE);
-
-  // deal with 404 (Not Found) HTTP response,
-  // just return, this causes the request to be ignored.
-  nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
-  if (httpChannel) {
-    uint32_t responseCode = 0;
-    rv = httpChannel->GetResponseStatus(&responseCode);
-    if (NS_FAILED(rv)) {
-      // NPP_Notify() will be called from OnStopRequest
-      // in nsNPAPIPluginStreamListener::CleanUpStream
-      // return error will cancel this request
-      // ...and we also need to tell the plugin that
-      mRequestFailed = true;
-      return NS_ERROR_FAILURE;
-    }
-
-    if (responseCode > 206) {  // not normal
-      uint32_t wantsAllNetworkStreams = 0;
-
-      // We don't always have an instance here already, but if we do, check
-      // to see if it wants all streams.
-      if (mPluginInstance) {
-        rv = mPluginInstance->GetValueFromPlugin(
-            NPPVpluginWantsAllNetworkStreams, &wantsAllNetworkStreams);
-        // If the call returned an error code make sure we still use our default
-        // value.
-        if (NS_FAILED(rv)) {
-          wantsAllNetworkStreams = 0;
-        }
-      }
-
-      if (!wantsAllNetworkStreams) {
-        mRequestFailed = true;
-        return NS_ERROR_FAILURE;
-      }
-    }
-  }
-
-  nsAutoCString contentType;
-  rv = channel->GetContentType(contentType);
-  if (NS_FAILED(rv)) return rv;
-
-  // Check ShouldProcess with content policy
-  nsCOMPtr<nsILoadInfo> loadInfo = channel->LoadInfo();
-
-  int16_t shouldLoad = nsIContentPolicy::ACCEPT;
-  rv = NS_CheckContentProcessPolicy(mURL, loadInfo, contentType, &shouldLoad);
-  if (NS_FAILED(rv) || NS_CP_REJECTED(shouldLoad)) {
-    mRequestFailed = true;
-    return NS_ERROR_CONTENT_BLOCKED;
-  }
-
-  // Get the notification callbacks from the channel and save it as
-  // week ref we'll use it in nsPluginStreamInfo::RequestRead() when
-  // we'll create channel for byte range request.
-  nsCOMPtr<nsIInterfaceRequestor> callbacks;
-  channel->GetNotificationCallbacks(getter_AddRefs(callbacks));
-  if (callbacks) mWeakPtrChannelCallbacks = do_GetWeakReference(callbacks);
-
-  nsCOMPtr<nsILoadGroup> loadGroup;
-  channel->GetLoadGroup(getter_AddRefs(loadGroup));
-  if (loadGroup) mWeakPtrChannelLoadGroup = do_GetWeakReference(loadGroup);
-
-  int64_t length;
-  rv = channel->GetContentLength(&length);
-
-  // it's possible for the server to not send a Content-Length.
-  // we should still work in this case.
-  if (NS_FAILED(rv) || length < 0 || length > UINT32_MAX) {
-    // check out if this is file channel
-    nsCOMPtr<nsIFileChannel> fileChannel = do_QueryInterface(channel);
-    if (fileChannel) {
-      // file does not exist
-      mRequestFailed = true;
-      return NS_ERROR_FAILURE;
-    }
-    mLength = 0;
-  } else {
-    mLength = uint32_t(length);
-  }
-
-  nsCOMPtr<nsIURI> aURL;
-  rv = channel->GetURI(getter_AddRefs(aURL));
-  if (NS_FAILED(rv)) return rv;
-
-  aURL->GetSpec(mURLSpec);
-
-  if (!contentType.IsEmpty()) mContentType = contentType;
-
-#ifdef PLUGIN_LOGGING
-  MOZ_LOG(nsPluginLogging::gPluginLog, PLUGIN_LOG_NOISY,
-          ("nsPluginStreamListenerPeer::OnStartRequest this=%p request=%p "
-           "mime=%s, url=%s\n",
-           this, request, contentType.get(), mURLSpec.get()));
-
-  PR_LogFlush();
-#endif
-
-  // Set up the stream listener...
-  rv = SetUpStreamListener(request, aURL);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  return rv;
-}
-
-NS_IMETHODIMP nsPluginStreamListenerPeer::OnProgress(nsIRequest* request,
-                                                     int64_t aProgress,
-                                                     int64_t aProgressMax) {
-  nsresult rv = NS_OK;
-  return rv;
-}
-
-NS_IMETHODIMP nsPluginStreamListenerPeer::OnStatus(nsIRequest* request,
-                                                   nsresult aStatus,
-                                                   const char16_t* aStatusArg) {
-  return NS_OK;
-}
-
-nsresult nsPluginStreamListenerPeer::GetContentType(char** result) {
-  *result = const_cast<char*>(mContentType.get());
-  return NS_OK;
-}
-
-nsresult nsPluginStreamListenerPeer::GetLength(uint32_t* result) {
-  *result = mLength;
-  return NS_OK;
-}
-
-nsresult nsPluginStreamListenerPeer::GetLastModified(uint32_t* result) {
-  *result = mModified;
-  return NS_OK;
-}
-
-nsresult nsPluginStreamListenerPeer::GetURL(const char** result) {
-  *result = mURLSpec.get();
-  return NS_OK;
-}
-
-nsresult nsPluginStreamListenerPeer::GetStreamOffset(int32_t* result) {
-  *result = mStreamOffset;
-  return NS_OK;
-}
-
-nsresult nsPluginStreamListenerPeer::SetStreamOffset(int32_t value) {
-  mStreamOffset = value;
-  return NS_OK;
-}
-
-NS_IMETHODIMP nsPluginStreamListenerPeer::OnDataAvailable(
-    nsIRequest* request, nsIInputStream* aIStream, uint64_t sourceOffset,
-    uint32_t aLength) {
-  if (mRequests.IndexOfObject(request) == -1) {
-    MOZ_ASSERT(false, "Received OnDataAvailable for untracked request.");
-    return NS_ERROR_UNEXPECTED;
-  }
-
-  if (mRequestFailed) return NS_ERROR_FAILURE;
-
-  nsresult rv = NS_OK;
-
-  if (!mPStreamListener) return NS_ERROR_FAILURE;
-
-  const char* url = nullptr;
-  GetURL(&url);
-
-  PLUGIN_LOG(PLUGIN_LOG_NOISY,
-             ("nsPluginStreamListenerPeer::OnDataAvailable this=%p request=%p, "
-              "offset=%" PRIu64 ", length=%u, url=%s\n",
-              this, request, sourceOffset, aLength, url ? url : "no url set"));
-
-  nsCOMPtr<nsIInputStream> stream = aIStream;
-  rv = mPStreamListener->OnDataAvailable(this, stream, aLength);
-
-  // if a plugin returns an error, the peer must kill the stream
-  //   else the stream and PluginStreamListener leak
-  if (NS_FAILED(rv)) {
-    request->Cancel(rv);
-  }
-
-  return rv;
-}
-
-NS_IMETHODIMP nsPluginStreamListenerPeer::OnStopRequest(nsIRequest* request,
-                                                        nsresult aStatus) {
-  nsresult rv = NS_OK;
-
-  nsCOMPtr<nsIMultiPartChannel> mp = do_QueryInterface(request);
-  if (!mp) {
-    bool found = mRequests.RemoveObject(request);
-    if (!found) {
-      NS_ERROR("Received OnStopRequest for untracked request.");
-    }
-  }
-
-  PLUGIN_LOG(
-      PLUGIN_LOG_NOISY,
-      ("nsPluginStreamListenerPeer::OnStopRequest this=%p aStatus=%" PRIu32
-       " request=%p\n",
-       this, static_cast<uint32_t>(aStatus), request));
-
-  // if we still have pending stuff to do, lets not close the plugin socket.
-  if (--mPendingRequests > 0) return NS_OK;
-
-  if (!mPStreamListener) return NS_ERROR_FAILURE;
-
-  nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
-  if (!channel) return NS_ERROR_FAILURE;
-  // Set the content type to ensure we don't pass null to the plugin
-  nsAutoCString aContentType;
-  rv = channel->GetContentType(aContentType);
-  if (NS_FAILED(rv) && !mRequestFailed) return rv;
-
-  if (!aContentType.IsEmpty()) mContentType = aContentType;
-
-  // set error status if stream failed so we notify the plugin
-  if (mRequestFailed) aStatus = NS_ERROR_FAILURE;
-
-  if (NS_FAILED(aStatus)) {
-    // on error status cleanup the stream
-    // and return w/o OnFileAvailable()
-    mPStreamListener->OnStopBinding(this, aStatus);
-    return NS_OK;
-  }
-
-  if (mStartBinding) {
-    // On start binding has been called
-    mPStreamListener->OnStopBinding(this, aStatus);
-  } else {
-    // OnStartBinding hasn't been called, so complete the action.
-    mPStreamListener->OnStartBinding(this);
-    mPStreamListener->OnStopBinding(this, aStatus);
-  }
-
-  if (NS_SUCCEEDED(aStatus)) {
-    mStreamComplete = true;
-  }
-
-  return NS_OK;
-}
-
-nsresult nsPluginStreamListenerPeer::SetUpStreamListener(nsIRequest* request,
-                                                         nsIURI* aURL) {
-  nsresult rv = NS_OK;
-
-  // If we don't yet have a stream listener, we need to get
-  // one from the plugin.
-  // NOTE: this should only happen when a stream was NOT created
-  // with GetURL or PostURL (i.e. it's the initial stream we
-  // send to the plugin as determined by the SRC or DATA attribute)
-  if (!mPStreamListener) {
-    if (!mPluginInstance) {
-      return NS_ERROR_FAILURE;
-    }
-
-    RefPtr<nsNPAPIPluginStreamListener> streamListener;
-    rv = mPluginInstance->NewStreamListener(nullptr, nullptr,
-                                            getter_AddRefs(streamListener));
-    if (NS_FAILED(rv) || !streamListener) {
-      return NS_ERROR_FAILURE;
-    }
-
-    mPStreamListener =
-        static_cast<nsNPAPIPluginStreamListener*>(streamListener.get());
-  }
-
-  mPStreamListener->SetStreamListenerPeer(this);
-
-  // get httpChannel to retrieve some info we need for nsIPluginStreamInfo setup
-  nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
-  nsCOMPtr<nsIHttpChannel> httpChannel = do_QueryInterface(channel);
-
-  /*
-   * Assumption
-   * By the time nsPluginStreamListenerPeer::OnDataAvailable() gets
-   * called, all the headers have been read.
-   */
-  if (httpChannel) {
-    // Reassemble the HTTP response status line and provide it to our
-    // listener.  Would be nice if we could get the raw status line,
-    // but nsIHttpChannel doesn't currently provide that.
-    // Status code: required; the status line isn't useful without it.
-    uint32_t statusNum;
-    if (NS_SUCCEEDED(httpChannel->GetResponseStatus(&statusNum)) &&
-        statusNum < 1000) {
-      // HTTP version: provide if available.  Defaults to empty string.
-      nsCString ver;
-      nsCOMPtr<nsIHttpChannelInternal> httpChannelInternal =
-          do_QueryInterface(channel);
-      if (httpChannelInternal) {
-        uint32_t major, minor;
-        if (NS_SUCCEEDED(
-                httpChannelInternal->GetResponseVersion(&major, &minor))) {
-          ver = nsPrintfCString("/%" PRIu32 ".%" PRIu32, major, minor);
-        }
-      }
-
-      // Status text: provide if available.  Defaults to "OK".
-      nsCString statusText;
-      if (NS_FAILED(httpChannel->GetResponseStatusText(statusText))) {
-        statusText = "OK";
-      }
-
-      // Assemble everything and pass to listener.
-      nsPrintfCString status("HTTP%s %" PRIu32 " %s", ver.get(), statusNum,
-                             statusText.get());
-      static_cast<nsIHTTPHeaderListener*>(mPStreamListener)
-          ->StatusLine(status.get());
-    }
-
-    // Also provide all HTTP response headers to our listener.
-    rv = httpChannel->VisitResponseHeaders(this);
-    MOZ_ASSERT(NS_SUCCEEDED(rv));
-
-    // we require a content len
-    // get Last-Modified header for plugin info
-    nsAutoCString lastModified;
-    if (NS_SUCCEEDED(
-            httpChannel->GetResponseHeader("last-modified"_ns, lastModified)) &&
-        !lastModified.IsEmpty()) {
-      PRTime time64;
-      PR_ParseTimeString(lastModified.get(), true,
-                         &time64);  // convert string time to integer time
-
-      // Convert PRTime to unix-style time_t, i.e. seconds since the epoch
-      double fpTime = double(time64);
-      mModified = (uint32_t)(fpTime * 1e-6 + 0.5);
-    }
-  }
-
-  MOZ_ASSERT(!mRequest);
-  mRequest = request;
-
-  rv = mPStreamListener->OnStartBinding(this);
-
-  mStartBinding = true;
-
-  if (NS_FAILED(rv)) return rv;
-
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsPluginStreamListenerPeer::VisitHeader(const nsACString& header,
-                                        const nsACString& value) {
-  return mPStreamListener->NewResponseHeader(PromiseFlatCString(header).get(),
-                                             PromiseFlatCString(value).get());
-}
-
-nsresult nsPluginStreamListenerPeer::GetInterfaceGlobal(const nsIID& aIID,
-                                                        void** result) {
-  if (!mPluginInstance) {
-    return NS_ERROR_FAILURE;
-  }
-
-  RefPtr<nsPluginInstanceOwner> owner = mPluginInstance->GetOwner();
-  if (!owner) {
-    return NS_ERROR_FAILURE;
-  }
-
-  nsCOMPtr<mozilla::dom::Document> doc;
-  nsresult rv = owner->GetDocument(getter_AddRefs(doc));
-  if (NS_FAILED(rv) || !doc) {
-    return NS_ERROR_FAILURE;
-  }
-
-  nsPIDOMWindowOuter* window = doc->GetWindow();
-  if (!window) {
-    return NS_ERROR_FAILURE;
-  }
-
-  nsCOMPtr<nsIWebNavigation> webNav = do_GetInterface(window);
-  nsCOMPtr<nsIInterfaceRequestor> ir = do_QueryInterface(webNav);
-  if (!ir) {
-    return NS_ERROR_FAILURE;
-  }
-
-  return ir->GetInterface(aIID, result);
-}
-
-NS_IMETHODIMP
-nsPluginStreamListenerPeer::GetInterface(const nsIID& aIID, void** result) {
-  // Provide nsIChannelEventSink ourselves, otherwise let our document's
-  // script global object owner provide the interface.
-  if (aIID.Equals(NS_GET_IID(nsIChannelEventSink))) {
-    return QueryInterface(aIID, result);
-  }
-
-  return GetInterfaceGlobal(aIID, result);
-}
-
-/**
- * Proxy class which forwards async redirect notifications back to the necko
- * callback, keeping nsPluginStreamListenerPeer::mRequests in sync with
- * which channel is active.
- */
-class ChannelRedirectProxyCallback : public nsIAsyncVerifyRedirectCallback {
- public:
-  ChannelRedirectProxyCallback(nsPluginStreamListenerPeer* listener,
-                               nsIAsyncVerifyRedirectCallback* parent,
-                               nsIChannel* oldChannel, nsIChannel* newChannel)
-      : mWeakListener(
-            do_GetWeakReference(static_cast<nsIStreamListener*>(listener))),
-        mParent(parent),
-        mOldChannel(oldChannel),
-        mNewChannel(newChannel) {}
-
-  ChannelRedirectProxyCallback() = default;
-
-  NS_DECL_ISUPPORTS
-
-  NS_IMETHOD OnRedirectVerifyCallback(nsresult aResult) override {
-    if (NS_SUCCEEDED(aResult)) {
-      nsCOMPtr<nsIStreamListener> listener = do_QueryReferent(mWeakListener);
-      if (listener)
-        static_cast<nsPluginStreamListenerPeer*>(listener.get())
-            ->ReplaceRequest(mOldChannel, mNewChannel);
-    }
-    return mParent->OnRedirectVerifyCallback(aResult);
-  }
-
- private:
-  virtual ~ChannelRedirectProxyCallback() = default;
-
-  nsWeakPtr mWeakListener;
-  nsCOMPtr<nsIAsyncVerifyRedirectCallback> mParent;
-  nsCOMPtr<nsIChannel> mOldChannel;
-  nsCOMPtr<nsIChannel> mNewChannel;
-};
-
-NS_IMPL_ISUPPORTS(ChannelRedirectProxyCallback, nsIAsyncVerifyRedirectCallback)
-
-NS_IMETHODIMP
-nsPluginStreamListenerPeer::AsyncOnChannelRedirect(
-    nsIChannel* oldChannel, nsIChannel* newChannel, uint32_t flags,
-    nsIAsyncVerifyRedirectCallback* callback) {
-  // Disallow redirects if we don't have a stream listener.
-  if (!mPStreamListener) {
-    return NS_ERROR_FAILURE;
-  }
-
-  // Don't allow cross-origin 307/308 POST redirects.
-  nsCOMPtr<nsIHttpChannel> oldHttpChannel(do_QueryInterface(oldChannel));
-  if (oldHttpChannel) {
-    uint32_t responseStatus;
-    nsresult rv = oldHttpChannel->GetResponseStatus(&responseStatus);
-    if (NS_FAILED(rv)) {
-      return rv;
-    }
-    if (responseStatus == 307 || responseStatus == 308) {
-      nsAutoCString method;
-      rv = oldHttpChannel->GetRequestMethod(method);
-      if (NS_FAILED(rv)) {
-        return rv;
-      }
-      if (method.EqualsLiteral("POST")) {
-        rv = nsContentUtils::CheckSameOrigin(oldChannel, newChannel);
-        if (NS_FAILED(rv)) {
-          return rv;
-        }
-      }
-    }
-  }
-
-  nsCOMPtr<nsIAsyncVerifyRedirectCallback> proxyCallback =
-      new ChannelRedirectProxyCallback(this, callback, oldChannel, newChannel);
-
-  // Give NPAPI a chance to control redirects.
-  bool notificationHandled = mPStreamListener->HandleRedirectNotification(
-      oldChannel, newChannel, proxyCallback);
-  if (notificationHandled) {
-    return NS_OK;
-  }
-
-  // Fall back to channel event sink for window.
-  nsCOMPtr<nsIChannelEventSink> channelEventSink;
-  nsresult rv = GetInterfaceGlobal(NS_GET_IID(nsIChannelEventSink),
-                                   getter_AddRefs(channelEventSink));
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  return channelEventSink->AsyncOnChannelRedirect(oldChannel, newChannel, flags,
-                                                  proxyCallback);
-}
diff --git a/dom/plugins/base/nsPluginStreamListenerPeer.h b/dom/plugins/base/nsPluginStreamListenerPeer.h
deleted file mode 100644
index 00c35abfd9907..0000000000000
--- a/dom/plugins/base/nsPluginStreamListenerPeer.h
+++ /dev/null
@@ -1,149 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef nsPluginStreamListenerPeer_h_
-#define nsPluginStreamListenerPeer_h_
-
-#include "nscore.h"
-#include "nsIFile.h"
-#include "nsIRequest.h"
-#include "nsIStreamListener.h"
-#include "nsIProgressEventSink.h"
-#include "nsIHttpHeaderVisitor.h"
-#include "nsWeakReference.h"
-#include "nsNPAPIPluginStreamListener.h"
-#include "nsHashKeys.h"
-#include "nsNPAPIPluginInstance.h"
-#include "nsIInterfaceRequestor.h"
-#include "nsIChannelEventSink.h"
-
-class nsIChannel;
-
-/**
- * When a plugin requests opens multiple requests to the same URL and
- * the request must be satified by saving a file to disk, each stream
- * listener holds a reference to the backing file: the file is only removed
- * when all the listeners are done.
- */
-class CachedFileHolder {
- public:
-  explicit CachedFileHolder(nsIFile* cacheFile);
-  ~CachedFileHolder();
-
-  void AddRef();
-  void Release();
-
-  nsIFile* file() const { return mFile; }
-
- private:
-  nsAutoRefCnt mRefCnt;
-  nsCOMPtr<nsIFile> mFile;
-};
-
-class nsPluginStreamListenerPeer : public nsIStreamListener,
-                                   public nsIProgressEventSink,
-                                   public nsIHttpHeaderVisitor,
-                                   public nsSupportsWeakReference,
-                                   public nsIInterfaceRequestor,
-                                   public nsIChannelEventSink {
-  virtual ~nsPluginStreamListenerPeer();
-
- public:
-  nsPluginStreamListenerPeer();
-
-  NS_DECL_ISUPPORTS
-  NS_DECL_NSIPROGRESSEVENTSINK
-  NS_DECL_NSIREQUESTOBSERVER
-  NS_DECL_NSISTREAMLISTENER
-  NS_DECL_NSIHTTPHEADERVISITOR
-  NS_DECL_NSIINTERFACEREQUESTOR
-  NS_DECL_NSICHANNELEVENTSINK
-
-  // Called by GetURL and PostURL (via NewStream) or by the host in the case of
-  // the initial plugin stream.
-  nsresult Initialize(nsIURI* aURL, nsNPAPIPluginInstance* aInstance,
-                      nsNPAPIPluginStreamListener* aListener);
-
-  nsNPAPIPluginInstance* GetPluginInstance() { return mPluginInstance; }
-
-  nsresult GetLength(uint32_t* result);
-  nsresult GetURL(const char** result);
-  nsresult GetLastModified(uint32_t* result);
-  nsresult GetContentType(char** result);
-  nsresult GetStreamOffset(int32_t* result);
-  nsresult SetStreamOffset(int32_t value);
-
-  void TrackRequest(nsIRequest* request) { mRequests.AppendObject(request); }
-
-  void ReplaceRequest(nsIRequest* oldRequest, nsIRequest* newRequest) {
-    int32_t i = mRequests.IndexOfObject(oldRequest);
-    if (i == -1) {
-      NS_ASSERTION(mRequests.Count() == 0,
-                   "Only our initial stream should be unknown!");
-      mRequests.AppendObject(oldRequest);
-    } else {
-      mRequests.ReplaceObjectAt(newRequest, i);
-    }
-  }
-
-  void CancelRequests(nsresult status) {
-    // Copy the array to avoid modification during the loop.
-    nsCOMArray<nsIRequest> requestsCopy(mRequests);
-    for (int32_t i = 0; i < requestsCopy.Count(); ++i)
-      requestsCopy[i]->Cancel(status);
-  }
-
-  void SuspendRequests() {
-    nsCOMArray<nsIRequest> requestsCopy(mRequests);
-    for (int32_t i = 0; i < requestsCopy.Count(); ++i)
-      requestsCopy[i]->Suspend();
-  }
-
-  void ResumeRequests() {
-    nsCOMArray<nsIRequest> requestsCopy(mRequests);
-    for (int32_t i = 0; i < requestsCopy.Count(); ++i)
-      requestsCopy[i]->Resume();
-  }
-
- private:
-  nsresult SetUpStreamListener(nsIRequest* request, nsIURI* aURL);
-  nsresult GetInterfaceGlobal(const nsIID& aIID, void** result);
-
-  nsCOMPtr<nsIURI> mURL;
-  nsCString
-      mURLSpec;  // Have to keep this member because GetURL hands out char*
-  RefPtr<nsNPAPIPluginStreamListener> mPStreamListener;
-
-  // Set to true if we request failed (like with a HTTP response of 404)
-  bool mRequestFailed;
-
-  /*
-   * Set to true after nsNPAPIPluginStreamListener::OnStartBinding() has
-   * been called.  Checked in ::OnStopRequest so we can call the
-   * plugin's OnStartBinding if, for some reason, it has not already
-   * been called.
-   */
-  bool mStartBinding;
-  bool mHaveFiredOnStartRequest;
-  // these get passed to the plugin stream listener
-  uint32_t mLength;
-  int32_t mStreamType;
-
-  nsCString mContentType;
-  bool mUseLocalCache;
-  nsCOMPtr<nsIRequest> mRequest;
-  uint32_t mModified;
-  RefPtr<nsNPAPIPluginInstance> mPluginInstance;
-  int32_t mStreamOffset;
-  bool mStreamComplete;
-
- public:
-  int32_t mPendingRequests;
-  nsWeakPtr mWeakPtrChannelCallbacks;
-  nsWeakPtr mWeakPtrChannelLoadGroup;
-  nsCOMArray<nsIRequest> mRequests;
-};
-
-#endif  // nsPluginStreamListenerPeer_h_
diff --git a/dom/plugins/base/nsPluginTags.cpp b/dom/plugins/base/nsPluginTags.cpp
index 8055ffbd3acd2..6268f883eb99b 100644
--- a/dom/plugins/base/nsPluginTags.cpp
+++ b/dom/plugins/base/nsPluginTags.cpp
@@ -7,11 +7,9 @@
 
 #include "prlink.h"
 #include "plstr.h"
-#include "nsPluginsDir.h"
 #include "nsPluginHost.h"
 #include "nsIBlocklistService.h"
 #include "nsPluginLogging.h"
-#include "nsNPAPIPlugin.h"
 #include "nsCharSeparatedTokenizer.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/Unused.h"
@@ -194,28 +192,6 @@ bool nsIInternalPluginTag::HasMimeType(const nsACString& aMimeType) const {
 
 /* nsPluginTag */
 
-nsPluginTag::nsPluginTag(nsPluginInfo* aPluginInfo, int64_t aLastModifiedTime,
-                         uint32_t aBlocklistState)
-    : nsIInternalPluginTag(aPluginInfo->fName, aPluginInfo->fDescription,
-                           aPluginInfo->fFileName, aPluginInfo->fVersion),
-      mId(sNextId++),
-      mContentProcessRunningCount(0),
-      mHadLocalInstance(false),
-      mLibrary(nullptr),
-      mIsFlashPlugin(false),
-      mSupportsAsyncRender(false),
-      mFullPath(aPluginInfo->fFullPath),
-      mLastModifiedTime(aLastModifiedTime),
-      mSandboxLevel(0),
-      mIsSandboxLoggingEnabled(false),
-      mBlocklistState(aBlocklistState) {
-  InitMime(aPluginInfo->fMimeTypeArray, aPluginInfo->fMimeDescriptionArray,
-           aPluginInfo->fExtensionArray, aPluginInfo->fVariantCount);
-  InitSandboxLevel();
-  EnsureMembersAreUTF8();
-  FixupVersion();
-}
-
 nsPluginTag::nsPluginTag(const char* aName, const char* aDescription,
                          const char* aFileName, const char* aFullPath,
                          const char* aVersion, const char* const* aMimeTypes,
@@ -579,22 +555,9 @@ bool nsPluginTag::HasSameNameAndMimes(const nsPluginTag* aPluginTag) const {
 }
 
 NS_IMETHODIMP
-nsPluginTag::GetLoaded(bool* aIsLoaded) {
-  *aIsLoaded = !!mPlugin;
-  return NS_OK;
-}
+nsPluginTag::GetLoaded(bool* aIsLoaded) { return NS_ERROR_FAILURE; }
 
-void nsPluginTag::TryUnloadPlugin(bool inShutdown) {
-  // We never want to send NPP_Shutdown to an in-process plugin unless
-  // this process is shutting down.
-  if (!mPlugin) {
-    return;
-  }
-  if (inShutdown || mPlugin->GetLibrary()->IsOOP()) {
-    mPlugin->Shutdown();
-    mPlugin = nullptr;
-  }
-}
+void nsPluginTag::TryUnloadPlugin(bool inShutdown) {}
 
 /* static */ void nsPluginTag::EnsureSandboxInformation() {
   if (sInitializedSandboxingInfo) {
diff --git a/dom/plugins/base/nsPluginTags.h b/dom/plugins/base/nsPluginTags.h
index 73e597cb2f8d2..1f88833b14a07 100644
--- a/dom/plugins/base/nsPluginTags.h
+++ b/dom/plugins/base/nsPluginTags.h
@@ -16,8 +16,6 @@
 
 class nsIURI;
 struct PRLibrary;
-struct nsPluginInfo;
-class nsNPAPIPlugin;
 
 namespace mozilla {
 namespace dom {
@@ -113,8 +111,6 @@ class nsPluginTag final : public nsIInternalPluginTag {
     ePluginState_MaxValue = 3,
   };
 
-  nsPluginTag(nsPluginInfo* aPluginInfo, int64_t aLastModifiedTime,
-              uint32_t aBlocklistState);
   nsPluginTag(const char* aName, const char* aDescription,
               const char* aFileName, const char* aFullPath,
               const char* aVersion, const char* const* aMimeTypes,
@@ -161,7 +157,6 @@ class nsPluginTag final : public nsIInternalPluginTag {
   bool mHadLocalInstance;
 
   PRLibrary* mLibrary;
-  RefPtr<nsNPAPIPlugin> mPlugin;
   bool mIsFlashPlugin;
   bool mSupportsAsyncRender;
   nsCString mFullPath;  // UTF-8
diff --git a/dom/plugins/base/nsPluginsCID.h b/dom/plugins/base/nsPluginsCID.h
deleted file mode 100644
index 14fb48642e375..0000000000000
--- a/dom/plugins/base/nsPluginsCID.h
+++ /dev/null
@@ -1,16 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef nsPluginsCID_h_
-#define nsPluginsCID_h_
-
-#define NS_PLUGIN_HOST_CID                           \
-  {                                                  \
-    0x23E8FD98, 0xA625, 0x4B08, {                    \
-      0xBE, 0x1A, 0xF7, 0xCC, 0x18, 0xA5, 0xB1, 0x06 \
-    }                                                \
-  }
-
-#endif  // nsPluginsCID_h_
diff --git a/dom/plugins/base/nsPluginsDir.h b/dom/plugins/base/nsPluginsDir.h
deleted file mode 100644
index 42a24f8382e63..0000000000000
--- a/dom/plugins/base/nsPluginsDir.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef nsPluginsDir_h_
-#define nsPluginsDir_h_
-
-#include "nsError.h"
-#include "nsIFile.h"
-
-/**
- * nsPluginsDir is nearly obsolete. Directory Service should be used instead.
- * It exists for the sake of one static function.
- */
-
-class nsPluginsDir {
- public:
-  /**
-   * Determines whether or not the given file is actually a plugin file.
-   */
-  static bool IsPluginFile(nsIFile* file);
-};
-
-struct PRLibrary;
-
-struct nsPluginInfo {
-  char* fName;         // name of the plugin
-  char* fDescription;  // etc.
-  uint32_t fVariantCount;
-  char** fMimeTypeArray;
-  char** fMimeDescriptionArray;
-  char** fExtensionArray;
-  char* fFileName;
-  char* fFullPath;
-  char* fVersion;
-  bool fSupportsAsyncRender;
-};
-
-/**
- * Provides cross-platform access to a plugin file. Deals with reading
- * properties from the plugin file, and loading the plugin's shared
- * library. Insulates core nsIPluginHost implementations from these
- * details.
- */
-class nsPluginFile {
-#ifndef XP_WIN
-  PRLibrary* pLibrary;
-#endif
-  nsCOMPtr<nsIFile> mPlugin;
-
- public:
-  /**
-   * If spec corresponds to a valid plugin file, constructs a reference
-   * to a plugin file on disk. Plugins are typically located using the
-   * nsPluginsDir class.
-   */
-  explicit nsPluginFile(nsIFile* spec);
-  virtual ~nsPluginFile();
-
-  /**
-   * Loads the plugin into memory using NSPR's shared-library loading
-   * mechanism. Handles platform differences in loading shared libraries.
-   */
-  nsresult LoadPlugin(PRLibrary** outLibrary);
-
-  /**
-   * Obtains all of the information currently available for this plugin.
-   * Has a library outparam which will be non-null if a library load was
-   * required.
-   */
-  nsresult GetPluginInfo(nsPluginInfo& outPluginInfo, PRLibrary** outLibrary);
-
-  /**
-   * Should be called after GetPluginInfo to free all allocated stuff
-   */
-  nsresult FreePluginInfo(nsPluginInfo& PluginInfo);
-};
-
-#endif /* nsPluginsDir_h_ */
diff --git a/dom/plugins/base/nsPluginsDirDarwin.cpp b/dom/plugins/base/nsPluginsDirDarwin.cpp
deleted file mode 100644
index 8efe40f698b39..0000000000000
--- a/dom/plugins/base/nsPluginsDirDarwin.cpp
+++ /dev/null
@@ -1,522 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-/*
-  nsPluginsDirDarwin.cpp
-
-  Mac OS X implementation of the nsPluginsDir/nsPluginsFile classes.
-
-  by Patrick C. Beard.
- */
-
-#include "GeckoChildProcessHost.h"
-#include "base/process_util.h"
-
-#include "prlink.h"
-#include "prnetdb.h"
-#include "nsXPCOM.h"
-
-#include "nsPluginsDir.h"
-#include "nsNPAPIPlugin.h"
-#include "nsPluginsDirUtils.h"
-
-#include "mozilla/UniquePtr.h"
-
-#include "nsCocoaFeatures.h"
-#include "nsExceptionHandler.h"
-
-#include <string.h>
-#include <stdio.h>
-#include <unistd.h>
-#include <fcntl.h>
-
-#include <Carbon/Carbon.h>
-#include <CoreServices/CoreServices.h>
-#include <mach-o/loader.h>
-#include <mach-o/fat.h>
-
-typedef NS_NPAPIPLUGIN_CALLBACK(const char*, NP_GETMIMEDESCRIPTION)();
-typedef NS_NPAPIPLUGIN_CALLBACK(OSErr, BP_GETSUPPORTEDMIMETYPES)(
-    BPSupportedMIMETypes* mimeInfo, UInt32 flags);
-
-/*
-** Returns a CFBundleRef if the path refers to a Mac OS X bundle directory.
-** The caller is responsible for calling CFRelease() to deallocate.
-*/
-static CFBundleRef getPluginBundle(const char* path) {
-  CFBundleRef bundle = nullptr;
-  CFStringRef pathRef =
-      ::CFStringCreateWithCString(nullptr, path, kCFStringEncodingUTF8);
-  if (pathRef) {
-    CFURLRef bundleURL = ::CFURLCreateWithFileSystemPath(
-        nullptr, pathRef, kCFURLPOSIXPathStyle, true);
-    if (bundleURL) {
-      bundle = ::CFBundleCreate(nullptr, bundleURL);
-      ::CFRelease(bundleURL);
-    }
-    ::CFRelease(pathRef);
-  }
-  return bundle;
-}
-
-bool nsPluginsDir::IsPluginFile(nsIFile* file) {
-  nsCString fileName;
-  file->GetNativeLeafName(fileName);
-  /*
-   * Don't load the VDP fake plugin, to avoid tripping a bad bug in OS X
-   * 10.5.3 (see bug 436575).
-   */
-  if (!strcmp(fileName.get(), "VerifiedDownloadPlugin.plugin")) {
-    NS_WARNING(
-        "Preventing load of VerifiedDownloadPlugin.plugin (see bug 436575)");
-    return false;
-  }
-  return true;
-}
-
-// Caller is responsible for freeing returned buffer.
-static char* CFStringRefToUTF8Buffer(CFStringRef cfString) {
-  const char* buffer = ::CFStringGetCStringPtr(cfString, kCFStringEncodingUTF8);
-  if (buffer) {
-    return PL_strdup(buffer);
-  }
-
-  int64_t bufferLength =
-      ::CFStringGetMaximumSizeForEncoding(::CFStringGetLength(cfString),
-                                          kCFStringEncodingUTF8) +
-      1;
-  char* newBuffer = static_cast<char*>(moz_xmalloc(bufferLength));
-
-  if (!::CFStringGetCString(cfString, newBuffer, bufferLength,
-                            kCFStringEncodingUTF8)) {
-    free(newBuffer);
-    return nullptr;
-  }
-
-  newBuffer =
-      static_cast<char*>(moz_xrealloc(newBuffer, strlen(newBuffer) + 1));
-  return newBuffer;
-}
-
-class AutoCFTypeObject {
- public:
-  explicit AutoCFTypeObject(CFTypeRef aObject) { mObject = aObject; }
-  ~AutoCFTypeObject() { ::CFRelease(mObject); }
-
- private:
-  CFTypeRef mObject;
-};
-
-static Boolean MimeTypeEnabled(CFDictionaryRef mimeDict) {
-  if (!mimeDict) {
-    return true;
-  }
-
-  CFTypeRef value;
-  if (::CFDictionaryGetValueIfPresent(mimeDict, CFSTR("WebPluginTypeEnabled"),
-                                      &value)) {
-    if (value && ::CFGetTypeID(value) == ::CFBooleanGetTypeID()) {
-      return ::CFBooleanGetValue(static_cast<CFBooleanRef>(value));
-    }
-  }
-  return true;
-}
-
-static CFDictionaryRef ParsePlistForMIMETypesFilename(CFBundleRef bundle) {
-  CFTypeRef mimeFileName = ::CFBundleGetValueForInfoDictionaryKey(
-      bundle, CFSTR("WebPluginMIMETypesFilename"));
-  if (!mimeFileName || ::CFGetTypeID(mimeFileName) != ::CFStringGetTypeID()) {
-    return nullptr;
-  }
-
-  FSRef homeDir;
-  if (::FSFindFolder(kUserDomain, kCurrentUserFolderType, kDontCreateFolder,
-                     &homeDir) != noErr) {
-    return nullptr;
-  }
-
-  CFURLRef userDirURL = ::CFURLCreateFromFSRef(kCFAllocatorDefault, &homeDir);
-  if (!userDirURL) {
-    return nullptr;
-  }
-
-  AutoCFTypeObject userDirURLAutorelease(userDirURL);
-  CFStringRef mimeFilePath = ::CFStringCreateWithFormat(
-      kCFAllocatorDefault, nullptr, CFSTR("Library/Preferences/%@"),
-      static_cast<CFStringRef>(mimeFileName));
-  if (!mimeFilePath) {
-    return nullptr;
-  }
-
-  AutoCFTypeObject mimeFilePathAutorelease(mimeFilePath);
-  CFURLRef mimeFileURL = ::CFURLCreateWithFileSystemPathRelativeToBase(
-      kCFAllocatorDefault, mimeFilePath, kCFURLPOSIXPathStyle, false,
-      userDirURL);
-  if (!mimeFileURL) {
-    return nullptr;
-  }
-
-  AutoCFTypeObject mimeFileURLAutorelease(mimeFileURL);
-  SInt32 errorCode = 0;
-  CFDataRef mimeFileData = nullptr;
-  Boolean result = ::CFURLCreateDataAndPropertiesFromResource(
-      kCFAllocatorDefault, mimeFileURL, &mimeFileData, nullptr, nullptr,
-      &errorCode);
-  if (!result) {
-    return nullptr;
-  }
-
-  AutoCFTypeObject mimeFileDataAutorelease(mimeFileData);
-  if (errorCode != 0) {
-    return nullptr;
-  }
-
-  CFPropertyListRef propertyList = ::CFPropertyListCreateFromXMLData(
-      kCFAllocatorDefault, mimeFileData, kCFPropertyListImmutable, nullptr);
-  if (!propertyList) {
-    return nullptr;
-  }
-
-  AutoCFTypeObject propertyListAutorelease(propertyList);
-  if (::CFGetTypeID(propertyList) != ::CFDictionaryGetTypeID()) {
-    return nullptr;
-  }
-
-  CFTypeRef mimeTypes = ::CFDictionaryGetValue(
-      static_cast<CFDictionaryRef>(propertyList), CFSTR("WebPluginMIMETypes"));
-  if (!mimeTypes || ::CFGetTypeID(mimeTypes) != ::CFDictionaryGetTypeID() ||
-      ::CFDictionaryGetCount(static_cast<CFDictionaryRef>(mimeTypes)) == 0) {
-    return nullptr;
-  }
-
-  return static_cast<CFDictionaryRef>(::CFRetain(mimeTypes));
-}
-
-static void ParsePlistPluginInfo(nsPluginInfo& info, CFBundleRef bundle) {
-  CFDictionaryRef mimeDict = ParsePlistForMIMETypesFilename(bundle);
-
-  if (!mimeDict) {
-    CFTypeRef mimeTypes = ::CFBundleGetValueForInfoDictionaryKey(
-        bundle, CFSTR("WebPluginMIMETypes"));
-    if (!mimeTypes || ::CFGetTypeID(mimeTypes) != ::CFDictionaryGetTypeID() ||
-        ::CFDictionaryGetCount(static_cast<CFDictionaryRef>(mimeTypes)) == 0)
-      return;
-    mimeDict = static_cast<CFDictionaryRef>(::CFRetain(mimeTypes));
-  }
-
-  AutoCFTypeObject mimeDictAutorelease(mimeDict);
-  int mimeDictKeyCount = ::CFDictionaryGetCount(mimeDict);
-
-  // Allocate memory for mime data
-  int mimeDataArraySize = mimeDictKeyCount * sizeof(char*);
-  info.fMimeTypeArray = static_cast<char**>(moz_xmalloc(mimeDataArraySize));
-  memset(info.fMimeTypeArray, 0, mimeDataArraySize);
-  info.fExtensionArray = static_cast<char**>(moz_xmalloc(mimeDataArraySize));
-  memset(info.fExtensionArray, 0, mimeDataArraySize);
-  info.fMimeDescriptionArray =
-      static_cast<char**>(moz_xmalloc(mimeDataArraySize));
-  memset(info.fMimeDescriptionArray, 0, mimeDataArraySize);
-
-  // Allocate memory for mime dictionary keys and values
-  mozilla::UniquePtr<CFTypeRef[]> keys(new CFTypeRef[mimeDictKeyCount]);
-  mozilla::UniquePtr<CFTypeRef[]> values(new CFTypeRef[mimeDictKeyCount]);
-
-  info.fVariantCount = 0;
-
-  ::CFDictionaryGetKeysAndValues(mimeDict, keys.get(), values.get());
-  for (int i = 0; i < mimeDictKeyCount; i++) {
-    CFTypeRef mimeString = keys[i];
-    if (!mimeString || ::CFGetTypeID(mimeString) != ::CFStringGetTypeID()) {
-      continue;
-    }
-    CFTypeRef mimeDict = values[i];
-    if (mimeDict && ::CFGetTypeID(mimeDict) == ::CFDictionaryGetTypeID()) {
-      if (!MimeTypeEnabled(static_cast<CFDictionaryRef>(mimeDict))) {
-        continue;
-      }
-      info.fMimeTypeArray[info.fVariantCount] =
-          CFStringRefToUTF8Buffer(static_cast<CFStringRef>(mimeString));
-      if (!info.fMimeTypeArray[info.fVariantCount]) {
-        continue;
-      }
-      CFTypeRef extensions = ::CFDictionaryGetValue(
-          static_cast<CFDictionaryRef>(mimeDict), CFSTR("WebPluginExtensions"));
-      if (extensions && ::CFGetTypeID(extensions) == ::CFArrayGetTypeID()) {
-        int extensionCount =
-            ::CFArrayGetCount(static_cast<CFArrayRef>(extensions));
-        CFMutableStringRef extensionList =
-            ::CFStringCreateMutable(kCFAllocatorDefault, 0);
-        for (int j = 0; j < extensionCount; j++) {
-          CFTypeRef extension =
-              ::CFArrayGetValueAtIndex(static_cast<CFArrayRef>(extensions), j);
-          if (extension && ::CFGetTypeID(extension) == ::CFStringGetTypeID()) {
-            if (j > 0) ::CFStringAppend(extensionList, CFSTR(","));
-            ::CFStringAppend(static_cast<CFMutableStringRef>(extensionList),
-                             static_cast<CFStringRef>(extension));
-          }
-        }
-        info.fExtensionArray[info.fVariantCount] =
-            CFStringRefToUTF8Buffer(static_cast<CFStringRef>(extensionList));
-        ::CFRelease(extensionList);
-      }
-      CFTypeRef description =
-          ::CFDictionaryGetValue(static_cast<CFDictionaryRef>(mimeDict),
-                                 CFSTR("WebPluginTypeDescription"));
-      if (description && ::CFGetTypeID(description) == ::CFStringGetTypeID())
-        info.fMimeDescriptionArray[info.fVariantCount] =
-            CFStringRefToUTF8Buffer(static_cast<CFStringRef>(description));
-    }
-    info.fVariantCount++;
-  }
-}
-
-nsPluginFile::nsPluginFile(nsIFile* spec) : pLibrary(nullptr), mPlugin(spec) {}
-
-nsPluginFile::~nsPluginFile() {}
-
-nsresult nsPluginFile::LoadPlugin(PRLibrary** outLibrary) {
-  if (!mPlugin) return NS_ERROR_NULL_POINTER;
-
-    // 64-bit NSPR does not (yet) support bundles.  So in 64-bit builds we need
-    // (for now) to load the bundle's executable.  However this can cause
-    // problems:  CFBundleCreate() doesn't run the bundle's executable's
-    // initialization code, while NSAddImage() and dlopen() do run it.  So using
-    // NSPR's dyld loading mechanisms here (NSAddImage() or dlopen()) can cause
-    // a bundle's initialization code to run earlier than expected, and lead to
-    // crashes.  See bug 577967.
-#ifdef __LP64__
-  char executablePath[PATH_MAX];
-  executablePath[0] = '\0';
-  nsAutoCString bundlePath;
-  mPlugin->GetNativePath(bundlePath);
-  CFStringRef pathRef = ::CFStringCreateWithCString(nullptr, bundlePath.get(),
-                                                    kCFStringEncodingUTF8);
-  if (pathRef) {
-    CFURLRef bundleURL = ::CFURLCreateWithFileSystemPath(
-        nullptr, pathRef, kCFURLPOSIXPathStyle, true);
-    if (bundleURL) {
-      CFBundleRef bundle = ::CFBundleCreate(nullptr, bundleURL);
-      if (bundle) {
-        CFURLRef executableURL = ::CFBundleCopyExecutableURL(bundle);
-        if (executableURL) {
-          if (!::CFURLGetFileSystemRepresentation(
-                  executableURL, true, (UInt8*)&executablePath, PATH_MAX))
-            executablePath[0] = '\0';
-          ::CFRelease(executableURL);
-        }
-        ::CFRelease(bundle);
-      }
-      ::CFRelease(bundleURL);
-    }
-    ::CFRelease(pathRef);
-  }
-#else
-  nsAutoCString bundlePath;
-  mPlugin->GetNativePath(bundlePath);
-  const char* executablePath = bundlePath.get();
-#endif
-
-  *outLibrary = PR_LoadLibrary(executablePath);
-  pLibrary = *outLibrary;
-  if (!pLibrary) {
-    return NS_ERROR_FAILURE;
-  }
-#ifdef DEBUG
-  printf("[loaded plugin %s]\n", bundlePath.get());
-#endif
-  return NS_OK;
-}
-
-static char* p2cstrdup(StringPtr pstr) {
-  int len = pstr[0];
-  char* cstr = static_cast<char*>(moz_xmalloc(len + 1));
-  memmove(cstr, pstr + 1, len);
-  cstr[len] = '\0';
-  return cstr;
-}
-
-static char* GetNextPluginStringFromHandle(Handle h, short* index) {
-  char* ret = p2cstrdup((unsigned char*)(*h + *index));
-  *index += (ret ? strlen(ret) : 0) + 1;
-  return ret;
-}
-
-/**
- * Obtains all of the information currently available for this plugin.
- */
-nsresult nsPluginFile::GetPluginInfo(nsPluginInfo& info,
-                                     PRLibrary** outLibrary) {
-  *outLibrary = nullptr;
-
-  nsresult rv = NS_OK;
-
-  // clear out the info, except for the first field.
-  memset(&info, 0, sizeof(info));
-
-  // Try to get a bundle reference.
-  nsAutoCString path;
-  if (NS_FAILED(rv = mPlugin->GetNativePath(path))) return rv;
-  CFBundleRef bundle = getPluginBundle(path.get());
-
-  // fill in full path
-  info.fFullPath = PL_strdup(path.get());
-
-  // fill in file name
-  nsAutoCString fileName;
-  if (NS_FAILED(rv = mPlugin->GetNativeLeafName(fileName))) return rv;
-  info.fFileName = PL_strdup(fileName.get());
-
-  // Get fName
-  if (bundle) {
-    CFTypeRef name =
-        ::CFBundleGetValueForInfoDictionaryKey(bundle, CFSTR("WebPluginName"));
-    if (name && ::CFGetTypeID(name) == ::CFStringGetTypeID())
-      info.fName = CFStringRefToUTF8Buffer(static_cast<CFStringRef>(name));
-  }
-
-  // Get fDescription
-  if (bundle) {
-    CFTypeRef description = ::CFBundleGetValueForInfoDictionaryKey(
-        bundle, CFSTR("WebPluginDescription"));
-    if (description && ::CFGetTypeID(description) == ::CFStringGetTypeID())
-      info.fDescription =
-          CFStringRefToUTF8Buffer(static_cast<CFStringRef>(description));
-  }
-
-  // Get fVersion
-  if (bundle) {
-    // Look for the release version first
-    CFTypeRef version = ::CFBundleGetValueForInfoDictionaryKey(
-        bundle, CFSTR("CFBundleShortVersionString"));
-    if (!version)  // try the build version
-      version =
-          ::CFBundleGetValueForInfoDictionaryKey(bundle, kCFBundleVersionKey);
-    if (version && ::CFGetTypeID(version) == ::CFStringGetTypeID())
-      info.fVersion =
-          CFStringRefToUTF8Buffer(static_cast<CFStringRef>(version));
-  }
-
-  // The last thing we need to do is get MIME data
-  // fVariantCount, fMimeTypeArray, fExtensionArray, fMimeDescriptionArray
-
-  // First look for data in a bundle plist
-  if (bundle) {
-    ParsePlistPluginInfo(info, bundle);
-    ::CFRelease(bundle);
-    if (info.fVariantCount > 0) return NS_OK;
-  }
-
-  // Don't load "fbplugin" or any plugins whose name starts with "fbplugin_"
-  // (Facebook plugins) if we're running on OS X 10.10 (Yosemite) or later.
-  // A "fbplugin" file crashes on load, in the call to LoadPlugin() below.
-  // See bug 1086977.
-  if (fileName.EqualsLiteral("fbplugin") ||
-      StringBeginsWith(fileName, "fbplugin_"_ns)) {
-    nsAutoCString msg;
-    msg.AppendPrintf("Preventing load of %s (see bug 1086977)", fileName.get());
-    NS_WARNING(msg.get());
-    return NS_ERROR_FAILURE;
-  }
-
-  // The block above assumes that "fbplugin" is the filename of the plugin
-  // to be blocked, or that the filename starts with "fbplugin_".  But we
-  // don't yet know for sure if this is always true.  So for the time being
-  // record extra information in our crash logs.
-  CrashReporter::AnnotateCrashReport(CrashReporter::Annotation::Bug_1086977,
-                                     fileName);
-
-  // It's possible that our plugin has 2 entry points that'll give us mime type
-  // info. Quicktime does this to get around the need of having admin rights to
-  // change mime info in the resource fork. We need to use this info instead of
-  // the resource. See bug 113464.
-
-  // Sadly we have to load the library for this to work.
-  rv = LoadPlugin(outLibrary);
-
-  // If we didn't crash in LoadPlugin(), remove the annotation so we don't
-  // sow confusion.
-  CrashReporter::RemoveCrashReportAnnotation(
-      CrashReporter::Annotation::Bug_1086977);
-
-  if (NS_FAILED(rv)) return rv;
-
-  // Try to get data from NP_GetMIMEDescription
-  if (pLibrary) {
-    NP_GETMIMEDESCRIPTION pfnGetMimeDesc =
-        (NP_GETMIMEDESCRIPTION)PR_FindFunctionSymbol(
-            pLibrary, NP_GETMIMEDESCRIPTION_NAME);
-    if (pfnGetMimeDesc) ParsePluginMimeDescription(pfnGetMimeDesc(), info);
-    if (info.fVariantCount) return NS_OK;
-  }
-
-  // We'll fill this in using BP_GetSupportedMIMETypes and/or resource fork data
-  BPSupportedMIMETypes mi = {kBPSupportedMIMETypesStructVers_1, nullptr,
-                             nullptr};
-
-  // Try to get data from BP_GetSupportedMIMETypes
-  if (pLibrary) {
-    BP_GETSUPPORTEDMIMETYPES pfnMime =
-        (BP_GETSUPPORTEDMIMETYPES)PR_FindFunctionSymbol(
-            pLibrary, "BP_GetSupportedMIMETypes");
-    if (pfnMime && noErr == pfnMime(&mi, 0) && mi.typeStrings) {
-      info.fVariantCount = (**(short**)mi.typeStrings) / 2;
-      ::HLock(mi.typeStrings);
-      if (mi.infoStrings)  // it's possible some plugins have infoStrings
-                           // missing
-        ::HLock(mi.infoStrings);
-    }
-  }
-
-  // Fill in the info struct based on the data in the BPSupportedMIMETypes
-  // struct
-  int variantCount = info.fVariantCount;
-  info.fMimeTypeArray =
-      static_cast<char**>(moz_xmalloc(variantCount * sizeof(char*)));
-  info.fExtensionArray =
-      static_cast<char**>(moz_xmalloc(variantCount * sizeof(char*)));
-  if (mi.infoStrings) {
-    info.fMimeDescriptionArray =
-        static_cast<char**>(moz_xmalloc(variantCount * sizeof(char*)));
-  }
-  short mimeIndex = 2;
-  short descriptionIndex = 2;
-  for (int i = 0; i < variantCount; i++) {
-    info.fMimeTypeArray[i] =
-        GetNextPluginStringFromHandle(mi.typeStrings, &mimeIndex);
-    info.fExtensionArray[i] =
-        GetNextPluginStringFromHandle(mi.typeStrings, &mimeIndex);
-    if (mi.infoStrings)
-      info.fMimeDescriptionArray[i] =
-          GetNextPluginStringFromHandle(mi.infoStrings, &descriptionIndex);
-  }
-
-  ::HUnlock(mi.typeStrings);
-  ::DisposeHandle(mi.typeStrings);
-  if (mi.infoStrings) {
-    ::HUnlock(mi.infoStrings);
-    ::DisposeHandle(mi.infoStrings);
-  }
-
-  return NS_OK;
-}
-
-nsresult nsPluginFile::FreePluginInfo(nsPluginInfo& info) {
-  free(info.fName);
-  free(info.fDescription);
-  int variantCount = info.fVariantCount;
-  for (int i = 0; i < variantCount; i++) {
-    free(info.fMimeTypeArray[i]);
-    free(info.fExtensionArray[i]);
-    free(info.fMimeDescriptionArray[i]);
-  }
-  free(info.fMimeTypeArray);
-  free(info.fMimeDescriptionArray);
-  free(info.fExtensionArray);
-  free(info.fFileName);
-  free(info.fFullPath);
-  free(info.fVersion);
-
-  return NS_OK;
-}
diff --git a/dom/plugins/base/nsPluginsDirUnix.cpp b/dom/plugins/base/nsPluginsDirUnix.cpp
deleted file mode 100644
index 62df31daeabe5..0000000000000
--- a/dom/plugins/base/nsPluginsDirUnix.cpp
+++ /dev/null
@@ -1,188 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "nsNPAPIPlugin.h"
-#include "nsNPAPIPluginInstance.h"
-#include "nsPluginsDir.h"
-#include "nsPluginsDirUtils.h"
-#include "prenv.h"
-#include "prerror.h"
-#include "prio.h"
-#include <sys/stat.h>
-#include "nsString.h"
-#include "nsIFile.h"
-
-#define LOCAL_PLUGIN_DLL_SUFFIX ".so"
-#if defined(__hpux)
-#  define DEFAULT_X11_PATH "/usr/lib/X11R6/"
-#  undef LOCAL_PLUGIN_DLL_SUFFIX
-#  define LOCAL_PLUGIN_DLL_SUFFIX ".sl"
-#  define LOCAL_PLUGIN_DLL_ALT_SUFFIX ".so"
-#elif defined(_AIX)
-#  define DEFAULT_X11_PATH "/usr/lib"
-#  define LOCAL_PLUGIN_DLL_ALT_SUFFIX ".a"
-#elif defined(SOLARIS)
-#  define DEFAULT_X11_PATH "/usr/openwin/lib/"
-#elif defined(LINUX)
-#  define DEFAULT_X11_PATH "/usr/X11R6/lib/"
-#elif defined(__APPLE__)
-#  define DEFAULT_X11_PATH "/usr/X11R6/lib"
-#  undef LOCAL_PLUGIN_DLL_SUFFIX
-#  define LOCAL_PLUGIN_DLL_SUFFIX ".dylib"
-#  define LOCAL_PLUGIN_DLL_ALT_SUFFIX ".so"
-#else
-#  define DEFAULT_X11_PATH ""
-#endif
-
-/* nsPluginsDir implementation */
-
-bool nsPluginsDir::IsPluginFile(nsIFile* file) {
-  nsAutoCString filename;
-  if (NS_FAILED(file->GetNativeLeafName(filename))) return false;
-
-  constexpr auto dllSuffix = nsLiteralCString{LOCAL_PLUGIN_DLL_SUFFIX};
-  if (filename.Length() > dllSuffix.Length() &&
-      StringEndsWith(filename, dllSuffix))
-    return true;
-
-#ifdef LOCAL_PLUGIN_DLL_ALT_SUFFIX
-  constexpr auto dllAltSuffix = nsLiteralCString{LOCAL_PLUGIN_DLL_ALT_SUFFIX};
-  if (filename.Length() > dllAltSuffix.Length() &&
-      StringEndsWith(filename, dllAltSuffix))
-    return true;
-#endif
-  return false;
-}
-
-/* nsPluginFile implementation */
-
-nsPluginFile::nsPluginFile(nsIFile* file) : mPlugin(file) {}
-
-nsPluginFile::~nsPluginFile() = default;
-
-nsresult nsPluginFile::LoadPlugin(PRLibrary** outLibrary) {
-  PRLibSpec libSpec;
-  libSpec.type = PR_LibSpec_Pathname;
-  bool exists = false;
-  mPlugin->Exists(&exists);
-  if (!exists) return NS_ERROR_FILE_NOT_FOUND;
-
-  nsresult rv;
-  nsAutoCString path;
-  rv = mPlugin->GetNativePath(path);
-  if (NS_FAILED(rv)) return rv;
-
-  libSpec.value.pathname = path.get();
-
-  *outLibrary = PR_LoadLibraryWithFlags(libSpec, 0);
-  pLibrary = *outLibrary;
-
-#ifdef DEBUG
-  printf("LoadPlugin() %s returned %lx\n", libSpec.value.pathname,
-         (unsigned long)pLibrary);
-#endif
-
-  if (!pLibrary) {
-    return NS_ERROR_FAILURE;
-  }
-
-  return NS_OK;
-}
-
-nsresult nsPluginFile::GetPluginInfo(nsPluginInfo& info,
-                                     PRLibrary** outLibrary) {
-  *outLibrary = nullptr;
-
-  info.fVersion = nullptr;
-
-  // Sadly we have to load the library for this to work.
-  nsresult rv = LoadPlugin(outLibrary);
-  if (NS_FAILED(rv)) return rv;
-
-  const char* (*npGetPluginVersion)() =
-      (const char* (*)())PR_FindFunctionSymbol(pLibrary, "NP_GetPluginVersion");
-  if (npGetPluginVersion) {
-    info.fVersion = PL_strdup(npGetPluginVersion());
-  }
-
-  const char* (*npGetMIMEDescription)() =
-      (const char* (*)())PR_FindFunctionSymbol(pLibrary,
-                                               "NP_GetMIMEDescription");
-  if (!npGetMIMEDescription) {
-    return NS_ERROR_FAILURE;
-  }
-
-  const char* mimedescr = npGetMIMEDescription();
-  if (!mimedescr) {
-    return NS_ERROR_FAILURE;
-  }
-
-  rv = ParsePluginMimeDescription(mimedescr, info);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  nsAutoCString path;
-  if (NS_FAILED(rv = mPlugin->GetNativePath(path))) return rv;
-  info.fFullPath = PL_strdup(path.get());
-
-  nsAutoCString fileName;
-  if (NS_FAILED(rv = mPlugin->GetNativeLeafName(fileName))) return rv;
-  info.fFileName = PL_strdup(fileName.get());
-
-  NP_GetValueFunc npGetValue =
-      (NP_GetValueFunc)PR_FindFunctionSymbol(pLibrary, "NP_GetValue");
-  if (!npGetValue) {
-    return NS_ERROR_FAILURE;
-  }
-
-  const char* name = nullptr;
-  npGetValue(nullptr, NPPVpluginNameString, &name);
-  if (name) {
-    info.fName = PL_strdup(name);
-  } else {
-    info.fName = PL_strdup(fileName.get());
-  }
-
-  const char* description = nullptr;
-  npGetValue(nullptr, NPPVpluginDescriptionString, &description);
-  if (description) {
-    info.fDescription = PL_strdup(description);
-  } else {
-    info.fDescription = PL_strdup("");
-  }
-
-  return NS_OK;
-}
-
-nsresult nsPluginFile::FreePluginInfo(nsPluginInfo& info) {
-  if (info.fName != nullptr) PL_strfree(info.fName);
-
-  if (info.fDescription != nullptr) PL_strfree(info.fDescription);
-
-  for (uint32_t i = 0; i < info.fVariantCount; i++) {
-    if (info.fMimeTypeArray[i] != nullptr) PL_strfree(info.fMimeTypeArray[i]);
-
-    if (info.fMimeDescriptionArray[i] != nullptr)
-      PL_strfree(info.fMimeDescriptionArray[i]);
-
-    if (info.fExtensionArray[i] != nullptr) PL_strfree(info.fExtensionArray[i]);
-  }
-
-  free(info.fMimeTypeArray);
-  info.fMimeTypeArray = nullptr;
-  free(info.fMimeDescriptionArray);
-  info.fMimeDescriptionArray = nullptr;
-  free(info.fExtensionArray);
-  info.fExtensionArray = nullptr;
-
-  if (info.fFullPath != nullptr) PL_strfree(info.fFullPath);
-
-  if (info.fFileName != nullptr) PL_strfree(info.fFileName);
-
-  if (info.fVersion != nullptr) PL_strfree(info.fVersion);
-
-  return NS_OK;
-}
diff --git a/dom/plugins/base/nsPluginsDirUtils.h b/dom/plugins/base/nsPluginsDirUtils.h
deleted file mode 100644
index e4d929d1fca21..0000000000000
--- a/dom/plugins/base/nsPluginsDirUtils.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef nsPluginsDirUtils_h___
-#define nsPluginsDirUtils_h___
-
-#include "nsPluginsDir.h"
-#include "nsTArray.h"
-
-///////////////////////////////////////////////////////////////////////////////
-// Output format from NPP_GetMIMEDescription: "...mime
-// type[;version]:[extension]:[desecription];..." The ambiguity of mime
-// description could cause the browser fail to parse the MIME types correctly.
-// E.g. "mime type::desecription;" // correct w/o ext
-//      "mime type:desecription;"  // wrong w/o ext
-//
-static nsresult ParsePluginMimeDescription(const char* mdesc,
-                                           nsPluginInfo& info) {
-  nsresult rv = NS_ERROR_FAILURE;
-  if (!mdesc || !*mdesc) return rv;
-
-  char* mdescDup =
-      PL_strdup(mdesc);  // make a dup of intput string we'll change it content
-  char anEmptyString[] = "";
-  AutoTArray<char*, 8> tmpMimeTypeArr;
-  char delimiters[] = {':', ':', ';'};
-  int mimeTypeVariantCount = 0;
-  char* p = mdescDup;  // make a dup of intput string we'll change it content
-  while (p) {
-    char* ptrMimeArray[] = {anEmptyString, anEmptyString, anEmptyString};
-
-    // It's easy to point out ptrMimeArray[0] to the string sounds like
-    // "Mime type is not specified, plugin will not function properly."
-    // and show this on "about:plugins" page, but we have to mark this
-    // particular mime type of given plugin as disable on "about:plugins" page,
-    // which feature is not implemented yet.
-    // So we'll ignore, without any warnings, an empty description strings,
-    // in other words, if after parsing ptrMimeArray[0] == anEmptyString is
-    // true. It is possible do not to registry a plugin at all if it returns an
-    // empty string on GetMIMEDescription() call, e.g. plugger returns "" if
-    // pluggerrc file is not found.
-
-    char* s = p;
-    int i;
-    for (i = 0;
-         i < (int)sizeof(delimiters) && (p = PL_strchr(s, delimiters[i]));
-         i++) {
-      ptrMimeArray[i] = s;  // save start ptr
-      *p++ = 0;             // overwrite delimiter
-      s = p;                // move forward
-    }
-    if (i == 2) ptrMimeArray[i] = s;
-    // fill out the temp array
-    // the order is important, it should be the same in for loop below
-    if (ptrMimeArray[0] != anEmptyString) {
-      tmpMimeTypeArr.AppendElement(ptrMimeArray[0]);
-      tmpMimeTypeArr.AppendElement(ptrMimeArray[1]);
-      tmpMimeTypeArr.AppendElement(ptrMimeArray[2]);
-      mimeTypeVariantCount++;
-    }
-  }
-
-  // fill out info structure
-  if (mimeTypeVariantCount) {
-    info.fVariantCount = mimeTypeVariantCount;
-    // we can do these 3 mallocs at once, later on code cleanup
-    info.fMimeTypeArray = (char**)malloc(mimeTypeVariantCount * sizeof(char*));
-    info.fMimeDescriptionArray =
-        (char**)malloc(mimeTypeVariantCount * sizeof(char*));
-    info.fExtensionArray = (char**)malloc(mimeTypeVariantCount * sizeof(char*));
-
-    int j, i;
-    for (j = i = 0; i < mimeTypeVariantCount; i++) {
-      // the order is important, do not change it
-      // we can get rid of PL_strdup here, later on code cleanup
-      info.fMimeTypeArray[i] = PL_strdup(tmpMimeTypeArr.ElementAt(j++));
-      info.fExtensionArray[i] = PL_strdup(tmpMimeTypeArr.ElementAt(j++));
-      info.fMimeDescriptionArray[i] = PL_strdup(tmpMimeTypeArr.ElementAt(j++));
-    }
-    rv = NS_OK;
-  }
-  if (mdescDup) PL_strfree(mdescDup);
-  return rv;
-}
-
-#endif /* nsPluginsDirUtils_h___ */
diff --git a/dom/plugins/base/nsPluginsDirWin.cpp b/dom/plugins/base/nsPluginsDirWin.cpp
deleted file mode 100644
index ad534865681e9..0000000000000
--- a/dom/plugins/base/nsPluginsDirWin.cpp
+++ /dev/null
@@ -1,349 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-/*
-  nsPluginsDirWin.cpp
-
-  Windows implementation of the nsPluginsDir/nsPluginsFile classes.
-
-  by Alex Musil
- */
-
-#include "mozilla/ArrayUtils.h"  // ArrayLength
-#include "mozilla/DebugOnly.h"
-#include "mozilla/Printf.h"
-
-#include "nsPluginsDir.h"
-#include "prlink.h"
-#include "plstr.h"
-
-#include "windows.h"
-#include "winbase.h"
-
-#include "nsString.h"
-#include "nsIFile.h"
-#include "nsUnicharUtils.h"
-
-using namespace mozilla;
-
-/* Local helper functions */
-
-static char* GetKeyValue(void* verbuf, const WCHAR* key, UINT language,
-                         UINT codepage) {
-  WCHAR keybuf[64];  // plenty for the template below, with the longest key
-                     // we use (currently "FileDescription")
-  const WCHAR keyFormat[] = L"\\StringFileInfo\\%04X%04X\\%ls";
-  WCHAR* buf = nullptr;
-  UINT blen;
-
-  if (_snwprintf_s(keybuf, ArrayLength(keybuf), _TRUNCATE, keyFormat, language,
-                   codepage, key) < 0) {
-    MOZ_ASSERT_UNREACHABLE("plugin info key too long for buffer!");
-    return nullptr;
-  }
-
-  if (::VerQueryValueW(verbuf, keybuf, (void**)&buf, &blen) == 0 ||
-      buf == nullptr || blen == 0) {
-    return nullptr;
-  }
-
-  return PL_strdup(NS_ConvertUTF16toUTF8(buf, blen).get());
-}
-
-static char* GetVersion(void* verbuf) {
-  VS_FIXEDFILEINFO* fileInfo;
-  UINT fileInfoLen;
-
-  ::VerQueryValueW(verbuf, L"\\", (void**)&fileInfo, &fileInfoLen);
-
-  if (fileInfo) {
-    return mozilla::Smprintf("%ld.%ld.%ld.%ld",
-                             HIWORD(fileInfo->dwFileVersionMS),
-                             LOWORD(fileInfo->dwFileVersionMS),
-                             HIWORD(fileInfo->dwFileVersionLS),
-                             LOWORD(fileInfo->dwFileVersionLS))
-        .release();
-  }
-
-  return nullptr;
-}
-
-// Returns a boolean indicating if the key's value contains a string
-// entry equal to "1" or "0". No entry for the key returns false.
-static bool GetBooleanFlag(void* verbuf, const WCHAR* key, UINT language,
-                           UINT codepage) {
-  char* flagStr = GetKeyValue(verbuf, key, language, codepage);
-  if (!flagStr) {
-    return false;
-  }
-  bool result = (PL_strncmp("1", flagStr, 1) == 0);
-  PL_strfree(flagStr);
-  return result;
-}
-
-static uint32_t CalculateVariantCount(char* mimeTypes) {
-  uint32_t variants = 1;
-
-  if (!mimeTypes) return 0;
-
-  char* index = mimeTypes;
-  while (*index) {
-    if (*index == '|') variants++;
-
-    ++index;
-  }
-  return variants;
-}
-
-static char** MakeStringArray(uint32_t variants, char* data) {
-  // The number of variants has been calculated based on the mime
-  // type array. Plugins are not explicitely required to match
-  // this number in two other arrays: file extention array and mime
-  // description array, and some of them actually don't.
-  // We should handle such situations gracefully
-
-  if ((variants <= 0) || !data) return nullptr;
-
-  char** array = (char**)calloc(variants, sizeof(char*));
-  if (!array) return nullptr;
-
-  char* start = data;
-
-  for (uint32_t i = 0; i < variants; i++) {
-    char* p = PL_strchr(start, '|');
-    if (p) *p = 0;
-
-    array[i] = PL_strdup(start);
-
-    if (!p) {
-      // nothing more to look for, fill everything left
-      // with empty strings and break
-      while (++i < variants) array[i] = PL_strdup("");
-
-      break;
-    }
-
-    start = ++p;
-  }
-  return array;
-}
-
-static void FreeStringArray(uint32_t variants, char** array) {
-  if ((variants == 0) || !array) return;
-
-  for (uint32_t i = 0; i < variants; i++) {
-    if (array[i]) {
-      PL_strfree(array[i]);
-      array[i] = nullptr;
-    }
-  }
-  free(array);
-}
-
-static bool CanLoadPlugin(char16ptr_t aBinaryPath) {
-#if defined(_M_IX86) || defined(_M_X64) || defined(_M_IA64)
-  bool canLoad = false;
-
-  HANDLE file =
-      CreateFileW(aBinaryPath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
-                  nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
-  if (file != INVALID_HANDLE_VALUE) {
-    HANDLE map = CreateFileMappingW(file, nullptr, PAGE_READONLY, 0,
-                                    GetFileSize(file, nullptr), nullptr);
-    if (map != nullptr) {
-      LPVOID mapView = MapViewOfFile(map, FILE_MAP_READ, 0, 0, 0);
-      if (mapView != nullptr) {
-        if (((IMAGE_DOS_HEADER*)mapView)->e_magic == IMAGE_DOS_SIGNATURE) {
-          long peImageHeaderStart = (((IMAGE_DOS_HEADER*)mapView)->e_lfanew);
-          if (peImageHeaderStart != 0L) {
-            DWORD arch =
-                (((IMAGE_NT_HEADERS*)((LPBYTE)mapView + peImageHeaderStart))
-                     ->FileHeader.Machine);
-#  ifdef _M_IX86
-            canLoad = (arch == IMAGE_FILE_MACHINE_I386);
-#  elif defined(_M_X64)
-            canLoad = (arch == IMAGE_FILE_MACHINE_AMD64);
-#  elif defined(_M_IA64)
-            canLoad = (arch == IMAGE_FILE_MACHINE_IA64);
-#  endif
-          }
-        }
-        UnmapViewOfFile(mapView);
-      }
-      CloseHandle(map);
-    }
-    CloseHandle(file);
-  }
-
-  return canLoad;
-#else
-  // Assume correct binaries for unhandled cases.
-  return true;
-#endif
-}
-
-/* nsPluginsDir implementation */
-
-// The file name must be in the form "np*.dll"
-bool nsPluginsDir::IsPluginFile(nsIFile* file) {
-  nsAutoString path;
-  if (NS_FAILED(file->GetPath(path))) return false;
-
-  // this is most likely a path, so skip to the filename
-  auto filename = Substring(path, path.RFindChar('\\') + 1);
-  // The file name must have at least one character between "np" and ".dll".
-  if (filename.Length() < 7) {
-    return false;
-  }
-
-  ToLowerCase(filename);
-  if (StringBeginsWith(filename, u"np"_ns) &&
-      StringEndsWith(filename, u".dll"_ns)) {
-    // don't load OJI-based Java plugins
-    if (StringBeginsWith(filename, u"npoji"_ns) ||
-        StringBeginsWith(filename, u"npjava"_ns))
-      return false;
-    return true;
-  }
-
-  return false;
-}
-
-/* nsPluginFile implementation */
-
-nsPluginFile::nsPluginFile(nsIFile* file) : mPlugin(file) {
-  // nada
-}
-
-nsPluginFile::~nsPluginFile() {
-  // nada
-}
-
-/**
- * Loads the plugin into memory using NSPR's shared-library loading
- * mechanism. Handles platform differences in loading shared libraries.
- */
-nsresult nsPluginFile::LoadPlugin(PRLibrary** outLibrary) {
-  if (!mPlugin) return NS_ERROR_NULL_POINTER;
-
-  nsAutoString pluginFilePath;
-  mPlugin->GetPath(pluginFilePath);
-
-  nsAutoString pluginFolderPath = pluginFilePath;
-  int32_t idx = pluginFilePath.RFindChar('\\');
-  pluginFolderPath.SetLength(idx);
-
-  BOOL restoreOrigDir = FALSE;
-  WCHAR aOrigDir[MAX_PATH + 1];
-  DWORD dwCheck = GetCurrentDirectoryW(MAX_PATH, aOrigDir);
-  NS_ASSERTION(dwCheck <= MAX_PATH + 1, "Error in Loading plugin");
-
-  if (dwCheck <= MAX_PATH + 1) {
-    restoreOrigDir = SetCurrentDirectoryW(pluginFolderPath.get());
-    NS_ASSERTION(restoreOrigDir, "Error in Loading plugin");
-  }
-
-  // Temporarily add the current directory back to the DLL load path.
-  SetDllDirectory(nullptr);
-
-  nsresult rv = mPlugin->Load(outLibrary);
-  if (NS_FAILED(rv)) *outLibrary = nullptr;
-
-  SetDllDirectory(L"");
-
-  if (restoreOrigDir) {
-    DebugOnly<BOOL> bCheck = SetCurrentDirectoryW(aOrigDir);
-    NS_ASSERTION(bCheck, "Error in Loading plugin");
-  }
-
-  return rv;
-}
-
-/**
- * Obtains all of the information currently available for this plugin.
- */
-nsresult nsPluginFile::GetPluginInfo(nsPluginInfo& info,
-                                     PRLibrary** outLibrary) {
-  *outLibrary = nullptr;
-
-  nsresult rv = NS_OK;
-  DWORD zerome, versionsize;
-  void* verbuf = nullptr;
-
-  if (!mPlugin) return NS_ERROR_NULL_POINTER;
-
-  nsAutoString fullPath;
-  if (NS_FAILED(rv = mPlugin->GetPath(fullPath))) return rv;
-
-  if (!CanLoadPlugin(fullPath.get())) return NS_ERROR_FAILURE;
-
-  nsAutoString fileName;
-  if (NS_FAILED(rv = mPlugin->GetLeafName(fileName))) return rv;
-
-  LPCWSTR lpFilepath = fullPath.get();
-
-  versionsize = ::GetFileVersionInfoSizeW(lpFilepath, &zerome);
-
-  if (versionsize > 0) verbuf = malloc(versionsize);
-  if (!verbuf) return NS_ERROR_OUT_OF_MEMORY;
-
-  if (::GetFileVersionInfoW(lpFilepath, 0, versionsize, verbuf)) {
-    // TODO: get appropriately-localized info from plugin file
-    UINT lang = 1033;  // language = English, 0x409
-    UINT cp = 1252;    // codepage = Western, 0x4E4
-    info.fName = GetKeyValue(verbuf, L"ProductName", lang, cp);
-    info.fDescription = GetKeyValue(verbuf, L"FileDescription", lang, cp);
-    info.fSupportsAsyncRender =
-        GetBooleanFlag(verbuf, L"AsyncDrawingSupport", lang, cp);
-
-    char* mimeType = GetKeyValue(verbuf, L"MIMEType", lang, cp);
-    char* mimeDescription = GetKeyValue(verbuf, L"FileOpenName", lang, cp);
-    char* extensions = GetKeyValue(verbuf, L"FileExtents", lang, cp);
-
-    info.fVariantCount = CalculateVariantCount(mimeType);
-    info.fMimeTypeArray = MakeStringArray(info.fVariantCount, mimeType);
-    info.fMimeDescriptionArray =
-        MakeStringArray(info.fVariantCount, mimeDescription);
-    info.fExtensionArray = MakeStringArray(info.fVariantCount, extensions);
-    info.fFullPath = PL_strdup(NS_ConvertUTF16toUTF8(fullPath).get());
-    info.fFileName = PL_strdup(NS_ConvertUTF16toUTF8(fileName).get());
-    info.fVersion = GetVersion(verbuf);
-
-    PL_strfree(mimeType);
-    PL_strfree(mimeDescription);
-    PL_strfree(extensions);
-  } else {
-    rv = NS_ERROR_FAILURE;
-  }
-
-  free(verbuf);
-
-  return rv;
-}
-
-nsresult nsPluginFile::FreePluginInfo(nsPluginInfo& info) {
-  if (info.fName) PL_strfree(info.fName);
-
-  if (info.fDescription) PL_strfree(info.fDescription);
-
-  if (info.fMimeTypeArray)
-    FreeStringArray(info.fVariantCount, info.fMimeTypeArray);
-
-  if (info.fMimeDescriptionArray)
-    FreeStringArray(info.fVariantCount, info.fMimeDescriptionArray);
-
-  if (info.fExtensionArray)
-    FreeStringArray(info.fVariantCount, info.fExtensionArray);
-
-  if (info.fFullPath) PL_strfree(info.fFullPath);
-
-  if (info.fFileName) PL_strfree(info.fFileName);
-
-  if (info.fVersion) free(info.fVersion);
-
-  ZeroMemory((void*)&info, sizeof(info));
-
-  return NS_OK;
-}
diff --git a/dom/plugins/base/nspluginroot.idl b/dom/plugins/base/nspluginroot.idl
index 6c931d37114c1..c16181c5ea358 100644
--- a/dom/plugins/base/nspluginroot.idl
+++ b/dom/plugins/base/nspluginroot.idl
@@ -3,29 +3,6 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-native REFNSIID(REFNSIID);
-native nativeVoid(void *);
-native nativeChar(const char * *);
-[ptr] native constVoidPtr(const void);
-[ref] native PRUint32Ref(uint32_t);
-[ref] native PRUint16Ref(uint16_t);
-[ref] native constCharStarConstStar(const char* const*);
-[ptr] native constCharPtr(const char);
-[ref] native constCharStarRef(const char *);
-
-native NPWindowType(NPWindowType);
-native NPWindow(NPWindow);
-[ptr] native NPWindowPtr(NPWindow);
 [ref] native NPWindowStarRef(NPWindow *);
-[ptr] native NPPrintPtr(NPPrint);
-native NPByteRange(NPByteRange);
-[ptr] native NPByteRangePtr(NPByteRange);
-native NPPVariable(NPPVariable);
-native NPNVariable(NPNVariable);
 [ptr] native NPRectPtr(NPRect);
 native NPRegion(NPRegion);
-native NPDrawingModel(NPDrawingModel);
-native NPEventModel(NPEventModel);
-
-[ptr] native JRIEnvPtr(JRIEnv);
-native jref(jref);
diff --git a/dom/plugins/ipc/AStream.h b/dom/plugins/ipc/AStream.h
deleted file mode 100644
index 06ac822320270..0000000000000
--- a/dom/plugins/ipc/AStream.h
+++ /dev/null
@@ -1,26 +0,0 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_plugins_AStream_h
-#define mozilla_plugins_AStream_h
-
-namespace mozilla {
-namespace plugins {
-
-/**
- * When we are passed NPStream->{ndata,pdata} in {NPN,NPP}_DestroyStream, we
- * don't know whether it's a plugin stream or a browser stream. This abstract
- * class lets us cast to the right type of object and send the appropriate
- * message.
- */
-class AStream {
- public:
-  virtual bool IsBrowserStream() = 0;
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif
diff --git a/dom/plugins/ipc/BrowserStreamChild.cpp b/dom/plugins/ipc/BrowserStreamChild.cpp
deleted file mode 100644
index 21e6706ba365f..0000000000000
--- a/dom/plugins/ipc/BrowserStreamChild.cpp
+++ /dev/null
@@ -1,217 +0,0 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "mozilla/plugins/BrowserStreamChild.h"
-
-#include "mozilla/Attributes.h"
-#include "mozilla/plugins/PluginInstanceChild.h"
-#include "mozilla/plugins/StreamNotifyChild.h"
-
-namespace mozilla::plugins {
-
-BrowserStreamChild::BrowserStreamChild(PluginInstanceChild* instance,
-                                       const nsCString& url,
-                                       const uint32_t& length,
-                                       const uint32_t& lastmodified,
-                                       StreamNotifyChild* notifyData,
-                                       const nsCString& headers)
-    : mInstance(instance),
-      mStreamStatus(kStreamOpen),
-      mDestroyPending(NOT_DESTROYED),
-      mNotifyPending(false),
-      mInstanceDying(false),
-      mState(CONSTRUCTING),
-      mURL(url),
-      mHeaders(headers),
-      mStreamNotify(notifyData),
-      mDeliveryTracker(this) {
-  PLUGIN_LOG_DEBUG(("%s (%s, %i, %i, %p, %s)", FULLFUNCTION, url.get(), length,
-                    lastmodified, (void*)notifyData, headers.get()));
-
-  AssertPluginThread();
-
-  memset(&mStream, 0, sizeof(mStream));
-  mStream.ndata = static_cast<AStream*>(this);
-  mStream.url = NullableStringGet(mURL);
-  mStream.end = length;
-  mStream.lastmodified = lastmodified;
-  mStream.headers = NullableStringGet(mHeaders);
-  if (notifyData) {
-    mStream.notifyData = notifyData->mClosure;
-    notifyData->SetAssociatedStream(this);
-  }
-}
-
-NPError BrowserStreamChild::StreamConstructed(const nsCString& mimeType,
-                                              const bool& seekable,
-                                              uint16_t* stype) {
-  NPError rv = NPERR_NO_ERROR;
-
-  *stype = NP_NORMAL;
-  rv = mInstance->mPluginIface->newstream(
-      &mInstance->mData, const_cast<char*>(NullableStringGet(mimeType)),
-      &mStream, seekable, stype);
-
-  // NP_NORMAL is the only permissible stream type
-  if (*stype != NP_NORMAL) {
-    rv = NPERR_INVALID_PARAM;
-    // The plugin thinks the stream is alive, so we kill it explicitly
-    (void)mInstance->mPluginIface->destroystream(&mInstance->mData, &mStream,
-                                                 NPRES_NETWORK_ERR);
-  }
-
-  if (rv != NPERR_NO_ERROR) {
-    mState = DELETING;
-    if (mStreamNotify) {
-      mStreamNotify->SetAssociatedStream(nullptr);
-      mStreamNotify = nullptr;
-    }
-  } else {
-    mState = ALIVE;
-  }
-
-  return rv;
-}
-
-BrowserStreamChild::~BrowserStreamChild() {
-  NS_ASSERTION(!mStreamNotify, "Should have nulled it by now!");
-}
-
-mozilla::ipc::IPCResult BrowserStreamChild::RecvWrite(const int32_t& offset,
-                                                      const uint32_t& newlength,
-                                                      const Buffer& data) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-
-  AssertPluginThread();
-
-  if (ALIVE != mState)
-    MOZ_CRASH("Unexpected state: received data after NPP_DestroyStream?");
-
-  if (kStreamOpen != mStreamStatus) return IPC_OK();
-
-  mStream.end = newlength;
-
-  NS_ASSERTION(data.Length() > 0, "Empty data");
-
-  PendingData* newdata = mPendingData.AppendElement();
-  newdata->offset = offset;
-  newdata->data = data;
-  newdata->curpos = 0;
-
-  EnsureDeliveryPending();
-
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult BrowserStreamChild::RecvNPP_DestroyStream(
-    const NPReason& reason) {
-  PLUGIN_LOG_DEBUG_METHOD;
-
-  if (ALIVE != mState)
-    MOZ_CRASH("Unexpected state: recevied NPP_DestroyStream twice?");
-
-  mState = DYING;
-  mDestroyPending = DESTROY_PENDING;
-  if (NPRES_DONE != reason) mStreamStatus = reason;
-
-  EnsureDeliveryPending();
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult BrowserStreamChild::Recv__delete__() {
-  AssertPluginThread();
-
-  if (DELETING != mState) MOZ_CRASH("Bad state, not DELETING");
-
-  return IPC_OK();
-}
-
-void BrowserStreamChild::EnsureDeliveryPending() {
-  MessageLoop::current()->PostTask(
-      mDeliveryTracker.NewRunnableMethod(&BrowserStreamChild::Deliver));
-}
-
-void BrowserStreamChild::Deliver() {
-  while (kStreamOpen == mStreamStatus && mPendingData.Length()) {
-    if (DeliverPendingData() && kStreamOpen == mStreamStatus) {
-      SetSuspendedTimer();
-      return;
-    }
-  }
-  ClearSuspendedTimer();
-
-  NS_ASSERTION(kStreamOpen != mStreamStatus || 0 == mPendingData.Length(),
-               "Exit out of the data-delivery loop with pending data");
-  mPendingData.Clear();
-
-  if (DESTROY_PENDING == mDestroyPending) {
-    mDestroyPending = DESTROYED;
-    if (mState != DYING) MOZ_CRASH("mDestroyPending but state not DYING");
-
-    NS_ASSERTION(NPRES_DONE != mStreamStatus, "Success status set too early!");
-    if (kStreamOpen == mStreamStatus) mStreamStatus = NPRES_DONE;
-
-    (void)mInstance->mPluginIface->destroystream(&mInstance->mData, &mStream,
-                                                 mStreamStatus);
-  }
-  if (DESTROYED == mDestroyPending && mNotifyPending) {
-    NS_ASSERTION(mStreamNotify, "mDestroyPending but no mStreamNotify?");
-
-    mNotifyPending = false;
-    mStreamNotify->NPP_URLNotify(mStreamStatus);
-    delete mStreamNotify;
-    mStreamNotify = nullptr;
-  }
-  if (DYING == mState && DESTROYED == mDestroyPending && !mStreamNotify &&
-      !mInstanceDying) {
-    SendStreamDestroyed();
-    mState = DELETING;
-  }
-}
-
-bool BrowserStreamChild::DeliverPendingData() {
-  if (mState != ALIVE && mState != DYING) MOZ_CRASH("Unexpected state");
-
-  NS_ASSERTION(mPendingData.Length(), "Called from Deliver with empty pending");
-
-  while (mPendingData[0].curpos <
-         static_cast<int32_t>(mPendingData[0].data.Length())) {
-    int32_t r =
-        mInstance->mPluginIface->writeready(&mInstance->mData, &mStream);
-    if (kStreamOpen != mStreamStatus) return false;
-    if (0 == r)  // plugin wants to suspend delivery
-      return true;
-
-    r = mInstance->mPluginIface->write(
-        &mInstance->mData, &mStream,
-        mPendingData[0].offset + mPendingData[0].curpos,         // offset
-        mPendingData[0].data.Length() - mPendingData[0].curpos,  // length
-        const_cast<char*>(mPendingData[0].data.BeginReading() +
-                          mPendingData[0].curpos));
-    if (kStreamOpen != mStreamStatus) return false;
-    if (0 == r) return true;
-    if (r < 0) {  // error condition
-      mStreamStatus = NPRES_NETWORK_ERR;
-
-      // Set up stream destruction
-      EnsureDeliveryPending();
-      return false;
-    }
-    mPendingData[0].curpos += r;
-  }
-  mPendingData.RemoveElementAt(0);
-  return false;
-}
-
-void BrowserStreamChild::SetSuspendedTimer() {
-  if (mSuspendedTimer.IsRunning()) return;
-  mSuspendedTimer.Start(base::TimeDelta::FromMilliseconds(
-                            100),  // 100ms copied from Mozilla plugin host
-                        this, &BrowserStreamChild::Deliver);
-}
-
-void BrowserStreamChild::ClearSuspendedTimer() { mSuspendedTimer.Stop(); }
-
-}  // namespace mozilla::plugins
diff --git a/dom/plugins/ipc/BrowserStreamChild.h b/dom/plugins/ipc/BrowserStreamChild.h
deleted file mode 100644
index 5df88d9aabaec..0000000000000
--- a/dom/plugins/ipc/BrowserStreamChild.h
+++ /dev/null
@@ -1,150 +0,0 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_plugins_BrowserStreamChild_h
-#define mozilla_plugins_BrowserStreamChild_h 1
-
-#include "mozilla/plugins/PBrowserStreamChild.h"
-#include "mozilla/plugins/AStream.h"
-#include "base/task.h"
-#include "base/timer.h"
-
-namespace mozilla {
-namespace plugins {
-
-class PluginInstanceChild;
-class StreamNotifyChild;
-
-class BrowserStreamChild : public PBrowserStreamChild, public AStream {
- public:
-  BrowserStreamChild(PluginInstanceChild* instance, const nsCString& url,
-                     const uint32_t& length, const uint32_t& lastmodified,
-                     StreamNotifyChild* notifyData, const nsCString& headers);
-  virtual ~BrowserStreamChild();
-
-  virtual bool IsBrowserStream() override { return true; }
-
-  NPError StreamConstructed(const nsCString& mimeType, const bool& seekable,
-                            uint16_t* stype);
-
-  mozilla::ipc::IPCResult RecvWrite(const int32_t& offset,
-                                    const uint32_t& newsize,
-                                    const Buffer& data);
-  mozilla::ipc::IPCResult RecvNPP_DestroyStream(const NPReason& reason);
-  virtual mozilla::ipc::IPCResult Recv__delete__() override;
-
-  void EnsureCorrectInstance(PluginInstanceChild* i) {
-    if (i != mInstance) MOZ_CRASH("Incorrect stream instance");
-  }
-  void EnsureCorrectStream(NPStream* s) {
-    if (s != &mStream) MOZ_CRASH("Incorrect stream data");
-  }
-
-  void NotifyPending() {
-    NS_ASSERTION(!mNotifyPending, "Pending twice?");
-    mNotifyPending = true;
-    EnsureDeliveryPending();
-  }
-
-  /**
-   * During instance destruction, artificially cancel all outstanding streams.
-   *
-   * @return false if we are already in the DELETING state.
-   */
-  bool InstanceDying() {
-    if (DELETING == mState) return false;
-
-    mInstanceDying = true;
-    return true;
-  }
-
-  void FinishDelivery() {
-    NS_ASSERTION(mInstanceDying, "Should only be called after InstanceDying");
-    NS_ASSERTION(DELETING != mState, "InstanceDying didn't work?");
-    mStreamStatus = NPRES_USER_BREAK;
-    Deliver();
-    NS_ASSERTION(!mStreamNotify, "Didn't deliver NPN_URLNotify?");
-  }
-
- private:
-  friend class StreamNotifyChild;
-
-  /**
-   * Post an event to ensure delivery of pending data/destroy/urlnotify events
-   * outside of the current RPC stack.
-   */
-  void EnsureDeliveryPending();
-
-  /**
-   * Deliver data, destruction, notify scheduling
-   * or cancelling the suspended timer as needed.
-   */
-  void Deliver();
-
-  /**
-   * Deliver one chunk of pending data.
-   * @return true if the plugin indicated a pause was necessary
-   */
-  bool DeliverPendingData();
-
-  void SetSuspendedTimer();
-  void ClearSuspendedTimer();
-
-  PluginInstanceChild* mInstance;
-  NPStream mStream;
-
-  static const NPReason kStreamOpen = -1;
-
-  /**
-   * The plugin's notion of whether a stream has been "closed" (no more
-   * data delivery) differs from the plugin host due to asynchronous delivery
-   * of data and stream destruction. While the plugin-visible stream is open,
-   * mStreamStatus should be kStreamOpen (-1). mStreamStatus will be a
-   * failure code if either the parent or child indicates stream failure.
-   */
-  NPReason mStreamStatus;
-
-  /**
-   * Delivery of NPP_DestroyStream and NPP_URLNotify must be postponed until
-   * all data has been delivered.
-   */
-  enum {
-    NOT_DESTROYED,    // NPP_DestroyStream not yet received
-    DESTROY_PENDING,  // NPP_DestroyStream received, not yet delivered
-    DESTROYED         // NPP_DestroyStream delivered, NPP_URLNotify may still be
-                      // pending
-  } mDestroyPending;
-  bool mNotifyPending;
-
-  // When NPP_Destroy is called for our instance (manager), this flag is set
-  // cancels the stream and avoids sending StreamDestroyed.
-  bool mInstanceDying;
-
-  enum { CONSTRUCTING, ALIVE, DYING, DELETING } mState;
-  nsCString mURL;
-  nsCString mHeaders;
-  StreamNotifyChild* mStreamNotify;
-
-  struct PendingData {
-    int32_t offset;
-    Buffer data;
-    int32_t curpos;
-  };
-  nsTArray<PendingData> mPendingData;
-
-  /**
-   * Asynchronous RecvWrite messages are never delivered to the plugin
-   * immediately, because that may be in the midst of an unexpected RPC
-   * stack frame. It instead posts a runnable using this tracker to cancel
-   * in case we are destroyed.
-   */
-  ScopedRunnableMethodFactory<BrowserStreamChild> mDeliveryTracker;
-  base::RepeatingTimer<BrowserStreamChild> mSuspendedTimer;
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif /* mozilla_plugins_BrowserStreamChild_h */
diff --git a/dom/plugins/ipc/BrowserStreamParent.cpp b/dom/plugins/ipc/BrowserStreamParent.cpp
deleted file mode 100644
index f1a5a0e2dca64..0000000000000
--- a/dom/plugins/ipc/BrowserStreamParent.cpp
+++ /dev/null
@@ -1,85 +0,0 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "BrowserStreamParent.h"
-#include "PluginInstanceParent.h"
-#include "nsNPAPIPlugin.h"
-
-#include "mozilla/UniquePtr.h"
-#include "mozilla/Unused.h"
-
-// How much data are we willing to send across the wire
-// in one chunk?
-static const int32_t kSendDataChunk = 0xffff;
-
-namespace mozilla::plugins {
-
-BrowserStreamParent::BrowserStreamParent(PluginInstanceParent* npp,
-                                         NPStream* stream)
-    : mNPP(npp), mStream(stream), mState(INITIALIZING) {
-  mStream->pdata = static_cast<AStream*>(this);
-  nsNPAPIStreamWrapper* wrapper =
-      reinterpret_cast<nsNPAPIStreamWrapper*>(mStream->ndata);
-  if (wrapper) {
-    mStreamListener = wrapper->GetStreamListener();
-  }
-}
-
-BrowserStreamParent::~BrowserStreamParent() { mStream->pdata = nullptr; }
-
-void BrowserStreamParent::ActorDestroy(ActorDestroyReason aWhy) {
-  // Implement me! Bug 1005159
-}
-
-void BrowserStreamParent::NPP_DestroyStream(NPReason reason) {
-  NS_ASSERTION(ALIVE == mState || INITIALIZING == mState,
-               "NPP_DestroyStream called twice?");
-  bool stillInitializing = INITIALIZING == mState;
-  if (stillInitializing) {
-    mState = DEFERRING_DESTROY;
-  } else {
-    mState = DYING;
-    Unused << SendNPP_DestroyStream(reason);
-  }
-}
-
-mozilla::ipc::IPCResult BrowserStreamParent::RecvStreamDestroyed() {
-  if (DYING != mState) {
-    NS_ERROR("Unexpected state");
-    return IPC_FAIL_NO_REASON(this);
-  }
-
-  mStreamPeer = nullptr;
-
-  mState = DELETING;
-  IProtocol* mgr = Manager();
-  if (!Send__delete__(this)) {
-    return IPC_FAIL_NO_REASON(mgr);
-  }
-  return IPC_OK();
-}
-
-int32_t BrowserStreamParent::WriteReady() {
-  if (mState == INITIALIZING) {
-    return 0;
-  }
-  return kSendDataChunk;
-}
-
-int32_t BrowserStreamParent::Write(int32_t offset, int32_t len, void* buffer) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-
-  NS_ASSERTION(ALIVE == mState, "Sending data after NPP_DestroyStream?");
-  NS_ASSERTION(len > 0, "Non-positive length to NPP_Write");
-
-  if (len > kSendDataChunk) len = kSendDataChunk;
-
-  return SendWrite(offset, mStream->end,
-                   nsCString(static_cast<char*>(buffer), len))
-             ? len
-             : -1;
-}
-
-}  // namespace mozilla::plugins
diff --git a/dom/plugins/ipc/BrowserStreamParent.h b/dom/plugins/ipc/BrowserStreamParent.h
deleted file mode 100644
index 492288eb3efd7..0000000000000
--- a/dom/plugins/ipc/BrowserStreamParent.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_plugins_BrowserStreamParent_h
-#define mozilla_plugins_BrowserStreamParent_h
-
-#include "mozilla/plugins/PBrowserStreamParent.h"
-#include "mozilla/plugins/AStream.h"
-#include "nsNPAPIPluginStreamListener.h"
-#include "nsPluginStreamListenerPeer.h"
-
-namespace mozilla {
-namespace plugins {
-
-class PluginInstanceParent;
-
-class BrowserStreamParent : public PBrowserStreamParent, public AStream {
-  friend class PluginModuleParent;
-  friend class PluginInstanceParent;
-
- public:
-  BrowserStreamParent(PluginInstanceParent* npp, NPStream* stream);
-  virtual ~BrowserStreamParent();
-
-  virtual bool IsBrowserStream() override { return true; }
-
-  virtual void ActorDestroy(ActorDestroyReason aWhy) override;
-
-  virtual mozilla::ipc::IPCResult RecvStreamDestroyed() override;
-
-  int32_t WriteReady();
-  int32_t Write(int32_t offset, int32_t len, void* buffer);
-
-  void NPP_DestroyStream(NPReason reason);
-
-  void SetAlive() {
-    if (mState == INITIALIZING) {
-      mState = ALIVE;
-    }
-  }
-
- private:
-  using PBrowserStreamParent::SendNPP_DestroyStream;
-
-  PluginInstanceParent* mNPP;
-  NPStream* mStream;
-  nsCOMPtr<nsISupports> mStreamPeer;
-  RefPtr<nsNPAPIPluginStreamListener> mStreamListener;
-
-  enum { INITIALIZING, DEFERRING_DESTROY, ALIVE, DYING, DELETING } mState;
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif
diff --git a/dom/plugins/ipc/ChildTimer.cpp b/dom/plugins/ipc/ChildTimer.cpp
deleted file mode 100644
index e9a096c62cf6f..0000000000000
--- a/dom/plugins/ipc/ChildTimer.cpp
+++ /dev/null
@@ -1,31 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=8 et :
- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "ChildTimer.h"
-#include "PluginInstanceChild.h"
-#include "nsComponentManagerUtils.h"
-
-namespace mozilla::plugins {
-
-ChildTimer::ChildTimer(PluginInstanceChild* instance, uint32_t interval,
-                       bool repeat, TimerFunc func)
-    : mInstance(instance),
-      mFunc(func),
-      mRepeating(repeat),
-      mID(gNextTimerID++) {
-  mTimer.Start(base::TimeDelta::FromMilliseconds(interval), this,
-               &ChildTimer::Run);
-}
-
-uint32_t ChildTimer::gNextTimerID = 1;
-
-void ChildTimer::Run() {
-  if (!mRepeating) mTimer.Stop();
-  mFunc(mInstance->GetNPP(), mID);
-}
-
-}  // namespace mozilla::plugins
diff --git a/dom/plugins/ipc/ChildTimer.h b/dom/plugins/ipc/ChildTimer.h
deleted file mode 100644
index 8b9ff72dede35..0000000000000
--- a/dom/plugins/ipc/ChildTimer.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=8 et :
- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_plugins_ChildTimer_h
-#define mozilla_plugins_ChildTimer_h
-
-#include "PluginMessageUtils.h"
-#include "npapi.h"
-#include "base/timer.h"
-#include "mozilla/UniquePtr.h"
-
-namespace mozilla {
-namespace plugins {
-
-class PluginInstanceChild;
-typedef void (*TimerFunc)(NPP npp, uint32_t timerID);
-
-class ChildTimer {
- public:
-  /**
-   * If initialization failed, ID() will return 0.
-   */
-  ChildTimer(PluginInstanceChild* instance, uint32_t interval, bool repeat,
-             TimerFunc func);
-  ~ChildTimer() = default;
-
-  uint32_t ID() const { return mID; }
-
-  class IDComparator {
-   public:
-    bool Equals(const UniquePtr<ChildTimer>& t, uint32_t id) const {
-      return t->ID() == id;
-    }
-  };
-
- private:
-  PluginInstanceChild* mInstance;
-  TimerFunc mFunc;
-  bool mRepeating;
-  uint32_t mID;
-  base::RepeatingTimer<ChildTimer> mTimer;
-
-  void Run();
-
-  static uint32_t gNextTimerID;
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // mozilla_plugins_ChildTimer_h
diff --git a/dom/plugins/ipc/D3D11SurfaceHolder.cpp b/dom/plugins/ipc/D3D11SurfaceHolder.cpp
deleted file mode 100644
index 429f3be6731d4..0000000000000
--- a/dom/plugins/ipc/D3D11SurfaceHolder.cpp
+++ /dev/null
@@ -1,81 +0,0 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-#include "nsDebug.h"
-#include "D3D11SurfaceHolder.h"
-#include "mozilla/gfx/2D.h"
-#include "mozilla/gfx/DeviceManagerDx.h"
-#include "mozilla/layers/TextureD3D11.h"
-#include <d3d11.h>
-
-namespace mozilla {
-namespace plugins {
-
-using namespace mozilla::gfx;
-using namespace mozilla::layers;
-
-D3D11SurfaceHolder::D3D11SurfaceHolder(ID3D11Texture2D* back,
-                                       SurfaceFormat format,
-                                       const IntSize& size)
-    : mDevice11(DeviceManagerDx::Get()->GetContentDevice()),
-      mBack(back),
-      mFormat(format),
-      mSize(size) {}
-
-D3D11SurfaceHolder::~D3D11SurfaceHolder() {}
-
-bool D3D11SurfaceHolder::IsValid() {
-  // If a TDR occurred, platform devices will be recreated.
-  if (DeviceManagerDx::Get()->GetContentDevice() != mDevice11) {
-    return false;
-  }
-  return true;
-}
-
-bool D3D11SurfaceHolder::CopyToTextureClient(TextureClient* aClient) {
-  MOZ_ASSERT(NS_IsMainThread());
-
-  D3D11TextureData* data = aClient->GetInternalData()->AsD3D11TextureData();
-  if (!data) {
-    // We don't support this yet. We expect to have a D3D11 compositor, and
-    // therefore D3D11 surfaces.
-    NS_WARNING("Plugin DXGI surface has unsupported TextureClient");
-    return false;
-  }
-
-  RefPtr<ID3D11DeviceContext> context;
-  mDevice11->GetImmediateContext(getter_AddRefs(context));
-  if (!context) {
-    NS_WARNING("Could not get an immediate D3D11 context");
-    return false;
-  }
-
-  TextureClientAutoLock autoLock(aClient, OpenMode::OPEN_WRITE_ONLY);
-  if (!autoLock.Succeeded()) {
-    return false;
-  }
-
-  RefPtr<IDXGIKeyedMutex> mutex;
-  HRESULT hr = mBack->QueryInterface(__uuidof(IDXGIKeyedMutex),
-                                     (void**)getter_AddRefs(mutex));
-  if (FAILED(hr) || !mutex) {
-    NS_WARNING("Could not acquire an IDXGIKeyedMutex");
-    return false;
-  }
-
-  {
-    AutoTextureLock lock(mutex, hr);
-    if (hr == WAIT_ABANDONED || hr == WAIT_TIMEOUT || FAILED(hr)) {
-      NS_WARNING(
-          "Could not acquire DXGI surface lock - plugin forgot to release?");
-      return false;
-    }
-
-    context->CopyResource(data->GetD3D11Texture(), mBack);
-  }
-  return true;
-}
-
-}  // namespace plugins
-}  // namespace mozilla
diff --git a/dom/plugins/ipc/D3D11SurfaceHolder.h b/dom/plugins/ipc/D3D11SurfaceHolder.h
deleted file mode 100644
index 4031091f7c7bc..0000000000000
--- a/dom/plugins/ipc/D3D11SurfaceHolder.h
+++ /dev/null
@@ -1,46 +0,0 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-#ifndef _include_dom_plugins_ipc_D3D11SurfaceHolder_h__
-#define _include_dom_plugins_ipc_D3D11SurfaceHolder_h__
-
-#include "ipc/IPCMessageUtils.h"
-#include "mozilla/gfx/Point.h"
-#include "mozilla/gfx/Types.h"
-
-namespace mozilla {
-namespace layers {
-class D3D11ShareHandleImage;
-class TextureClient;
-}  // namespace layers
-
-namespace plugins {
-
-class D3D11SurfaceHolder {
- public:
-  D3D11SurfaceHolder(ID3D11Texture2D* back, gfx::SurfaceFormat format,
-                     const gfx::IntSize& size);
-
-  NS_INLINE_DECL_REFCOUNTING(D3D11SurfaceHolder);
-
-  bool IsValid();
-  bool CopyToTextureClient(layers::TextureClient* aClient);
-
-  gfx::SurfaceFormat GetFormat() const { return mFormat; }
-  const gfx::IntSize& GetSize() const { return mSize; }
-
- private:
-  ~D3D11SurfaceHolder();
-
- private:
-  RefPtr<ID3D11Device> mDevice11;
-  RefPtr<ID3D11Texture2D> mBack;
-  gfx::SurfaceFormat mFormat;
-  gfx::IntSize mSize;
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // _include_dom_plugins_ipc_D3D11nSurfaceHolder_h__
diff --git a/dom/plugins/ipc/FunctionBroker.cpp b/dom/plugins/ipc/FunctionBroker.cpp
deleted file mode 100644
index 9068cf322de7e..0000000000000
--- a/dom/plugins/ipc/FunctionBroker.cpp
+++ /dev/null
@@ -1,1429 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "FunctionBroker.h"
-#include "FunctionBrokerParent.h"
-#include "PluginQuirks.h"
-
-#if defined(XP_WIN)
-#  include <commdlg.h>
-#  include <schannel.h>
-#  include <sddl.h>
-#endif  // defined(XP_WIN)
-
-using namespace mozilla;
-using namespace mozilla::ipc;
-using namespace mozilla::plugins;
-
-namespace mozilla::plugins {
-
-template <int QuirkFlag>
-static bool CheckQuirks(int aQuirks) {
-  return static_cast<bool>(aQuirks & QuirkFlag);
-}
-
-void FreeDestructor(void* aObj) { free(aObj); }
-
-#if defined(XP_WIN)
-
-// Specialization of EndpointHandlers for Flash file dialog brokering.
-struct FileDlgEHContainer {
-  template <Endpoint e>
-  struct EndpointHandler;
-};
-
-template <>
-struct FileDlgEHContainer::EndpointHandler<CLIENT>
-    : public BaseEndpointHandler<CLIENT,
-                                 FileDlgEHContainer::EndpointHandler<CLIENT>> {
-  using BaseEndpointHandler<CLIENT, EndpointHandler<CLIENT>>::Copy;
-
-  inline static void Copy(OpenFileNameIPC& aDest, const LPOPENFILENAMEW& aSrc) {
-    aDest.CopyFromOfn(aSrc);
-  }
-  inline static void Copy(LPOPENFILENAMEW& aDest,
-                          const OpenFileNameRetIPC& aSrc) {
-    aSrc.AddToOfn(aDest);
-  }
-};
-
-template <>
-struct FileDlgEHContainer::EndpointHandler<SERVER>
-    : public BaseEndpointHandler<SERVER,
-                                 FileDlgEHContainer::EndpointHandler<SERVER>> {
-  using BaseEndpointHandler<SERVER, EndpointHandler<SERVER>>::Copy;
-
-  inline static void Copy(OpenFileNameRetIPC& aDest,
-                          const LPOPENFILENAMEW& aSrc) {
-    aDest.CopyFromOfn(aSrc);
-  }
-  inline static void Copy(ServerCallData* aScd, LPOPENFILENAMEW& aDest,
-                          const OpenFileNameIPC& aSrc) {
-    MOZ_ASSERT(!aDest);
-    ServerCallData::DestructorType* destructor = [](void* aObj) {
-      OpenFileNameIPC::FreeOfnStrings(static_cast<LPOPENFILENAMEW>(aObj));
-      DeleteDestructor<OPENFILENAMEW>(aObj);
-    };
-    aDest = aScd->Allocate<OPENFILENAMEW>(destructor);
-    aSrc.AllocateOfnStrings(aDest);
-    aSrc.AddToOfn(aDest);
-  }
-};
-
-// FunctionBroker type that uses FileDlgEHContainer
-template <FunctionHookId functionId, typename FunctionType>
-using FileDlgFunctionBroker =
-    FunctionBroker<functionId, FunctionType, FileDlgEHContainer>;
-
-// Specialization of EndpointHandlers for Flash SSL brokering.
-struct SslEHContainer {
-  template <Endpoint e>
-  struct EndpointHandler;
-};
-
-template <>
-struct SslEHContainer::EndpointHandler<CLIENT>
-    : public BaseEndpointHandler<CLIENT,
-                                 SslEHContainer::EndpointHandler<CLIENT>> {
-  using BaseEndpointHandler<CLIENT, EndpointHandler<CLIENT>>::Copy;
-
-  inline static void Copy(uint64_t& aDest, const PSecHandle& aSrc) {
-    MOZ_ASSERT((aSrc->dwLower == aSrc->dwUpper) && IsOdd(aSrc->dwLower));
-    aDest = static_cast<uint64_t>(aSrc->dwLower);
-  }
-  inline static void Copy(PSecHandle& aDest, const uint64_t& aSrc) {
-    MOZ_ASSERT(IsOdd(aSrc));
-    aDest->dwLower = static_cast<ULONG_PTR>(aSrc);
-    aDest->dwUpper = static_cast<ULONG_PTR>(aSrc);
-  }
-  inline static void Copy(IPCSchannelCred& aDest, const PSCHANNEL_CRED& aSrc) {
-    if (aSrc) {
-      aDest.CopyFrom(aSrc);
-    }
-  }
-  inline static void Copy(IPCInternetBuffers& aDest,
-                          const LPINTERNET_BUFFERSA& aSrc) {
-    aDest.CopyFrom(aSrc);
-  }
-};
-
-template <>
-struct SslEHContainer::EndpointHandler<SERVER>
-    : public BaseEndpointHandler<SERVER,
-                                 SslEHContainer::EndpointHandler<SERVER>> {
-  using BaseEndpointHandler<SERVER, EndpointHandler<SERVER>>::Copy;
-
-  // PSecHandle is the same thing as PCtxtHandle and PCredHandle.
-  inline static void Copy(uint64_t& aDest, const PSecHandle& aSrc) {
-    // If the SecHandle was an error then don't store it.
-    if (!aSrc) {
-      aDest = 0;
-      return;
-    }
-
-    static uint64_t sNextVal = 1;
-    UlongPair key(aSrc->dwLower, aSrc->dwUpper);
-    // Fetch val by reference to update the value in the map
-    uint64_t& val = sPairToIdMap[key];
-    if (val == 0) {
-      MOZ_ASSERT(IsOdd(sNextVal));
-      val = sNextVal;
-      sIdToPairMap[val] = key;
-      sNextVal += 2;
-    }
-    aDest = val;
-  }
-
-  // HANDLEs and HINTERNETs marshal with obfuscation (for return values)
-  inline static void Copy(uint64_t& aDest, void* const& aSrc) {
-    // If the HANDLE/HINTERNET was an error then don't store it.
-    if (!aSrc) {
-      aDest = 0;
-      return;
-    }
-
-    static uint64_t sNextVal = 1;
-    // Fetch val by reference to update the value in the map
-    uint64_t& val = sPtrToIdMap[aSrc];
-    if (val == 0) {
-      MOZ_ASSERT(IsOdd(sNextVal));
-      val = sNextVal;
-      sIdToPtrMap[val] = aSrc;
-      sNextVal += 2;
-    }
-    aDest = val;
-  }
-
-  // HANDLEs and HINTERNETs unmarshal with obfuscation
-  inline static void Copy(void*& aDest, const uint64_t& aSrc) {
-    aDest = nullptr;
-    MOZ_RELEASE_ASSERT(IsOdd(aSrc));
-
-    // If the src is not found in the map then we get aDest == 0
-    void* ptr = sIdToPtrMap[aSrc];
-    aDest = reinterpret_cast<void*>(ptr);
-    MOZ_RELEASE_ASSERT(aDest);
-  }
-
-  inline static void Copy(PSCHANNEL_CRED& aDest, const IPCSchannelCred& aSrc) {
-    if (aDest) {
-      aSrc.CopyTo(aDest);
-    }
-  }
-
-  inline static void Copy(ServerCallData* aScd, PSecHandle& aDest,
-                          const uint64_t& aSrc) {
-    MOZ_ASSERT(!aDest);
-    MOZ_RELEASE_ASSERT(IsOdd(aSrc));
-
-    // If the src is not found in the map then we get the pair { 0, 0 }
-    aDest = aScd->Allocate<SecHandle>();
-    const UlongPair& pair = sIdToPairMap[aSrc];
-    MOZ_RELEASE_ASSERT(pair.first || pair.second);
-    aDest->dwLower = pair.first;
-    aDest->dwUpper = pair.second;
-  }
-
-  inline static void Copy(ServerCallData* aScd, PSCHANNEL_CRED& aDest,
-                          const IPCSchannelCred& aSrc) {
-    MOZ_ASSERT(!aDest);
-    aDest = aScd->Allocate<SCHANNEL_CRED>();
-    Copy(aDest, aSrc);
-  }
-
-  inline static void Copy(ServerCallData* aScd, LPINTERNET_BUFFERSA& aDest,
-                          const IPCInternetBuffers& aSrc) {
-    MOZ_ASSERT(!aDest);
-    aSrc.CopyTo(aDest);
-    ServerCallData::DestructorType* destructor = [](void* aObj) {
-      LPINTERNET_BUFFERSA inetBuf = static_cast<LPINTERNET_BUFFERSA>(aObj);
-      IPCInternetBuffers::FreeBuffers(inetBuf);
-      FreeDestructor(inetBuf);
-    };
-    aScd->PostDestructor(aDest, destructor);
-  }
-};
-
-// FunctionBroker type that uses SslEHContainer
-template <FunctionHookId functionId, typename FunctionType>
-using SslFunctionBroker =
-    FunctionBroker<functionId, FunctionType, SslEHContainer>;
-
-/* GetKeyState */
-
-typedef FunctionBroker<ID_GetKeyState, decltype(GetKeyState)> GetKeyStateFB;
-
-template <>
-ShouldHookFunc* const GetKeyStateFB::BaseType::mShouldHook =
-    &CheckQuirks<QUIRK_FLASH_HOOK_GETKEYSTATE>;
-
-/* SetCursorPos */
-
-typedef FunctionBroker<ID_SetCursorPos, decltype(SetCursorPos)> SetCursorPosFB;
-
-/* GetSaveFileNameW */
-
-typedef FileDlgFunctionBroker<ID_GetSaveFileNameW, decltype(GetSaveFileNameW)>
-    GetSaveFileNameWFB;
-
-// Remember files granted access in the chrome process
-static void GrantFileAccess(base::ProcessId aClientId, LPOPENFILENAME& aLpofn,
-                            bool isSave) {
-#  if defined(MOZ_SANDBOX)
-  if (aLpofn->Flags & OFN_ALLOWMULTISELECT) {
-    // We only support multiselect with the OFN_EXPLORER flag.
-    // This guarantees that ofn.lpstrFile follows the pattern below.
-    MOZ_ASSERT(aLpofn->Flags & OFN_EXPLORER);
-
-    // lpstrFile is one of two things:
-    // 1. A null terminated full path to a file, or
-    // 2. A path to a folder, followed by a NULL, followed by a
-    // list of file names, each NULL terminated, followed by an
-    // additional NULL (so it is also double-NULL terminated).
-    std::wstring path = std::wstring(aLpofn->lpstrFile);
-    MOZ_ASSERT(aLpofn->nFileOffset > 0);
-    // For condition #1, nFileOffset points to the file name in the path.
-    // It will be preceeded by a non-NULL character from the path.
-    if (aLpofn->lpstrFile[aLpofn->nFileOffset - 1] != L'\0') {
-      FunctionBrokerParent::GetSandboxPermissions()->GrantFileAccess(
-          aClientId, path.c_str(), isSave);
-    } else {
-      // This is condition #2
-      wchar_t* nextFile = aLpofn->lpstrFile + path.size() + 1;
-      while (*nextFile != L'\0') {
-        std::wstring nextFileStr(nextFile);
-        std::wstring fullPath = path + std::wstring(L"\\") + nextFileStr;
-        FunctionBrokerParent::GetSandboxPermissions()->GrantFileAccess(
-            aClientId, fullPath.c_str(), isSave);
-        nextFile += nextFileStr.size() + 1;
-      }
-    }
-  } else {
-    FunctionBrokerParent::GetSandboxPermissions()->GrantFileAccess(
-        aClientId, aLpofn->lpstrFile, isSave);
-  }
-#  else
-  MOZ_ASSERT_UNREACHABLE(
-      "GetFileName IPC message is only available on "
-      "Windows builds with sandbox.");
-#  endif
-}
-
-template <>
-template <>
-BROKER_DISABLE_CFGUARD BOOL GetSaveFileNameWFB::RunFunction(
-    GetSaveFileNameWFB::FunctionType* aOrigFunction, base::ProcessId aClientId,
-    LPOPENFILENAMEW& aLpofn) const {
-  BOOL result = aOrigFunction(aLpofn);
-  if (result) {
-    // Record any file access permission that was just granted.
-    GrantFileAccess(aClientId, aLpofn, true);
-  }
-  return result;
-}
-
-template <>
-template <>
-struct GetSaveFileNameWFB::Response::Info::ShouldMarshal<0> {
-  static const bool value = true;
-};
-
-/* GetOpenFileNameW */
-
-typedef FileDlgFunctionBroker<ID_GetOpenFileNameW, decltype(GetOpenFileNameW)>
-    GetOpenFileNameWFB;
-
-template <>
-template <>
-BROKER_DISABLE_CFGUARD BOOL GetOpenFileNameWFB::RunFunction(
-    GetOpenFileNameWFB::FunctionType* aOrigFunction, base::ProcessId aClientId,
-    LPOPENFILENAMEW& aLpofn) const {
-  BOOL result = aOrigFunction(aLpofn);
-  if (result) {
-    // Record any file access permission that was just granted.
-    GrantFileAccess(aClientId, aLpofn, false);
-  }
-  return result;
-}
-
-template <>
-template <>
-struct GetOpenFileNameWFB::Response::Info::ShouldMarshal<0> {
-  static const bool value = true;
-};
-
-/* InternetOpenA */
-
-typedef SslFunctionBroker<ID_InternetOpenA, decltype(InternetOpenA)>
-    InternetOpenAFB;
-
-template <>
-ShouldHookFunc* const InternetOpenAFB::BaseType::mShouldHook =
-    &CheckQuirks<QUIRK_FLASH_HOOK_SSL>;
-
-/* InternetConnectA */
-
-typedef SslFunctionBroker<ID_InternetConnectA, decltype(InternetConnectA)>
-    InternetConnectAFB;
-
-template <>
-ShouldHookFunc* const InternetConnectAFB::BaseType::mShouldHook =
-    &CheckQuirks<QUIRK_FLASH_HOOK_SSL>;
-
-typedef InternetConnectAFB::Request ICAReqHandler;
-
-template <>
-bool ICAReqHandler::ShouldBroker(Endpoint endpoint, const HINTERNET& h,
-                                 const LPCSTR& srv, const INTERNET_PORT& port,
-                                 const LPCSTR& user, const LPCSTR& pass,
-                                 const DWORD& svc, const DWORD& flags,
-                                 const DWORD_PTR& cxt) {
-  return (endpoint == SERVER) || IsOdd(reinterpret_cast<uint64_t>(h));
-}
-
-/* InternetCloseHandle */
-
-typedef SslFunctionBroker<ID_InternetCloseHandle, decltype(InternetCloseHandle)>
-    InternetCloseHandleFB;
-
-template <>
-ShouldHookFunc* const InternetCloseHandleFB::BaseType::mShouldHook =
-    &CheckQuirks<QUIRK_FLASH_HOOK_SSL>;
-
-typedef InternetCloseHandleFB::Request ICHReqHandler;
-
-template <>
-bool ICHReqHandler::ShouldBroker(Endpoint endpoint, const HINTERNET& h) {
-  // If we are server side then we were already validated since we had to be
-  // looked up in the "uint64_t <-> HINTERNET" hashtable.
-  // In the client, we check that this is a dummy handle.
-  return (endpoint == SERVER) || IsOdd(reinterpret_cast<uint64_t>(h));
-}
-
-/* InternetQueryDataAvailable */
-
-typedef SslFunctionBroker<ID_InternetQueryDataAvailable,
-                          decltype(InternetQueryDataAvailable)>
-    InternetQueryDataAvailableFB;
-
-template <>
-ShouldHookFunc* const InternetQueryDataAvailableFB::BaseType::mShouldHook =
-    &CheckQuirks<QUIRK_FLASH_HOOK_SSL>;
-
-typedef InternetQueryDataAvailableFB::Request IQDAReq;
-typedef InternetQueryDataAvailableFB::RequestDelegate<BOOL HOOK_CALL(HINTERNET)>
-    IQDADelegateReq;
-
-template <>
-void IQDAReq::Marshal(IpdlTuple& aTuple, const HINTERNET& file,
-                      const LPDWORD& nBytes, const DWORD& flags,
-                      const DWORD_PTR& cxt) {
-  IQDADelegateReq::Marshal(aTuple, file);
-}
-
-template <>
-bool IQDAReq::Unmarshal(ServerCallData& aScd, const IpdlTuple& aTuple,
-                        HINTERNET& file, LPDWORD& nBytes, DWORD& flags,
-                        DWORD_PTR& cxt) {
-  bool success = IQDADelegateReq::Unmarshal(aScd, aTuple, file);
-  if (!success) {
-    return false;
-  }
-  flags = 0;
-  cxt = 0;
-  nBytes = aScd.Allocate<DWORD>();
-  return true;
-}
-
-template <>
-bool IQDAReq::ShouldBroker(Endpoint endpoint, const HINTERNET& file,
-                           const LPDWORD& nBytes, const DWORD& flags,
-                           const DWORD_PTR& cxt) {
-  // If we are server side then we were already validated since we had to be
-  // looked up in the "uint64_t <-> HINTERNET" hashtable.
-  // In the client, we check that this is a dummy handle.
-  return (endpoint == SERVER) || ((flags == 0) && (cxt == 0) &&
-                                  IsOdd(reinterpret_cast<uint64_t>(file)));
-}
-
-template <>
-template <>
-struct InternetQueryDataAvailableFB::Response::Info::ShouldMarshal<1> {
-  static const bool value = true;
-};
-
-/* InternetReadFile */
-
-typedef SslFunctionBroker<ID_InternetReadFile, decltype(InternetReadFile)>
-    InternetReadFileFB;
-
-template <>
-ShouldHookFunc* const InternetReadFileFB::BaseType::mShouldHook =
-    &CheckQuirks<QUIRK_FLASH_HOOK_SSL>;
-
-typedef InternetReadFileFB::Request IRFRequestHandler;
-typedef InternetReadFileFB::RequestDelegate<BOOL HOOK_CALL(HINTERNET, DWORD)>
-    IRFDelegateReq;
-
-template <>
-void IRFRequestHandler::Marshal(IpdlTuple& aTuple, const HINTERNET& h,
-                                const LPVOID& buf, const DWORD& nBytesToRead,
-                                const LPDWORD& nBytesRead) {
-  IRFDelegateReq::Marshal(aTuple, h, nBytesToRead);
-}
-
-template <>
-bool IRFRequestHandler::Unmarshal(ServerCallData& aScd, const IpdlTuple& aTuple,
-                                  HINTERNET& h, LPVOID& buf,
-                                  DWORD& nBytesToRead, LPDWORD& nBytesRead) {
-  bool ret = IRFDelegateReq::Unmarshal(aScd, aTuple, h, nBytesToRead);
-  if (!ret) {
-    return false;
-  }
-
-  nBytesRead = aScd.Allocate<DWORD>();
-  MOZ_ASSERT(nBytesToRead > 0);
-  aScd.AllocateMemory(nBytesToRead, buf);
-  return true;
-}
-
-template <>
-bool IRFRequestHandler::ShouldBroker(Endpoint endpoint, const HINTERNET& h,
-                                     const LPVOID& buf,
-                                     const DWORD& nBytesToRead,
-                                     const LPDWORD& nBytesRead) {
-  // For server-side validation, the HINTERNET deserialization will have
-  // required it to already be looked up in the IdToPtrMap.  At that point,
-  // any call is valid.
-  return (endpoint == SERVER) || IsOdd(reinterpret_cast<uint64_t>(h));
-}
-
-typedef InternetReadFileFB::Response IRFResponseHandler;
-typedef InternetReadFileFB::ResponseDelegate<BOOL HOOK_CALL(
-    nsDependentCSubstring)>
-    IRFDelegateResponseHandler;
-
-// Marshal the output parameter that we sent to the response delegate.
-template <>
-template <>
-struct IRFResponseHandler::Info::ShouldMarshal<0> {
-  static const bool value = true;
-};
-
-template <>
-void IRFResponseHandler::Marshal(IpdlTuple& aTuple, const BOOL& ret,
-                                 const HINTERNET& h, const LPVOID& buf,
-                                 const DWORD& nBytesToRead,
-                                 const LPDWORD& nBytesRead) {
-  nsDependentCSubstring str;
-  if (*nBytesRead) {
-    str.Assign(static_cast<const char*>(buf), *nBytesRead);
-  }
-  IRFDelegateResponseHandler::Marshal(aTuple, ret, str);
-}
-
-template <>
-bool IRFResponseHandler::Unmarshal(const IpdlTuple& aTuple, BOOL& ret,
-                                   HINTERNET& h, LPVOID& buf,
-                                   DWORD& nBytesToRead, LPDWORD& nBytesRead) {
-  nsDependentCSubstring str;
-  bool success = IRFDelegateResponseHandler::Unmarshal(aTuple, ret, str);
-  if (!success) {
-    return false;
-  }
-
-  if (str.Length()) {
-    memcpy(buf, str.Data(), str.Length());
-    *nBytesRead = str.Length();
-  }
-  return true;
-}
-
-/* InternetWriteFile */
-
-typedef SslFunctionBroker<ID_InternetWriteFile, decltype(InternetWriteFile)>
-    InternetWriteFileFB;
-
-template <>
-ShouldHookFunc* const InternetWriteFileFB::BaseType::mShouldHook =
-    &CheckQuirks<QUIRK_FLASH_HOOK_SSL>;
-
-typedef InternetWriteFileFB::Request IWFReqHandler;
-typedef InternetWriteFileFB::RequestDelegate<int HOOK_CALL(
-    HINTERNET, nsDependentCSubstring)>
-    IWFDelegateReqHandler;
-
-template <>
-void IWFReqHandler::Marshal(IpdlTuple& aTuple, const HINTERNET& file,
-                            const LPCVOID& buf, const DWORD& nToWrite,
-                            const LPDWORD& nWritten) {
-  MOZ_ASSERT(nWritten);
-  IWFDelegateReqHandler::Marshal(
-      aTuple, file,
-      nsDependentCSubstring(static_cast<const char*>(buf), nToWrite));
-}
-
-template <>
-bool IWFReqHandler::Unmarshal(ServerCallData& aScd, const IpdlTuple& aTuple,
-                              HINTERNET& file, LPCVOID& buf, DWORD& nToWrite,
-                              LPDWORD& nWritten) {
-  nsDependentCSubstring str;
-  if (!IWFDelegateReqHandler::Unmarshal(aScd, aTuple, file, str)) {
-    return false;
-  }
-
-  aScd.AllocateString(str, buf, false);
-  nToWrite = str.Length();
-  nWritten = aScd.Allocate<DWORD>();
-  return true;
-}
-
-template <>
-bool IWFReqHandler::ShouldBroker(Endpoint endpoint, const HINTERNET& file,
-                                 const LPCVOID& buf, const DWORD& nToWrite,
-                                 const LPDWORD& nWritten) {
-  // For server-side validation, the HINTERNET deserialization will have
-  // required it to already be looked up in the IdToPtrMap.  At that point,
-  // any call is valid.
-  return (endpoint == SERVER) || IsOdd(reinterpret_cast<uint64_t>(file));
-}
-
-template <>
-template <>
-struct InternetWriteFileFB::Response::Info::ShouldMarshal<3> {
-  static const bool value = true;
-};
-
-/* InternetSetOptionA */
-
-typedef SslFunctionBroker<ID_InternetSetOptionA, decltype(InternetSetOptionA)>
-    InternetSetOptionAFB;
-
-template <>
-ShouldHookFunc* const InternetSetOptionAFB::BaseType::mShouldHook =
-    &CheckQuirks<QUIRK_FLASH_HOOK_SSL>;
-
-typedef InternetSetOptionAFB::Request ISOAReqHandler;
-typedef InternetSetOptionAFB::RequestDelegate<BOOL HOOK_CALL(
-    HINTERNET, DWORD, nsDependentCSubstring)>
-    ISOADelegateReqHandler;
-
-template <>
-void ISOAReqHandler::Marshal(IpdlTuple& aTuple, const HINTERNET& h,
-                             const DWORD& opt, const LPVOID& buf,
-                             const DWORD& bufLen) {
-  ISOADelegateReqHandler::Marshal(
-      aTuple, h, opt,
-      nsDependentCSubstring(static_cast<const char*>(buf), bufLen));
-}
-
-template <>
-bool ISOAReqHandler::Unmarshal(ServerCallData& aScd, const IpdlTuple& aTuple,
-                               HINTERNET& h, DWORD& opt, LPVOID& buf,
-                               DWORD& bufLen) {
-  nsDependentCSubstring str;
-  if (!ISOADelegateReqHandler::Unmarshal(aScd, aTuple, h, opt, str)) {
-    return false;
-  }
-
-  aScd.AllocateString(str, buf, false);
-  bufLen = str.Length();
-  return true;
-}
-
-template <>
-bool ISOAReqHandler::ShouldBroker(Endpoint endpoint, const HINTERNET& h,
-                                  const DWORD& opt, const LPVOID& buf,
-                                  const DWORD& bufLen) {
-  // For server-side validation, the HINTERNET deserialization will have
-  // required it to already be looked up in the IdToPtrMap.  At that point,
-  // any call is valid.
-  return (endpoint == SERVER) || IsOdd(reinterpret_cast<uint64_t>(h));
-}
-
-/* HttpAddRequestHeadersA */
-
-typedef SslFunctionBroker<ID_HttpAddRequestHeadersA,
-                          decltype(HttpAddRequestHeadersA)>
-    HttpAddRequestHeadersAFB;
-
-template <>
-ShouldHookFunc* const HttpAddRequestHeadersAFB::BaseType::mShouldHook =
-    &CheckQuirks<QUIRK_FLASH_HOOK_SSL>;
-
-typedef HttpAddRequestHeadersAFB::Request HARHAReqHandler;
-
-template <>
-bool HARHAReqHandler::ShouldBroker(Endpoint endpoint, const HINTERNET& h,
-                                   const LPCSTR& head, const DWORD& headLen,
-                                   const DWORD& mods) {
-  // For server-side validation, the HINTERNET deserialization will have
-  // required it to already be looked up in the IdToPtrMap.  At that point,
-  // any call is valid.
-  return (endpoint == SERVER) || IsOdd(reinterpret_cast<uint64_t>(h));
-}
-
-/* HttpOpenRequestA */
-
-typedef SslFunctionBroker<ID_HttpOpenRequestA, decltype(HttpOpenRequestA)>
-    HttpOpenRequestAFB;
-
-template <>
-ShouldHookFunc* const HttpOpenRequestAFB::BaseType::mShouldHook =
-    &CheckQuirks<QUIRK_FLASH_HOOK_SSL>;
-
-typedef HttpOpenRequestAFB::Request HORAReqHandler;
-typedef HttpOpenRequestAFB::RequestDelegate<HINTERNET HOOK_CALL(
-    HINTERNET, LPCSTR, LPCSTR, LPCSTR, LPCSTR, CopyableTArray<nsCString>, DWORD,
-    DWORD_PTR)>
-    HORADelegateReqHandler;
-
-template <>
-void HORAReqHandler::Marshal(IpdlTuple& aTuple, const HINTERNET& h,
-                             const LPCSTR& verb, const LPCSTR& obj,
-                             const LPCSTR& ver, const LPCSTR& ref,
-                             LPCSTR* const& acceptTypes, const DWORD& flags,
-                             const DWORD_PTR& cxt) {
-  CopyableTArray<nsCString> arrayAcceptTypes;
-  LPCSTR* curAcceptType = acceptTypes;
-  if (curAcceptType) {
-    while (*curAcceptType) {
-      arrayAcceptTypes.AppendElement(nsCString(*curAcceptType));
-      ++curAcceptType;
-    }
-  }
-  // XXX Could we move arrayAcceptTypes here?
-  HORADelegateReqHandler::Marshal(aTuple, h, verb, obj, ver, ref,
-                                  arrayAcceptTypes, flags, cxt);
-}
-
-template <>
-bool HORAReqHandler::Unmarshal(ServerCallData& aScd, const IpdlTuple& aTuple,
-                               HINTERNET& h, LPCSTR& verb, LPCSTR& obj,
-                               LPCSTR& ver, LPCSTR& ref, LPCSTR*& acceptTypes,
-                               DWORD& flags, DWORD_PTR& cxt) {
-  CopyableTArray<nsCString> arrayAcceptTypes;
-  if (!HORADelegateReqHandler::Unmarshal(aScd, aTuple, h, verb, obj, ver, ref,
-                                         arrayAcceptTypes, flags, cxt)) {
-    return false;
-  }
-  if (arrayAcceptTypes.Length() == 0) {
-    acceptTypes = nullptr;
-  } else {
-    aScd.AllocateMemory((arrayAcceptTypes.Length() + 1) * sizeof(LPCSTR),
-                        acceptTypes);
-    for (size_t i = 0; i < arrayAcceptTypes.Length(); ++i) {
-      aScd.AllocateString(arrayAcceptTypes[i], acceptTypes[i]);
-    }
-    acceptTypes[arrayAcceptTypes.Length()] = nullptr;
-  }
-  return true;
-}
-
-template <>
-bool HORAReqHandler::ShouldBroker(Endpoint endpoint, const HINTERNET& h,
-                                  const LPCSTR& verb, const LPCSTR& obj,
-                                  const LPCSTR& ver, const LPCSTR& ref,
-                                  LPCSTR* const& acceptTypes,
-                                  const DWORD& flags, const DWORD_PTR& cxt) {
-  // For the server-side test, the HINTERNET deserialization will have
-  // required it to already be looked up in the IdToPtrMap.  At that point,
-  // any call is valid.
-  return (endpoint == SERVER) || IsOdd(reinterpret_cast<uint64_t>(h));
-}
-
-/* HttpQueryInfoA */
-
-typedef SslFunctionBroker<ID_HttpQueryInfoA, decltype(HttpQueryInfoA)>
-    HttpQueryInfoAFB;
-
-template <>
-ShouldHookFunc* const HttpQueryInfoAFB::BaseType::mShouldHook =
-    &CheckQuirks<QUIRK_FLASH_HOOK_SSL>;
-
-typedef HttpQueryInfoAFB::Request HQIARequestHandler;
-typedef HttpQueryInfoAFB::RequestDelegate<BOOL HOOK_CALL(HINTERNET, DWORD, BOOL,
-                                                         DWORD, BOOL, DWORD)>
-    HQIADelegateRequestHandler;
-
-template <>
-void HQIARequestHandler::Marshal(IpdlTuple& aTuple, const HINTERNET& h,
-                                 const DWORD& lvl, const LPVOID& buf,
-                                 const LPDWORD& bufLen, const LPDWORD& idx) {
-  HQIADelegateRequestHandler::Marshal(aTuple, h, lvl, bufLen != nullptr,
-                                      bufLen ? *bufLen : 0, idx != nullptr,
-                                      idx ? *idx : 0);
-}
-
-template <>
-bool HQIARequestHandler::Unmarshal(ServerCallData& aScd,
-                                   const IpdlTuple& aTuple, HINTERNET& h,
-                                   DWORD& lvl, LPVOID& buf, LPDWORD& bufLen,
-                                   LPDWORD& idx) {
-  BOOL hasBufLen, hasIdx;
-  DWORD tempBufLen, tempIdx;
-  bool success = HQIADelegateRequestHandler::Unmarshal(
-      aScd, aTuple, h, lvl, hasBufLen, tempBufLen, hasIdx, tempIdx);
-  if (!success) {
-    return false;
-  }
-
-  bufLen = nullptr;
-  if (hasBufLen) {
-    aScd.AllocateMemory(tempBufLen, buf, bufLen);
-  }
-
-  idx = nullptr;
-  if (hasIdx) {
-    idx = aScd.Allocate<DWORD>(tempIdx);
-  }
-
-  return true;
-}
-
-template <>
-bool HQIARequestHandler::ShouldBroker(Endpoint endpoint, const HINTERNET& h,
-                                      const DWORD& lvl, const LPVOID& buf,
-                                      const LPDWORD& bufLen,
-                                      const LPDWORD& idx) {
-  return (endpoint == SERVER) || IsOdd(reinterpret_cast<uint64_t>(h));
-}
-
-// Marshal all of the output parameters that we sent to the response delegate.
-template <>
-template <>
-struct HttpQueryInfoAFB::Response::Info::ShouldMarshal<0> {
-  static const bool value = true;
-};
-template <>
-template <>
-struct HttpQueryInfoAFB::Response::Info::ShouldMarshal<1> {
-  static const bool value = true;
-};
-template <>
-template <>
-struct HttpQueryInfoAFB::Response::Info::ShouldMarshal<2> {
-  static const bool value = true;
-};
-
-typedef HttpQueryInfoAFB::Response HQIAResponseHandler;
-typedef HttpQueryInfoAFB::ResponseDelegate<BOOL HOOK_CALL(nsDependentCSubstring,
-                                                          DWORD, DWORD)>
-    HQIADelegateResponseHandler;
-
-template <>
-void HQIAResponseHandler::Marshal(IpdlTuple& aTuple, const BOOL& ret,
-                                  const HINTERNET& h, const DWORD& lvl,
-                                  const LPVOID& buf, const LPDWORD& bufLen,
-                                  const LPDWORD& idx) {
-  nsDependentCSubstring str;
-  if (buf && ret) {
-    MOZ_ASSERT(bufLen);
-    str.Assign(static_cast<const char*>(buf), *bufLen);
-  }
-  // Note that we send the bufLen separately to handle the case where buf wasn't
-  // allocated or large enough to hold the entire return value.  bufLen is then
-  // the required buffer size.
-  HQIADelegateResponseHandler::Marshal(aTuple, ret, str, bufLen ? *bufLen : 0,
-                                       idx ? *idx : 0);
-}
-
-template <>
-bool HQIAResponseHandler::Unmarshal(const IpdlTuple& aTuple, BOOL& ret,
-                                    HINTERNET& h, DWORD& lvl, LPVOID& buf,
-                                    LPDWORD& bufLen, LPDWORD& idx) {
-  DWORD totalBufLen = *bufLen;
-  nsDependentCSubstring str;
-  DWORD tempBufLen, tempIdx;
-  bool success = HQIADelegateResponseHandler::Unmarshal(aTuple, ret, str,
-                                                        tempBufLen, tempIdx);
-  if (!success) {
-    return false;
-  }
-
-  if (bufLen) {
-    *bufLen = tempBufLen;
-  }
-  if (idx) {
-    *idx = tempIdx;
-  }
-
-  if (buf && ret) {
-    // When HttpQueryInfo returns strings, the buffer length will not include
-    // the null terminator.  Rather than (brittle-y) trying to determine if the
-    // return buffer is a string, we always tack on a null terminator if the
-    // buffer has room for it.
-    MOZ_ASSERT(str.Length() == *bufLen);
-    memcpy(buf, str.Data(), str.Length());
-    if (str.Length() < totalBufLen) {
-      char* cbuf = static_cast<char*>(buf);
-      cbuf[str.Length()] = '\0';
-    }
-  }
-  return true;
-}
-
-/* HttpSendRequestA */
-
-typedef SslFunctionBroker<ID_HttpSendRequestA, decltype(HttpSendRequestA)>
-    HttpSendRequestAFB;
-
-template <>
-ShouldHookFunc* const HttpSendRequestAFB::BaseType::mShouldHook =
-    &CheckQuirks<QUIRK_FLASH_HOOK_SSL>;
-
-typedef HttpSendRequestAFB::Request HSRARequestHandler;
-typedef HttpSendRequestAFB::RequestDelegate<BOOL HOOK_CALL(
-    HINTERNET, nsDependentCSubstring, nsDependentCSubstring)>
-    HSRADelegateRequestHandler;
-
-template <>
-void HSRARequestHandler::Marshal(IpdlTuple& aTuple, const HINTERNET& h,
-                                 const LPCSTR& head, const DWORD& headLen,
-                                 const LPVOID& opt, const DWORD& optLen) {
-  nsDependentCSubstring headStr;
-  headStr.SetIsVoid(head == nullptr);
-  if (head) {
-    // HttpSendRequest allows headLen == -1L for length of a null terminated
-    // string.
-    DWORD ncHeadLen = headLen;
-    if (ncHeadLen == -1L) {
-      ncHeadLen = strlen(head);
-    }
-    headStr.Rebind(head, ncHeadLen);
-  }
-  nsDependentCSubstring optStr;
-  optStr.SetIsVoid(opt == nullptr);
-  if (opt) {
-    optStr.Rebind(static_cast<const char*>(opt), optLen);
-  }
-  HSRADelegateRequestHandler::Marshal(aTuple, h, headStr, optStr);
-}
-
-template <>
-bool HSRARequestHandler::Unmarshal(ServerCallData& aScd,
-                                   const IpdlTuple& aTuple, HINTERNET& h,
-                                   LPCSTR& head, DWORD& headLen, LPVOID& opt,
-                                   DWORD& optLen) {
-  nsDependentCSubstring headStr;
-  nsDependentCSubstring optStr;
-  bool success =
-      HSRADelegateRequestHandler::Unmarshal(aScd, aTuple, h, headStr, optStr);
-  if (!success) {
-    return false;
-  }
-
-  if (headStr.IsVoid()) {
-    head = nullptr;
-    MOZ_ASSERT(headLen == 0);
-  } else {
-    aScd.AllocateString(headStr, head, false);
-    headLen = headStr.Length();
-  }
-
-  if (optStr.IsVoid()) {
-    opt = nullptr;
-    MOZ_ASSERT(optLen == 0);
-  } else {
-    aScd.AllocateString(optStr, opt, false);
-    optLen = optStr.Length();
-  }
-  return true;
-}
-
-template <>
-bool HSRARequestHandler::ShouldBroker(Endpoint endpoint, const HINTERNET& h,
-                                      const LPCSTR& head, const DWORD& headLen,
-                                      const LPVOID& opt, const DWORD& optLen) {
-  // If we are server side then we were already validated since we had to be
-  // looked up in the "uint64_t <-> HINTERNET" hashtable.
-  // In the client, we check that this is a dummy handle.
-  return (endpoint == SERVER) || IsOdd(reinterpret_cast<uint64_t>(h));
-}
-
-/* HttpSendRequestExA */
-
-typedef SslFunctionBroker<ID_HttpSendRequestExA, decltype(HttpSendRequestExA)>
-    HttpSendRequestExAFB;
-
-template <>
-ShouldHookFunc* const HttpSendRequestExAFB::BaseType::mShouldHook =
-    &CheckQuirks<QUIRK_FLASH_HOOK_SSL>;
-
-typedef RequestInfo<ID_HttpSendRequestExA> HSRExAReqInfo;
-
-template <>
-template <>
-struct HSRExAReqInfo::FixedValue<2> {
-  static const LPINTERNET_BUFFERSA value;
-};
-const LPINTERNET_BUFFERSA HSRExAReqInfo::FixedValue<2>::value = nullptr;
-
-// Docs for HttpSendRequestExA say this parameter 'must' be zero but Flash
-// passes other values.
-// template<> template<>
-// struct HSRExAReqInfo::FixedValue<3> { static const DWORD value = 0; };
-
-template <>
-template <>
-struct HSRExAReqInfo::FixedValue<4> {
-  static const DWORD_PTR value;
-};
-const DWORD_PTR HSRExAReqInfo::FixedValue<4>::value = 0;
-
-/* HttpEndRequestA */
-
-typedef SslFunctionBroker<ID_HttpEndRequestA, decltype(HttpEndRequestA)>
-    HttpEndRequestAFB;
-
-template <>
-ShouldHookFunc* const HttpEndRequestAFB::BaseType::mShouldHook =
-    &CheckQuirks<QUIRK_FLASH_HOOK_SSL>;
-
-typedef RequestInfo<ID_HttpEndRequestA> HERAReqInfo;
-
-template <>
-template <>
-struct HERAReqInfo::FixedValue<1> {
-  static const LPINTERNET_BUFFERSA value;
-};
-const LPINTERNET_BUFFERSA HERAReqInfo::FixedValue<1>::value = nullptr;
-
-template <>
-template <>
-struct HERAReqInfo::FixedValue<2> {
-  static const DWORD value;
-};
-const DWORD HERAReqInfo::FixedValue<2>::value = 0;
-
-template <>
-template <>
-struct HERAReqInfo::FixedValue<3> {
-  static const DWORD_PTR value;
-};
-const DWORD_PTR HERAReqInfo::FixedValue<3>::value = 0;
-
-/* InternetQueryOptionA */
-
-typedef SslFunctionBroker<ID_InternetQueryOptionA,
-                          decltype(InternetQueryOptionA)>
-    InternetQueryOptionAFB;
-
-template <>
-ShouldHookFunc* const InternetQueryOptionAFB::BaseType::mShouldHook =
-    &CheckQuirks<QUIRK_FLASH_HOOK_SSL>;
-
-typedef InternetQueryOptionAFB::Request IQOARequestHandler;
-typedef InternetQueryOptionAFB::RequestDelegate<BOOL HOOK_CALL(HINTERNET, DWORD,
-                                                               DWORD)>
-    IQOADelegateRequestHandler;
-
-template <>
-void IQOARequestHandler::Marshal(IpdlTuple& aTuple, const HINTERNET& h,
-                                 const DWORD& opt, const LPVOID& buf,
-                                 const LPDWORD& bufLen) {
-  MOZ_ASSERT(bufLen);
-  IQOADelegateRequestHandler::Marshal(aTuple, h, opt, buf ? *bufLen : 0);
-}
-
-template <>
-bool IQOARequestHandler::Unmarshal(ServerCallData& aScd,
-                                   const IpdlTuple& aTuple, HINTERNET& h,
-                                   DWORD& opt, LPVOID& buf, LPDWORD& bufLen) {
-  DWORD tempBufLen;
-  bool success =
-      IQOADelegateRequestHandler::Unmarshal(aScd, aTuple, h, opt, tempBufLen);
-  if (!success) {
-    return false;
-  }
-
-  aScd.AllocateMemory(tempBufLen, buf, bufLen);
-  return true;
-}
-
-template <>
-bool IQOARequestHandler::ShouldBroker(Endpoint endpoint, const HINTERNET& h,
-                                      const DWORD& opt, const LPVOID& buf,
-                                      const LPDWORD& bufLen) {
-  // If we are server side then we were already validated since we had to be
-  // looked up in the "uint64_t <-> HINTERNET" hashtable.
-  // In the client, we check that this is a dummy handle.
-  return (endpoint == SERVER) || IsOdd(reinterpret_cast<uint64_t>(h));
-}
-
-// Marshal all of the output parameters that we sent to the response delegate.
-template <>
-template <>
-struct InternetQueryOptionAFB::Response::Info::ShouldMarshal<0> {
-  static const bool value = true;
-};
-template <>
-template <>
-struct InternetQueryOptionAFB::Response::Info::ShouldMarshal<1> {
-  static const bool value = true;
-};
-
-typedef InternetQueryOptionAFB::Response IQOAResponseHandler;
-typedef InternetQueryOptionAFB::ResponseDelegate<BOOL HOOK_CALL(
-    nsDependentCSubstring, DWORD)>
-    IQOADelegateResponseHandler;
-
-template <>
-void IQOAResponseHandler::Marshal(IpdlTuple& aTuple, const BOOL& ret,
-                                  const HINTERNET& h, const DWORD& opt,
-                                  const LPVOID& buf, const LPDWORD& bufLen) {
-  nsDependentCSubstring str;
-  if (buf && ret) {
-    MOZ_ASSERT(*bufLen);
-    str.Assign(static_cast<const char*>(buf), *bufLen);
-  }
-  IQOADelegateResponseHandler::Marshal(aTuple, ret, str, *bufLen);
-}
-
-template <>
-bool IQOAResponseHandler::Unmarshal(const IpdlTuple& aTuple, BOOL& ret,
-                                    HINTERNET& h, DWORD& opt, LPVOID& buf,
-                                    LPDWORD& bufLen) {
-  nsDependentCSubstring str;
-  bool success =
-      IQOADelegateResponseHandler::Unmarshal(aTuple, ret, str, *bufLen);
-  if (!success) {
-    return false;
-  }
-
-  if (buf && ret) {
-    MOZ_ASSERT(str.Length() == *bufLen);
-    memcpy(buf, str.Data(), str.Length());
-  }
-  return true;
-}
-
-/* InternetErrorDlg */
-
-typedef SslFunctionBroker<ID_InternetErrorDlg, decltype(InternetErrorDlg)>
-    InternetErrorDlgFB;
-
-template <>
-ShouldHookFunc* const InternetErrorDlgFB::BaseType::mShouldHook =
-    &CheckQuirks<QUIRK_FLASH_HOOK_SSL>;
-
-typedef RequestInfo<ID_InternetErrorDlg> IEDReqInfo;
-
-template <>
-template <>
-struct IEDReqInfo::FixedValue<4> {
-  static LPVOID* const value;
-};
-LPVOID* const IEDReqInfo::FixedValue<4>::value = nullptr;
-
-typedef InternetErrorDlgFB::Request IEDReqHandler;
-
-template <>
-bool IEDReqHandler::ShouldBroker(Endpoint endpoint, const HWND& hwnd,
-                                 const HINTERNET& h, const DWORD& err,
-                                 const DWORD& flags, LPVOID* const& data) {
-  const DWORD SUPPORTED_FLAGS =
-      FLAGS_ERROR_UI_FILTER_FOR_ERRORS | FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS |
-      FLAGS_ERROR_UI_FLAGS_GENERATE_DATA | FLAGS_ERROR_UI_FLAGS_NO_UI;
-
-  // We broker if (1) the handle h is brokered (odd in client),
-  // (2) we support the requested action flags and (3) there is no user
-  // data, which wouldn't make sense for our supported flags anyway.
-  return ((endpoint == SERVER) || IsOdd(reinterpret_cast<uint64_t>(h))) &&
-         (!(flags & ~SUPPORTED_FLAGS)) && (data == nullptr);
-}
-
-/* AcquireCredentialsHandleA */
-
-typedef SslFunctionBroker<ID_AcquireCredentialsHandleA,
-                          decltype(AcquireCredentialsHandleA)>
-    AcquireCredentialsHandleAFB;
-
-template <>
-ShouldHookFunc* const AcquireCredentialsHandleAFB::BaseType::mShouldHook =
-    &CheckQuirks<QUIRK_FLASH_HOOK_SSL>;
-
-typedef RequestInfo<ID_AcquireCredentialsHandleA> ACHAReqInfo;
-
-template <>
-template <>
-struct ACHAReqInfo::FixedValue<0> {
-  static const LPSTR value;
-};
-const LPSTR ACHAReqInfo::FixedValue<0>::value = nullptr;
-
-template <>
-template <>
-struct ACHAReqInfo::FixedValue<1> {
-  static const LPSTR value;
-};
-const LPSTR ACHAReqInfo::FixedValue<1>::value =
-    const_cast<char*>(UNISP_NAME_A);  // -Wwritable-strings
-
-template <>
-template <>
-struct ACHAReqInfo::FixedValue<2> {
-  static const unsigned long value;
-};
-const unsigned long ACHAReqInfo::FixedValue<2>::value = SECPKG_CRED_OUTBOUND;
-
-template <>
-template <>
-struct ACHAReqInfo::FixedValue<3> {
-  static void* const value;
-};
-void* const ACHAReqInfo::FixedValue<3>::value = nullptr;
-
-template <>
-template <>
-struct ACHAReqInfo::FixedValue<5> {
-  static const SEC_GET_KEY_FN value;
-};
-const SEC_GET_KEY_FN ACHAReqInfo::FixedValue<5>::value = nullptr;
-
-template <>
-template <>
-struct ACHAReqInfo::FixedValue<6> {
-  static void* const value;
-};
-void* const ACHAReqInfo::FixedValue<6>::value = nullptr;
-
-typedef AcquireCredentialsHandleAFB::Request ACHARequestHandler;
-typedef AcquireCredentialsHandleAFB::RequestDelegate<SECURITY_STATUS HOOK_CALL(
-    LPSTR, LPSTR, unsigned long, void*, PSCHANNEL_CRED, SEC_GET_KEY_FN, void*)>
-    ACHADelegateRequestHandler;
-
-template <>
-void ACHARequestHandler::Marshal(IpdlTuple& aTuple, const LPSTR& principal,
-                                 const LPSTR& pkg, const unsigned long& credUse,
-                                 const PVOID& logonId, const PVOID& auth,
-                                 const SEC_GET_KEY_FN& getKeyFn,
-                                 const PVOID& getKeyArg,
-                                 const PCredHandle& cred,
-                                 const PTimeStamp& expiry) {
-  const PSCHANNEL_CRED& scCred = reinterpret_cast<const PSCHANNEL_CRED&>(auth);
-  ACHADelegateRequestHandler::Marshal(aTuple, principal, pkg, credUse, logonId,
-                                      scCred, getKeyFn, getKeyArg);
-}
-
-template <>
-bool ACHARequestHandler::Unmarshal(ServerCallData& aScd,
-                                   const IpdlTuple& aTuple, LPSTR& principal,
-                                   LPSTR& pkg, unsigned long& credUse,
-                                   PVOID& logonId, PVOID& auth,
-                                   SEC_GET_KEY_FN& getKeyFn, PVOID& getKeyArg,
-                                   PCredHandle& cred, PTimeStamp& expiry) {
-  PSCHANNEL_CRED& scCred = reinterpret_cast<PSCHANNEL_CRED&>(auth);
-  if (!ACHADelegateRequestHandler::Unmarshal(aScd, aTuple, principal, pkg,
-                                             credUse, logonId, scCred, getKeyFn,
-                                             getKeyArg)) {
-    return false;
-  }
-
-  cred = aScd.Allocate<CredHandle>();
-  expiry = aScd.Allocate<::TimeStamp>();
-  return true;
-}
-
-typedef ResponseInfo<ID_AcquireCredentialsHandleA> ACHARspInfo;
-
-// Response phase must send output parameters
-template <>
-template <>
-struct ACHARspInfo::ShouldMarshal<7> {
-  static const bool value = true;
-};
-template <>
-template <>
-struct ACHARspInfo::ShouldMarshal<8> {
-  static const bool value = true;
-};
-
-/* QueryCredentialsAttributesA */
-
-typedef SslFunctionBroker<ID_QueryCredentialsAttributesA,
-                          decltype(QueryCredentialsAttributesA)>
-    QueryCredentialsAttributesAFB;
-
-template <>
-ShouldHookFunc* const QueryCredentialsAttributesAFB::BaseType::mShouldHook =
-    &CheckQuirks<QUIRK_FLASH_HOOK_SSL>;
-
-/* FreeCredentialsHandle */
-
-typedef SslFunctionBroker<ID_FreeCredentialsHandle,
-                          decltype(FreeCredentialsHandle)>
-    FreeCredentialsHandleFB;
-
-template <>
-ShouldHookFunc* const FreeCredentialsHandleFB::BaseType::mShouldHook =
-    &CheckQuirks<QUIRK_FLASH_HOOK_SSL>;
-
-typedef FreeCredentialsHandleFB::Request FCHReq;
-
-template <>
-bool FCHReq::ShouldBroker(Endpoint endpoint, const PCredHandle& h) {
-  // If we are server side then we were already validated since we had to be
-  // looked up in the "uint64_t <-> CredHandle" hashtable.
-  // In the client, we check that this is a dummy handle.
-  return (endpoint == SERVER) || ((h->dwLower == h->dwUpper) &&
-                                  IsOdd(static_cast<uint64_t>(h->dwLower)));
-}
-
-/* CreateMutexW */
-
-// Get the user's SID as a string.  Returns an empty string on failure.
-static std::wstring GetUserSid() {
-  std::wstring ret;
-  // Get user SID from process token information
-  HANDLE token;
-  BOOL success = ::OpenProcessToken(::GetCurrentProcess(), TOKEN_QUERY, &token);
-  if (!success) {
-    return ret;
-  }
-  DWORD bufLen;
-  success = ::GetTokenInformation(token, TokenUser, nullptr, 0, &bufLen);
-  if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
-    return ret;
-  }
-  void* buf = malloc(bufLen);
-  success = ::GetTokenInformation(token, TokenUser, buf, bufLen, &bufLen);
-  MOZ_ASSERT(success);
-  if (success) {
-    TOKEN_USER* tokenUser = static_cast<TOKEN_USER*>(buf);
-    PSID sid = tokenUser->User.Sid;
-    LPWSTR sidStr;
-    success = ::ConvertSidToStringSid(sid, &sidStr);
-    if (success) {
-      ret = sidStr;
-      ::LocalFree(sidStr);
-    }
-  }
-  free(buf);
-  ::CloseHandle(token);
-  return ret;
-}
-
-// Get the name Windows uses for the camera mutex.  Returns an empty string
-// on failure.
-// The camera mutex is identified in Windows code using a hard-coded GUID
-// string, "eed3bd3a-a1ad-4e99-987b-d7cb3fcfa7f0", and the user's SID.  The GUID
-// value was determined by investigating Windows code.  It is referenced in
-// CCreateSwEnum::CCreateSwEnum(void) in devenum.dll.
-static std::wstring GetCameraMutexName() {
-  std::wstring userSid = GetUserSid();
-  if (userSid.empty()) {
-    return userSid;
-  }
-  return std::wstring(L"eed3bd3a-a1ad-4e99-987b-d7cb3fcfa7f0 - ") + userSid;
-}
-
-typedef FunctionBroker<ID_CreateMutexW, decltype(CreateMutexW)> CreateMutexWFB;
-
-template <>
-ShouldHookFunc* const CreateMutexWFB::BaseType::mShouldHook =
-    &CheckQuirks<QUIRK_FLASH_HOOK_CREATEMUTEXW>;
-
-typedef CreateMutexWFB::Request CMWReqHandler;
-typedef CMWReqHandler::Info CMWReqInfo;
-typedef CreateMutexWFB::Response CMWRspHandler;
-
-template <>
-bool CMWReqHandler::ShouldBroker(Endpoint endpoint,
-                                 const LPSECURITY_ATTRIBUTES& aAttribs,
-                                 const BOOL& aOwner, const LPCWSTR& aName) {
-  // Statically hold the camera mutex name so that we dont recompute it for
-  // every CreateMutexW call in the client process.
-  static std::wstring camMutexName = GetCameraMutexName();
-
-  // Only broker if we are requesting the camera mutex.  Note that we only
-  // need to check that the client is actually requesting the camera.  The
-  // command is always valid on the server as long as we can construct the
-  // mutex name.
-  if (endpoint == SERVER) {
-    return !camMutexName.empty();
-  }
-
-  return (!aOwner) && aName && (!camMutexName.empty()) &&
-         (camMutexName == aName);
-}
-
-// We dont need to marshal any parameters.  We construct all of them
-// server-side.
-template <>
-template <>
-struct CMWReqInfo::ShouldMarshal<0> {
-  static const bool value = false;
-};
-template <>
-template <>
-struct CMWReqInfo::ShouldMarshal<1> {
-  static const bool value = false;
-};
-template <>
-template <>
-struct CMWReqInfo::ShouldMarshal<2> {
-  static const bool value = false;
-};
-
-template <>
-template <>
-BROKER_DISABLE_CFGUARD HANDLE CreateMutexWFB::RunFunction(
-    CreateMutexWFB::FunctionType* aOrigFunction, base::ProcessId aClientId,
-    LPSECURITY_ATTRIBUTES& aAttribs, BOOL& aOwner, LPCWSTR& aName) const {
-  // Use CreateMutexW to get the camera mutex and DuplicateHandle to open it
-  // for use in the child process.
-  // Recall that aAttribs, aOwner and aName are all unmarshaled so they are
-  // unassigned garbage.
-  SECURITY_ATTRIBUTES mutexAttrib = {sizeof(SECURITY_ATTRIBUTES),
-                                     nullptr /* ignored */, TRUE};
-  std::wstring camMutexName = GetCameraMutexName();
-  if (camMutexName.empty()) {
-    return 0;
-  }
-  HANDLE serverMutex =
-      ::CreateMutexW(&mutexAttrib, FALSE, camMutexName.c_str());
-  if (serverMutex == 0) {
-    return 0;
-  }
-  ScopedProcessHandle clientProcHandle;
-  if (!base::OpenProcessHandle(aClientId, &clientProcHandle.rwget())) {
-    return 0;
-  }
-  HANDLE ret;
-  if (!::DuplicateHandle(::GetCurrentProcess(), serverMutex, clientProcHandle,
-                         &ret, SYNCHRONIZE, FALSE, DUPLICATE_CLOSE_SOURCE)) {
-    return 0;
-  }
-  return ret;
-}
-
-#endif  // defined(XP_WIN)
-
-/*****************************************************************************/
-
-#define FUN_HOOK(x) static_cast<FunctionHook*>(x)
-void AddBrokeredFunctionHooks(FunctionHookArray& aHooks) {
-  // We transfer ownership of the FunctionHook objects to the array.
-#if defined(XP_WIN)
-  aHooks[ID_GetKeyState] =
-      FUN_HOOK(new GetKeyStateFB("user32.dll", "GetKeyState", &GetKeyState));
-  aHooks[ID_SetCursorPos] =
-      FUN_HOOK(new SetCursorPosFB("user32.dll", "SetCursorPos", &SetCursorPos));
-  aHooks[ID_GetSaveFileNameW] = FUN_HOOK(new GetSaveFileNameWFB(
-      "comdlg32.dll", "GetSaveFileNameW", &GetSaveFileNameW));
-  aHooks[ID_GetOpenFileNameW] = FUN_HOOK(new GetOpenFileNameWFB(
-      "comdlg32.dll", "GetOpenFileNameW", &GetOpenFileNameW));
-  aHooks[ID_InternetOpenA] = FUN_HOOK(
-      new InternetOpenAFB("wininet.dll", "InternetOpenA", &InternetOpenA));
-  aHooks[ID_InternetConnectA] = FUN_HOOK(new InternetConnectAFB(
-      "wininet.dll", "InternetConnectA", &InternetConnectA));
-  aHooks[ID_InternetCloseHandle] = FUN_HOOK(new InternetCloseHandleFB(
-      "wininet.dll", "InternetCloseHandle", &InternetCloseHandle));
-  aHooks[ID_InternetQueryDataAvailable] =
-      FUN_HOOK(new InternetQueryDataAvailableFB("wininet.dll",
-                                                "InternetQueryDataAvailable",
-                                                &InternetQueryDataAvailable));
-  aHooks[ID_InternetReadFile] = FUN_HOOK(new InternetReadFileFB(
-      "wininet.dll", "InternetReadFile", &InternetReadFile));
-  aHooks[ID_InternetWriteFile] = FUN_HOOK(new InternetWriteFileFB(
-      "wininet.dll", "InternetWriteFile", &InternetWriteFile));
-  aHooks[ID_InternetSetOptionA] = FUN_HOOK(new InternetSetOptionAFB(
-      "wininet.dll", "InternetSetOptionA", &InternetSetOptionA));
-  aHooks[ID_HttpAddRequestHeadersA] = FUN_HOOK(new HttpAddRequestHeadersAFB(
-      "wininet.dll", "HttpAddRequestHeadersA", &HttpAddRequestHeadersA));
-  aHooks[ID_HttpOpenRequestA] = FUN_HOOK(new HttpOpenRequestAFB(
-      "wininet.dll", "HttpOpenRequestA", &HttpOpenRequestA));
-  aHooks[ID_HttpQueryInfoA] = FUN_HOOK(
-      new HttpQueryInfoAFB("wininet.dll", "HttpQueryInfoA", &HttpQueryInfoA));
-  aHooks[ID_HttpSendRequestA] = FUN_HOOK(new HttpSendRequestAFB(
-      "wininet.dll", "HttpSendRequestA", &HttpSendRequestA));
-  aHooks[ID_HttpSendRequestExA] = FUN_HOOK(new HttpSendRequestExAFB(
-      "wininet.dll", "HttpSendRequestExA", &HttpSendRequestExA));
-  aHooks[ID_HttpEndRequestA] = FUN_HOOK(new HttpEndRequestAFB(
-      "wininet.dll", "HttpEndRequestA", &HttpEndRequestA));
-  aHooks[ID_InternetQueryOptionA] = FUN_HOOK(new InternetQueryOptionAFB(
-      "wininet.dll", "InternetQueryOptionA", &InternetQueryOptionA));
-  aHooks[ID_InternetErrorDlg] = FUN_HOOK(new InternetErrorDlgFB(
-      "wininet.dll", "InternetErrorDlg", InternetErrorDlg));
-  aHooks[ID_AcquireCredentialsHandleA] =
-      FUN_HOOK(new AcquireCredentialsHandleAFB("sspicli.dll",
-                                               "AcquireCredentialsHandleA",
-                                               &AcquireCredentialsHandleA));
-  aHooks[ID_QueryCredentialsAttributesA] =
-      FUN_HOOK(new QueryCredentialsAttributesAFB("sspicli.dll",
-                                                 "QueryCredentialsAttributesA",
-                                                 &QueryCredentialsAttributesA));
-  aHooks[ID_FreeCredentialsHandle] = FUN_HOOK(new FreeCredentialsHandleFB(
-      "sspicli.dll", "FreeCredentialsHandle", &FreeCredentialsHandle));
-  aHooks[ID_CreateMutexW] = FUN_HOOK(
-      new CreateMutexWFB("kernel32.dll", "CreateMutexW", &CreateMutexW));
-#endif  // defined(XP_WIN)
-}
-
-#undef FUN_HOOK
-
-}  // namespace mozilla::plugins
diff --git a/dom/plugins/ipc/FunctionBroker.h b/dom/plugins/ipc/FunctionBroker.h
deleted file mode 100644
index ddbde631e3674..0000000000000
--- a/dom/plugins/ipc/FunctionBroker.h
+++ /dev/null
@@ -1,1452 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef dom_plugins_ipc_PluginHooksWin_h
-#define dom_plugins_ipc_PluginHooksWin_h 1
-
-#include <map>
-#include <algorithm>
-#include <utility>
-#include "base/task.h"
-#include "mozilla/ipc/ProcessChild.h"
-#include "FunctionBrokerChild.h"
-#include "transport/runnable_utils.h"
-#include "PluginMessageUtils.h"
-#include "mozilla/Logging.h"
-#include "FunctionHook.h"
-#include "FunctionBrokerIPCUtils.h"
-
-#if defined(XP_WIN)
-#  define SECURITY_WIN32
-#  include <security.h>
-#  include <wininet.h>
-#  include <schnlsp.h>
-#  if defined(MOZ_SANDBOX)
-#    include "sandboxPermissions.h"
-#  endif
-#endif  // defined(XP_WIN)
-
-/**
- * This functionality supports automatic method hooking (FunctionHook) and
- * brokering (FunctionBroker), which are used to intercept system calls
- * (using the nsDllInterceptor) and replace them with new functionality (hook)
- * or proxy them on another process (broker).
- * There isn't much of a public interface to this (see FunctionHook
- * for initialization functionality) since the majority of the behavior
- * comes from intercepting calls to DLL methods (making those DLL methods the
- * public interface).  Generic RPC can be achieved without DLLs or function
- * interception by directly calling the FunctionBroker::InterceptorStub.
- *
- * The system supports the most common logic surrounding brokering by allowing
- * the client to supply strategies for them.  Some examples of common tasks that
- * are supported by automatic brokering:
- *
- * * Intercepting a new Win32 method:
- *
- * Step 1: Add a typedef or subclass of either FunctionHook (non-brokering) or
- * FunctionBroker (automatic brokering) to FunctionBroker.cpp, using a new
- * FunctionHookID (added to that enum).
- * For example:
- *   typedef FunctionBroker<ID_GetKeyState, decltype(GetKeyState)> GetKeyStateFB
- * Use a subclass instead of a typedef if you need to maintain data or state.
- *
- * Step 2: Add an instance of that object to the FunctionHookList in
- * AddFunctionHook(FunctionHookList&) or
- * AddBrokeredFunctionHook(FunctionHookList&).
- * This typically just means calling the constructor with the correct info.
- * At a minimum, this means supplying the names of the DLL and method to
- * broker, and a pointer to the original version of the method.
- * For example:
- *   aHooks[ID_GetKeyState] =
- *     new GetKeyStateFB("user32.dll", "GetKeyState", &GetKeyState);
- *
- * Step 3: If brokering, make sure the system can (un)marshal the parameters,
- * either by the means below or by adding the type to IpdlTuple, which we use
- * for type-safely (un)marshaling the parameter list.
- *
- * * Only brokering _some_ calls to the method:
- *
- * FunctionBroker's constructor allows the user to supply a ShouldBroker
- * function, which takes the parameters of the method call and returns false
- * if we should use the original method instead of brokering.
- *
- * * Only passing _some_ parameters to the brokering process / returning
- *   parameters to client:
- *
- * If a system call changes a parameter call-by-reference style then the
- * parameter's value needs to be returned to the client.  The FunctionBroker
- * has "phase" (request/response) objects that it uses to determine which
- * parameters are sent/returned.  This example tells InternetWriteFileFB to
- * return its third parameter:
- *   template<> template<>
- *   struct InternetWriteFileFB::Response::Info::ShouldMarshal<3> {
- *     static const bool value = true;
- *   };
- * By default, all parameters have ShouldMarshal set in the request phase
- * and only the return value (parameter -1) has it set in the response phase.
- *
- * * Marshalling special parameter/return types:
- *
- * The IPCTypeMap in FunctionBroker maps a parameter or return type
- * to a type that IpdlTuple knows how to marshal.  By default, the map is
- * the identity but some types need special handling.
- * The map is endpoint-specific (it is a member of the EndpointHandler),
- * so a different type can be used
- * for client -> server and for server -> client.  Note that the
- * types must be able to Copy() from one another -- the default Copy()
- * implementation uses the type's assignment operator.
- * The EndpointHandler itself is a template parameter of the FunctionBroker.
- * The default EndpointHandler recognizes basic types.
- * See e.g. FileDlgEndpointHandler<CLIENT>::IPCTypeMap<LPOPENFILENAMEW>
- * for an example of specialization.
- *
- * * Anything more complex involving parameter transmission:
- *
- * Sometimes marshaling parameters can require something more complex.  In
- * those cases, you will need to specialize the Marshal and Unmarshal
- * methods of the request or response handler and perform your complex logic
- * there.  A wise approach is to map your complex parameters into a simpler
- * parameter list and delegate the Marshal/Unmarshal calls to them.  For
- * example, an API might take a void* and an int as a buffer and length.
- * Obviously a void* cannot generally be marshaled.  However,  we can delegate
- * this call to a parameter list that takes a string in place of the buffer and
- * length.  Something like:
- *
- * typedef RequestHandler<ID_HookedFunc,
- *                        int HOOK_CALL (nsDependentCSubstring)>
- *   HookedFuncDelegateReq;
- *
- * template<>
- * void HookedFuncFB::Request::Marshal(IpdlTuple& aTuple, const void*& aBuf,
- *                                     const int& aBufLen)
- * {
- *   MOZ_ASSERT(nWritten);
- *   HookedFuncDelegateReq::Marshal(aTuple,
- *                                  nsDependentCSubstring(aBuf, aBufLen));
- * }
- *
- * template<>
- * bool HookedFuncFB::Request::Unmarshal(ServerCallData& aScd, const IpdlTuple&
- * aTuple, void*& aBuf, int& aBufLen)
- * {
- *   nsDependentCSubstring str;
- *   if (!HookedFuncDelegateReq::Unmarshal(aScd, aTuple, str)) {
- *     return false;
- *   }
- *
- *   // Request phase unmarshal uses ServerCallData for dynamically-allocating
- *   // memory.
- *   aScd.AllocateString(str, aBuf, false);
- *   aBufLen = str.Length();
- *   return true;
- * }
- *
- * See e.g. InternetWriteFileFB for a complete example of delegation.
- *
- * * Brokering but need the server to do more than just run the function:
- *
- * Specialize the FunctionBroker's RunFunction.  By default, it just runs
- * the function.  See GetSaveFileNameWFB for an example that does more.
- *
- */
-
-#if defined(XP_WIN) && defined(__clang__)
-#  if __has_declspec_attribute(guard)
-// Workaround for https://bugs.llvm.org/show_bug.cgi?id=47617
-// Some of the brokered function thunks don't get properly marked as call
-// targets, so we have to disable CFG when returning to the original function.
-#    define BROKER_DISABLE_CFGUARD __declspec(guard(nocf))
-#  else
-#    define BROKER_DISABLE_CFGUARD /* nothing */
-#  endif
-#else
-#  define BROKER_DISABLE_CFGUARD /* nothing */
-#endif
-
-namespace mozilla {
-namespace plugins {
-
-#if defined(XP_WIN)
-
-// Currently, all methods we hook use the WINAPI calling convention.
-#  define HOOK_CALL WINAPI
-
-typedef std::pair<ULONG_PTR, ULONG_PTR> UlongPair;
-typedef std::map<UlongPair, uint64_t> UlongPairToIdMap;
-extern UlongPairToIdMap sPairToIdMap;
-typedef std::map<uint64_t, UlongPair> IdToUlongPairMap;
-extern IdToUlongPairMap sIdToPairMap;
-typedef std::map<void*, uint64_t> PtrToIdMap;
-extern PtrToIdMap sPtrToIdMap;
-typedef std::map<uint64_t, void*> IdToPtrMap;
-extern IdToPtrMap sIdToPtrMap;
-
-#else  // defined(XP_WIN)
-
-// Any methods we hook use the default calling convention.
-#  define HOOK_CALL
-
-#endif  // defined(XP_WIN)
-
-inline bool IsOdd(uint64_t aVal) { return aVal & 1; }
-
-// This enum is used to track if this process is currently running the client
-// or server side of brokering.
-enum Endpoint { SERVER, CLIENT };
-inline const char* EndpointMsg(Endpoint aVal) {
-  return aVal == SERVER ? "SERVER" : "CLIENT";
-}
-
-template <typename ParamType>
-inline void LogParameterValue(int aIndex, const ParamType& aParam) {
-  // To avoid overhead, don't do this in release.
-#ifdef DEBUG
-  if (!MOZ_LOG_TEST(sPluginHooksLog, LogLevel::Verbose)) {
-    return;
-  }
-  std::wstring paramString;
-  IPC::LogParam(aParam, &paramString);
-  HOOK_LOG(LogLevel::Verbose,
-           ("Parameter %d: %S", aIndex, paramString.c_str()));
-#endif
-}
-
-// This specialization is needed to log the common pattern where null is used
-// as a fixed value for a pointer-type that is unknown to IPC.
-template <typename ParamType>
-inline void LogParameterValue(int aIndex, ParamType* const& aParam) {
-#ifdef DEBUG
-  HOOK_LOG(LogLevel::Verbose,
-           ("Parameter %d: pointer value - %p", aIndex, aParam));
-#endif
-}
-
-template <>
-inline void LogParameterValue(int aIndex, const nsDependentCSubstring& aParam) {
-#ifdef DEBUG
-  HOOK_LOG(LogLevel::Verbose,
-           ("Parameter %d : %s", aIndex, FormatBlob(aParam).Data()));
-#endif
-}
-
-template <>
-inline void LogParameterValue(int aIndex, char* const& aParam) {
-#ifdef DEBUG
-  // A char* can be a block of raw memory.
-  nsDependentCSubstring str;
-  if (aParam) {
-    str.Rebind(const_cast<char*>(aParam),
-               strnlen(aParam, MAX_BLOB_CHARS_TO_LOG));
-  } else {
-    str.SetIsVoid(true);
-  }
-  LogParameterValue(aIndex, str);
-#endif
-}
-
-template <>
-inline void LogParameterValue(int aIndex, const char* const& aParam) {
-#ifdef DEBUG
-  LogParameterValue(aIndex, const_cast<char* const&>(aParam));
-#endif
-}
-
-#if defined(XP_WIN)
-template <>
-inline void LogParameterValue(int aIndex, const SEC_GET_KEY_FN& aParam) {
-#  ifdef DEBUG
-  MOZ_ASSERT(aParam == nullptr);
-  HOOK_LOG(LogLevel::Verbose, ("Parameter %d: null function.", aIndex));
-#  endif
-}
-
-template <>
-inline void LogParameterValue(int aIndex, LPVOID* const& aParam) {
-#  ifdef DEBUG
-  MOZ_ASSERT(aParam == nullptr);
-  HOOK_LOG(LogLevel::Verbose, ("Parameter %d: null void pointer.", aIndex));
-#  endif
-}
-#endif  // defined(XP_WIN)
-
-// Used to check if a fixed parameter value is equal to the parameter given
-// in the original function call.
-template <typename ParamType>
-inline bool ParameterEquality(const ParamType& aParam1,
-                              const ParamType& aParam2) {
-  return aParam1 == aParam2;
-}
-
-// Specialization: char* equality is string equality
-template <>
-inline bool ParameterEquality(char* const& aParam1, char* const& aParam2) {
-  return ((!aParam1 && !aParam2) ||
-          (aParam1 && aParam2 && !strcmp(aParam1, aParam2)));
-}
-
-// Specialization: const char* const equality is string equality
-template <>
-inline bool ParameterEquality(const char* const& aParam1,
-                              const char* const& aParam2) {
-  return ParameterEquality(const_cast<char* const&>(aParam1),
-                           const_cast<char* const&>(aParam2));
-}
-
-/**
- * A type map _from_ the type of a parameter in the original function
- * we are brokering _to_ a type that we can marshal.  We must be able
- * to Copy() the marshaled type using the parameter type.
- * The default maps from type T back to type T.
- */
-template <typename OrigType>
-struct IPCTypeMap {
-  typedef OrigType ipc_type;
-};
-template <>
-struct IPCTypeMap<char*> {
-  typedef nsDependentCSubstring ipc_type;
-};
-template <>
-struct IPCTypeMap<const char*> {
-  typedef nsDependentCSubstring ipc_type;
-};
-template <>
-struct IPCTypeMap<wchar_t*> {
-  typedef nsString ipc_type;
-};
-template <>
-struct IPCTypeMap<const wchar_t*> {
-  typedef nsString ipc_type;
-};
-template <>
-struct IPCTypeMap<long> {
-  typedef int32_t ipc_type;
-};
-template <>
-struct IPCTypeMap<unsigned long> {
-  typedef uint32_t ipc_type;
-};
-
-#if defined(XP_WIN)
-template <>
-struct IPCTypeMap<PSecHandle> {
-  typedef uint64_t ipc_type;
-};
-template <>
-struct IPCTypeMap<PTimeStamp> {
-  typedef uint64_t ipc_type;
-};
-template <>
-struct IPCTypeMap<void*> {
-  typedef uint64_t ipc_type;
-};  // HANDLEs
-template <>
-struct IPCTypeMap<HWND> {
-  typedef NativeWindowHandle ipc_type;
-};
-template <>
-struct IPCTypeMap<PSCHANNEL_CRED> {
-  typedef IPCSchannelCred ipc_type;
-};
-template <>
-struct IPCTypeMap<LPINTERNET_BUFFERSA> {
-  typedef IPCInternetBuffers ipc_type;
-};
-template <>
-struct IPCTypeMap<LPDWORD> {
-  typedef uint32_t ipc_type;
-};
-#endif
-
-template <typename AllocType>
-static void DeleteDestructor(void* aObj) {
-  delete static_cast<AllocType*>(aObj);
-}
-
-extern void FreeDestructor(void* aObj);
-
-// The ServerCallData is a list of ServerCallItems that should be freed when
-// the server has completed a function call and marshaled a response.
-class ServerCallData {
- public:
-  typedef void(DestructorType)(void*);
-
-  // Allocate a certain type.
-  template <typename AllocType>
-  AllocType* Allocate(
-      DestructorType* aDestructor = &DeleteDestructor<AllocType>) {
-    AllocType* ret = new AllocType();
-    mList.AppendElement(FreeItem(ret, aDestructor));
-    return ret;
-  }
-
-  template <typename AllocType>
-  AllocType* Allocate(
-      const AllocType& aValueToCopy,
-      DestructorType* aDestructor = &DeleteDestructor<AllocType>) {
-    AllocType* ret = Allocate<AllocType>(aDestructor);
-    *ret = aValueToCopy;
-    return ret;
-  }
-
-  // Allocate memory, storing the pointer in buf.
-  template <typename PtrType>
-  void AllocateMemory(unsigned long aBufLen, PtrType& aBuf) {
-    if (aBufLen) {
-      aBuf = static_cast<PtrType>(malloc(aBufLen));
-      mList.AppendElement(FreeItem(aBuf, FreeDestructor));
-    } else {
-      aBuf = nullptr;
-    }
-  }
-
-  template <typename PtrType>
-  void AllocateString(const nsACString& aStr, PtrType& aBuf,
-                      bool aCopyNullTerminator = true) {
-    uint32_t nullByte = aCopyNullTerminator ? 1 : 0;
-    char* tempBuf = static_cast<char*>(malloc(aStr.Length() + nullByte));
-    memcpy(tempBuf, aStr.Data(), aStr.Length() + nullByte);
-    mList.AppendElement(FreeItem(tempBuf, FreeDestructor));
-    aBuf = tempBuf;
-  }
-
-  // Run the given destructor on the given memory, for special cases where
-  // memory is allocated elsewhere but must still be freed.
-  void PostDestructor(void* aMem, DestructorType* aDestructor) {
-    mList.AppendElement(FreeItem(aMem, aDestructor));
-  }
-
-#if defined(XP_WIN)
-  // Allocate memory and a DWORD block-length, storing them in the
-  // corresponding parameters.
-  template <typename PtrType>
-  void AllocateMemory(DWORD aBufLen, PtrType& aBuf, LPDWORD& aBufLenCopy) {
-    aBufLenCopy = static_cast<LPDWORD>(malloc(sizeof(DWORD)));
-    *aBufLenCopy = aBufLen;
-    mList.AppendElement(FreeItem(aBufLenCopy, FreeDestructor));
-    AllocateMemory(aBufLen, aBuf);
-  }
-#endif  // defined(XP_WIN)
-
- private:
-  // FreeItems are used to free objects that were temporarily needed for
-  // dispatch, such as buffers that are given as a parameter.
-  class FreeItem {
-    void* mPtr;
-    DestructorType* mDestructor;
-    FreeItem(FreeItem& aOther);  // revoked
-   public:
-    explicit FreeItem(void* aPtr, DestructorType* aDestructor)
-        : mPtr(aPtr), mDestructor(aDestructor) {
-      MOZ_ASSERT(mDestructor || !aPtr);
-    }
-
-    FreeItem(FreeItem&& aOther)
-        : mPtr(aOther.mPtr), mDestructor(aOther.mDestructor) {
-      aOther.mPtr = nullptr;
-      aOther.mDestructor = nullptr;
-    }
-
-    ~FreeItem() {
-      if (mDestructor) {
-        mDestructor(mPtr);
-      }
-    }
-  };
-
-  typedef nsTArray<FreeItem> FreeItemList;
-  FreeItemList mList;
-};
-
-// Holds an IpdlTuple and a ServerCallData.  This is used by the phase handlers
-// (RequestHandler and ResponseHandler) in the Unmarshaling phase.
-// Server-side unmarshaling (during the request phase) uses a ServerCallData
-// to keep track of allocated memory.  In the client, ServerCallDatas are
-// not used and that value will always be null.
-class IpdlTupleContext {
- public:
-  explicit IpdlTupleContext(const IpdlTuple* aTuple,
-                            ServerCallData* aScd = nullptr)
-      : mTuple(aTuple), mScd(aScd) {
-    MOZ_ASSERT(aTuple);
-  }
-
-  ServerCallData* GetServerCallData() { return mScd; }
-  const IpdlTuple* GetIpdlTuple() { return mTuple; }
-
- private:
-  const IpdlTuple* mTuple;
-  ServerCallData* mScd;
-};
-
-template <typename DestType, typename SrcType>
-inline void Copy(DestType& aDest, const SrcType& aSrc) {
-  aDest = (DestType)aSrc;
-}
-
-template <>
-inline void Copy(nsDependentCSubstring& aDest,
-                 const nsDependentCSubstring& aSrc) {
-  if (aSrc.IsVoid()) {
-    aDest.SetIsVoid(true);
-  } else {
-    aDest.Rebind(aSrc.Data(), aSrc.Length());
-  }
-}
-
-#if defined(XP_WIN)
-
-template <>
-inline void Copy(uint64_t& aDest, const PTimeStamp& aSrc) {
-  aDest = static_cast<uint64_t>(aSrc->QuadPart);
-}
-
-template <>
-inline void Copy(PTimeStamp& aDest, const uint64_t& aSrc) {
-  aDest->QuadPart = static_cast<LONGLONG>(aSrc);
-}
-
-#endif  // defined(XP_WIN)
-
-template <Endpoint e, typename SelfType>
-struct BaseEndpointHandler;
-template <typename SelfType>
-struct BaseEndpointHandler<CLIENT, SelfType> {
-  static const Endpoint OtherSide = SERVER;
-
-  template <typename DestType, typename SrcType>
-  inline static void Copy(ServerCallData* aScd, DestType& aDest,
-                          const SrcType& aSrc) {
-    MOZ_ASSERT(!aScd);  // never used in the CLIENT
-    SelfType::Copy(aDest, aSrc);
-  }
-
-  template <typename DestType, typename SrcType>
-  inline static void Copy(DestType& aDest, const SrcType& aSrc) {
-    mozilla::plugins::Copy(aDest, aSrc);
-  }
-
-  // const char* should be null terminated but this is not always the case.
-  // In those cases, we must override this default behavior.
-  inline static void Copy(nsDependentCSubstring& aDest,
-                          const char* const& aSrc) {
-    // In the client, we just bind to the caller's string
-    if (aSrc) {
-      aDest.Rebind(aSrc, strlen(aSrc));
-    } else {
-      aDest.SetIsVoid(true);
-    }
-  }
-
-  inline static void Copy(const char*& aDest,
-                          const nsDependentCSubstring& aSrc) {
-    MOZ_ASSERT_UNREACHABLE("Cannot return const parameters.");
-  }
-
-  inline static void Copy(nsDependentCSubstring& aDest, char* const& aSrc) {
-    // In the client, we just bind to the caller's string
-    if (aSrc) {
-      aDest.Rebind(aSrc, strlen(aSrc));
-    } else {
-      aDest.SetIsVoid(true);
-    }
-  }
-
-  inline static void Copy(nsString& aDest, wchar_t* const& aSrc) {
-    if (aSrc) {
-      // We are using nsString as a "raw" container for a wchar_t string.  We
-      // just use its data as a wchar_t* later (so the reinterpret_cast is
-      // safe).
-      aDest.Rebind(reinterpret_cast<char16_t*>(aSrc), wcslen(aSrc));
-    } else {
-      aDest.SetIsVoid(true);
-    }
-  }
-
-  inline static void Copy(char*& aDest, const nsDependentCSubstring& aSrc) {
-    MOZ_ASSERT_UNREACHABLE("Returning char* parameters is not yet suported.");
-  }
-
-#if defined(XP_WIN)
-  inline static void Copy(uint32_t& aDest, const LPDWORD& aSrc) {
-    aDest = *aSrc;
-  }
-
-  inline static void Copy(LPDWORD& aDest, const uint32_t& aSrc) {
-    *aDest = aSrc;
-  }
-#endif  // #if defined(XP_WIN)
-};
-
-template <typename SelfType>
-struct BaseEndpointHandler<SERVER, SelfType> {
-  static const Endpoint OtherSide = CLIENT;
-
-  // Specializations of this method may allocate memory for types that need it
-  // during Unmarshaling.  They record the allocation in the ServerCallData.
-  // When copying values in the SERVER, we should be sure to carefully validate
-  // the information that came from the client as the client may be compromised
-  // by malicious code.
-  template <typename DestType, typename SrcType>
-  inline static void Copy(ServerCallData* aScd, DestType& aDest,
-                          const SrcType& aSrc) {
-    SelfType::Copy(aDest, aSrc);
-  }
-
-  template <typename DestType, typename SrcType>
-  inline static void Copy(DestType& aDest, const SrcType& aSrc) {
-    mozilla::plugins::Copy(aDest, aSrc);
-  }
-
-  inline static void Copy(nsDependentCSubstring& aDest,
-                          const nsDependentCSubstring& aSrc) {
-    aDest.Rebind(aSrc.Data(), aSrc.Length());
-    aDest.SetIsVoid(aSrc.IsVoid());
-  }
-
-  // const char* should be null terminated but this is not always the case.
-  // In those cases, we override this default behavior.
-  inline static void Copy(nsDependentCSubstring& aDest,
-                          const char* const& aSrc) {
-    MOZ_ASSERT_UNREACHABLE(
-        "Const parameter cannot be returned by brokering process.");
-  }
-
-  inline static void Copy(nsDependentCSubstring& aDest, char* const& aSrc) {
-    MOZ_ASSERT_UNREACHABLE("Returning char* parameters is not yet suported.");
-  }
-
-  inline static void Copy(ServerCallData* aScd, char*& aDest,
-                          const nsDependentCSubstring& aSrc) {
-    // In the parent, we must allocate the string.
-    MOZ_ASSERT(aScd);
-    if (aSrc.IsVoid()) {
-      aDest = nullptr;
-      return;
-    }
-    aScd->AllocateMemory(aSrc.Length() + 1, aDest);
-    memcpy(aDest, aSrc.Data(), aSrc.Length());
-    aDest[aSrc.Length()] = '\0';
-  }
-
-  inline static void Copy(ServerCallData* aScd, const char*& aDest,
-                          const nsDependentCSubstring& aSrc) {
-    char* nonConstDest;
-    Copy(aScd, nonConstDest, aSrc);
-    aDest = nonConstDest;
-  }
-
-  inline static void Copy(ServerCallData* aScd, wchar_t*& aDest,
-                          const nsString& aSrc) {
-    // Allocating the string with aScd means it will last during the server call
-    // and be freed when the call is complete.
-    MOZ_ASSERT(aScd);
-    if (aSrc.IsVoid()) {
-      aDest = nullptr;
-      return;
-    }
-    aScd->AllocateMemory((aSrc.Length() + 1) * sizeof(wchar_t), aDest);
-    memcpy(aDest, aSrc.Data(), aSrc.Length() * sizeof(wchar_t));
-    aDest[aSrc.Length()] = L'\0';
-  }
-
-  inline static void Copy(ServerCallData* aScd, const wchar_t*& aDest,
-                          const nsString& aSrc) {
-    wchar_t* nonConstDest;
-    Copy(aScd, nonConstDest, aSrc);
-    aDest = nonConstDest;
-  }
-
-#if defined(XP_WIN)
-  inline static void Copy(uint32_t& aDest, const LPDWORD& aSrc) {
-    aDest = *aSrc;
-  }
-
-  inline static void Copy(LPDWORD& aDest, const uint32_t& aSrc) {
-    MOZ_RELEASE_ASSERT(aDest);
-    *aDest = aSrc;
-  }
-
-  inline static void Copy(ServerCallData* aScd, PTimeStamp& aDest,
-                          const uint64_t& aSrc) {
-    MOZ_ASSERT(!aDest);
-    aDest = aScd->Allocate<::TimeStamp>();
-    Copy(aDest, aSrc);
-  }
-#endif  // defined(XP_WIN)
-};
-
-// PhaseHandler is a RequestHandler or a ResponseHandler.
-template <Endpoint endpoint, typename PhaseHandler>
-struct Marshaler {
-  // Driver
-  template <int firstIndex = 0, typename... VarParams>
-  static void Marshal(IpdlTuple& aMarshaledTuple, const VarParams&... aParams) {
-    MarshalParameters<firstIndex>(aMarshaledTuple, aParams...);
-  }
-
-  // Driver
-  template <int firstIndex = 0, typename... VarParams>
-  static bool Unmarshal(IpdlTupleContext& aUnmarshaledTuple,
-                        VarParams&... aParams) {
-    return UnmarshalParameters<firstIndex>(aUnmarshaledTuple, 0, aParams...);
-  }
-
-  template <int paramIndex, typename OrigType,
-            bool shouldMarshal =
-                PhaseHandler::Info::template ShouldMarshal<paramIndex>::value>
-  struct MaybeMarshalParameter {};
-
-  /**
-   * shouldMarshal = true case
-   */
-  template <int paramIndex, typename OrigType>
-  struct MaybeMarshalParameter<paramIndex, OrigType, true> {
-    template <typename IPCType = typename PhaseHandler::template IPCTypeMap<
-                  OrigType>::ipc_type>
-    static void MarshalParameter(IpdlTuple& aMarshaledTuple,
-                                 const OrigType& aParam) {
-      HOOK_LOG(LogLevel::Verbose, ("%s marshaling parameter %d.",
-                                   EndpointMsg(endpoint), paramIndex));
-      IPCType ipcObject;
-      // EndpointHandler must be able to Copy() from OrigType to IPCType
-      PhaseHandler::EHContainer::template EndpointHandler<endpoint>::Copy(
-          ipcObject, aParam);
-      LogParameterValue(paramIndex, ipcObject);
-      aMarshaledTuple.AddElement(ipcObject);
-    }
-  };
-
-  /**
-   * shouldMarshal = false case
-   */
-  template <int paramIndex, typename OrigType>
-  struct MaybeMarshalParameter<paramIndex, OrigType, false> {
-    static void MarshalParameter(IpdlTuple& aMarshaledTuple,
-                                 const OrigType& aParam) {
-      HOOK_LOG(LogLevel::Verbose, ("%s not marshaling parameter %d.",
-                                   EndpointMsg(endpoint), paramIndex));
-    }
-  };
-
-  /**
-   * Recursive case: marshals aFirstParam to aMarshaledTuple (if desired),
-   * then marshals the aRemainingParams.
-   */
-  template <int paramIndex, typename VarParam, typename... VarParams>
-  static void MarshalParameters(IpdlTuple& aMarshaledTuple,
-                                const VarParam& aFirstParam,
-                                const VarParams&... aRemainingParams) {
-    MaybeMarshalParameter<paramIndex, VarParam>::MarshalParameter(
-        aMarshaledTuple, aFirstParam);
-    MarshalParameters<paramIndex + 1, VarParams...>(aMarshaledTuple,
-                                                    aRemainingParams...);
-  }
-
-  /**
-   * Base case: empty parameter list -- nothing to marshal.
-   */
-  template <int paramIndex>
-  static void MarshalParameters(IpdlTuple& aMarshaledTuple) {}
-
-  template <int tupleIndex, typename OrigType,
-            bool shouldMarshal =
-                PhaseHandler::Info::template ShouldMarshal<tupleIndex>::value,
-            bool hasFixedValue =
-                PhaseHandler::Info::template HasFixedValue<tupleIndex>::value>
-  struct MaybeUnmarshalParameter {};
-
-  /**
-   * ShouldMarshal = true case.  HasFixedValue must be false in that case.
-   */
-  template <int tupleIndex, typename VarParam>
-  struct MaybeUnmarshalParameter<tupleIndex, VarParam, true, false> {
-    template <typename IPCType = typename PhaseHandler::template IPCTypeMap<
-                  VarParam>::ipc_type>
-    static inline bool UnmarshalParameter(IpdlTupleContext& aUnmarshaledTuple,
-                                          int& aNextTupleIdx,
-                                          VarParam& aParam) {
-      const IPCType* ipcObject =
-          aUnmarshaledTuple.GetIpdlTuple()->Element<IPCType>(aNextTupleIdx);
-      if (!ipcObject) {
-        HOOK_LOG(LogLevel::Error, ("%s failed to unmarshal parameter %d.",
-                                   EndpointMsg(endpoint), tupleIndex));
-        return false;
-      }
-      HOOK_LOG(LogLevel::Verbose, ("%s unmarshaled parameter %d.",
-                                   EndpointMsg(endpoint), tupleIndex));
-      LogParameterValue(tupleIndex, *ipcObject);
-      PhaseHandler::EHContainer::template EndpointHandler<endpoint>::Copy(
-          aUnmarshaledTuple.GetServerCallData(), aParam, *ipcObject);
-      ++aNextTupleIdx;
-      return true;
-    }
-  };
-
-  /**
-   * ShouldMarshal = true : nsDependentCSubstring specialization
-   */
-  template <int tupleIndex>
-  struct MaybeUnmarshalParameter<tupleIndex, nsDependentCSubstring, true,
-                                 false> {
-    static inline bool UnmarshalParameter(IpdlTupleContext& aUnmarshaledTuple,
-                                          int& aNextTupleIdx,
-                                          nsDependentCSubstring& aParam) {
-      // Deserialize as an nsCString and then copy the info into the
-      // nsDependentCSubstring
-      const nsCString* ipcObject =
-          aUnmarshaledTuple.GetIpdlTuple()->Element<nsCString>(aNextTupleIdx);
-      if (!ipcObject) {
-        HOOK_LOG(LogLevel::Error, ("%s failed to unmarshal parameter %d.",
-                                   EndpointMsg(endpoint), tupleIndex));
-        return false;
-      }
-      HOOK_LOG(LogLevel::Verbose, ("%s unmarshaled parameter %d.",
-                                   EndpointMsg(endpoint), tupleIndex));
-
-      aParam.Rebind(ipcObject->Data(), ipcObject->Length());
-      aParam.SetIsVoid(ipcObject->IsVoid());
-      LogParameterValue(tupleIndex, aParam);
-      ++aNextTupleIdx;
-      return true;
-    }
-  };
-
-  /**
-   * ShouldMarshal = true : char* specialization
-   */
-  template <int tupleIndex>
-  struct MaybeUnmarshalParameter<tupleIndex, char*, true, false> {
-    static inline bool UnmarshalParameter(IpdlTupleContext& aUnmarshaledTuple,
-                                          int& aNextTupleIdx, char*& aParam) {
-      nsDependentCSubstring tempStr;
-      bool ret =
-          MaybeUnmarshalParameter<tupleIndex, nsDependentCSubstring, true,
-                                  false>::UnmarshalParameter(aUnmarshaledTuple,
-                                                             aNextTupleIdx,
-                                                             tempStr);
-      PhaseHandler::EHContainer::template EndpointHandler<endpoint>::Copy(
-          aUnmarshaledTuple.GetServerCallData(), aParam, tempStr);
-      return ret;
-    }
-  };
-
-  /**
-   * ShouldMarshal = true : const char* specialization
-   */
-  template <int tupleIndex>
-  struct MaybeUnmarshalParameter<tupleIndex, const char*, true, false> {
-    static inline bool UnmarshalParameter(IpdlTupleContext& aUnmarshaledTuple,
-                                          int& aNextTupleIdx,
-                                          const char*& aParam) {
-      char* tempStr;
-      bool ret =
-          MaybeUnmarshalParameter<tupleIndex, char*, true,
-                                  false>::UnmarshalParameter(aUnmarshaledTuple,
-                                                             aNextTupleIdx,
-                                                             tempStr);
-      aParam = tempStr;
-      return ret;
-    }
-  };
-
-  /**
-   * ShouldMarshal = false, fixed parameter case
-   */
-  template <int tupleIndex, typename VarParam>
-  struct MaybeUnmarshalParameter<tupleIndex, VarParam, false, true> {
-    static inline bool UnmarshalParameter(IpdlTupleContext& aUnmarshaledTuple,
-                                          int& aNextTupleIdx,
-                                          VarParam& aParam) {
-      // Copy default value if this is client->server communication (and if it
-      // exists)
-      PhaseHandler::template CopyFixedParam<tupleIndex, VarParam>(aParam);
-      HOOK_LOG(LogLevel::Verbose,
-               ("%s parameter %d not unmarshaling -- using fixed value.",
-                EndpointMsg(endpoint), tupleIndex));
-      LogParameterValue(tupleIndex, aParam);
-      return true;
-    }
-  };
-
-  /**
-   * ShouldMarshal = false, unfixed parameter case.  Assume user has done
-   * special handling.
-   */
-  template <int tupleIndex, typename VarParam>
-  struct MaybeUnmarshalParameter<tupleIndex, VarParam, false, false> {
-    static inline bool UnmarshalParameter(IpdlTupleContext& aUnmarshaledTuple,
-                                          int& aNextTupleIdx,
-                                          VarParam& aParam) {
-      HOOK_LOG(LogLevel::Verbose,
-               ("%s parameter %d not automatically unmarshaling.",
-                EndpointMsg(endpoint), tupleIndex));
-      // DLP: TODO: specializations fail LogParameterValue(tupleIndex, aParam);
-      return true;
-    }
-  };
-
-  /**
-   * Recursive case: unmarshals aFirstParam to aUnmarshaledTuple (if desired),
-   * then unmarshals the aRemainingParams.
-   * The endpoint specifies the side this process is on: client or server.
-   */
-  template <int tupleIndex, typename VarParam, typename... VarParams>
-  static bool UnmarshalParameters(IpdlTupleContext& aUnmarshaledTuple,
-                                  int aNextTupleIdx, VarParam& aFirstParam,
-                                  VarParams&... aRemainingParams) {
-    // TODO: DLP: I currently increment aNextTupleIdx in the method (its a
-    // reference).  This is awful.
-    if (!MaybeUnmarshalParameter<tupleIndex, VarParam>::UnmarshalParameter(
-            aUnmarshaledTuple, aNextTupleIdx, aFirstParam)) {
-      return false;
-    }
-    return UnmarshalParameters<tupleIndex + 1, VarParams...>(
-        aUnmarshaledTuple, aNextTupleIdx, aRemainingParams...);
-  }
-
-  /**
-   * Base case: empty parameter list -- nothing to unmarshal.
-   */
-  template <int>
-  static bool UnmarshalParameters(IpdlTupleContext& aUnmarshaledTuple,
-                                  int aNextTupleIdx) {
-    return true;
-  }
-};
-
-// The default marshals all parameters.
-template <FunctionHookId functionId>
-struct RequestInfo {
-  template <int paramIndex>
-  struct FixedValue;
-
-  template <int paramIndex, typename = int>
-  struct HasFixedValue {
-    static const bool value = false;
-  };
-  template <int paramIndex>
-  struct HasFixedValue<paramIndex, decltype(FixedValue<paramIndex>::value, 0)> {
-    static const bool value = true;
-  };
-
-  // By default we the request should marshal any non-fixed parameters.
-  template <int paramIndex>
-  struct ShouldMarshal {
-    static const bool value = !HasFixedValue<paramIndex>::value;
-  };
-};
-
-/**
- * This base stores the RequestHandler's IPCTypeMap.  It really only
- * exists to circumvent the arbitrary C++ rule (enforced by mingw) forbidding
- * full class specialization of a class (IPCTypeMap<T>) inside of an
- * unspecialized template class (RequestHandler<T>).
- */
-struct RequestHandlerBase {
-  // Default to the namespace-level IPCTypeMap
-  template <typename OrigType>
-  struct IPCTypeMap {
-    typedef typename mozilla::plugins::IPCTypeMap<OrigType>::ipc_type ipc_type;
-  };
-};
-
-#if defined(XP_WIN)
-
-// Request phase uses OpenFileNameIPC for an LPOPENFILENAMEW parameter.
-template <>
-struct RequestHandlerBase::IPCTypeMap<LPOPENFILENAMEW> {
-  typedef OpenFileNameIPC ipc_type;
-};
-
-#endif  // defined(XP_WIN)
-
-struct BaseEHContainer {
-  template <Endpoint e>
-  struct EndpointHandler : public BaseEndpointHandler<e, EndpointHandler<e>> {};
-};
-
-template <FunctionHookId functionId, typename FunctionType,
-          typename EHContainer>
-struct RequestHandler;
-
-template <FunctionHookId functionId, typename EHContainerType,
-          typename ResultType, typename... ParamTypes>
-struct RequestHandler<functionId, ResultType HOOK_CALL(ParamTypes...),
-                      EHContainerType> : public RequestHandlerBase {
-  typedef ResultType(HOOK_CALL FunctionType)(ParamTypes...);
-  typedef RequestHandler<functionId, FunctionType, EHContainerType> SelfType;
-  typedef RequestInfo<functionId> Info;
-  typedef EHContainerType EHContainer;
-
-  static void Marshal(IpdlTuple& aTuple, const ParamTypes&... aParams) {
-    ReqMarshaler::Marshal(aTuple, aParams...);
-  }
-
-  static bool Unmarshal(ServerCallData& aScd, const IpdlTuple& aTuple,
-                        ParamTypes&... aParams) {
-    IpdlTupleContext cxt(&aTuple, &aScd);
-    return ReqUnmarshaler::Unmarshal(cxt, aParams...);
-  }
-
-  typedef Marshaler<CLIENT, SelfType> ReqMarshaler;
-  typedef Marshaler<SERVER, SelfType> ReqUnmarshaler;
-
-  /**
-   * Returns true if a call made with the given parameters should be
-   * brokered (vs. passed-through to the original function).
-   */
-  static bool ShouldBroker(Endpoint aEndpoint, const ParamTypes&... aParams) {
-    // True if all filtered parameters match their filter value.
-    return CheckFixedParams(aParams...);
-  }
-
-  template <int paramIndex, typename VarParam>
-  static void CopyFixedParam(VarParam& aParam) {
-    aParam = Info::template FixedValue<paramIndex>::value;
-  }
-
- protected:
-  // Returns true if filtered parameters match their filter value.
-  static bool CheckFixedParams(const ParamTypes&... aParams) {
-    return CheckFixedParamsHelper<0>(aParams...);
-  }
-
-  // If no FixedValue<paramIndex> is defined and equal to FixedType then always
-  // pass.
-  template <int paramIndex, typename = int>
-  struct CheckFixedParam {
-    template <typename ParamType>
-    static inline bool Check(const ParamType& aParam) {
-      return true;
-    }
-  };
-
-  // If FixedValue<paramIndex> is defined then check equality.
-  template <int paramIndex>
-  struct CheckFixedParam<
-      paramIndex, decltype(Info::template FixedValue<paramIndex>::value, 0)> {
-    template <typename ParamType>
-    static inline bool Check(ParamType& aParam) {
-      return ParameterEquality(aParam,
-                               Info::template FixedValue<paramIndex>::value);
-    }
-  };
-
-  // Recursive case: Chcek head parameter, then tail parameters.
-  template <int index, typename VarParam, typename... VarParams>
-  static bool CheckFixedParamsHelper(const VarParam& aParam,
-                                     const VarParams&... aParams) {
-    if (!CheckFixedParam<index>::Check(aParam)) {
-      return false;  // didn't match a fixed parameter
-    }
-    return CheckFixedParamsHelper<index + 1>(aParams...);
-  }
-
-  // Base case: All fixed parameters matched.
-  template <int>
-  static bool CheckFixedParamsHelper() {
-    return true;
-  }
-};
-
-// The default returns no parameters -- only the return value.
-template <FunctionHookId functionId>
-struct ResponseInfo {
-  template <int paramIndex>
-  struct HasFixedValue {
-    static const bool value =
-        RequestInfo<functionId>::template HasFixedValue<paramIndex>::value;
-  };
-
-  // Only the return value (index -1) is sent by default.
-  template <int paramIndex>
-  struct ShouldMarshal {
-    static const bool value = (paramIndex == -1);
-  };
-
-  // This is the condition on the function result that we use to determine if
-  // the windows thread-local error state should be sent to the client.  The
-  // error is typically only relevant if the function did not succeed.
-  template <typename ResultType>
-  static bool ShouldTransmitError(const ResultType& aResult) {
-    return !static_cast<bool>(aResult);
-  }
-};
-
-/**
- * Same rationale as for RequestHandlerBase.
- */
-struct ResponseHandlerBase {
-  // Default to the namespace-level IPCTypeMap
-  template <typename OrigType>
-  struct IPCTypeMap {
-    typedef typename mozilla::plugins::IPCTypeMap<OrigType>::ipc_type ipc_type;
-  };
-};
-
-#if defined(XP_WIN)
-
-// Response phase uses OpenFileNameRetIPC for an LPOPENFILENAMEW parameter.
-template <>
-struct ResponseHandlerBase::IPCTypeMap<LPOPENFILENAMEW> {
-  typedef OpenFileNameRetIPC ipc_type;
-};
-
-#endif
-
-template <FunctionHookId functionId, typename FunctionType,
-          typename EHContainer>
-struct ResponseHandler;
-
-template <FunctionHookId functionId, typename EHContainerType,
-          typename ResultType, typename... ParamTypes>
-struct ResponseHandler<functionId, ResultType HOOK_CALL(ParamTypes...),
-                       EHContainerType> : public ResponseHandlerBase {
-  typedef ResultType(HOOK_CALL FunctionType)(ParamTypes...);
-  typedef ResponseHandler<functionId, FunctionType, EHContainerType> SelfType;
-  typedef ResponseInfo<functionId> Info;
-  typedef EHContainerType EHContainer;
-
-  static void Marshal(IpdlTuple& aTuple, const ResultType& aResult,
-                      const ParamTypes&... aParams) {
-    // Note that this "trick" means that the first parameter we marshal is
-    // considered to be parameter #-1 when checking the ResponseInfo.
-    // The parameters in the list therefore start at index 0.
-    RspMarshaler::template Marshal<-1>(aTuple, aResult, aParams...);
-  }
-  static bool Unmarshal(const IpdlTuple& aTuple, ResultType& aResult,
-                        ParamTypes&... aParams) {
-    IpdlTupleContext cxt(&aTuple);
-    return RspUnmarshaler::template Unmarshal<-1>(cxt, aResult, aParams...);
-  }
-
-  typedef Marshaler<SERVER, SelfType> RspMarshaler;
-  typedef Marshaler<CLIENT, SelfType> RspUnmarshaler;
-
-  // Fixed parameters are not used in the response phase.
-  template <int tupleIndex, typename VarParam>
-  static void CopyFixedParam(VarParam& aParam) {}
-};
-
-/**
- * Reference-counted monitor, used to synchronize communication between a
- * thread using a brokered API and the FunctionDispatch thread.
- */
-class FDMonitor : public Monitor {
- public:
-  FDMonitor() : Monitor("FunctionDispatchThread lock") {}
-
-  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(FDMonitor)
-
- private:
-  ~FDMonitor() = default;
-};
-
-/**
- * Data for hooking a function that we automatically broker in a remote
- * process.
- */
-template <FunctionHookId functionId, typename FunctionType,
-          typename EHContainer = BaseEHContainer>
-class FunctionBroker;
-
-template <FunctionHookId functionId, typename EHContainer, typename ResultType,
-          typename... ParamTypes>
-class FunctionBroker<functionId, ResultType HOOK_CALL(ParamTypes...),
-                     EHContainer>
-    : public BasicFunctionHook<functionId,
-                               ResultType HOOK_CALL(ParamTypes...)> {
- public:
-  typedef Tuple<ParamTypes...> TupleParamTypes;
-  typedef Tuple<mozilla::Maybe<ParamTypes>...> TupleMaybeParamTypes;
-  typedef Tuple<ParamTypes*...> TupleParamPtrTypes;
-  typedef Tuple<ParamTypes&...> TupleParamRefTypes;
-  static const size_t numParams = sizeof...(ParamTypes);
-
-  typedef ResultType(HOOK_CALL FunctionType)(ParamTypes...);
-  typedef FunctionBroker<functionId, FunctionType, EHContainer> SelfType;
-  typedef BasicFunctionHook<functionId, FunctionType> FunctionHookInfoType;
-  typedef FunctionHookInfoType BaseType;
-
-  typedef RequestHandler<functionId, FunctionType, EHContainer> Request;
-  typedef ResponseHandler<functionId, FunctionType, EHContainer> Response;
-
-  template <typename DelegateFcnType>
-  using RequestDelegate =
-      RequestHandler<functionId, DelegateFcnType, EHContainer>;
-  template <typename DelegateFcnType>
-  using ResponseDelegate =
-      ResponseHandler<functionId, DelegateFcnType, EHContainer>;
-
-  FunctionBroker(const char* aModuleName, const char* aMethodName,
-                 FunctionType* aOriginalFunction)
-      : BasicFunctionHook<functionId, FunctionType>(
-            aModuleName, aMethodName, aOriginalFunction, InterceptorStub) {}
-
-  // This is the function used to replace the original DLL-intercepted function.
-  static ResultType HOOK_CALL InterceptorStub(ParamTypes... aParams) {
-    MOZ_ASSERT(functionId < FunctionHook::GetHooks()->Length());
-    FunctionHook* self = FunctionHook::GetHooks()->ElementAt(functionId);
-    MOZ_ASSERT(self && self->FunctionId() == functionId);
-    const SelfType* broker = static_cast<const SelfType*>(self);
-    return broker->MaybeBrokerCallClient(aParams...);
-  }
-
-  /**
-   * Handle a call by running the original version or brokering, depending on
-   * ShouldBroker.  All parameter types (including the result type)
-   * must have IPDL ParamTraits specializations or appear in this object's
-   * IPCTypeMap.  If brokering fails for any reason then this falls back to
-   * calling the original version of the function.
-   */
-  ResultType MaybeBrokerCallClient(ParamTypes&... aParameters) const;
-
-  /**
-   * Called server-side to run the original function using aInTuple
-   * as parameter values.  The return value and returned parameters
-   * (in that order) are added to aOutTuple.
-   */
-  bool RunOriginalFunction(base::ProcessId aClientId,
-                           const IPC::IpdlTuple& aInTuple,
-                           IPC::IpdlTuple* aOutTuple) const override {
-    return BrokerCallServer(aClientId, aInTuple, aOutTuple);
-  }
-
- protected:
-  bool BrokerCallServer(base::ProcessId aClientId, const IpdlTuple& aInTuple,
-                        IpdlTuple* aOutTuple) const {
-    return BrokerCallServer(aClientId, aInTuple, aOutTuple,
-                            std::index_sequence_for<ParamTypes...>{});
-  }
-
-  bool BrokerCallClient(uint32_t& aWinError, ResultType& aResult,
-                        ParamTypes&... aParameters) const;
-  bool PostToDispatchThread(uint32_t& aWinError, ResultType& aRet,
-                            ParamTypes&... aParameters) const;
-
-  static void PostToDispatchHelper(const SelfType* bmhi,
-                                   RefPtr<FDMonitor> monitor, bool* notified,
-                                   bool* ok, uint32_t* winErr, ResultType* r,
-                                   ParamTypes*... p) {
-    // Note: p is also non-null... its just hard to assert that.
-    MOZ_ASSERT(bmhi && monitor && notified && ok && winErr && r);
-    MOZ_ASSERT(*notified == false);
-    *ok = bmhi->BrokerCallClient(*winErr, *r, *p...);
-
-    {
-      // We need to grab the lock to make sure that Wait() has been
-      // called in PostToDispatchThread.  We need that since we wake it with
-      // Notify().
-      MonitorAutoLock lock(*monitor);
-      *notified = true;
-    }
-
-    monitor->Notify();
-  };
-
-  template <typename... VarParams>
-  BROKER_DISABLE_CFGUARD ResultType RunFunction(FunctionType* aFunction,
-                                                base::ProcessId aClientId,
-                                                VarParams&... aParams) const {
-    return aFunction(aParams...);
-  };
-
-  bool BrokerCallServer(base::ProcessId aClientId, const IpdlTuple& aInTuple,
-                        IpdlTuple* aOutTuple, ParamTypes&... aParams) const;
-
-  template <size_t... Indices>
-  bool BrokerCallServer(base::ProcessId aClientId, const IpdlTuple& aInTuple,
-                        IpdlTuple* aOutTuple,
-                        std::index_sequence<Indices...>) const {
-    TupleParamTypes paramTuple;
-    return BrokerCallServer(aClientId, aInTuple, aOutTuple,
-                            Get<Indices>(paramTuple)...);
-  }
-};
-
-template <FunctionHookId functionId, typename EHContainer, typename ResultType,
-          typename... ParamTypes>
-ResultType FunctionBroker<
-    functionId, ResultType HOOK_CALL(ParamTypes...),
-    EHContainer>::MaybeBrokerCallClient(ParamTypes&... aParameters) const {
-  MOZ_ASSERT(FunctionBrokerChild::GetInstance());
-
-  // Broker the call if ShouldBroker says to.  Otherwise, or if brokering
-  // fails, then call the original implementation.
-  if (!FunctionBrokerChild::GetInstance()) {
-    HOOK_LOG(LogLevel::Error,
-             ("[%s] Client attempted to broker call without actor.",
-              FunctionHookInfoType::mFunctionName.Data()));
-  } else if (Request::ShouldBroker(CLIENT, aParameters...)) {
-    HOOK_LOG(LogLevel::Debug, ("[%s] Client attempting to broker call.",
-                               FunctionHookInfoType::mFunctionName.Data()));
-    uint32_t winError;
-    ResultType ret;
-    bool success = BrokerCallClient(winError, ret, aParameters...);
-    HOOK_LOG(LogLevel::Info,
-             ("[%s] Client brokering %s.",
-              FunctionHookInfoType::mFunctionName.Data(), SuccessMsg(success)));
-    if (success) {
-#if defined(XP_WIN)
-      if (Response::Info::ShouldTransmitError(ret)) {
-        HOOK_LOG(LogLevel::Debug,
-                 ("[%s] Client setting thread error code: %08x.",
-                  FunctionHookInfoType::mFunctionName.Data(), winError));
-        ::SetLastError(winError);
-      }
-#endif
-      return ret;
-    }
-  }
-
-  HOOK_LOG(LogLevel::Info,
-           ("[%s] Client could not broker.  Running original version.",
-            FunctionHookInfoType::mFunctionName.Data()));
-  return FunctionHookInfoType::mOldFunction(aParameters...);
-}
-
-template <FunctionHookId functionId, typename EHContainer, typename ResultType,
-          typename... ParamTypes>
-bool FunctionBroker<functionId, ResultType HOOK_CALL(ParamTypes...),
-                    EHContainer>::BrokerCallClient(uint32_t& aWinError,
-                                                   ResultType& aResult,
-                                                   ParamTypes&... aParameters)
-    const {
-  if (!FunctionBrokerChild::GetInstance()->IsDispatchThread()) {
-    return PostToDispatchThread(aWinError, aResult, aParameters...);
-  }
-
-  if (FunctionBrokerChild::GetInstance()) {
-    IpdlTuple sending, returned;
-    HOOK_LOG(LogLevel::Debug, ("[%s] Client marshaling parameters.",
-                               FunctionHookInfoType::mFunctionName.Data()));
-    Request::Marshal(sending, aParameters...);
-    HOOK_LOG(LogLevel::Info, ("[%s] Client sending broker message.",
-                              FunctionHookInfoType::mFunctionName.Data()));
-    if (FunctionBrokerChild::GetInstance()->SendBrokerFunction(
-            FunctionHookInfoType::FunctionId(), sending, &returned)) {
-      HOOK_LOG(LogLevel::Debug,
-               ("[%s] Client received broker message response.",
-                FunctionHookInfoType::mFunctionName.Data()));
-      bool success = Response::Unmarshal(returned, aResult, aParameters...);
-      HOOK_LOG(LogLevel::Info, ("[%s] Client response unmarshaling: %s.",
-                                FunctionHookInfoType::mFunctionName.Data(),
-                                SuccessMsg(success)));
-#if defined(XP_WIN)
-      if (success && Response::Info::ShouldTransmitError(aResult)) {
-        uint32_t* winError =
-            returned.Element<UINT32>(returned.NumElements() - 1);
-        if (!winError) {
-          HOOK_LOG(LogLevel::Error,
-                   ("[%s] Client failed to unmarshal error code.",
-                    FunctionHookInfoType::mFunctionName.Data()));
-          return false;
-        }
-        HOOK_LOG(LogLevel::Debug,
-                 ("[%s] Client response unmarshaled error code: %08x.",
-                  FunctionHookInfoType::mFunctionName.Data(), *winError));
-        aWinError = *winError;
-      }
-#endif
-      return success;
-    }
-  }
-
-  HOOK_LOG(LogLevel::Error, ("[%s] Client failed to broker call.",
-                             FunctionHookInfoType::mFunctionName.Data()));
-  return false;
-}
-
-template <FunctionHookId functionId, typename EHContainer, typename ResultType,
-          typename... ParamTypes>
-bool FunctionBroker<functionId, ResultType HOOK_CALL(ParamTypes...),
-                    EHContainer>::BrokerCallServer(base::ProcessId aClientId,
-                                                   const IpdlTuple& aInTuple,
-                                                   IpdlTuple* aOutTuple,
-                                                   ParamTypes&... aParams)
-    const {
-  HOOK_LOG(LogLevel::Info, ("[%s] Server brokering function.",
-                            FunctionHookInfoType::mFunctionName.Data()));
-
-  ServerCallData scd;
-  if (!Request::Unmarshal(scd, aInTuple, aParams...)) {
-    HOOK_LOG(LogLevel::Info, ("[%s] Server failed to unmarshal.",
-                              FunctionHookInfoType::mFunctionName.Data()));
-    return false;
-  }
-
-  // Make sure that this call was legal -- do not execute a call that
-  // shouldn't have been brokered in the first place.
-  if (!Request::ShouldBroker(SERVER, aParams...)) {
-    HOOK_LOG(LogLevel::Error, ("[%s] Server rejected brokering request.",
-                               FunctionHookInfoType::mFunctionName.Data()));
-    return false;
-  }
-
-  // Run the function we are brokering.
-  HOOK_LOG(LogLevel::Info, ("[%s] Server broker running function.",
-                            FunctionHookInfoType::mFunctionName.Data()));
-  ResultType ret =
-      RunFunction(FunctionHookInfoType::mOldFunction, aClientId, aParams...);
-
-#if defined(XP_WIN)
-  // Record the thread-local error state (before it is changed) if needed.
-  uint32_t err = UINT_MAX;
-  bool transmitError = Response::Info::ShouldTransmitError(ret);
-  if (transmitError) {
-    err = ::GetLastError();
-    HOOK_LOG(LogLevel::Info, ("[%s] Server returning thread error code: %08x.",
-                              FunctionHookInfoType::mFunctionName.Data(), err));
-  }
-#endif
-
-  // Add the result, win thread error and any returned parameters to the
-  // returned tuple.
-  Response::Marshal(*aOutTuple, ret, aParams...);
-#if defined(XP_WIN)
-  if (transmitError) {
-    aOutTuple->AddElement(err);
-  }
-#endif
-
-  return true;
-}
-
-template <FunctionHookId functionId, typename EHContainer, typename ResultType,
-          typename... ParamTypes>
-bool FunctionBroker<
-    functionId, ResultType HOOK_CALL(ParamTypes...),
-    EHContainer>::PostToDispatchThread(uint32_t& aWinError, ResultType& aRet,
-                                       ParamTypes&... aParameters) const {
-  MOZ_ASSERT(!FunctionBrokerChild::GetInstance()->IsDispatchThread());
-  HOOK_LOG(LogLevel::Debug, ("Posting broker task '%s' to dispatch thread",
-                             FunctionHookInfoType::mFunctionName.Data()));
-
-  // Run PostToDispatchHelper on the dispatch thread.  It will notify our
-  // waiting monitor when it is done.
-  RefPtr<FDMonitor> monitor(new FDMonitor());
-  MonitorAutoLock lock(*monitor);
-  bool success = false;
-  bool notified = false;
-  FunctionBrokerChild::GetInstance()->PostToDispatchThread(NewRunnableFunction(
-      "FunctionDispatchThreadRunnable", &PostToDispatchHelper, this, monitor,
-      &notified, &success, &aWinError, &aRet, &aParameters...));
-
-  // We wait to be notified, testing that notified was actually set to make
-  // sure this isn't a spurious wakeup.
-  while (!notified) {
-    monitor->Wait();
-  }
-  return success;
-}
-
-void AddBrokeredFunctionHooks(FunctionHookArray& aHooks);
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // dom_plugins_ipc_PluginHooksWin_h
diff --git a/dom/plugins/ipc/FunctionBrokerChild.cpp b/dom/plugins/ipc/FunctionBrokerChild.cpp
deleted file mode 100644
index a0780d853f366..0000000000000
--- a/dom/plugins/ipc/FunctionBrokerChild.cpp
+++ /dev/null
@@ -1,111 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "FunctionBrokerChild.h"
-#include "FunctionBrokerThread.h"
-
-#include "mozilla/ipc/Endpoint.h"
-
-namespace mozilla::plugins {
-
-FunctionBrokerChild* FunctionBrokerChild::sInstance = nullptr;
-
-bool FunctionBrokerChild::IsDispatchThread() { return mThread->IsOnThread(); }
-
-void FunctionBrokerChild::PostToDispatchThread(
-    already_AddRefed<nsIRunnable>&& runnable) {
-  mThread->Dispatch(std::move(runnable));
-}
-
-/* static */
-bool FunctionBrokerChild::Initialize(
-    Endpoint<PFunctionBrokerChild>&& aBrokerEndpoint) {
-  MOZ_RELEASE_ASSERT(
-      XRE_IsPluginProcess(),
-      "FunctionBrokerChild can only be used in plugin processes");
-
-  MOZ_ASSERT(!sInstance);
-  FunctionBrokerThread* thread = FunctionBrokerThread::Create();
-  if (!thread) {
-    return false;
-  }
-  sInstance = new FunctionBrokerChild(thread, std::move(aBrokerEndpoint));
-  return true;
-}
-
-/* static */
-FunctionBrokerChild* FunctionBrokerChild::GetInstance() {
-  MOZ_RELEASE_ASSERT(
-      XRE_IsPluginProcess(),
-      "FunctionBrokerChild can only be used in plugin processes");
-
-  MOZ_ASSERT(sInstance, "Must initialize FunctionBrokerChild before using it");
-  return sInstance;
-}
-
-FunctionBrokerChild::FunctionBrokerChild(
-    FunctionBrokerThread* aThread, Endpoint<PFunctionBrokerChild>&& aEndpoint)
-    : mThread(aThread),
-      mShutdownDone(false),
-      mMonitor("FunctionBrokerChild Lock") {
-  MOZ_ASSERT(aThread);
-  PostToDispatchThread(
-      NewNonOwningRunnableMethod<Endpoint<PFunctionBrokerChild>&&>(
-          "FunctionBrokerChild::Bind", this, &FunctionBrokerChild::Bind,
-          std::move(aEndpoint)));
-}
-
-void FunctionBrokerChild::Bind(Endpoint<PFunctionBrokerChild>&& aEndpoint) {
-  MOZ_RELEASE_ASSERT(mThread->IsOnThread());
-  DebugOnly<bool> ok = aEndpoint.Bind(this);
-  MOZ_ASSERT(ok);
-}
-
-void FunctionBrokerChild::ShutdownOnDispatchThread() {
-  MOZ_ASSERT(mThread->IsOnThread());
-
-  // Set mShutdownDone and notify waiting thread (if any) that we are done.
-  MonitorAutoLock lock(mMonitor);
-  mShutdownDone = true;
-  mMonitor.Notify();
-}
-
-void FunctionBrokerChild::ActorDestroy(ActorDestroyReason aWhy) {
-  MOZ_ASSERT(mThread->IsOnThread());
-
-  // Queue up a task on the PD thread.  When that task is executed then
-  // we know that anything queued before ActorDestroy has completed.
-  // At that point, we can set mShutdownDone and alert any waiting
-  // threads that it is safe to destroy us.
-  sInstance->PostToDispatchThread(NewNonOwningRunnableMethod(
-      "FunctionBrokerChild::ShutdownOnDispatchThread", sInstance,
-      &FunctionBrokerChild::ShutdownOnDispatchThread));
-}
-
-void FunctionBrokerChild::Destroy() {
-  MOZ_ASSERT(NS_IsMainThread());
-
-  if (!sInstance) {
-    return;
-  }
-
-  // mShutdownDone will tell us when ActorDestroy has been run and any tasks
-  // on the FunctionBrokerThread have completed.  At that point, we can
-  // safely delete the actor.
-  {
-    MonitorAutoLock lock(sInstance->mMonitor);
-    while (!sInstance->mShutdownDone) {
-      // Release lock and wait.  Regain lock when we are notified that
-      // we have ShutdownOnDispatchThread.
-      sInstance->mMonitor.Wait();
-    }
-  }
-
-  delete sInstance;
-  sInstance = nullptr;
-}
-
-}  // namespace mozilla::plugins
diff --git a/dom/plugins/ipc/FunctionBrokerChild.h b/dom/plugins/ipc/FunctionBrokerChild.h
deleted file mode 100644
index 767aaab1707aa..0000000000000
--- a/dom/plugins/ipc/FunctionBrokerChild.h
+++ /dev/null
@@ -1,51 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_plugins_functionbrokerchild_h
-#define mozilla_plugins_functionbrokerchild_h
-
-#include "mozilla/plugins/PFunctionBrokerChild.h"
-
-namespace mozilla {
-namespace plugins {
-
-class FunctionBrokerThread;
-
-/**
- * Dispatches brokered methods to the Parent process to allow functionality
- * that is otherwise blocked by the sandbox.
- */
-class FunctionBrokerChild : public PFunctionBrokerChild {
- public:
-  static bool Initialize(Endpoint<PFunctionBrokerChild>&& aBrokerEndpoint);
-  static FunctionBrokerChild* GetInstance();
-  static void Destroy();
-
-  bool IsDispatchThread();
-  void PostToDispatchThread(already_AddRefed<nsIRunnable>&& runnable);
-
-  void ActorDestroy(ActorDestroyReason aWhy) override;
-
- private:
-  explicit FunctionBrokerChild(FunctionBrokerThread* aThread,
-                               Endpoint<PFunctionBrokerChild>&& aEndpoint);
-  void ShutdownOnDispatchThread();
-  void Bind(Endpoint<PFunctionBrokerChild>&& aEndpoint);
-
-  UniquePtr<FunctionBrokerThread> mThread;
-
-  // True if tasks on the FunctionBrokerThread have completed
-  bool mShutdownDone;
-  // This monitor guards mShutdownDone.
-  Monitor mMonitor;
-
-  static FunctionBrokerChild* sInstance;
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // mozilla_plugins_functionbrokerchild_h
diff --git a/dom/plugins/ipc/FunctionBrokerIPCUtils.cpp b/dom/plugins/ipc/FunctionBrokerIPCUtils.cpp
deleted file mode 100644
index e0ee31e635b95..0000000000000
--- a/dom/plugins/ipc/FunctionBrokerIPCUtils.cpp
+++ /dev/null
@@ -1,334 +0,0 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8; -*- */
-/* vim: set sw=2 ts=8 et tw=80 : */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "FunctionBrokerIPCUtils.h"
-
-#if defined(XP_WIN)
-
-#  include <schannel.h>
-
-/* these defines are missing from mingw headers */
-#  ifndef SP_PROT_TLS1_1_CLIENT
-#    define SP_PROT_TLS1_1_CLIENT 0x00000200
-#  endif
-
-#  ifndef SP_PROT_TLS1_2_CLIENT
-#    define SP_PROT_TLS1_2_CLIENT 0x00000800
-#  endif
-
-namespace mozilla {
-namespace plugins {
-
-mozilla::LazyLogModule sPluginHooksLog("PluginHooks");
-
-static const DWORD SCHANNEL_SUPPORTED_PROTOCOLS =
-    SP_PROT_TLS1_CLIENT | SP_PROT_TLS1_1_CLIENT | SP_PROT_TLS1_2_CLIENT;
-
-static const DWORD SCHANNEL_SUPPORTED_FLAGS =
-    SCH_CRED_MANUAL_CRED_VALIDATION | SCH_CRED_NO_DEFAULT_CREDS |
-    SCH_CRED_REVOCATION_CHECK_END_CERT;
-
-void OpenFileNameIPC::CopyFromOfn(LPOPENFILENAMEW aLpofn) {
-  mHwndOwner = nullptr;
-
-  // Filter is double-NULL terminated.  mFilter should include the double-NULL.
-  mHasFilter = aLpofn->lpstrFilter != nullptr;
-  if (mHasFilter) {
-    uint32_t dNullIdx = 0;
-    while (aLpofn->lpstrFilter[dNullIdx] != L'\0' ||
-           aLpofn->lpstrFilter[dNullIdx + 1] != L'\0') {
-      dNullIdx++;
-    }
-    mFilter.assign(aLpofn->lpstrFilter, dNullIdx + 2);
-  }
-  mHasCustomFilter = aLpofn->lpstrCustomFilter != nullptr;
-  if (mHasCustomFilter) {
-    mCustomFilterIn = std::wstring(aLpofn->lpstrCustomFilter);
-    mNMaxCustFilterOut =
-        aLpofn->nMaxCustFilter - (wcslen(aLpofn->lpstrCustomFilter) + 1);
-  } else {
-    mNMaxCustFilterOut = 0;
-  }
-  mFilterIndex = aLpofn->nFilterIndex;
-  mFile = std::wstring(aLpofn->lpstrFile);
-  mNMaxFile = aLpofn->nMaxFile;
-  mNMaxFileTitle =
-      aLpofn->lpstrFileTitle != nullptr ? aLpofn->nMaxFileTitle : 0;
-  mHasInitialDir = aLpofn->lpstrInitialDir != nullptr;
-  if (mHasInitialDir) {
-    mInitialDir = std::wstring(aLpofn->lpstrInitialDir);
-  }
-  mHasTitle = aLpofn->lpstrTitle != nullptr;
-  if (mHasTitle) {
-    mTitle = std::wstring(aLpofn->lpstrTitle);
-  }
-  mHasDefExt = aLpofn->lpstrDefExt != nullptr;
-  if (mHasDefExt) {
-    mDefExt = std::wstring(aLpofn->lpstrDefExt);
-  }
-
-  mFlags = aLpofn->Flags;
-  // If the user sets OFN_ALLOWMULTISELECT then we require OFN_EXPLORER
-  // as well.  Without OFN_EXPLORER, the method has ancient legacy
-  // behavior that we don't support.
-  MOZ_ASSERT((mFlags & OFN_EXPLORER) || !(mFlags & OFN_ALLOWMULTISELECT));
-
-  // We ignore any visual customization and callbacks that the user set.
-  mFlags &= ~(OFN_ENABLEHOOK | OFN_ENABLETEMPLATEHANDLE | OFN_ENABLETEMPLATE);
-
-  mFlagsEx = aLpofn->FlagsEx;
-}
-
-void OpenFileNameIPC::AddToOfn(LPOPENFILENAMEW aLpofn) const {
-  aLpofn->lStructSize = sizeof(OPENFILENAMEW);
-  aLpofn->hwndOwner = mHwndOwner;
-  if (mHasFilter) {
-    memcpy(const_cast<LPWSTR>(aLpofn->lpstrFilter), mFilter.data(),
-           mFilter.size() * sizeof(wchar_t));
-  }
-  if (mHasCustomFilter) {
-    aLpofn->nMaxCustFilter = mCustomFilterIn.size() + 1 + mNMaxCustFilterOut;
-    wcscpy(aLpofn->lpstrCustomFilter, mCustomFilterIn.c_str());
-    memset(aLpofn->lpstrCustomFilter + mCustomFilterIn.size() + 1, 0,
-           mNMaxCustFilterOut * sizeof(wchar_t));
-  } else {
-    aLpofn->nMaxCustFilter = 0;
-  }
-  aLpofn->nFilterIndex = mFilterIndex;
-  if (mNMaxFile > 0) {
-    wcsncpy(aLpofn->lpstrFile, mFile.c_str(),
-            std::min(static_cast<uint32_t>(mFile.size() + 1), mNMaxFile));
-    aLpofn->lpstrFile[mNMaxFile - 1] = L'\0';
-  }
-  aLpofn->nMaxFile = mNMaxFile;
-  aLpofn->nMaxFileTitle = mNMaxFileTitle;
-  if (mHasInitialDir) {
-    wcscpy(const_cast<LPWSTR>(aLpofn->lpstrInitialDir), mInitialDir.c_str());
-  }
-  if (mHasTitle) {
-    wcscpy(const_cast<LPWSTR>(aLpofn->lpstrTitle), mTitle.c_str());
-  }
-  aLpofn->Flags = mFlags; /* TODO: Consider adding OFN_NOCHANGEDIR */
-  if (mHasDefExt) {
-    wcscpy(const_cast<LPWSTR>(aLpofn->lpstrDefExt), mDefExt.c_str());
-  }
-  aLpofn->FlagsEx = mFlagsEx;
-}
-
-void OpenFileNameIPC::AllocateOfnStrings(LPOPENFILENAMEW aLpofn) const {
-  if (mHasFilter) {
-    // mFilter is double-NULL terminated and it includes the double-NULL in its
-    // length.
-    aLpofn->lpstrFilter =
-        static_cast<LPCTSTR>(moz_xmalloc(sizeof(wchar_t) * (mFilter.size())));
-  }
-  if (mHasCustomFilter) {
-    aLpofn->lpstrCustomFilter = static_cast<LPTSTR>(moz_xmalloc(
-        sizeof(wchar_t) * (mCustomFilterIn.size() + 1 + mNMaxCustFilterOut)));
-  }
-  aLpofn->lpstrFile =
-      static_cast<LPTSTR>(moz_xmalloc(sizeof(wchar_t) * mNMaxFile));
-  if (mNMaxFileTitle > 0) {
-    aLpofn->lpstrFileTitle =
-        static_cast<LPTSTR>(moz_xmalloc(sizeof(wchar_t) * mNMaxFileTitle));
-  }
-  if (mHasInitialDir) {
-    aLpofn->lpstrInitialDir = static_cast<LPCTSTR>(
-        moz_xmalloc(sizeof(wchar_t) * (mInitialDir.size() + 1)));
-  }
-  if (mHasTitle) {
-    aLpofn->lpstrTitle = static_cast<LPCTSTR>(
-        moz_xmalloc(sizeof(wchar_t) * (mTitle.size() + 1)));
-  }
-  if (mHasDefExt) {
-    aLpofn->lpstrDefExt = static_cast<LPCTSTR>(
-        moz_xmalloc(sizeof(wchar_t) * (mDefExt.size() + 1)));
-  }
-}
-
-// static
-void OpenFileNameIPC::FreeOfnStrings(LPOPENFILENAMEW aLpofn) {
-  if (aLpofn->lpstrFilter) {
-    free(const_cast<LPWSTR>(aLpofn->lpstrFilter));
-  }
-  if (aLpofn->lpstrCustomFilter) {
-    free(aLpofn->lpstrCustomFilter);
-  }
-  if (aLpofn->lpstrFile) {
-    free(aLpofn->lpstrFile);
-  }
-  if (aLpofn->lpstrFileTitle) {
-    free(aLpofn->lpstrFileTitle);
-  }
-  if (aLpofn->lpstrInitialDir) {
-    free(const_cast<LPWSTR>(aLpofn->lpstrInitialDir));
-  }
-  if (aLpofn->lpstrTitle) {
-    free(const_cast<LPWSTR>(aLpofn->lpstrTitle));
-  }
-  if (aLpofn->lpstrDefExt) {
-    free(const_cast<LPWSTR>(aLpofn->lpstrDefExt));
-  }
-}
-
-void OpenFileNameRetIPC::CopyFromOfn(LPOPENFILENAMEW aLpofn) {
-  if (aLpofn->lpstrCustomFilter != nullptr) {
-    mCustomFilterOut = std::wstring(aLpofn->lpstrCustomFilter +
-                                    wcslen(aLpofn->lpstrCustomFilter) + 1);
-  }
-  mFile.assign(aLpofn->lpstrFile, aLpofn->nMaxFile);
-  if (aLpofn->lpstrFileTitle != nullptr) {
-    mFileTitle.assign(aLpofn->lpstrFileTitle,
-                      wcslen(aLpofn->lpstrFileTitle) + 1);
-  }
-  mFileOffset = aLpofn->nFileOffset;
-  mFileExtension = aLpofn->nFileExtension;
-}
-
-void OpenFileNameRetIPC::AddToOfn(LPOPENFILENAMEW aLpofn) const {
-  if (aLpofn->lpstrCustomFilter) {
-    LPWSTR secondString =
-        aLpofn->lpstrCustomFilter + wcslen(aLpofn->lpstrCustomFilter) + 1;
-    const wchar_t* customFilterOut = mCustomFilterOut.c_str();
-    MOZ_ASSERT(wcslen(aLpofn->lpstrCustomFilter) + 1 + wcslen(customFilterOut) +
-                   1 + 1 <=
-               aLpofn->nMaxCustFilter);
-    wcscpy(secondString, customFilterOut);
-    secondString[wcslen(customFilterOut) + 1] =
-        L'\0';  // terminated with two NULLs
-  }
-  MOZ_ASSERT(mFile.size() <= aLpofn->nMaxFile);
-  memcpy(aLpofn->lpstrFile, mFile.data(), mFile.size() * sizeof(wchar_t));
-  if (aLpofn->lpstrFileTitle != nullptr) {
-    MOZ_ASSERT(mFileTitle.size() + 1 < aLpofn->nMaxFileTitle);
-    wcscpy(aLpofn->lpstrFileTitle, mFileTitle.c_str());
-  }
-  aLpofn->nFileOffset = mFileOffset;
-  aLpofn->nFileExtension = mFileExtension;
-}
-
-void IPCSchannelCred::CopyFrom(const PSCHANNEL_CRED& aSCred) {
-  // We assert that the aSCred fields take supported values.
-  // If they do not then we ignore the values we were given.
-  MOZ_ASSERT(aSCred->dwVersion == SCHANNEL_CRED_VERSION);
-  MOZ_ASSERT(aSCred->cCreds == 0);
-  MOZ_ASSERT(aSCred->paCred == nullptr);
-  MOZ_ASSERT(aSCred->hRootStore == nullptr);
-  MOZ_ASSERT(aSCred->cMappers == 0);
-  MOZ_ASSERT(aSCred->aphMappers == nullptr);
-  MOZ_ASSERT(aSCred->cSupportedAlgs == 0);
-  MOZ_ASSERT(aSCred->palgSupportedAlgs == nullptr);
-  MOZ_ASSERT((aSCred->grbitEnabledProtocols & SCHANNEL_SUPPORTED_PROTOCOLS) ==
-             aSCred->grbitEnabledProtocols);
-  mEnabledProtocols =
-      aSCred->grbitEnabledProtocols & SCHANNEL_SUPPORTED_PROTOCOLS;
-  mMinStrength = aSCred->dwMinimumCipherStrength;
-  mMaxStrength = aSCred->dwMaximumCipherStrength;
-  MOZ_ASSERT(aSCred->dwSessionLifespan == 0);
-  MOZ_ASSERT((aSCred->dwFlags & SCHANNEL_SUPPORTED_FLAGS) == aSCred->dwFlags);
-  mFlags = aSCred->dwFlags & SCHANNEL_SUPPORTED_FLAGS;
-  MOZ_ASSERT(aSCred->dwCredFormat == 0);
-}
-
-void IPCSchannelCred::CopyTo(PSCHANNEL_CRED& aSCred) const {
-  // Validate values as they come from an untrusted process.
-  memset(aSCred, 0, sizeof(SCHANNEL_CRED));
-  aSCred->dwVersion = SCHANNEL_CRED_VERSION;
-  aSCred->grbitEnabledProtocols =
-      mEnabledProtocols & SCHANNEL_SUPPORTED_PROTOCOLS;
-  aSCred->dwMinimumCipherStrength = mMinStrength;
-  aSCred->dwMaximumCipherStrength = mMaxStrength;
-  aSCred->dwFlags = mFlags & SCHANNEL_SUPPORTED_FLAGS;
-}
-
-void IPCInternetBuffers::CopyFrom(const LPINTERNET_BUFFERSA& aBufs) {
-  mBuffers.Clear();
-
-  LPINTERNET_BUFFERSA inetBuf = aBufs;
-  while (inetBuf) {
-    MOZ_ASSERT(inetBuf->dwStructSize == sizeof(INTERNET_BUFFERSA));
-    Buffer* ipcBuf = mBuffers.AppendElement();
-
-    ipcBuf->mHeader.SetIsVoid(inetBuf->lpcszHeader == nullptr);
-    if (inetBuf->lpcszHeader) {
-      ipcBuf->mHeader.Assign(inetBuf->lpcszHeader, inetBuf->dwHeadersLength);
-    }
-    ipcBuf->mHeaderTotal = inetBuf->dwHeadersTotal;
-
-    ipcBuf->mBuffer.SetIsVoid(inetBuf->lpvBuffer == nullptr);
-    if (inetBuf->lpvBuffer) {
-      ipcBuf->mBuffer.Assign(static_cast<char*>(inetBuf->lpvBuffer),
-                             inetBuf->dwBufferLength);
-    }
-    ipcBuf->mBufferTotal = inetBuf->dwBufferTotal;
-    inetBuf = inetBuf->Next;
-  }
-}
-
-void IPCInternetBuffers::CopyTo(LPINTERNET_BUFFERSA& aBufs) const {
-  MOZ_ASSERT(!aBufs);
-
-  LPINTERNET_BUFFERSA lastBuf = nullptr;
-  for (size_t idx = 0; idx < mBuffers.Length(); ++idx) {
-    const Buffer& ipcBuf = mBuffers[idx];
-    LPINTERNET_BUFFERSA newBuf = static_cast<LPINTERNET_BUFFERSA>(
-        moz_xcalloc(1, sizeof(INTERNET_BUFFERSA)));
-    if (idx == 0) {
-      aBufs = newBuf;
-    } else {
-      MOZ_ASSERT(lastBuf);
-      lastBuf->Next = newBuf;
-      lastBuf = newBuf;
-    }
-
-    newBuf->dwStructSize = sizeof(INTERNET_BUFFERSA);
-
-    newBuf->dwHeadersTotal = ipcBuf.mHeaderTotal;
-    if (!ipcBuf.mHeader.IsVoid()) {
-      newBuf->lpcszHeader =
-          static_cast<LPCSTR>(moz_xmalloc(ipcBuf.mHeader.Length()));
-      memcpy(const_cast<char*>(newBuf->lpcszHeader), ipcBuf.mHeader.Data(),
-             ipcBuf.mHeader.Length());
-      newBuf->dwHeadersLength = ipcBuf.mHeader.Length();
-    }
-
-    newBuf->dwBufferTotal = ipcBuf.mBufferTotal;
-    if (!ipcBuf.mBuffer.IsVoid()) {
-      newBuf->lpvBuffer = moz_xmalloc(ipcBuf.mBuffer.Length());
-      memcpy(newBuf->lpvBuffer, ipcBuf.mBuffer.Data(), ipcBuf.mBuffer.Length());
-      newBuf->dwBufferLength = ipcBuf.mBuffer.Length();
-    }
-  }
-}
-
-/* static */
-void IPCInternetBuffers::FreeBuffers(LPINTERNET_BUFFERSA& aBufs) {
-  if (!aBufs) {
-    return;
-  }
-  while (aBufs) {
-    LPINTERNET_BUFFERSA temp = aBufs->Next;
-    free(const_cast<char*>(aBufs->lpcszHeader));
-    free(aBufs->lpvBuffer);
-    free(aBufs);
-    aBufs = temp;
-  }
-}
-
-void IPCPrintDlg::CopyFrom(const LPPRINTDLGW& aDlg) {
-  // DLP: Trouble -- my prior impl "worked" but didn't return anything
-  // AFAIR.  So... ???  But it printed a page!!!  How?!
-  MOZ_ASSERT_UNREACHABLE("TODO: DLP:");
-}
-
-void IPCPrintDlg::CopyTo(LPPRINTDLGW& aDlg) const {
-  MOZ_ASSERT_UNREACHABLE("TODO: DLP:");
-}
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // defined(XP_WIN)
diff --git a/dom/plugins/ipc/FunctionBrokerIPCUtils.h b/dom/plugins/ipc/FunctionBrokerIPCUtils.h
deleted file mode 100644
index c4b72dbe95afc..0000000000000
--- a/dom/plugins/ipc/FunctionBrokerIPCUtils.h
+++ /dev/null
@@ -1,436 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef dom_plugins_ipc_functionbrokeripcutils_h
-#define dom_plugins_ipc_functionbrokeripcutils_h 1
-
-#include "ipc/EnumSerializer.h"
-#include "ipc/IPCMessageUtilsSpecializations.h"
-#include "PluginMessageUtils.h"
-
-#if defined(XP_WIN)
-
-#  define SECURITY_WIN32
-#  include <security.h>
-#  include <wininet.h>
-#  include <schannel.h>
-#  include <commdlg.h>
-
-#endif  // defined(XP_WIN)
-
-namespace mozilla {
-namespace plugins {
-
-/**
- * This enum represents all of the methods hooked by the main facility in
- * BrokerClient. It is used to allow quick lookup in the sFunctionsToHook
- * structure.
- */
-enum FunctionHookId {
-#if defined(XP_WIN)
-  ID_GetWindowInfo = 0,
-  ID_GetKeyState,
-  ID_SetCursorPos,
-  ID_GetSaveFileNameW,
-  ID_GetOpenFileNameW,
-  ID_InternetOpenA,
-  ID_InternetConnectA,
-  ID_InternetCloseHandle,
-  ID_InternetQueryDataAvailable,
-  ID_InternetReadFile,
-  ID_InternetWriteFile,
-  ID_InternetSetOptionA,
-  ID_HttpAddRequestHeadersA,
-  ID_HttpOpenRequestA,
-  ID_HttpQueryInfoA,
-  ID_HttpSendRequestA,
-  ID_HttpSendRequestExA,
-  ID_HttpEndRequestA,
-  ID_InternetQueryOptionA,
-  ID_InternetErrorDlg,
-  ID_AcquireCredentialsHandleA,
-  ID_QueryCredentialsAttributesA,
-  ID_FreeCredentialsHandle,
-  ID_PrintDlgW,
-  ID_CreateMutexW
-#  if defined(MOZ_SANDBOX)
-  ,
-  ID_GetFileAttributesW
-#  endif  // defined(MOZ_SANDBOX)
-  ,
-  ID_FunctionHookCount
-#else   // defined(XP_WIN)
-  ID_FunctionHookCount
-#endif  // defined(XP_WIN)
-};
-
-// Max number of bytes to show when logging a blob of raw memory
-static const uint32_t MAX_BLOB_CHARS_TO_LOG = 12;
-
-// Format strings for safe logging despite the fact that they are sometimes
-// used as raw binary blobs.
-inline nsCString FormatBlob(const nsACString& aParam) {
-  if (aParam.IsVoid() || aParam.IsEmpty()) {
-    return nsCString(aParam.IsVoid() ? "<void>" : "<empty>");
-  }
-
-  nsCString str;
-  uint32_t totalLen = std::min(MAX_BLOB_CHARS_TO_LOG, aParam.Length());
-  // If we are printing only a portion of the string then follow it with
-  // ellipsis
-  const char* maybeEllipsis =
-      (MAX_BLOB_CHARS_TO_LOG < aParam.Length()) ? "..." : "";
-  for (uint32_t idx = 0; idx < totalLen; ++idx) {
-    // Should be %02x but I've run into a AppendPrintf bug...
-    str.AppendPrintf("0x%2x ", aParam.Data()[idx] & 0xff);
-  }
-  str.AppendPrintf("%s   | '", maybeEllipsis);
-  for (uint32_t idx = 0; idx < totalLen; ++idx) {
-    str.AppendPrintf("%c", (aParam.Data()[idx] > 0) ? aParam.Data()[idx] : '.');
-  }
-  str.AppendPrintf("'%s", maybeEllipsis);
-  return str;
-}
-
-#if defined(XP_WIN)
-
-// Values indicate GetOpenFileNameW and GetSaveFileNameW.
-enum GetFileNameFunc { OPEN_FUNC, SAVE_FUNC };
-
-typedef CopyableTArray<nsCString> StringArray;
-
-// IPC-capable version of the Windows OPENFILENAMEW struct.
-typedef struct _OpenFileNameIPC {
-  // Allocates memory for the strings in this object.  This should usually
-  // be used with a zeroed out OPENFILENAMEW structure.
-  void AllocateOfnStrings(LPOPENFILENAMEW aLpofn) const;
-  static void FreeOfnStrings(LPOPENFILENAMEW aLpofn);
-  void AddToOfn(LPOPENFILENAMEW aLpofn) const;
-  void CopyFromOfn(LPOPENFILENAMEW aLpofn);
-  bool operator==(const _OpenFileNameIPC& o) const {
-    return (o.mHwndOwner == mHwndOwner) && (o.mFilter == mFilter) &&
-           (o.mHasFilter == mHasFilter) &&
-           (o.mCustomFilterIn == mCustomFilterIn) &&
-           (o.mHasCustomFilter == mHasCustomFilter) &&
-           (o.mNMaxCustFilterOut == mNMaxCustFilterOut) &&
-           (o.mFilterIndex == mFilterIndex) && (o.mFile == mFile) &&
-           (o.mNMaxFile == mNMaxFile) && (o.mNMaxFileTitle == mNMaxFileTitle) &&
-           (o.mInitialDir == mInitialDir) &&
-           (o.mHasInitialDir == mHasInitialDir) && (o.mTitle == mTitle) &&
-           (o.mHasTitle == mHasTitle) && (o.mFlags == mFlags) &&
-           (o.mDefExt == mDefExt) && (o.mHasDefExt == mHasDefExt) &&
-           (o.mFlagsEx == mFlagsEx);
-  }
-
-  NativeWindowHandle mHwndOwner;
-  std::wstring
-      mFilter;  // Double-NULL terminated (i.e. L"\0\0") if mHasFilter is true
-  bool mHasFilter;
-  std::wstring mCustomFilterIn;
-  bool mHasCustomFilter;
-  uint32_t mNMaxCustFilterOut;
-  uint32_t mFilterIndex;
-  std::wstring mFile;
-  uint32_t mNMaxFile;
-  uint32_t mNMaxFileTitle;
-  std::wstring mInitialDir;
-  bool mHasInitialDir;
-  std::wstring mTitle;
-  bool mHasTitle;
-  uint32_t mFlags;
-  std::wstring mDefExt;
-  bool mHasDefExt;
-  uint32_t mFlagsEx;
-} OpenFileNameIPC;
-
-// GetOpenFileNameW and GetSaveFileNameW overwrite fields of their OPENFILENAMEW
-// parameter.  This represents those values so that they can be returned via
-// IPC.
-typedef struct _OpenFileNameRetIPC {
-  void CopyFromOfn(LPOPENFILENAMEW aLpofn);
-  void AddToOfn(LPOPENFILENAMEW aLpofn) const;
-  bool operator==(const _OpenFileNameRetIPC& o) const {
-    return (o.mCustomFilterOut == mCustomFilterOut) && (o.mFile == mFile) &&
-           (o.mFileTitle == mFileTitle) && (o.mFileOffset == mFileOffset) &&
-           (o.mFileExtension == mFileExtension);
-  }
-
-  std::wstring mCustomFilterOut;
-  std::wstring mFile;  // Double-NULL terminated (i.e. L"\0\0")
-  std::wstring mFileTitle;
-  uint16_t mFileOffset;
-  uint16_t mFileExtension;
-} OpenFileNameRetIPC;
-
-typedef struct _IPCSchannelCred {
-  void CopyFrom(const PSCHANNEL_CRED& aSCred);
-  void CopyTo(PSCHANNEL_CRED& aSCred) const;
-  bool operator==(const _IPCSchannelCred& o) const {
-    return (o.mEnabledProtocols == mEnabledProtocols) &&
-           (o.mMinStrength == mMinStrength) &&
-           (o.mMaxStrength == mMaxStrength) && (o.mFlags == mFlags);
-  }
-
-  DWORD mEnabledProtocols;
-  DWORD mMinStrength;
-  DWORD mMaxStrength;
-  DWORD mFlags;
-} IPCSchannelCred;
-
-typedef struct _IPCInternetBuffers {
-  void CopyFrom(const LPINTERNET_BUFFERSA& aBufs);
-  void CopyTo(LPINTERNET_BUFFERSA& aBufs) const;
-  bool operator==(const _IPCInternetBuffers& o) const {
-    return o.mBuffers == mBuffers;
-  }
-  static void FreeBuffers(LPINTERNET_BUFFERSA& aBufs);
-
-  struct Buffer {
-    nsCString mHeader;
-    uint32_t mHeaderTotal;
-    nsCString mBuffer;
-    uint32_t mBufferTotal;
-    bool operator==(const Buffer& o) const {
-      return (o.mHeader == mHeader) && (o.mHeaderTotal == mHeaderTotal) &&
-             (o.mBuffer == mBuffer) && (o.mBufferTotal == mBufferTotal);
-    }
-  };
-  CopyableTArray<Buffer> mBuffers;
-} IPCInternetBuffers;
-
-typedef struct _IPCPrintDlg {
-  void CopyFrom(const LPPRINTDLGW& aDlg);
-  void CopyTo(LPPRINTDLGW& aDlg) const;
-  bool operator==(const _IPCPrintDlg& o) const {
-    MOZ_ASSERT_UNREACHABLE("DLP: TODO:");
-    return false;
-  }
-} IPCPrintDlg;
-
-#endif  // defined(XP_WIN)
-
-}  // namespace plugins
-}  // namespace mozilla
-
-namespace IPC {
-
-using mozilla::plugins::FunctionHookId;
-
-#if defined(XP_WIN)
-
-using mozilla::plugins::IPCInternetBuffers;
-using mozilla::plugins::IPCPrintDlg;
-using mozilla::plugins::IPCSchannelCred;
-using mozilla::plugins::NativeWindowHandle;
-using mozilla::plugins::OpenFileNameIPC;
-using mozilla::plugins::OpenFileNameRetIPC;
-using mozilla::plugins::StringArray;
-
-template <>
-struct ParamTraits<OpenFileNameIPC> {
-  typedef OpenFileNameIPC paramType;
-
-  static void Write(Message* aMsg, const paramType& aParam) {
-    WriteParam(aMsg, aParam.mHwndOwner);
-    WriteParam(aMsg, aParam.mFilter);
-    WriteParam(aMsg, aParam.mHasFilter);
-    WriteParam(aMsg, aParam.mCustomFilterIn);
-    WriteParam(aMsg, aParam.mHasCustomFilter);
-    WriteParam(aMsg, aParam.mNMaxCustFilterOut);
-    WriteParam(aMsg, aParam.mFilterIndex);
-    WriteParam(aMsg, aParam.mFile);
-    WriteParam(aMsg, aParam.mNMaxFile);
-    WriteParam(aMsg, aParam.mNMaxFileTitle);
-    WriteParam(aMsg, aParam.mInitialDir);
-    WriteParam(aMsg, aParam.mHasInitialDir);
-    WriteParam(aMsg, aParam.mTitle);
-    WriteParam(aMsg, aParam.mHasTitle);
-    WriteParam(aMsg, aParam.mFlags);
-    WriteParam(aMsg, aParam.mDefExt);
-    WriteParam(aMsg, aParam.mHasDefExt);
-    WriteParam(aMsg, aParam.mFlagsEx);
-  }
-
-  static bool Read(const Message* aMsg, PickleIterator* aIter,
-                   paramType* aResult) {
-    if (ReadParam(aMsg, aIter, &aResult->mHwndOwner) &&
-        ReadParam(aMsg, aIter, &aResult->mFilter) &&
-        ReadParam(aMsg, aIter, &aResult->mHasFilter) &&
-        ReadParam(aMsg, aIter, &aResult->mCustomFilterIn) &&
-        ReadParam(aMsg, aIter, &aResult->mHasCustomFilter) &&
-        ReadParam(aMsg, aIter, &aResult->mNMaxCustFilterOut) &&
-        ReadParam(aMsg, aIter, &aResult->mFilterIndex) &&
-        ReadParam(aMsg, aIter, &aResult->mFile) &&
-        ReadParam(aMsg, aIter, &aResult->mNMaxFile) &&
-        ReadParam(aMsg, aIter, &aResult->mNMaxFileTitle) &&
-        ReadParam(aMsg, aIter, &aResult->mInitialDir) &&
-        ReadParam(aMsg, aIter, &aResult->mHasInitialDir) &&
-        ReadParam(aMsg, aIter, &aResult->mTitle) &&
-        ReadParam(aMsg, aIter, &aResult->mHasTitle) &&
-        ReadParam(aMsg, aIter, &aResult->mFlags) &&
-        ReadParam(aMsg, aIter, &aResult->mDefExt) &&
-        ReadParam(aMsg, aIter, &aResult->mHasDefExt) &&
-        ReadParam(aMsg, aIter, &aResult->mFlagsEx)) {
-      return true;
-    }
-    return false;
-  }
-
-  static void Log(const paramType& aParam, std::wstring* aLog) {
-    aLog->append(StringPrintf(L"[%ls, %ls, %ls, %ls]", aParam.mFilter.c_str(),
-                              aParam.mCustomFilterIn.c_str(),
-                              aParam.mFile.c_str(), aParam.mTitle.c_str()));
-  }
-};
-
-template <>
-struct ParamTraits<OpenFileNameRetIPC> {
-  typedef OpenFileNameRetIPC paramType;
-
-  static void Write(Message* aMsg, const paramType& aParam) {
-    WriteParam(aMsg, aParam.mCustomFilterOut);
-    WriteParam(aMsg, aParam.mFile);
-    WriteParam(aMsg, aParam.mFileTitle);
-    WriteParam(aMsg, aParam.mFileOffset);
-    WriteParam(aMsg, aParam.mFileExtension);
-  }
-
-  static bool Read(const Message* aMsg, PickleIterator* aIter,
-                   paramType* aResult) {
-    if (ReadParam(aMsg, aIter, &aResult->mCustomFilterOut) &&
-        ReadParam(aMsg, aIter, &aResult->mFile) &&
-        ReadParam(aMsg, aIter, &aResult->mFileTitle) &&
-        ReadParam(aMsg, aIter, &aResult->mFileOffset) &&
-        ReadParam(aMsg, aIter, &aResult->mFileExtension)) {
-      return true;
-    }
-    return false;
-  }
-
-  static void Log(const paramType& aParam, std::wstring* aLog) {
-    aLog->append(StringPrintf(L"[%ls, %ls, %ls, %d, %d]",
-                              aParam.mCustomFilterOut.c_str(),
-                              aParam.mFile.c_str(), aParam.mFileTitle.c_str(),
-                              aParam.mFileOffset, aParam.mFileExtension));
-  }
-};
-
-template <>
-struct ParamTraits<mozilla::plugins::GetFileNameFunc>
-    : public ContiguousEnumSerializerInclusive<
-          mozilla::plugins::GetFileNameFunc, mozilla::plugins::OPEN_FUNC,
-          mozilla::plugins::SAVE_FUNC> {};
-
-template <>
-struct ParamTraits<IPCSchannelCred> {
-  typedef mozilla::plugins::IPCSchannelCred paramType;
-
-  static void Write(Message* aMsg, const paramType& aParam) {
-    WriteParam(aMsg, static_cast<uint32_t>(aParam.mEnabledProtocols));
-    WriteParam(aMsg, static_cast<uint32_t>(aParam.mMinStrength));
-    WriteParam(aMsg, static_cast<uint32_t>(aParam.mMaxStrength));
-    WriteParam(aMsg, static_cast<uint32_t>(aParam.mFlags));
-  }
-
-  static bool Read(const Message* aMsg, PickleIterator* aIter,
-                   paramType* aResult) {
-    uint32_t proto, minStr, maxStr, flags;
-    if (!ReadParam(aMsg, aIter, &proto) || !ReadParam(aMsg, aIter, &minStr) ||
-        !ReadParam(aMsg, aIter, &maxStr) || !ReadParam(aMsg, aIter, &flags)) {
-      return false;
-    }
-    aResult->mEnabledProtocols = proto;
-    aResult->mMinStrength = minStr;
-    aResult->mMaxStrength = maxStr;
-    aResult->mFlags = flags;
-    return true;
-  }
-
-  static void Log(const paramType& aParam, std::wstring* aLog) {
-    aLog->append(StringPrintf(L"[%d,%d,%d,%d]", aParam.mEnabledProtocols,
-                              aParam.mMinStrength, aParam.mMaxStrength,
-                              aParam.mFlags));
-  }
-};
-
-template <>
-struct ParamTraits<IPCInternetBuffers::Buffer> {
-  typedef mozilla::plugins::IPCInternetBuffers::Buffer paramType;
-
-  static void Write(Message* aMsg, const paramType& aParam) {
-    WriteParam(aMsg, aParam.mHeader);
-    WriteParam(aMsg, aParam.mHeaderTotal);
-    WriteParam(aMsg, aParam.mBuffer);
-    WriteParam(aMsg, aParam.mBufferTotal);
-  }
-
-  static bool Read(const Message* aMsg, PickleIterator* aIter,
-                   paramType* aResult) {
-    return ReadParam(aMsg, aIter, &aResult->mHeader) &&
-           ReadParam(aMsg, aIter, &aResult->mHeaderTotal) &&
-           ReadParam(aMsg, aIter, &aResult->mBuffer) &&
-           ReadParam(aMsg, aIter, &aResult->mBufferTotal);
-  }
-
-  static void Log(const paramType& aParam, std::wstring* aLog) {
-    nsCString head = mozilla::plugins::FormatBlob(aParam.mHeader);
-    nsCString buffer = mozilla::plugins::FormatBlob(aParam.mBuffer);
-    std::string msg =
-        StringPrintf("[%s, %d, %s, %d]", head.Data(), aParam.mHeaderTotal,
-                     buffer.Data(), aParam.mBufferTotal);
-    aLog->append(msg.begin(), msg.end());
-  }
-};
-
-template <>
-struct ParamTraits<IPCInternetBuffers> {
-  typedef mozilla::plugins::IPCInternetBuffers paramType;
-
-  static void Write(Message* aMsg, const paramType& aParam) {
-    WriteParam(aMsg, aParam.mBuffers);
-  }
-
-  static bool Read(const Message* aMsg, PickleIterator* aIter,
-                   paramType* aResult) {
-    return ReadParam(aMsg, aIter, &aResult->mBuffers);
-  }
-
-  static void Log(const paramType& aParam, std::wstring* aLog) {
-    ParamTraits<nsTArray<IPCInternetBuffers::Buffer>>::Log(aParam.mBuffers,
-                                                           aLog);
-  }
-};
-
-template <>
-struct ParamTraits<IPCPrintDlg> {
-  typedef mozilla::plugins::IPCPrintDlg paramType;
-
-  static void Write(Message* aMsg, const paramType& aParam) {
-    MOZ_ASSERT_UNREACHABLE("TODO: DLP:");
-  }
-
-  static bool Read(const Message* aMsg, PickleIterator* aIter,
-                   paramType* aResult) {
-    MOZ_ASSERT_UNREACHABLE("TODO: DLP:");
-    return true;
-  }
-
-  static void Log(const paramType& aParam, std::wstring* aLog) {
-    MOZ_ASSERT_UNREACHABLE("TODO: DLP:");
-  }
-};
-
-#endif  // defined(XP_WIN)
-
-template <>
-struct ParamTraits<FunctionHookId>
-    : public ContiguousEnumSerializer<FunctionHookId,
-                                      static_cast<FunctionHookId>(0),
-                                      FunctionHookId::ID_FunctionHookCount> {};
-
-}  // namespace IPC
-
-#endif /* dom_plugins_ipc_functionbrokeripcutils_h */
diff --git a/dom/plugins/ipc/FunctionBrokerParent.cpp b/dom/plugins/ipc/FunctionBrokerParent.cpp
deleted file mode 100644
index 51e3b62899101..0000000000000
--- a/dom/plugins/ipc/FunctionBrokerParent.cpp
+++ /dev/null
@@ -1,139 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "FunctionBrokerParent.h"
-#include "FunctionBroker.h"
-#include "FunctionBrokerThread.h"
-
-#include "mozilla/ipc/Endpoint.h"
-
-namespace mozilla::plugins {
-
-#if defined(XP_WIN)
-UlongPairToIdMap sPairToIdMap;
-IdToUlongPairMap sIdToPairMap;
-PtrToIdMap sPtrToIdMap;
-IdToPtrMap sIdToPtrMap;
-#endif  // defined(XP_WIN)
-
-/* static */
-FunctionBrokerParent* FunctionBrokerParent::Create(
-    Endpoint<PFunctionBrokerParent>&& aParentEnd) {
-  FunctionBrokerThread* thread = FunctionBrokerThread::Create();
-  if (!thread) {
-    return nullptr;
-  }
-
-  // We get the FunctionHooks so that they are created here, not on the
-  // message thread.
-  FunctionHook::GetHooks();
-
-  return new FunctionBrokerParent(thread, std::move(aParentEnd));
-}
-
-FunctionBrokerParent::FunctionBrokerParent(
-    FunctionBrokerThread* aThread, Endpoint<PFunctionBrokerParent>&& aParentEnd)
-    : mThread(aThread),
-      mMonitor("FunctionBrokerParent Lock"),
-      mShutdownDone(false) {
-  MOZ_ASSERT(mThread);
-  mThread->Dispatch(
-      NewNonOwningRunnableMethod<Endpoint<PFunctionBrokerParent>&&>(
-          "FunctionBrokerParent::Bind", this, &FunctionBrokerParent::Bind,
-          std::move(aParentEnd)));
-}
-
-FunctionBrokerParent::~FunctionBrokerParent() {
-#if defined(XP_WIN) && defined(MOZ_SANDBOX)
-  // Clean up any file permissions that we granted to the child process.
-  MOZ_RELEASE_ASSERT(NS_IsMainThread());
-  RemovePermissionsForProcess(OtherPid());
-#endif
-}
-
-void FunctionBrokerParent::Bind(Endpoint<PFunctionBrokerParent>&& aEnd) {
-  MOZ_RELEASE_ASSERT(mThread->IsOnThread());
-  DebugOnly<bool> ok = aEnd.Bind(this);
-  MOZ_ASSERT(ok);
-}
-
-void FunctionBrokerParent::ShutdownOnBrokerThread() {
-  MOZ_ASSERT(mThread->IsOnThread());
-  Close();
-
-  // Notify waiting thread that we are done.
-  MonitorAutoLock lock(mMonitor);
-  mShutdownDone = true;
-  mMonitor.Notify();
-}
-
-void FunctionBrokerParent::Destroy(FunctionBrokerParent* aInst) {
-  MOZ_ASSERT(NS_IsMainThread());
-  MOZ_ASSERT(aInst);
-
-  {
-    // Hold the lock while we destroy the actor on the broker thread.
-    MonitorAutoLock lock(aInst->mMonitor);
-    aInst->mThread->Dispatch(NewNonOwningRunnableMethod(
-        "FunctionBrokerParent::ShutdownOnBrokerThread", aInst,
-        &FunctionBrokerParent::ShutdownOnBrokerThread));
-
-    // Wait for broker thread to complete destruction.
-    while (!aInst->mShutdownDone) {
-      aInst->mMonitor.Wait();
-    }
-  }
-
-  delete aInst;
-}
-
-void FunctionBrokerParent::ActorDestroy(ActorDestroyReason aWhy) {
-  MOZ_RELEASE_ASSERT(mThread->IsOnThread());
-}
-
-mozilla::ipc::IPCResult FunctionBrokerParent::RecvBrokerFunction(
-    const FunctionHookId& aFunctionId, const IpdlTuple& aInTuple,
-    IpdlTuple* aOutTuple) {
-#if defined(XP_WIN)
-  MOZ_ASSERT(mThread->IsOnThread());
-  if (RunBrokeredFunction(OtherPid(), aFunctionId, aInTuple, aOutTuple)) {
-    return IPC_OK();
-  }
-  return IPC_FAIL_NO_REASON(this);
-#else
-  MOZ_ASSERT_UNREACHABLE(
-      "BrokerFunction is currently only implemented on Windows.");
-  return IPC_FAIL_NO_REASON(this);
-#endif
-}
-
-// static
-bool FunctionBrokerParent::RunBrokeredFunction(
-    base::ProcessId aClientId, const FunctionHookId& aFunctionId,
-    const IPC::IpdlTuple& aInTuple, IPC::IpdlTuple* aOutTuple) {
-  if ((size_t)aFunctionId >= FunctionHook::GetHooks()->Length()) {
-    MOZ_ASSERT_UNREACHABLE("Invalid function ID");
-    return false;
-  }
-
-  FunctionHook* hook = FunctionHook::GetHooks()->ElementAt(aFunctionId);
-  MOZ_ASSERT(hook->FunctionId() == aFunctionId);
-  return hook->RunOriginalFunction(aClientId, aInTuple, aOutTuple);
-}
-
-#if defined(XP_WIN) && defined(MOZ_SANDBOX)
-
-mozilla::SandboxPermissions FunctionBrokerParent::sSandboxPermissions;
-
-// static
-void FunctionBrokerParent::RemovePermissionsForProcess(
-    base::ProcessId aClientId) {
-  sSandboxPermissions.RemovePermissionsForProcess(aClientId);
-}
-
-#endif  // defined(XP_WIN) && defined(MOZ_SANDBOX)
-
-}  // namespace mozilla::plugins
diff --git a/dom/plugins/ipc/FunctionBrokerParent.h b/dom/plugins/ipc/FunctionBrokerParent.h
deleted file mode 100644
index 5ad26678b8399..0000000000000
--- a/dom/plugins/ipc/FunctionBrokerParent.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_plugins_functionbrokerparent_h
-#define mozilla_plugins_functionbrokerparent_h
-
-#include "mozilla/plugins/PFunctionBrokerParent.h"
-#if defined(XP_WIN) && defined(MOZ_SANDBOX)
-#  include "sandboxPermissions.h"
-#endif
-
-namespace mozilla {
-namespace plugins {
-
-class FunctionBrokerThread;
-
-/**
- * Top-level actor run on the process to which we broker calls from sandboxed
- * plugin processes.
- */
-class FunctionBrokerParent : public PFunctionBrokerParent {
- public:
-  static FunctionBrokerParent* Create(
-      Endpoint<PFunctionBrokerParent>&& aParentEnd);
-  static void Destroy(FunctionBrokerParent* aInst);
-
-  void ActorDestroy(ActorDestroyReason aWhy) override;
-
-  mozilla::ipc::IPCResult RecvBrokerFunction(const FunctionHookId& aFunctionId,
-                                             const IpdlTuple& aInTuple,
-                                             IpdlTuple* aOutTuple) override;
-
-#if defined(XP_WIN) && defined(MOZ_SANDBOX)
-  static mozilla::SandboxPermissions* GetSandboxPermissions() {
-    return &sSandboxPermissions;
-  }
-#endif  // defined(XP_WIN) && defined(MOZ_SANDBOX)
-
- private:
-  explicit FunctionBrokerParent(FunctionBrokerThread* aThread,
-                                Endpoint<PFunctionBrokerParent>&& aParentEnd);
-  ~FunctionBrokerParent();
-  void ShutdownOnBrokerThread();
-  void Bind(Endpoint<PFunctionBrokerParent>&& aEnd);
-
-  static bool RunBrokeredFunction(base::ProcessId aClientId,
-                                  const FunctionHookId& aFunctionId,
-                                  const IPC::IpdlTuple& aInTuple,
-                                  IPC::IpdlTuple* aOutTuple);
-
-#if defined(XP_WIN) && defined(MOZ_SANDBOX)
-  static void RemovePermissionsForProcess(base::ProcessId aClientId);
-  static mozilla::SandboxPermissions sSandboxPermissions;
-#endif  // defined(XP_WIN) && defined(MOZ_SANDBOX)
-
-  UniquePtr<FunctionBrokerThread> mThread;
-  Monitor mMonitor;
-  bool mShutdownDone;
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // mozilla_plugins_functionbrokerparent_hk
diff --git a/dom/plugins/ipc/FunctionBrokerThread.h b/dom/plugins/ipc/FunctionBrokerThread.h
deleted file mode 100644
index f5fe66e9ef99d..0000000000000
--- a/dom/plugins/ipc/FunctionBrokerThread.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_plugins_functionbrokerthread_h
-#define mozilla_plugins_functionbrokerthread_h
-
-#include "nsThreadManager.h"
-
-namespace mozilla {
-namespace plugins {
-
-class FunctionBrokerThread {
- public:
-  void Dispatch(already_AddRefed<nsIRunnable>&& aRunnable) {
-    mThread->Dispatch(std::move(aRunnable), nsIEventTarget::NS_DISPATCH_NORMAL);
-  }
-
-  bool IsOnThread() {
-    bool on;
-    return NS_SUCCEEDED(mThread->IsOnCurrentThread(&on)) && on;
-  }
-
-  static FunctionBrokerThread* Create() {
-    MOZ_RELEASE_ASSERT(NS_IsMainThread());
-    nsCOMPtr<nsIThread> thread;
-    if (NS_FAILED(
-            NS_NewNamedThread("Function Broker", getter_AddRefs(thread)))) {
-      return nullptr;
-    }
-    return new FunctionBrokerThread(thread);
-  }
-
-  ~FunctionBrokerThread() {
-    MOZ_RELEASE_ASSERT(NS_IsMainThread());
-    mThread->Shutdown();
-  }
-
- private:
-  explicit FunctionBrokerThread(nsIThread* aThread) : mThread(aThread) {
-    MOZ_ASSERT(mThread);
-  }
-
-  nsCOMPtr<nsIThread> mThread;
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // mozilla_plugins_functionbrokerthread_h
diff --git a/dom/plugins/ipc/FunctionHook.cpp b/dom/plugins/ipc/FunctionHook.cpp
deleted file mode 100644
index 99361d24f86a4..0000000000000
--- a/dom/plugins/ipc/FunctionHook.cpp
+++ /dev/null
@@ -1,359 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "mozilla/TextUtils.h"
-
-#include "FunctionHook.h"
-#include "FunctionBroker.h"
-#include "nsClassHashtable.h"
-#include "mozilla/ClearOnShutdown.h"
-
-#if defined(XP_WIN)
-#  include <shlobj.h>
-#  include "PluginModuleChild.h"
-#endif
-
-namespace mozilla::plugins {
-
-StaticAutoPtr<FunctionHookArray> FunctionHook::sFunctionHooks;
-
-bool AlwaysHook(int) { return true; }
-
-FunctionHookArray* FunctionHook::GetHooks() {
-  if (sFunctionHooks) {
-    return sFunctionHooks;
-  }
-
-  // sFunctionHooks is the StaticAutoPtr to the singleton array of FunctionHook
-  // objects.  We free it by clearing the StaticAutoPtr on shutdown.
-  sFunctionHooks = new FunctionHookArray();
-  ClearOnShutdown(&sFunctionHooks);
-  sFunctionHooks->SetLength(ID_FunctionHookCount);
-
-  AddFunctionHooks(*sFunctionHooks);
-  AddBrokeredFunctionHooks(*sFunctionHooks);
-  return sFunctionHooks;
-}
-
-void FunctionHook::HookFunctions(int aQuirks) {
-  MOZ_ASSERT(XRE_GetProcessType() == GeckoProcessType_Plugin);
-  FunctionHookArray* hooks = FunctionHook::GetHooks();
-  MOZ_ASSERT(hooks);
-  for (size_t i = 0; i < hooks->Length(); ++i) {
-    FunctionHook* mhb = hooks->ElementAt(i);
-    // Check that the FunctionHook array is in the same order as the
-    // FunctionHookId enum.
-    MOZ_ASSERT((size_t)mhb->FunctionId() == i);
-    mhb->Register(aQuirks);
-  }
-}
-
-#if defined(XP_WIN)
-
-// This cache is created when a DLL is registered with a FunctionHook.
-// It is cleared on a call to ClearDllInterceptorCache().  It
-// must be freed before exit to avoid leaks.
-typedef nsClassHashtable<nsStringHashKey, WindowsDllInterceptor>
-    DllInterceptors;
-DllInterceptors* sDllInterceptorCache = nullptr;
-
-WindowsDllInterceptor* FunctionHook::GetDllInterceptorFor(
-    const char* aModuleName) {
-  if (!sDllInterceptorCache) {
-    sDllInterceptorCache = new DllInterceptors();
-  }
-
-  MOZ_ASSERT(IsAsciiNullTerminated(aModuleName),
-             "Non-ASCII module names are not supported");
-  NS_ConvertASCIItoUTF16 moduleName(aModuleName);
-
-  WindowsDllInterceptor* ret = sDllInterceptorCache->GetOrInsertNew(moduleName);
-  MOZ_ASSERT(ret);
-  ret->Init(moduleName.get());
-  return ret;
-}
-
-void FunctionHook::ClearDllInterceptorCache() {
-  delete sDllInterceptorCache;
-  sDllInterceptorCache = nullptr;
-}
-
-/* GetWindowInfo */
-
-typedef BasicFunctionHook<ID_GetWindowInfo, decltype(GetWindowInfo)>
-    GetWindowInfoFH;
-
-template <>
-ShouldHookFunc* const GetWindowInfoFH::mShouldHook =
-    &CheckQuirks<QUIRK_FLASH_HOOK_GETWINDOWINFO>;
-
-static const wchar_t* kMozillaWindowClass = L"MozillaWindowClass";
-static HWND sBrowserHwnd = nullptr;
-
-INTERCEPTOR_DISABLE_CFGUARD BOOL WINAPI GetWindowInfoHook(HWND hWnd,
-                                                          PWINDOWINFO pwi) {
-  if (!pwi) {
-    return FALSE;
-  }
-
-  MOZ_ASSERT(ID_GetWindowInfo < FunctionHook::GetHooks()->Length());
-  GetWindowInfoFH* functionHook = static_cast<GetWindowInfoFH*>(
-      FunctionHook::GetHooks()->ElementAt(ID_GetWindowInfo));
-  if (!functionHook->OriginalFunction()) {
-    NS_ASSERTION(FALSE, "Something is horribly wrong in PHGetWindowInfoHook!");
-    return FALSE;
-  }
-
-  if (!sBrowserHwnd) {
-    wchar_t szClass[20];
-    // GetClassNameW returns the length it copied w/o null terminator.
-    // Therefore, if the name and null-terminator fit then it returns a
-    // value less than the buffer's length.
-    int nameLen = GetClassNameW(hWnd, szClass, ArrayLength(szClass));
-    if ((nameLen < (int)ArrayLength(szClass)) &&
-        !wcscmp(szClass, kMozillaWindowClass)) {
-      sBrowserHwnd = hWnd;
-    }
-  }
-
-  // Oddity: flash does strange rect comparisons for mouse input destined for
-  // it's internal settings window. Post removing sub widgets for tabs, touch
-  // this up so they get the rect they expect.
-  // XXX potentially tie this to a specific major version?
-  typedef BOOL(WINAPI * GetWindowInfoPtr)(HWND hwnd, PWINDOWINFO pwi);
-  GetWindowInfoPtr gwiFunc =
-      static_cast<GetWindowInfoPtr>(functionHook->OriginalFunction());
-  BOOL result = gwiFunc(hWnd, pwi);
-  if (sBrowserHwnd && sBrowserHwnd == hWnd) {
-    pwi->rcWindow = pwi->rcClient;
-  }
-  return result;
-}
-
-/* PrintDlgW */
-
-typedef BasicFunctionHook<ID_PrintDlgW, decltype(PrintDlgW)> PrintDlgWFH;
-
-template <>
-ShouldHookFunc* const PrintDlgWFH::mShouldHook =
-    &CheckQuirks<QUIRK_FLASH_HOOK_PRINTDLGW>;
-
-INTERCEPTOR_DISABLE_CFGUARD BOOL WINAPI PrintDlgWHook(LPPRINTDLGW aDlg) {
-  // Zero out the HWND supplied by the plugin.  We are sacrificing window
-  // parentage for the ability to run in the NPAPI sandbox.
-  HWND hwnd = aDlg->hwndOwner;
-  aDlg->hwndOwner = 0;
-  MOZ_ASSERT(ID_PrintDlgW < FunctionHook::GetHooks()->Length());
-  PrintDlgWFH* functionHook = static_cast<PrintDlgWFH*>(
-      FunctionHook::GetHooks()->ElementAt(ID_PrintDlgW));
-  MOZ_ASSERT(functionHook);
-  BOOL ret = functionHook->OriginalFunction()(aDlg);
-  aDlg->hwndOwner = hwnd;
-  return ret;
-}
-
-// Hooking CreateFileW for protected-mode magic
-static WindowsDllInterceptor sKernel32Intercept;
-typedef HANDLE(WINAPI* CreateFileWPtr)(LPCWSTR aFname, DWORD aAccess,
-                                       DWORD aShare,
-                                       LPSECURITY_ATTRIBUTES aSecurity,
-                                       DWORD aCreation, DWORD aFlags,
-                                       HANDLE aFTemplate);
-static WindowsDllInterceptor::FuncHookType<CreateFileWPtr> sCreateFileWStub;
-typedef HANDLE(WINAPI* CreateFileAPtr)(LPCSTR aFname, DWORD aAccess,
-                                       DWORD aShare,
-                                       LPSECURITY_ATTRIBUTES aSecurity,
-                                       DWORD aCreation, DWORD aFlags,
-                                       HANDLE aFTemplate);
-static WindowsDllInterceptor::FuncHookType<CreateFileAPtr> sCreateFileAStub;
-
-// Windows 8 RTM (kernelbase's version is 6.2.9200.16384) doesn't call
-// CreateFileW from CreateFileA.
-// So we hook CreateFileA too to use CreateFileW hook.
-static HANDLE WINAPI CreateFileAHookFn(LPCSTR aFname, DWORD aAccess,
-                                       DWORD aShare,
-                                       LPSECURITY_ATTRIBUTES aSecurity,
-                                       DWORD aCreation, DWORD aFlags,
-                                       HANDLE aFTemplate) {
-  while (true) {  // goto out
-    // Our hook is for mms.cfg into \Windows\System32\Macromed\Flash
-    // We don't require supporting too long path.
-    WCHAR unicodeName[MAX_PATH];
-    size_t len = strlen(aFname);
-
-    if (len >= MAX_PATH) {
-      break;
-    }
-
-    // We call to CreateFileW for workaround of Windows 8 RTM
-    int newLen = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, aFname, len,
-                                     unicodeName, MAX_PATH);
-    if (newLen == 0 || newLen >= MAX_PATH) {
-      break;
-    }
-    unicodeName[newLen] = '\0';
-
-    return CreateFileW(unicodeName, aAccess, aShare, aSecurity, aCreation,
-                       aFlags, aFTemplate);
-  }
-
-  return sCreateFileAStub(aFname, aAccess, aShare, aSecurity, aCreation, aFlags,
-                          aFTemplate);
-}
-
-static bool GetLocalLowTempPath(size_t aLen, LPWSTR aPath) {
-  constexpr auto tempname = u"\\Temp"_ns;
-  LPWSTR path;
-  if (SUCCEEDED(
-          SHGetKnownFolderPath(FOLDERID_LocalAppDataLow, 0, nullptr, &path))) {
-    if (wcslen(path) + tempname.Length() < aLen) {
-      wcscpy(aPath, path);
-      wcscat(aPath, tempname.get());
-      CoTaskMemFree(path);
-      return true;
-    }
-    CoTaskMemFree(path);
-  }
-
-  // XP doesn't support SHGetKnownFolderPath and LocalLow
-  if (!GetTempPathW(aLen, aPath)) {
-    return false;
-  }
-  return true;
-}
-
-HANDLE WINAPI CreateFileWHookFn(LPCWSTR aFname, DWORD aAccess, DWORD aShare,
-                                LPSECURITY_ATTRIBUTES aSecurity,
-                                DWORD aCreation, DWORD aFlags,
-                                HANDLE aFTemplate) {
-  static const WCHAR kConfigFile[] = L"mms.cfg";
-  static const size_t kConfigLength = ArrayLength(kConfigFile) - 1;
-
-  while (true) {  // goto out, in sheep's clothing
-    size_t len = wcslen(aFname);
-    if (len < kConfigLength) {
-      break;
-    }
-    if (wcscmp(aFname + len - kConfigLength, kConfigFile) != 0) {
-      break;
-    }
-
-    // This is the config file we want to rewrite
-    WCHAR tempPath[MAX_PATH + 1];
-    if (GetLocalLowTempPath(MAX_PATH, tempPath) == 0) {
-      break;
-    }
-    WCHAR tempFile[MAX_PATH + 1];
-    if (GetTempFileNameW(tempPath, L"fx", 0, tempFile) == 0) {
-      break;
-    }
-    HANDLE replacement = sCreateFileWStub(
-        tempFile, GENERIC_READ | GENERIC_WRITE, aShare, aSecurity,
-        TRUNCATE_EXISTING, FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE,
-        nullptr);
-    if (replacement == INVALID_HANDLE_VALUE) {
-      break;
-    }
-
-    HANDLE original = sCreateFileWStub(aFname, aAccess, aShare, aSecurity,
-                                       aCreation, aFlags, aFTemplate);
-    if (original != INVALID_HANDLE_VALUE) {
-      // copy original to replacement
-      static const size_t kBufferSize = 1024;
-      char buffer[kBufferSize];
-      DWORD bytes;
-      while (ReadFile(original, buffer, kBufferSize, &bytes, NULL)) {
-        if (bytes == 0) {
-          break;
-        }
-        DWORD wbytes;
-        WriteFile(replacement, buffer, bytes, &wbytes, NULL);
-        if (bytes < kBufferSize) {
-          break;
-        }
-      }
-      CloseHandle(original);
-    }
-    static const char kSettingString[] = "\nProtectedMode=0\n";
-    DWORD wbytes;
-    WriteFile(replacement, static_cast<const void*>(kSettingString),
-              sizeof(kSettingString) - 1, &wbytes, NULL);
-    SetFilePointer(replacement, 0, NULL, FILE_BEGIN);
-    return replacement;
-  }
-  return sCreateFileWStub(aFname, aAccess, aShare, aSecurity, aCreation, aFlags,
-                          aFTemplate);
-}
-
-void FunctionHook::HookProtectedMode() {
-  // Legacy code.  Uses the nsWindowsDLLInterceptor directly instead of
-  // using the FunctionHook
-  sKernel32Intercept.Init("kernel32.dll");
-  MOZ_ASSERT(XRE_GetProcessType() == GeckoProcessType_Plugin);
-  sCreateFileWStub.Set(sKernel32Intercept, "CreateFileW", &CreateFileWHookFn);
-  sCreateFileAStub.Set(sKernel32Intercept, "CreateFileA", &CreateFileAHookFn);
-}
-
-#  if defined(MOZ_SANDBOX)
-
-/* GetFileAttributesW */
-
-typedef BasicFunctionHook<ID_GetFileAttributesW, decltype(GetFileAttributesW)>
-    GetFileAttributesWFH;
-
-INTERCEPTOR_DISABLE_CFGUARD DWORD WINAPI
-GetFileAttributesWHook(LPCWSTR aFilename) {
-  MOZ_ASSERT(ID_GetFileAttributesW < FunctionHook::GetHooks()->Length());
-  GetFileAttributesWFH* functionHook = static_cast<GetFileAttributesWFH*>(
-      FunctionHook::GetHooks()->ElementAt(ID_GetFileAttributesW));
-  if (!functionHook->OriginalFunction()) {
-    NS_ASSERTION(FALSE,
-                 "Something is horribly wrong in GetFileAttributesWHook!");
-    return FALSE;
-  }
-
-  DWORD ret = functionHook->OriginalFunction()(aFilename);
-  if (ret != INVALID_FILE_ATTRIBUTES) {
-    return ret;
-  }
-
-  // If aFilename is a parent of PluginModuleChild::GetFlashRoamingPath then
-  // assume it was blocked by the sandbox and just report it as a plain
-  // directory.
-  size_t len = wcslen(aFilename);
-  std::wstring roamingPath = PluginModuleChild::GetFlashRoamingPath();
-  bool isParent = (len > 0) && (aFilename[len - 1] == L'\\') &&
-                  (_wcsnicmp(aFilename, roamingPath.c_str(), len) == 0);
-  if (!isParent) {
-    return ret;
-  }
-  return FILE_ATTRIBUTE_DIRECTORY;
-}
-
-#  endif  // defined(MOZ_SANDBOX)
-
-#endif  // defined(XP_WIN)
-
-#define FUN_HOOK(x) static_cast<FunctionHook*>(x)
-
-void FunctionHook::AddFunctionHooks(FunctionHookArray& aHooks) {
-  // We transfer ownership of the FunctionHook objects to the array.
-#if defined(XP_WIN)
-  aHooks[ID_GetWindowInfo] = FUN_HOOK(new GetWindowInfoFH(
-      "user32.dll", "GetWindowInfo", &GetWindowInfo, &GetWindowInfoHook));
-  aHooks[ID_PrintDlgW] = FUN_HOOK(
-      new PrintDlgWFH("comdlg32.dll", "PrintDlgW", &PrintDlgW, PrintDlgWHook));
-#  if defined(MOZ_SANDBOX)
-  aHooks[ID_GetFileAttributesW] = FUN_HOOK(
-      new GetFileAttributesWFH("kernel32.dll", "GetFileAttributesW",
-                               &GetFileAttributesW, &GetFileAttributesWHook));
-#  endif  // defined(MOZ_SANDBOX)
-#endif    // defined(XP_WIN)
-}
-
-#undef FUN_HOOK
-
-}  // namespace mozilla::plugins
diff --git a/dom/plugins/ipc/FunctionHook.h b/dom/plugins/ipc/FunctionHook.h
deleted file mode 100644
index ac259d6bd3499..0000000000000
--- a/dom/plugins/ipc/FunctionHook.h
+++ /dev/null
@@ -1,206 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef dom_plugins_ipc_functionhook_h
-#define dom_plugins_ipc_functionhook_h 1
-
-#include "IpdlTuple.h"
-#include "base/process.h"
-#include "mozilla/Atomics.h"
-
-#if defined(XP_WIN)
-#  include "nsWindowsDllInterceptor.h"
-#endif
-
-namespace mozilla {
-
-template <class T>
-class StaticAutoPtr;
-
-namespace plugins {
-
-// "PluginHooks" logging helpers
-extern mozilla::LazyLogModule sPluginHooksLog;
-#define HOOK_LOG(lvl, msg) MOZ_LOG(mozilla::plugins::sPluginHooksLog, lvl, msg);
-inline const char* SuccessMsg(bool aVal) {
-  return aVal ? "succeeded" : "failed";
-}
-
-class FunctionHook;
-class FunctionHookArray;
-
-class FunctionHook {
- public:
-  virtual ~FunctionHook() = default;
-
-  virtual FunctionHookId FunctionId() const = 0;
-
-  /**
-   * Register to hook the function represented by this class.
-   * Returns false if we should have hooked but didn't.
-   */
-  virtual bool Register(int aQuirks) = 0;
-
-  /**
-   * Run the original function with parameters stored in a tuple.
-   * This is only supported on server-side and for auto-brokered methods.
-   */
-  virtual bool RunOriginalFunction(base::ProcessId aClientId,
-                                   const IPC::IpdlTuple& aInTuple,
-                                   IPC::IpdlTuple* aOutTuple) const = 0;
-
-  /**
-   * Hook the Win32 methods needed by the plugin process.
-   */
-  static void HookFunctions(int aQuirks);
-
-  static FunctionHookArray* GetHooks();
-
-#if defined(XP_WIN)
-  /**
-   * Special handler for hooking some kernel32.dll methods that we use to
-   * disable Flash protected mode.
-   */
-  static void HookProtectedMode();
-
-  /**
-   * Get the WindowsDllInterceptor for the given module.  Creates a cache of
-   * WindowsDllInterceptors by name.
-   */
-  static WindowsDllInterceptor* GetDllInterceptorFor(const char* aModuleName);
-
-  /**
-   * Must be called to clear the cache created by calls to GetDllInterceptorFor.
-   */
-  static void ClearDllInterceptorCache();
-#endif  // defined(XP_WIN)
-
- private:
-  static StaticAutoPtr<FunctionHookArray> sFunctionHooks;
-  static void AddFunctionHooks(FunctionHookArray& aHooks);
-};
-
-// The FunctionHookArray deletes its FunctionHook objects when freed.
-class FunctionHookArray : public nsTArray<FunctionHook*> {
- public:
-  ~FunctionHookArray() {
-    for (uint32_t idx = 0; idx < Length(); ++idx) {
-      FunctionHook* elt = ElementAt(idx);
-      MOZ_ASSERT(elt);
-      delete elt;
-    }
-  }
-};
-
-// Type of function that returns true if a function should be hooked according
-// to quirks.
-typedef bool(ShouldHookFunc)(int aQuirks);
-
-template <FunctionHookId functionId, typename FunctionType>
-class BasicFunctionHook : public FunctionHook {
-#if defined(XP_WIN)
-  using FuncHookType = WindowsDllInterceptor::FuncHookType<FunctionType*>;
-#endif  // defined(XP_WIN)
-
- public:
-  BasicFunctionHook(const char* aModuleName, const char* aFunctionName,
-                    FunctionType* aOldFunction, FunctionType* aNewFunction)
-      : mOldFunction(aOldFunction),
-        mRegistration(UNREGISTERED),
-        mModuleName(aModuleName),
-        mFunctionName(aFunctionName),
-        mNewFunction(aNewFunction) {
-    MOZ_ASSERT(mOldFunction);
-    MOZ_ASSERT(mNewFunction);
-  }
-
-  /**
-   * Hooks the function if we haven't already and if ShouldHook() says to.
-   */
-  bool Register(int aQuirks) override;
-
-  /**
-   * Can be specialized to perform "extra" operations when running the
-   * function on the server side.
-   */
-  bool RunOriginalFunction(base::ProcessId aClientId,
-                           const IPC::IpdlTuple& aInTuple,
-                           IPC::IpdlTuple* aOutTuple) const override {
-    return false;
-  }
-
-  FunctionHookId FunctionId() const override { return functionId; }
-
-  FunctionType* OriginalFunction() const { return mOldFunction; }
-
- protected:
-  // Once the function is hooked, this field will take the value of a pointer to
-  // a function that performs the old behavior.  Before that, it is a pointer to
-  // the original function.
-  Atomic<FunctionType*> mOldFunction;
-#if defined(XP_WIN)
-  FuncHookType mStub;
-#endif  // defined(XP_WIN)
-
-  enum RegistrationStatus { UNREGISTERED, FAILED, SUCCEEDED };
-  RegistrationStatus mRegistration;
-
-  // The name of the module containing the function to hook.  E.g. "user32.dll".
-  const nsCString mModuleName;
-  // The name of the function in the module.
-  const nsCString mFunctionName;
-  // The function that we should replace functionName with.  The signature of
-  // newFunction must match that of functionName.
-  FunctionType* const mNewFunction;
-  static ShouldHookFunc* const mShouldHook;
-};
-
-// Default behavior is to hook every registered function.
-extern bool AlwaysHook(int);
-template <FunctionHookId functionId, typename FunctionType>
-ShouldHookFunc* const BasicFunctionHook<functionId, FunctionType>::mShouldHook =
-    AlwaysHook;
-
-template <FunctionHookId functionId, typename FunctionType>
-bool BasicFunctionHook<functionId, FunctionType>::Register(int aQuirks) {
-  MOZ_RELEASE_ASSERT(XRE_IsPluginProcess());
-
-  // If we have already attempted to hook this function or if quirks tell us
-  // not to then don't hook.
-  if (mRegistration != UNREGISTERED || !mShouldHook(aQuirks)) {
-    return true;
-  }
-
-  bool isHooked = false;
-  mRegistration = FAILED;
-
-#if defined(XP_WIN)
-  WindowsDllInterceptor* dllInterceptor =
-      FunctionHook::GetDllInterceptorFor(mModuleName.Data());
-  if (!dllInterceptor) {
-    return false;
-  }
-
-  isHooked = mStub.Set(*dllInterceptor, mFunctionName.Data(), mNewFunction);
-#endif
-
-  if (isHooked) {
-#if defined(XP_WIN)
-    mOldFunction = mStub.GetStub();
-#endif
-    mRegistration = SUCCEEDED;
-  }
-
-  HOOK_LOG(LogLevel::Debug, ("Registering to intercept function '%s' : '%s'",
-                             mFunctionName.Data(), SuccessMsg(isHooked)));
-
-  return isHooked;
-}
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // dom_plugins_ipc_functionhook_h
diff --git a/dom/plugins/ipc/IpdlTuple.h b/dom/plugins/ipc/IpdlTuple.h
deleted file mode 100644
index 06db9bfddba08..0000000000000
--- a/dom/plugins/ipc/IpdlTuple.h
+++ /dev/null
@@ -1,186 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=8 sts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef dom_plugins_ipc_ipdltuple_h
-#define dom_plugins_ipc_ipdltuple_h
-
-#include "ipc/IPCMessageUtilsSpecializations.h"
-#include "mozilla/plugins/FunctionBrokerIPCUtils.h"
-#include "mozilla/Variant.h"
-
-namespace mozilla {
-namespace plugins {
-
-// The stuff in this "internal" namespace used to be inside the IpdlTuple
-// class, but that prevented the MOZ_DECLARE_RELOCATE_USING_MOVE_CONSTRUCTOR
-// that is needed on the IpdlTupleElement struct. Without this, nsTArray can end
-// up using a move constructor on this struct, which is not memmovable on
-// Windows.
-namespace internal {
-
-struct InvalidType {};
-
-// Like Variant but with a default constructor.
-template <typename... Types>
-struct MaybeVariant {
- public:
-  MaybeVariant() : mValue(InvalidType()) {}
-  MaybeVariant(MaybeVariant&& o) : mValue(std::move(o.mValue)) {}
-
-  template <typename Param>
-  void Set(const Param& aParam) {
-    mValue = mozilla::AsVariant(aParam);
-  }
-
-  typedef mozilla::Variant<InvalidType, Types...> MaybeVariantType;
-  MaybeVariantType& GetVariant() { return mValue; }
-  const MaybeVariantType& GetVariant() const { return mValue; }
-
- private:
-  MaybeVariantType mValue;
-};
-
-#if defined(XP_WIN)
-typedef MaybeVariant<int8_t, uint8_t, int16_t, uint16_t, int32_t, uint32_t,
-                     int64_t, uint64_t, nsCString, nsString, bool,
-                     OpenFileNameIPC, OpenFileNameRetIPC, NativeWindowHandle,
-                     IPCSchannelCred, IPCInternetBuffers, StringArray,
-                     IPCPrintDlg>
-    IpdlTupleElement;
-#else
-typedef MaybeVariant<int8_t, uint8_t, int16_t, uint16_t, int32_t, uint32_t,
-                     int64_t, uint64_t, nsCString, nsString, bool>
-    IpdlTupleElement;
-#endif  // defined(XP_WIN)
-
-}  // namespace internal
-}  // namespace plugins
-}  // namespace mozilla
-
-MOZ_DECLARE_RELOCATE_USING_MOVE_CONSTRUCTOR(
-    mozilla::plugins::internal::IpdlTupleElement)
-
-namespace mozilla {
-namespace plugins {
-
-/**
- * IpdlTuple is used by automatic function brokering to pass parameter
- * lists for brokered functions.  It supports a limited set of types
- * (see IpdlTuple::IpdlTupleElement).
- */
-class IpdlTuple {
- public:
-  uint32_t NumElements() const { return mTupleElements.Length(); }
-
-  template <typename EltType>
-  EltType* Element(uint32_t index) {
-    if ((index >= mTupleElements.Length()) ||
-        !mTupleElements[index].GetVariant().is<EltType>()) {
-      return nullptr;
-    }
-    return &mTupleElements[index].GetVariant().as<EltType>();
-  }
-
-  template <typename EltType>
-  const EltType* Element(uint32_t index) const {
-    return const_cast<IpdlTuple*>(this)->Element<EltType>(index);
-  }
-
-  template <typename EltType>
-  void AddElement(const EltType& aElt) {
-    IpdlTupleElement* newEntry = mTupleElements.AppendElement();
-    newEntry->Set(aElt);
-  }
-
- private:
-  typedef mozilla::plugins::internal::InvalidType InvalidType;
-  typedef mozilla::plugins::internal::IpdlTupleElement IpdlTupleElement;
-
-  friend struct IPC::ParamTraits<IpdlTuple>;
-  friend struct IPC::ParamTraits<IpdlTuple::IpdlTupleElement>;
-  friend struct IPC::ParamTraits<IpdlTuple::InvalidType>;
-
-  nsTArray<IpdlTupleElement> mTupleElements;
-};
-
-namespace internal {
-template <>
-template <>
-inline void IpdlTupleElement::Set<nsDependentCSubstring>(
-    const nsDependentCSubstring& aParam) {
-  mValue = MaybeVariantType(mozilla::VariantType<nsCString>(), aParam);
-}
-}  // namespace internal
-
-}  // namespace plugins
-}  // namespace mozilla
-
-namespace IPC {
-
-using namespace mozilla::plugins;
-
-template <>
-struct ParamTraits<IpdlTuple> {
-  typedef IpdlTuple paramType;
-
-  static void Write(Message* aMsg, const paramType& aParam) {
-    WriteParam(aMsg, aParam.mTupleElements);
-  }
-
-  static bool Read(const Message* aMsg, PickleIterator* aIter,
-                   paramType* aParam) {
-    return ReadParam(aMsg, aIter, &aParam->mTupleElements);
-  }
-
-  static void Log(const paramType& aParam, std::wstring* aLog) {
-    LogParam(aParam.mTupleElements, aLog);
-  }
-};
-
-template <>
-struct ParamTraits<IpdlTuple::IpdlTupleElement> {
-  typedef IpdlTuple::IpdlTupleElement paramType;
-
-  static void Write(Message* aMsg, const paramType& aParam) {
-    MOZ_RELEASE_ASSERT(!aParam.GetVariant().is<IpdlTuple::InvalidType>());
-    WriteParam(aMsg, aParam.GetVariant());
-  }
-
-  static bool Read(const Message* aMsg, PickleIterator* aIter,
-                   paramType* aParam) {
-    bool ret = ReadParam(aMsg, aIter, &aParam->GetVariant());
-    MOZ_RELEASE_ASSERT(!aParam->GetVariant().is<IpdlTuple::InvalidType>());
-    return ret;
-  }
-
-  static void Log(const paramType& aParam, std::wstring* aLog) {
-    aParam.GetVariant().match(
-        [aLog](const auto& aParam) { LogParam(aParam, aLog); });
-  }
-};
-
-template <>
-struct ParamTraits<IpdlTuple::InvalidType> {
-  typedef IpdlTuple::InvalidType paramType;
-
-  static void Write(Message* aMsg, const paramType& aParam) {
-    MOZ_ASSERT_UNREACHABLE("Attempt to serialize an invalid tuple element");
-  }
-
-  static bool Read(const Message* aMsg, PickleIterator* aIter,
-                   paramType* aParam) {
-    MOZ_ASSERT_UNREACHABLE("Attempt to deserialize an invalid tuple element");
-    return false;
-  }
-
-  static void Log(const paramType& aParam, std::wstring* aLog) {
-    aLog->append(L"<Invalid Tuple Entry>");
-  }
-};
-
-}  // namespace IPC
-
-#endif /* dom_plugins_ipc_ipdltuple_h */
diff --git a/dom/plugins/ipc/MiniShmParent.cpp b/dom/plugins/ipc/MiniShmParent.cpp
deleted file mode 100644
index 874b7fe339e0f..0000000000000
--- a/dom/plugins/ipc/MiniShmParent.cpp
+++ /dev/null
@@ -1,178 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "MiniShmParent.h"
-
-#include "base/scoped_handle.h"
-
-#include <sstream>
-
-namespace mozilla {
-namespace plugins {
-
-// static
-const unsigned int MiniShmParent::kDefaultMiniShmSectionSize = 0x1000;
-
-MiniShmParent::MiniShmParent()
-    : mSectionSize(0),
-      mParentEvent(nullptr),
-      mParentGuard(nullptr),
-      mChildEvent(nullptr),
-      mChildGuard(nullptr),
-      mRegWait(nullptr),
-      mFileMapping(nullptr),
-      mView(nullptr),
-      mIsConnected(false),
-      mTimeout(INFINITE) {}
-
-MiniShmParent::~MiniShmParent() { CleanUp(); }
-
-void MiniShmParent::CleanUp() {
-  if (mRegWait) {
-    ::UnregisterWaitEx(mRegWait, INVALID_HANDLE_VALUE);
-    mRegWait = nullptr;
-  }
-  if (mParentEvent) {
-    ::CloseHandle(mParentEvent);
-    mParentEvent = nullptr;
-  }
-  if (mParentGuard) {
-    ::CloseHandle(mParentGuard);
-    mParentGuard = nullptr;
-  }
-  if (mChildEvent) {
-    ::CloseHandle(mChildEvent);
-    mChildEvent = nullptr;
-  }
-  if (mChildGuard) {
-    ::CloseHandle(mChildGuard);
-    mChildGuard = nullptr;
-  }
-  if (mView) {
-    ::UnmapViewOfFile(mView);
-    mView = nullptr;
-  }
-  if (mFileMapping) {
-    ::CloseHandle(mFileMapping);
-    mFileMapping = nullptr;
-  }
-}
-
-nsresult MiniShmParent::Init(MiniShmObserver* aObserver, const DWORD aTimeout,
-                             const unsigned int aSectionSize) {
-  if (!aObserver || !aSectionSize || (aSectionSize % 0x1000) || !aTimeout) {
-    return NS_ERROR_ILLEGAL_VALUE;
-  }
-  if (mFileMapping) {
-    return NS_ERROR_ALREADY_INITIALIZED;
-  }
-  SECURITY_ATTRIBUTES securityAttributes = {sizeof(securityAttributes), nullptr,
-                                            TRUE};
-  ScopedHandle parentEvent(
-      ::CreateEvent(&securityAttributes, FALSE, FALSE, nullptr));
-  if (!parentEvent.IsValid()) {
-    return NS_ERROR_FAILURE;
-  }
-  ScopedHandle parentGuard(
-      ::CreateEvent(&securityAttributes, FALSE, TRUE, nullptr));
-  if (!parentGuard.IsValid()) {
-    return NS_ERROR_FAILURE;
-  }
-  ScopedHandle childEvent(
-      ::CreateEvent(&securityAttributes, FALSE, FALSE, nullptr));
-  if (!childEvent.IsValid()) {
-    return NS_ERROR_FAILURE;
-  }
-  ScopedHandle childGuard(
-      ::CreateEvent(&securityAttributes, FALSE, TRUE, nullptr));
-  if (!childGuard.IsValid()) {
-    return NS_ERROR_FAILURE;
-  }
-  ScopedHandle mapping(::CreateFileMapping(INVALID_HANDLE_VALUE,
-                                           &securityAttributes, PAGE_READWRITE,
-                                           0, aSectionSize, nullptr));
-  if (!mapping.IsValid()) {
-    return NS_ERROR_FAILURE;
-  }
-  ScopedMappedFileView view(::MapViewOfFile(mapping, FILE_MAP_WRITE, 0, 0, 0));
-  if (!view.IsValid()) {
-    return NS_ERROR_FAILURE;
-  }
-  nsresult rv = SetView(view, aSectionSize, false);
-  NS_ENSURE_SUCCESS(rv, rv);
-  rv = SetGuard(childGuard, aTimeout);
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  MiniShmInit* initStruct = nullptr;
-  rv = GetWritePtrInternal(initStruct);
-  NS_ENSURE_SUCCESS(rv, rv);
-  initStruct->mParentEvent = parentEvent;
-  initStruct->mParentGuard = parentGuard;
-  initStruct->mChildEvent = childEvent;
-  initStruct->mChildGuard = childGuard;
-
-  if (!::RegisterWaitForSingleObject(&mRegWait, parentEvent, &SOnEvent, this,
-                                     INFINITE, WT_EXECUTEDEFAULT)) {
-    return NS_ERROR_FAILURE;
-  }
-
-  mParentEvent = parentEvent.Take();
-  mParentGuard = parentGuard.Take();
-  mChildEvent = childEvent.Take();
-  mChildGuard = childGuard.Take();
-  mFileMapping = mapping.Take();
-  mView = view.Take();
-  mSectionSize = aSectionSize;
-  SetObserver(aObserver);
-  mTimeout = aTimeout;
-  return NS_OK;
-}
-
-nsresult MiniShmParent::GetCookie(std::wstring& cookie) {
-  if (!mFileMapping) {
-    return NS_ERROR_NOT_INITIALIZED;
-  }
-  std::wostringstream oss;
-  oss << mFileMapping;
-  if (!oss) {
-    return NS_ERROR_FAILURE;
-  }
-  cookie = oss.str();
-  return NS_OK;
-}
-
-nsresult MiniShmParent::Send() {
-  if (!mChildEvent) {
-    return NS_ERROR_NOT_INITIALIZED;
-  }
-  if (!::SetEvent(mChildEvent)) {
-    return NS_ERROR_FAILURE;
-  }
-  return NS_OK;
-}
-
-bool MiniShmParent::IsConnected() const { return mIsConnected; }
-
-void MiniShmParent::OnEvent() {
-  if (mIsConnected) {
-    MiniShmBase::OnEvent();
-  } else {
-    FinalizeConnection();
-  }
-  ::SetEvent(mParentGuard);
-}
-
-void MiniShmParent::FinalizeConnection() {
-  const MiniShmInitComplete* initCompleteStruct = nullptr;
-  nsresult rv = GetReadPtr(initCompleteStruct);
-  mIsConnected = NS_SUCCEEDED(rv) && initCompleteStruct->mSucceeded;
-  if (mIsConnected) {
-    OnConnect();
-  }
-}
-
-}  // namespace plugins
-}  // namespace mozilla
diff --git a/dom/plugins/ipc/MiniShmParent.h b/dom/plugins/ipc/MiniShmParent.h
deleted file mode 100644
index 06eec62560fcc..0000000000000
--- a/dom/plugins/ipc/MiniShmParent.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_plugins_MiniShmParent_h
-#define mozilla_plugins_MiniShmParent_h
-
-#include "MiniShmBase.h"
-
-#include <string>
-
-namespace mozilla {
-namespace plugins {
-
-/**
- * This class provides a lightweight shared memory interface for a parent
- * process in Win32.
- * This code assumes that there is a parent-child relationship between
- * processes, as it creates inheritable handles.
- * Note that this class is *not* an IPDL actor.
- *
- * @see MiniShmChild
- */
-class MiniShmParent : public MiniShmBase {
- public:
-  MiniShmParent();
-  virtual ~MiniShmParent();
-
-  static const unsigned int kDefaultMiniShmSectionSize;
-
-  /**
-   * Initialize shared memory on the parent side.
-   *
-   * @param aObserver A MiniShmObserver object to receive event notifications.
-   * @param aTimeout Timeout in milliseconds.
-   * @param aSectionSize Desired size of the shared memory section. This is
-   *                     expected to be a multiple of 0x1000 (4KiB).
-   * @return nsresult error code
-   */
-  nsresult Init(MiniShmObserver* aObserver, const DWORD aTimeout,
-                const unsigned int aSectionSize = kDefaultMiniShmSectionSize);
-
-  /**
-   * Destroys the shared memory section. Useful to explicitly release
-   * resources if it is known that they won't be needed again.
-   */
-  void CleanUp();
-
-  /**
-   * Provides a cookie string that should be passed to MiniShmChild
-   * during its initialization.
-   *
-   * @param aCookie A std::wstring variable to receive the cookie.
-   * @return nsresult error code
-   */
-  nsresult GetCookie(std::wstring& aCookie);
-
-  virtual nsresult Send() override;
-
-  bool IsConnected() const;
-
- protected:
-  void OnEvent() override;
-
- private:
-  void FinalizeConnection();
-
-  unsigned int mSectionSize;
-  HANDLE mParentEvent;
-  HANDLE mParentGuard;
-  HANDLE mChildEvent;
-  HANDLE mChildGuard;
-  HANDLE mRegWait;
-  HANDLE mFileMapping;
-  LPVOID mView;
-  bool mIsConnected;
-  DWORD mTimeout;
-
-  DISALLOW_COPY_AND_ASSIGN(MiniShmParent);
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // mozilla_plugins_MiniShmParent_h
diff --git a/dom/plugins/ipc/NPEventAndroid.h b/dom/plugins/ipc/NPEventAndroid.h
deleted file mode 100644
index 0aa94a1bc1da6..0000000000000
--- a/dom/plugins/ipc/NPEventAndroid.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
-/* vim: set sw=2 ts=8 et tw=80 ft=cpp : */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-// This is a NPEventX11.h derived stub for Android
-// Plugins aren't actually supported yet
-
-#ifndef mozilla_dom_plugins_NPEventAndroid_h
-#define mozilla_dom_plugins_NPEventAndroid_h
-
-#include "npapi.h"
-
-namespace mozilla {
-
-namespace plugins {
-
-struct NPRemoteEvent {
-  NPEvent event;
-};
-
-}  // namespace plugins
-
-}  // namespace mozilla
-
-namespace IPC {
-
-template <>
-struct ParamTraits<mozilla::plugins::NPRemoteEvent> {
-  typedef mozilla::plugins::NPRemoteEvent paramType;
-
-  static void Write(Message* aMsg, const paramType& aParam) {
-    aMsg->WriteBytes(&aParam, sizeof(paramType));
-  }
-
-  static bool Read(const Message* aMsg, PickleIterator* aIter,
-                   paramType* aResult) {
-    return aMsg->ReadBytesInto(aIter, aResult, sizeof(paramType));
-  }
-
-  static void Log(const paramType& aParam, std::wstring* aLog) {
-    // TODO
-    aLog->append(L"(AndroidEvent)");
-  }
-};
-
-}  // namespace IPC
-
-#endif  // mozilla_dom_plugins_NPEventAndroid_h
diff --git a/dom/plugins/ipc/NPEventOSX.h b/dom/plugins/ipc/NPEventOSX.h
deleted file mode 100644
index 9e24c426e5551..0000000000000
--- a/dom/plugins/ipc/NPEventOSX.h
+++ /dev/null
@@ -1,198 +0,0 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
-/* vim: set sw=2 ts=8 et tw=80 ft=cpp : */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_dom_plugins_NPEventOSX_h
-#define mozilla_dom_plugins_NPEventOSX_h 1
-
-#include "npapi.h"
-
-namespace mozilla {
-
-namespace plugins {
-
-struct NPRemoteEvent {
-  NPCocoaEvent event;
-  double contentsScaleFactor;
-};
-
-}  // namespace plugins
-
-}  // namespace mozilla
-
-namespace IPC {
-
-template <>
-struct ParamTraits<mozilla::plugins::NPRemoteEvent> {
-  typedef mozilla::plugins::NPRemoteEvent paramType;
-
-  static void Write(Message* aMsg, const paramType& aParam) {
-    aMsg->WriteInt(aParam.event.type);
-    aMsg->WriteUInt32(aParam.event.version);
-    switch (aParam.event.type) {
-      case NPCocoaEventMouseDown:
-      case NPCocoaEventMouseUp:
-      case NPCocoaEventMouseMoved:
-      case NPCocoaEventMouseEntered:
-      case NPCocoaEventMouseExited:
-      case NPCocoaEventMouseDragged:
-      case NPCocoaEventScrollWheel:
-        aMsg->WriteUInt32(aParam.event.data.mouse.modifierFlags);
-        aMsg->WriteDouble(aParam.event.data.mouse.pluginX);
-        aMsg->WriteDouble(aParam.event.data.mouse.pluginY);
-        aMsg->WriteInt32(aParam.event.data.mouse.buttonNumber);
-        aMsg->WriteInt32(aParam.event.data.mouse.clickCount);
-        aMsg->WriteDouble(aParam.event.data.mouse.deltaX);
-        aMsg->WriteDouble(aParam.event.data.mouse.deltaY);
-        aMsg->WriteDouble(aParam.event.data.mouse.deltaZ);
-        break;
-      case NPCocoaEventKeyDown:
-      case NPCocoaEventKeyUp:
-      case NPCocoaEventFlagsChanged:
-        aMsg->WriteUInt32(aParam.event.data.key.modifierFlags);
-        WriteParam(aMsg, aParam.event.data.key.characters);
-        WriteParam(aMsg, aParam.event.data.key.charactersIgnoringModifiers);
-        aMsg->WriteUnsignedChar(aParam.event.data.key.isARepeat);
-        aMsg->WriteUInt16(aParam.event.data.key.keyCode);
-        break;
-      case NPCocoaEventFocusChanged:
-      case NPCocoaEventWindowFocusChanged:
-        aMsg->WriteUnsignedChar(aParam.event.data.focus.hasFocus);
-        break;
-      case NPCocoaEventDrawRect:
-        // We don't write out the context pointer, it would always be
-        // nullptr and is just filled in as such on the read.
-        aMsg->WriteDouble(aParam.event.data.draw.x);
-        aMsg->WriteDouble(aParam.event.data.draw.y);
-        aMsg->WriteDouble(aParam.event.data.draw.width);
-        aMsg->WriteDouble(aParam.event.data.draw.height);
-        break;
-      case NPCocoaEventTextInput:
-        WriteParam(aMsg, aParam.event.data.text.text);
-        break;
-      default:
-        MOZ_ASSERT_UNREACHABLE(
-            "Attempted to serialize unknown event "
-            "type.");
-        return;
-    }
-    aMsg->WriteDouble(aParam.contentsScaleFactor);
-  }
-
-  static bool Read(const Message* aMsg, PickleIterator* aIter,
-                   paramType* aResult) {
-    int type = 0;
-    if (!aMsg->ReadInt(aIter, &type)) {
-      return false;
-    }
-    aResult->event.type = static_cast<NPCocoaEventType>(type);
-
-    if (!aMsg->ReadUInt32(aIter, &aResult->event.version)) {
-      return false;
-    }
-
-    switch (aResult->event.type) {
-      case NPCocoaEventMouseDown:
-      case NPCocoaEventMouseUp:
-      case NPCocoaEventMouseMoved:
-      case NPCocoaEventMouseEntered:
-      case NPCocoaEventMouseExited:
-      case NPCocoaEventMouseDragged:
-      case NPCocoaEventScrollWheel:
-        if (!aMsg->ReadUInt32(aIter,
-                              &aResult->event.data.mouse.modifierFlags)) {
-          return false;
-        }
-        if (!aMsg->ReadDouble(aIter, &aResult->event.data.mouse.pluginX)) {
-          return false;
-        }
-        if (!aMsg->ReadDouble(aIter, &aResult->event.data.mouse.pluginY)) {
-          return false;
-        }
-        if (!aMsg->ReadInt32(aIter, &aResult->event.data.mouse.buttonNumber)) {
-          return false;
-        }
-        if (!aMsg->ReadInt32(aIter, &aResult->event.data.mouse.clickCount)) {
-          return false;
-        }
-        if (!aMsg->ReadDouble(aIter, &aResult->event.data.mouse.deltaX)) {
-          return false;
-        }
-        if (!aMsg->ReadDouble(aIter, &aResult->event.data.mouse.deltaY)) {
-          return false;
-        }
-        if (!aMsg->ReadDouble(aIter, &aResult->event.data.mouse.deltaZ)) {
-          return false;
-        }
-        break;
-      case NPCocoaEventKeyDown:
-      case NPCocoaEventKeyUp:
-      case NPCocoaEventFlagsChanged:
-        if (!aMsg->ReadUInt32(aIter, &aResult->event.data.key.modifierFlags)) {
-          return false;
-        }
-        if (!ReadParam(aMsg, aIter, &aResult->event.data.key.characters)) {
-          return false;
-        }
-        if (!ReadParam(aMsg, aIter,
-                       &aResult->event.data.key.charactersIgnoringModifiers)) {
-          return false;
-        }
-        if (!aMsg->ReadUnsignedChar(aIter,
-                                    &aResult->event.data.key.isARepeat)) {
-          return false;
-        }
-        if (!aMsg->ReadUInt16(aIter, &aResult->event.data.key.keyCode)) {
-          return false;
-        }
-        break;
-      case NPCocoaEventFocusChanged:
-      case NPCocoaEventWindowFocusChanged:
-        if (!aMsg->ReadUnsignedChar(aIter,
-                                    &aResult->event.data.focus.hasFocus)) {
-          return false;
-        }
-        break;
-      case NPCocoaEventDrawRect:
-        aResult->event.data.draw.context = nullptr;
-        if (!aMsg->ReadDouble(aIter, &aResult->event.data.draw.x)) {
-          return false;
-        }
-        if (!aMsg->ReadDouble(aIter, &aResult->event.data.draw.y)) {
-          return false;
-        }
-        if (!aMsg->ReadDouble(aIter, &aResult->event.data.draw.width)) {
-          return false;
-        }
-        if (!aMsg->ReadDouble(aIter, &aResult->event.data.draw.height)) {
-          return false;
-        }
-        break;
-      case NPCocoaEventTextInput:
-        if (!ReadParam(aMsg, aIter, &aResult->event.data.text.text)) {
-          return false;
-        }
-        break;
-      default:
-        MOZ_ASSERT_UNREACHABLE(
-            "Attempted to de-serialize unknown "
-            "event type.");
-        return false;
-    }
-    if (!aMsg->ReadDouble(aIter, &aResult->contentsScaleFactor)) {
-      return false;
-    }
-
-    return true;
-  }
-
-  static void Log(const paramType& aParam, std::wstring* aLog) {
-    aLog->append(L"(NPCocoaEvent)");
-  }
-};
-
-}  // namespace IPC
-
-#endif  // ifndef mozilla_dom_plugins_NPEventOSX_h
diff --git a/dom/plugins/ipc/NPEventUnix.h b/dom/plugins/ipc/NPEventUnix.h
deleted file mode 100644
index 55494b4d8ce85..0000000000000
--- a/dom/plugins/ipc/NPEventUnix.h
+++ /dev/null
@@ -1,90 +0,0 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
-/* vim: set sw=2 ts=8 et tw=80 ft=cpp : */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_dom_plugins_NPEventUnix_h
-#define mozilla_dom_plugins_NPEventUnix_h 1
-
-#include "npapi.h"
-
-#ifdef MOZ_X11
-#  include "mozilla/X11Util.h"
-#endif
-
-namespace mozilla {
-
-namespace plugins {
-
-struct NPRemoteEvent {
-  NPEvent event;
-};
-
-}  // namespace plugins
-
-}  // namespace mozilla
-
-//
-// XEvent is defined as a union of all more specific X*Events.
-// Luckily, as of xorg 1.6.0 / X protocol 11 rev 0, the only pointer
-// field contained in any of these specific X*Event structs is a
-// |Display*|.  So to simplify serializing these XEvents, we make the
-//
-// ********** XXX ASSUMPTION XXX **********
-//
-// that the process to which the event is forwarded shares the same
-// display as the process on which the event originated.
-//
-// With this simplification, serialization becomes a simple memcpy to
-// the output stream.  Deserialization starts as just a memcpy from
-// the input stream, BUT we then have to write the correct |Display*|
-// into the right field of each X*Event that contains one.
-//
-
-namespace IPC {
-
-template <>
-struct ParamTraits<mozilla::plugins::NPRemoteEvent>  // synonym for XEvent
-{
-  typedef mozilla::plugins::NPRemoteEvent paramType;
-
-  static void Write(Message* aMsg, const paramType& aParam) {
-    aMsg->WriteBytes(&aParam, sizeof(paramType));
-  }
-
-  static bool Read(const Message* aMsg, PickleIterator* aIter,
-                   paramType* aResult) {
-    if (!aMsg->ReadBytesInto(aIter, aResult, sizeof(paramType))) {
-      return false;
-    }
-
-#ifdef MOZ_X11
-    SetXDisplay(aResult->event);
-#endif
-    return true;
-  }
-
-  static void Log(const paramType& aParam, std::wstring* aLog) {
-    // TODO
-    aLog->append(L"(XEvent)");
-  }
-
-#ifdef MOZ_X11
- private:
-  static void SetXDisplay(XEvent& ev) {
-    Display* display = mozilla::DefaultXDisplay();
-    if (ev.type >= KeyPress) {
-      ev.xany.display = display;
-    } else {
-      // XXX assuming that this is an error event
-      // (type == 0? not clear from Xlib.h)
-      ev.xerror.display = display;
-    }
-  }
-#endif
-};
-
-}  // namespace IPC
-
-#endif  // ifndef mozilla_dom_plugins_NPEventX11_h
diff --git a/dom/plugins/ipc/NPEventWindows.h b/dom/plugins/ipc/NPEventWindows.h
deleted file mode 100644
index b2429883f8822..0000000000000
--- a/dom/plugins/ipc/NPEventWindows.h
+++ /dev/null
@@ -1,158 +0,0 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
-/* vim: set sw=2 ts=8 et tw=80 ft=cpp : */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_dom_plugins_NPEventWindows_h
-#define mozilla_dom_plugins_NPEventWindows_h 1
-
-#ifndef WM_MOUSEHWHEEL
-#  define WM_MOUSEHWHEEL (0x020E)
-#endif
-
-#include "npapi.h"
-namespace mozilla {
-
-namespace plugins {
-
-// We use an NPRemoteEvent struct so that we can store the extra data on
-// the stack so that we don't need to worry about managing the memory.
-struct NPRemoteEvent {
-  NPEvent event;
-  union {
-    RECT rect;
-    WINDOWPOS windowpos;
-  } lParamData;
-  double contentsScaleFactor;
-};
-
-}  // namespace plugins
-
-}  // namespace mozilla
-
-namespace IPC {
-
-template <>
-struct ParamTraits<mozilla::plugins::NPRemoteEvent> {
-  typedef mozilla::plugins::NPRemoteEvent paramType;
-
-  static void Write(Message* aMsg, const paramType& aParam) {
-    // Make a non-const copy of aParam so that we can muck with
-    // its insides for tranport
-    paramType paramCopy;
-
-    paramCopy.event = aParam.event;
-
-    // We can't blindly ipc events because they may sometimes contain
-    // pointers to memory in the sending process. For example, the
-    // WM_IME_CONTROL with the IMC_GETCOMPOSITIONFONT message has lParam
-    // set to a pointer to a LOGFONT structure.
-    switch (paramCopy.event.event) {
-      case WM_WINDOWPOSCHANGED:
-        // The lParam parameter of WM_WINDOWPOSCHANGED holds a pointer to
-        // a WINDOWPOS structure that contains information about the
-        // window's new size and position
-        paramCopy.lParamData.windowpos =
-            *(reinterpret_cast<WINDOWPOS*>(paramCopy.event.lParam));
-        break;
-      case WM_PAINT:
-        // The lParam parameter of WM_PAINT holds a pointer to an RECT
-        // structure specifying the bounding box of the update area.
-        paramCopy.lParamData.rect =
-            *(reinterpret_cast<RECT*>(paramCopy.event.lParam));
-        break;
-
-      // the white list of events that we will ipc to the client
-      case WM_CHAR:
-      case WM_SYSCHAR:
-
-      case WM_KEYUP:
-      case WM_SYSKEYUP:
-
-      case WM_KEYDOWN:
-      case WM_SYSKEYDOWN:
-
-      case WM_DEADCHAR:
-      case WM_SYSDEADCHAR:
-      case WM_CONTEXTMENU:
-
-      case WM_CUT:
-      case WM_COPY:
-      case WM_PASTE:
-      case WM_CLEAR:
-      case WM_UNDO:
-
-      case WM_MOUSELEAVE:
-      case WM_MOUSEMOVE:
-      case WM_LBUTTONDOWN:
-      case WM_MBUTTONDOWN:
-      case WM_RBUTTONDOWN:
-      case WM_LBUTTONUP:
-      case WM_MBUTTONUP:
-      case WM_RBUTTONUP:
-      case WM_LBUTTONDBLCLK:
-      case WM_MBUTTONDBLCLK:
-      case WM_RBUTTONDBLCLK:
-
-      case WM_MOUSEWHEEL:
-      case WM_MOUSEHWHEEL:
-
-      case WM_SETFOCUS:
-      case WM_KILLFOCUS:
-
-      case WM_IME_STARTCOMPOSITION:
-      case WM_IME_COMPOSITION:
-      case WM_IME_ENDCOMPOSITION:
-      case WM_IME_CHAR:
-      case WM_IME_SETCONTEXT:
-      case WM_IME_COMPOSITIONFULL:
-      case WM_IME_KEYDOWN:
-      case WM_IME_KEYUP:
-      case WM_IME_SELECT:
-      case WM_INPUTLANGCHANGEREQUEST:
-      case WM_INPUTLANGCHANGE:
-        break;
-
-      default:
-        // RegisterWindowMessage events should be passed.
-        if (paramCopy.event.event >= 0xC000) break;
-
-        // FIXME/bug 567465: temporarily work around unhandled
-        // events by forwarding a "dummy event".  The eventual
-        // fix will be to stop trying to send these events
-        // entirely.
-        paramCopy.event.event = WM_NULL;
-        break;
-    }
-
-    aMsg->WriteBytes(&paramCopy, sizeof(paramType));
-  }
-
-  static bool Read(const Message* aMsg, PickleIterator* aIter,
-                   paramType* aResult) {
-    if (!aMsg->ReadBytesInto(aIter, aResult, sizeof(paramType))) {
-      return false;
-    }
-
-    if (aResult->event.event == WM_PAINT) {
-      // restore the lParam to point at the RECT
-      aResult->event.lParam =
-          reinterpret_cast<LPARAM>(&aResult->lParamData.rect);
-    } else if (aResult->event.event == WM_WINDOWPOSCHANGED) {
-      // restore the lParam to point at the WINDOWPOS
-      aResult->event.lParam =
-          reinterpret_cast<LPARAM>(&aResult->lParamData.windowpos);
-    }
-
-    return true;
-  }
-
-  static void Log(const paramType& aParam, std::wstring* aLog) {
-    aLog->append(L"(WINEvent)");
-  }
-};
-
-}  // namespace IPC
-
-#endif  // ifndef mozilla_dom_plugins_NPEventWindows_h
diff --git a/dom/plugins/ipc/PBrowserStream.ipdl b/dom/plugins/ipc/PBrowserStream.ipdl
deleted file mode 100644
index 65548ca06fd9a..0000000000000
--- a/dom/plugins/ipc/PBrowserStream.ipdl
+++ /dev/null
@@ -1,42 +0,0 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-include protocol PPluginInstance;
-
-
-using mozilla::plugins::Buffer from "mozilla/plugins/PluginMessageUtils.h";
-using mozilla::plugins::IPCByteRanges from "mozilla/plugins/PluginMessageUtils.h";
-
-using NPError from "npapi.h";
-using NPReason from "npapi.h";
-
-namespace mozilla {
-namespace plugins {
-
-/**
- * NPBrowserStream represents a NPStream sent from the browser to the plugin.
- */
-
-intr protocol PBrowserStream
-{
-  manager PPluginInstance;
-
-child:
-  async Write(int32_t offset, uint32_t newlength,
-              Buffer data);
-
-  /**
-   * NPP_DestroyStream may race with other messages: the child acknowledges
-   * the message with StreamDestroyed before this actor is deleted.
-   */
-  async NPP_DestroyStream(NPReason reason);
-  async __delete__();
-
-parent:
-  async StreamDestroyed();
-};
-
-} // namespace plugins
-} // namespace mozilla
diff --git a/dom/plugins/ipc/PFunctionBroker.ipdl b/dom/plugins/ipc/PFunctionBroker.ipdl
deleted file mode 100644
index d8ecb76746d0b..0000000000000
--- a/dom/plugins/ipc/PFunctionBroker.ipdl
+++ /dev/null
@@ -1,23 +0,0 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-using mozilla::plugins::FunctionHookId from "mozilla/plugins/FunctionBrokerIPCUtils.h";
-using IPC::IpdlTuple from "mozilla/plugins/IpdlTuple.h";
-
-namespace mozilla {
-namespace plugins {
-
-/**
- * Top-level actor that brokers functions for the client process.
- */
-sync protocol PFunctionBroker
-{
-parent:
-  sync BrokerFunction(FunctionHookId aFunctionId, IpdlTuple aFunctionParams)
-    returns (IpdlTuple aFunctionRet);
-};
-
-} // namespace plugins
-} // namespace mozilla
diff --git a/dom/plugins/ipc/PPluginBackgroundDestroyer.ipdl b/dom/plugins/ipc/PPluginBackgroundDestroyer.ipdl
deleted file mode 100644
index d8c552fd86c10..0000000000000
--- a/dom/plugins/ipc/PPluginBackgroundDestroyer.ipdl
+++ /dev/null
@@ -1,34 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
- * vim: sw=4 ts=8 et :
- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-include protocol PPluginInstance;
-
-namespace mozilla {
-namespace plugins {
-
-/**
- * This protocol exists to allow us to correctly destroy background
- * surfaces.  The browser owns the surfaces, but shares a "reference"
- * with the plugin.  The browser needs to notify the plugin when the
- * background is going to be destroyed, but it can't rely on the
- * plugin to destroy it because the plugin may crash at any time.  So
- * the plugin instance relinquishes destruction of the its old
- * background to actors of this protocol, which can deal with crashy
- * corner cases more easily than the instance.
- */
-protocol PPluginBackgroundDestroyer {
-    manager PPluginInstance;
-
-    // The ctor message for this protocol serves double-duty as
-    // notification that that the background is stale.
-
-parent:
-    async __delete__();
-};
-
-}  // namespace plugins
-}  // namespace mozilla
diff --git a/dom/plugins/ipc/PPluginInstance.ipdl b/dom/plugins/ipc/PPluginInstance.ipdl
deleted file mode 100644
index 48a4218746455..0000000000000
--- a/dom/plugins/ipc/PPluginInstance.ipdl
+++ /dev/null
@@ -1,270 +0,0 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-include protocol PPluginBackgroundDestroyer;
-include protocol PPluginModule;
-include protocol PPluginScriptableObject;
-include protocol PBrowserStream;
-include protocol PStreamNotify;
-
-include "gfxipc/ShadowLayerUtils.h";
-include "mozilla/GfxMessageUtils.h";
-include "mozilla/layers/LayersMessageUtils.h";
-
-using NPError from "npapi.h";
-using struct mozilla::plugins::NPRemoteWindow from "mozilla/plugins/PluginMessageUtils.h";
-using struct mozilla::plugins::NPRemoteEvent from "mozilla/plugins/PluginMessageUtils.h";
-using NPRect from "npapi.h";
-using NPNURLVariable from "npapi.h";
-using NPCoordinateSpace from "npapi.h";
-using NPNVariable from "npapi.h";
-using mozilla::plugins::NativeWindowHandle from "mozilla/plugins/PluginMessageUtils.h";
-using gfxSurfaceType from "gfxTypes.h";
-using mozilla::gfx::IntSize from "mozilla/gfx/2D.h";
-using mozilla::gfx::IntRect from "mozilla/gfx/2D.h";
-using struct mozilla::null_t from "mozilla/ipc/IPCCore.h";
-using mozilla::WindowsHandle from "mozilla/ipc/IPCTypes.h";
-using mozilla::plugins::WindowsSharedMemoryHandle from "mozilla/plugins/PluginMessageUtils.h";
-using mozilla::layers::SurfaceDescriptorX11 from "gfxipc/SurfaceDescriptor.h";
-using nsIntRect from "nsRect.h";
-using mozilla::gfx::SurfaceFormat from "mozilla/gfx/Types.h";
-using struct DxgiAdapterDesc from "mozilla/D3DMessageUtils.h";
-using struct mozilla::widget::CandidateWindowPosition from "ipc/nsGUIEventIPC.h";
-using class mozilla::NativeEventData from "ipc/nsGUIEventIPC.h";
-
-namespace mozilla {
-namespace plugins {
-
-struct IOSurfaceDescriptor {
-  uint32_t surfaceId;
-  double contentsScaleFactor;
-};
-
-union SurfaceDescriptor {
-  Shmem;
-  SurfaceDescriptorX11;
-  IOSurfaceDescriptor; // used on OSX 10.5+
-  // Descriptor can be null here in case
-  // 1) of first Show call (prevSurface is null)
-  // 2) when child is going to destroy
-  //    and it just want to grab prevSurface
-  //     back without giving new surface
-  null_t;
-};
-
-intr protocol PPluginInstance
-{
-  manager PPluginModule;
-
-  manages PPluginBackgroundDestroyer;
-  manages PPluginScriptableObject;
-  manages PBrowserStream;
-  manages PStreamNotify;
-
-child:
-  async __delete__();
-
-  // This is only used on Windows and, for windowed plugins, must be called
-  // before the first call to NPP_SetWindow.
-  intr CreateChildPluginWindow()
-    returns (NativeWindowHandle childPluginWindow);
-
-  // This is only used on Windows and, for windowless plugins.
-  async CreateChildPopupSurrogate(NativeWindowHandle netscapeWindow);
-
-  intr NPP_SetWindow(NPRemoteWindow window);
-
-  intr NPP_GetValue_NPPVpluginWantsAllNetworkStreams()
-    returns (bool value, NPError result);
-
-  intr NPP_GetValue_NPPVpluginScriptableNPObject()
-    returns (nullable PPluginScriptableObject value, NPError result);
-
-  intr NPP_SetValue_NPNVprivateModeBool(bool value) returns (NPError result);
-  intr NPP_GetValue_NPPVpluginNativeAccessibleAtkPlugId()
-    returns (nsCString plug_id, NPError result);
-
-  intr NPP_SetValue_NPNVCSSZoomFactor(double value) returns (NPError result);
-
-  intr NPP_SetValue_NPNVmuteAudioBool(bool muted) returns (NPError result);
-
-  intr NPP_HandleEvent(NPRemoteEvent event)
-    returns (int16_t handled);
-  // special cases where we need to a shared memory buffer
-  intr NPP_HandleEvent_Shmem(NPRemoteEvent event, Shmem buffer)
-    returns (int16_t handled, Shmem rtnbuffer);
-  // special cases where we need an iosurface
-  intr NPP_HandleEvent_IOSurface(NPRemoteEvent event, uint32_t surfaceid)
-    returns (int16_t handled);
-  // special cases of HandleEvent to make mediating races simpler
-  intr Paint(NPRemoteEvent event)
-    returns (int16_t handled);
-  // this is only used on windows to forward WM_WINDOWPOSCHANGE
-  async WindowPosChanged(NPRemoteEvent event);
-  // used on OS X to tell the child the contents scale factor
-  // of its parent has changed
-  async ContentsScaleFactorChanged(double aContentsScaleFactor);
-
-  // ********************** Async plugins rendering
-  // see https://wiki.mozilla.org/Gecko:AsyncPluginPainting
-  // **********************
-
-  // Async version of SetWindow call
-  // @param surfaceType - gfxASurface::gfxSurfaceType
-  //        plugin child must create offscreen buffer
-  //        with type equals to surfaceType
-  async AsyncSetWindow(gfxSurfaceType surfaceType, NPRemoteWindow window);
-
-  // There is now an opaque background behind this instance (or the
-  // background was updated).  The changed area is |rect|.  The
-  // browser owns the background surface, and it's read-only from
-  // within the plugin process.  |background| is either null_t to
-  // refer to the existing background or a fresh descriptor.
-  async UpdateBackground(SurfaceDescriptor background, nsIntRect rect);
-
-  async NPP_DidComposite();
-
-  intr NPP_Destroy()
-    returns (NPError rv);
-
-parent:
-  intr NPN_GetValue_NPNVWindowNPObject()
-    returns (nullable PPluginScriptableObject value, NPError result);
-  intr NPN_GetValue_NPNVPluginElementNPObject()
-    returns (nullable PPluginScriptableObject value, NPError result);
-  intr NPN_GetValue_NPNVprivateModeBool()
-    returns (bool value, NPError result);
-  intr NPN_GetValue_NPNVnetscapeWindow()
-    returns (NativeWindowHandle value, NPError result);
-  intr NPN_GetValue_NPNVdocumentOrigin()
-    returns (nsCString value, NPError result);
-  intr NPN_GetValue_DrawingModelSupport(NPNVariable model)
-    returns (bool value);
-  intr NPN_GetValue_SupportsAsyncBitmapSurface()
-    returns (bool value);
-  intr NPN_GetValue_SupportsAsyncDXGISurface()
-    returns (bool value);
-  intr NPN_GetValue_PreferredDXGIAdapter()
-    returns (DxgiAdapterDesc desc);
-
-  intr NPN_SetValue_NPPVpluginWindow(bool windowed)
-    returns (NPError result);
-  intr NPN_SetValue_NPPVpluginTransparent(bool transparent)
-    returns (NPError result);
-  intr NPN_SetValue_NPPVpluginUsesDOMForCursor(bool useDOMForCursor)
-    returns (NPError result);
-  intr NPN_SetValue_NPPVpluginDrawingModel(int drawingModel)
-    returns (NPError result);
-  intr NPN_SetValue_NPPVpluginEventModel(int eventModel)
-    returns (NPError result);
-  intr NPN_SetValue_NPPVpluginIsPlayingAudio(bool isAudioPlaying)
-    returns (NPError result);
-
-  intr NPN_GetURL(nsCString url, nsCString target)
-    returns (NPError result);
-  intr NPN_PostURL(nsCString url, nsCString target, nsCString buffer, bool file)
-    returns (NPError result);
-
-  /**
-   * Covers both NPN_GetURLNotify and NPN_PostURLNotify.
-   * @TODO This would be more readable as an overloaded method,
-   *       but IPDL doesn't allow that for constructors.
-   */
-  intr PStreamNotify(nsCString url, nsCString target, bool post,
-                    nsCString buffer, bool file)
-    returns (NPError result);
-
-  async NPN_InvalidateRect(NPRect rect);
-
-  // Clear the current plugin image.
-  sync RevokeCurrentDirectSurface();
-
-  // Create a new DXGI shared surface with the given format and size. The
-  // returned handle, on success, can be opened as an ID3D10Texture2D or
-  // ID3D11Texture2D on a corresponding device.
-  sync InitDXGISurface(SurfaceFormat format, IntSize size)
-    returns (WindowsHandle handle, NPError result);
-
-  // Destroy a surface previously allocated with InitDXGISurface().
-  sync FinalizeDXGISurface(WindowsHandle handle);
-
-  // Set the current plugin image to the bitmap in the given shmem buffer. The
-  // format must be B8G8R8A8 or B8G8R8X8.
-  sync ShowDirectBitmap(Shmem buffer,
-                        SurfaceFormat format,
-                        uint32_t stride,
-                        IntSize size,
-                        IntRect dirty);
-
-  // Set the current plugin image to the DXGI surface in |handle|.
-  sync ShowDirectDXGISurface(WindowsHandle handle,
-                              IntRect dirty);
-
-  // Give |newSurface|, containing this instance's updated pixels, to
-  // the browser for compositing.  When this method returns, any surface
-  // previously passed to Show may be destroyed.
-  //
-  // @param rect - actually updated rectangle, comparing to prevSurface content
-  //               could be used for partial render of layer to topLevel context
-  // @param newSurface - remotable surface
-  // @param prevSurface - if the previous surface was shared-memory, returns
-  //                      the shmem for reuse
-  sync Show(NPRect updatedRect, SurfaceDescriptor newSurface)
-    returns (SurfaceDescriptor prevSurface);
-
-  intr NPN_PushPopupsEnabledState(bool aState);
-
-  intr NPN_PopPopupsEnabledState();
-
-  intr NPN_GetValueForURL(NPNURLVariable variable, nsCString url)
-    returns (nsCString value, NPError result);
-
-  intr NPN_SetValueForURL(NPNURLVariable variable, nsCString url,
-                         nsCString value)
-    returns (NPError result);
-
-  intr NPN_ConvertPoint(double sourceX, bool ignoreDestX, double sourceY, bool ignoreDestY, NPCoordinateSpace sourceSpace,
-                       NPCoordinateSpace destSpace)
-    returns (double destX, double destY, bool result);
-
-  async RedrawPlugin();
-
-  // Sends a native window to be adopted by the native window that would be
-  // returned by NPN_GetValue_NPNVnetscapeWindow. Only used on Windows.
-  async SetNetscapeWindowAsParent(NativeWindowHandle childWindow);
-
-  sync GetCompositionString(uint32_t aType)
-                            returns (uint8_t[] aDist, int32_t aLength);
-  async RequestCommitOrCancel(bool aCommitted);
-
-both:
-  async PPluginScriptableObject();
-
-child:
-  /* NPP_NewStream */
-  async PBrowserStream(nsCString url,
-                       uint32_t length,
-                       uint32_t lastmodified,
-                       nullable PStreamNotify notifyData,
-                       nsCString headers);
-
-  // Implements the legacy (synchronous) version of NPP_NewStream for when
-  // async plugin init is preffed off.
-  intr NPP_NewStream(PBrowserStream actor, nsCString mimeType, bool seekable)
-    returns (NPError rv,
-             uint16_t stype);
-
-parent:
-  intr PluginFocusChange(bool gotFocus);
-
-child:
-  intr SetPluginFocus();
-  intr UpdateWindow();
-
-  async PPluginBackgroundDestroyer();
-};
-
-} // namespace plugins
-} // namespace mozilla
diff --git a/dom/plugins/ipc/PPluginModule.ipdl b/dom/plugins/ipc/PPluginModule.ipdl
deleted file mode 100644
index 70ba97aca0e18..0000000000000
--- a/dom/plugins/ipc/PPluginModule.ipdl
+++ /dev/null
@@ -1,148 +0,0 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-include protocol PPluginInstance;
-include protocol PPluginScriptableObject;
-include protocol PContent;
-include protocol PProfiler;
-include protocol PFunctionBroker;
-
-using NPError from "npapi.h";
-using NPNVariable from "npapi.h";
-using mozilla::dom::NativeThreadId from "mozilla/dom/NativeThreadId.h";
-using struct nsID from "nsID.h";
-using struct mozilla::plugins::NPAudioDeviceChangeDetailsIPC from "mozilla/plugins/PluginMessageUtils.h";
-using struct mozilla::plugins::NPAudioDeviceStateChangedIPC from "mozilla/plugins/PluginMessageUtils.h";
-
-namespace mozilla {
-namespace plugins {
-
-struct PluginSettings
-{
-  // These settings correspond to NPNVariable. They are fetched from
-  // mozilla::plugins::parent::_getvalue.
-  bool javascriptEnabled;
-  bool asdEnabled;
-  bool isOffline;
-  bool supportsXembed;
-  bool supportsWindowless;
-
-  // These settings come from elsewhere.
-  nsCString userAgent;
-  bool nativeCursorsSupported;
-};
-
-intr protocol PPluginModule
-{
-  manages PPluginInstance;
-
-both:
-  // Window-specific message which instructs the interrupt mechanism to enter
-  // a nested event loop for the current interrupt call.
-  async ProcessNativeEventsInInterruptCall();
-
-child:
-  async InitProfiler(Endpoint<PProfilerChild> aEndPoint);
-
-  async DisableFlashProtectedMode();
-
-  // Sync query to check if a Flash library indicates it
-  // supports async rendering mode.
-  intr ModuleSupportsAsyncRender()
-    returns (bool result);
-
-  // Forces the child process to update its plugin function table.
-  intr NP_GetEntryPoints()
-    returns (NPError rv);
-
-  intr NP_Initialize(PluginSettings settings)
-    returns (NPError rv);
-
-  async PPluginInstance(nsCString aMimeType,
-                        nsCString[] aNames,
-                        nsCString[] aValues);
-
-  // Implements the synchronous version of NPP_New for when async plugin init
-  // is preffed off.
-  intr SyncNPP_New(PPluginInstance aActor)
-    returns (NPError rv);
-
-  intr NP_Shutdown()
-    returns (NPError rv);
-
-  intr OptionalFunctionsSupported()
-    returns (bool aURLRedirectNotify, bool aClearSiteData,
-             bool aGetSitesWithData);
-
-  async NPP_ClearSiteData(nsCString site, uint64_t flags, uint64_t maxAge, uint64_t aCallbackId);
-
-  async NPP_GetSitesWithData(uint64_t aCallbackId);
-
-  // Windows specific message to set up an audio session in the plugin process
-  async SetAudioSessionData(nsID aID,
-                            nsString aDisplayName,
-                            nsString aIconPath);
-
-  async SetParentHangTimeout(uint32_t seconds);
-
-  intr InitCrashReporter()
-    returns (NativeThreadId tid);
-
-  async SettingChanged(PluginSettings settings);
-
-  async NPP_SetValue_NPNVaudioDeviceChangeDetails(NPAudioDeviceChangeDetailsIPC changeDetails);
-  async NPP_SetValue_NPNVaudioDeviceStateChanged(NPAudioDeviceStateChangedIPC deviceState);
-
-  async InitPluginModuleChild(Endpoint<PPluginModuleChild> endpoint);
-
-  async InitPluginFunctionBroker(Endpoint<PFunctionBrokerChild> endpoint);
-
-parent:
-  /**
-   * This message is only used on X11 platforms.
-   *
-   * Send a dup of the plugin process's X socket to the parent
-   * process.  In theory, this scheme keeps the plugin's X resources
-   * around until after both the plugin process shuts down *and* the
-   * parent process closes the dup fd.  This is used to prevent the
-   * parent process from crashing on X errors if, e.g., the plugin
-   * crashes *just before* a repaint and the parent process tries to
-   * use the newly-invalid surface.
-   */
-  async BackUpXResources(FileDescriptor aXSocketFd);
-
-  // Wake up and process a few native events.  Periodically called by
-  // Gtk-specific code upon detecting that the plugin process has
-  // entered a nested event loop.  If the browser doesn't process
-  // native events, then "livelock" and some other glitches can occur.
-  intr ProcessSomeEvents();
-
-  // OS X Specific calls to manage the plugin's window
-  // when interposing system calls.
-  async PluginShowWindow(uint32_t aWindowId, bool aModal,
-                         int32_t aX, int32_t aY,
-                         double aWidth, double aHeight);
-  async PluginHideWindow(uint32_t aWindowId);
-
-  sync NPN_SetException(nsCString message);
-
-  async NPN_ReloadPlugins(bool aReloadPages);
-
-  // Notifies the chrome process that a PluginModuleChild linked to a content
-  // process was destroyed. The chrome process may choose to asynchronously shut
-  // down the plugin process in response.
-  async NotifyContentModuleDestroyed();
-
-  // Answers to request about site data
-  async ReturnClearSiteData(NPError aRv, uint64_t aCallbackId);
-
-  async ReturnSitesWithData(nsCString[] aSites, uint64_t aCallbackId);
-
-  intr NPN_SetValue_NPPVpluginRequiresAudioDeviceChanges(bool shouldRegister)
-    returns (NPError result);
-};
-
-} // namespace plugins
-} // namespace mozilla
diff --git a/dom/plugins/ipc/PPluginScriptableObject.ipdl b/dom/plugins/ipc/PPluginScriptableObject.ipdl
deleted file mode 100644
index 8bee7b19972d8..0000000000000
--- a/dom/plugins/ipc/PPluginScriptableObject.ipdl
+++ /dev/null
@@ -1,102 +0,0 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-include protocol PPluginInstance;
-include PluginTypes;
-
-using struct mozilla::void_t from "mozilla/ipc/IPCCore.h";
-using struct mozilla::null_t from "mozilla/ipc/IPCCore.h";
-
-namespace mozilla {
-namespace plugins {
-
-union Variant {
-  void_t;
-  null_t;
-  bool;
-  int;
-  double;
-  nsCString;
-  nullable PPluginScriptableObject;
-};
-
-intr protocol PPluginScriptableObject
-{
-  manager PPluginInstance;
-
-both:
-  async __delete__();
-
-parent:
-  intr NPN_Evaluate(nsCString aScript)
-    returns (Variant aResult,
-             bool aSuccess);
-
-child:
-  intr Invalidate();
-
-both:
-  // NPClass methods
-  intr HasMethod(PluginIdentifier aId)
-    returns (bool aHasMethod);
-
-  intr Invoke(PluginIdentifier aId,
-             Variant[] aArgs)
-    returns (Variant aResult,
-             bool aSuccess);
-
-  intr InvokeDefault(Variant[] aArgs)
-    returns (Variant aResult,
-             bool aSuccess);
-
-  intr HasProperty(PluginIdentifier aId)
-    returns (bool aHasProperty);
-
-  intr SetProperty(PluginIdentifier aId,
-                  Variant aValue)
-    returns (bool aSuccess);
-
-  intr RemoveProperty(PluginIdentifier aId)
-    returns (bool aSuccess);
-
-  intr Enumerate()
-    returns (PluginIdentifier[] aProperties,
-             bool aSuccess);
-
-  intr Construct(Variant[] aArgs)
-    returns (Variant aResult,
-             bool aSuccess);
-
-  // Objects are initially unprotected, and the Protect and Unprotect functions
-  // only affect protocol objects that represent NPObjects created in the same
-  // process (rather than protocol objects that are a proxy for an NPObject
-  // created in another process). Protocol objects representing local NPObjects
-  // are protected after an NPObject has been associated with the protocol
-  // object. Sending the protocol object as an argument to the other process
-  // temporarily protects the protocol object again for the duration of the call.
-  async Protect();
-  async Unprotect();
-
-  /**
-   * GetProperty is slightly wonky due to the way we support NPObjects that have
-   * methods and properties with the same name. When child calls parent we
-   * simply return a property. When parent calls child, however, we need to do
-   * several checks at once and return all the results simultaneously.
-   */
-parent:
-  intr GetParentProperty(PluginIdentifier aId)
-    returns (Variant aResult,
-             bool aSuccess);
-
-child:
-  intr GetChildProperty(PluginIdentifier aId)
-    returns (bool aHasProperty,
-             bool aHasMethod,
-             Variant aResult,
-             bool aSuccess);
-};
-
-} // namespace plugins
-} // namespace mozilla
diff --git a/dom/plugins/ipc/PStreamNotify.ipdl b/dom/plugins/ipc/PStreamNotify.ipdl
deleted file mode 100644
index 3e196acab8ba8..0000000000000
--- a/dom/plugins/ipc/PStreamNotify.ipdl
+++ /dev/null
@@ -1,39 +0,0 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-
-include protocol PPluginInstance;
-
-
-using NPReason from "npapi.h";
-
-namespace mozilla {
-namespace plugins {
-
-intr protocol PStreamNotify
-{
-  manager PPluginInstance;
-
-parent:
-
-  /**
-   * Represents NPN_URLRedirectResponse
-   */
-  async RedirectNotifyResponse(bool allow);
-
-child:
-  /**
-   * Represents NPP_URLRedirectNotify
-   */
-  async RedirectNotify(nsCString url, int32_t status);
-
-  /**
-   * Represents NPP_URLNotify
-   */
-  async __delete__(NPReason reason);
-};
-
-} // namespace plugins
-} // namespace mozilla
diff --git a/dom/plugins/ipc/PluginBackgroundDestroyer.cpp b/dom/plugins/ipc/PluginBackgroundDestroyer.cpp
deleted file mode 100644
index 9c0b50d5e288f..0000000000000
--- a/dom/plugins/ipc/PluginBackgroundDestroyer.cpp
+++ /dev/null
@@ -1,35 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=8 et :
- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "PluginBackgroundDestroyer.h"
-#include "gfxSharedImageSurface.h"
-
-using namespace mozilla;
-using namespace plugins;
-
-PluginBackgroundDestroyerParent::PluginBackgroundDestroyerParent(
-    gfxASurface* aDyingBackground)
-    : mDyingBackground(aDyingBackground) {}
-
-PluginBackgroundDestroyerParent::~PluginBackgroundDestroyerParent() = default;
-
-void PluginBackgroundDestroyerParent::ActorDestroy(ActorDestroyReason why) {
-  switch (why) {
-    case Deletion:
-    case AncestorDeletion:
-      if (gfxSharedImageSurface::IsSharedImage(mDyingBackground)) {
-        gfxSharedImageSurface* s =
-            static_cast<gfxSharedImageSurface*>(mDyingBackground.get());
-        DeallocShmem(s->GetShmem());
-      }
-      break;
-    default:
-      // We're shutting down or crashed, let automatic cleanup
-      // take care of our shmem, if we have one.
-      break;
-  }
-}
diff --git a/dom/plugins/ipc/PluginBackgroundDestroyer.h b/dom/plugins/ipc/PluginBackgroundDestroyer.h
deleted file mode 100644
index 627b09fdc4ab5..0000000000000
--- a/dom/plugins/ipc/PluginBackgroundDestroyer.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=8 et :
- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef dom_plugins_PluginBackgroundDestroyer
-#define dom_plugins_PluginBackgroundDestroyer
-
-#include "mozilla/plugins/PPluginBackgroundDestroyerChild.h"
-#include "mozilla/plugins/PPluginBackgroundDestroyerParent.h"
-
-#include "gfxSharedImageSurface.h"
-
-class gfxASurface;
-
-namespace mozilla {
-namespace plugins {
-
-/**
- * When instances of this class are destroyed, the old background goes
- * along with them, completing the destruction process (whether or not
- * the plugin stayed alive long enough to ack).
- */
-class PluginBackgroundDestroyerParent
-    : public PPluginBackgroundDestroyerParent {
- public:
-  explicit PluginBackgroundDestroyerParent(gfxASurface* aDyingBackground);
-
-  virtual ~PluginBackgroundDestroyerParent();
-
- private:
-  virtual void ActorDestroy(ActorDestroyReason why) override;
-
-  RefPtr<gfxASurface> mDyingBackground;
-};
-
-/**
- * This class exists solely to instruct its instance to release its
- * current background, a new one may be coming.
- */
-class PluginBackgroundDestroyerChild : public PPluginBackgroundDestroyerChild {
- public:
-  PluginBackgroundDestroyerChild() = default;
-  virtual ~PluginBackgroundDestroyerChild() = default;
-
- private:
-  // Implementing this for good hygiene.
-  virtual void ActorDestroy(ActorDestroyReason why) override {}
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // dom_plugins_PluginBackgroundDestroyer
diff --git a/dom/plugins/ipc/PluginBridge.h b/dom/plugins/ipc/PluginBridge.h
deleted file mode 100644
index 312b36f97d705..0000000000000
--- a/dom/plugins/ipc/PluginBridge.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=2 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_plugins_PluginBridge_h
-#define mozilla_plugins_PluginBridge_h
-
-#include "base/process.h"
-
-namespace mozilla {
-
-namespace dom {
-class ContentParent;
-}  // namespace dom
-
-namespace ipc {
-template <class PFooSide>
-class Endpoint;
-}  // namespace ipc
-
-namespace plugins {
-
-class PPluginModuleParent;
-
-bool SetupBridge(uint32_t aPluginId, dom::ContentParent* aContentParent,
-                 nsresult* aResult, uint32_t* aRunID,
-                 ipc::Endpoint<PPluginModuleParent>* aEndpoint);
-
-void TakeFullMinidump(uint32_t aPluginId, base::ProcessId aContentProcessId,
-                      const nsAString& aBrowserDumpId, nsString& aDumpId);
-
-void TerminatePlugin(uint32_t aPluginId, base::ProcessId aContentProcessId,
-                     const nsCString& aMonitorDescription,
-                     const nsAString& aDumpId);
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // mozilla_plugins_PluginBridge_h
diff --git a/dom/plugins/ipc/PluginHangUIParent.cpp b/dom/plugins/ipc/PluginHangUIParent.cpp
deleted file mode 100644
index 4f0dab52ab30f..0000000000000
--- a/dom/plugins/ipc/PluginHangUIParent.cpp
+++ /dev/null
@@ -1,400 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "PluginHangUI.h"
-
-#include "PluginHangUIParent.h"
-
-#include "base/command_line.h"
-#include "mozilla/Telemetry.h"
-#include "mozilla/ipc/ProtocolUtils.h"
-#include "mozilla/plugins/PluginModuleParent.h"
-
-#include "nsContentUtils.h"
-#include "nsDirectoryServiceDefs.h"
-#include "nsIFile.h"
-#include "nsIProperties.h"
-#include "nsIWindowMediator.h"
-#include "nsIWinTaskbar.h"
-#include "nsServiceManagerUtils.h"
-#include "nsThreadUtils.h"
-
-#include "WidgetUtils.h"
-
-#define NS_TASKBAR_CONTRACTID "@mozilla.org/windows-taskbar;1"
-
-using base::ProcessHandle;
-
-using mozilla::widget::WidgetUtils;
-
-using std::string;
-using std::vector;
-
-namespace {
-class nsPluginHangUITelemetry : public mozilla::Runnable {
- public:
-  nsPluginHangUITelemetry(int aResponseCode, int aDontAskCode,
-                          uint32_t aResponseTimeMs, uint32_t aTimeoutMs)
-      : Runnable("nsPluginHangUITelemetry"),
-        mResponseCode(aResponseCode),
-        mDontAskCode(aDontAskCode),
-        mResponseTimeMs(aResponseTimeMs),
-        mTimeoutMs(aTimeoutMs) {}
-
-  NS_IMETHOD
-  Run() override {
-    mozilla::Telemetry::Accumulate(
-        mozilla::Telemetry::PLUGIN_HANG_UI_USER_RESPONSE, mResponseCode);
-    mozilla::Telemetry::Accumulate(mozilla::Telemetry::PLUGIN_HANG_UI_DONT_ASK,
-                                   mDontAskCode);
-    mozilla::Telemetry::Accumulate(
-        mozilla::Telemetry::PLUGIN_HANG_UI_RESPONSE_TIME, mResponseTimeMs);
-    mozilla::Telemetry::Accumulate(mozilla::Telemetry::PLUGIN_HANG_TIME,
-                                   mTimeoutMs + mResponseTimeMs);
-    return NS_OK;
-  }
-
- private:
-  int mResponseCode;
-  int mDontAskCode;
-  uint32_t mResponseTimeMs;
-  uint32_t mTimeoutMs;
-};
-}  // namespace
-
-namespace mozilla {
-namespace plugins {
-
-PluginHangUIParent::PluginHangUIParent(PluginModuleChromeParent* aModule,
-                                       const int32_t aHangUITimeoutPref,
-                                       const int32_t aChildTimeoutPref)
-    : mMutex("mozilla::plugins::PluginHangUIParent::mMutex"),
-      mModule(aModule),
-      mTimeoutPrefMs(static_cast<uint32_t>(aHangUITimeoutPref) * 1000U),
-      mIPCTimeoutMs(static_cast<uint32_t>(aChildTimeoutPref) * 1000U),
-      mMainThreadMessageLoop(MessageLoop::current()),
-      mIsShowing(false),
-      mLastUserResponse(0),
-      mHangUIProcessHandle(nullptr),
-      mMainWindowHandle(nullptr),
-      mRegWait(nullptr),
-      mShowEvent(nullptr),
-      mShowTicks(0),
-      mResponseTicks(0) {}
-
-PluginHangUIParent::~PluginHangUIParent() {
-  {  // Scope for lock
-    MutexAutoLock lock(mMutex);
-    UnwatchHangUIChildProcess(true);
-  }
-  if (mShowEvent) {
-    ::CloseHandle(mShowEvent);
-  }
-  if (mHangUIProcessHandle) {
-    ::CloseHandle(mHangUIProcessHandle);
-  }
-}
-
-bool PluginHangUIParent::DontShowAgain() const {
-  return (mLastUserResponse & HANGUI_USER_RESPONSE_DONT_SHOW_AGAIN);
-}
-
-bool PluginHangUIParent::WasLastHangStopped() const {
-  return (mLastUserResponse & HANGUI_USER_RESPONSE_STOP);
-}
-
-unsigned int PluginHangUIParent::LastShowDurationMs() const {
-  // We only return something if there was a user response
-  if (!mLastUserResponse) {
-    return 0;
-  }
-  return static_cast<unsigned int>(mResponseTicks - mShowTicks);
-}
-
-bool PluginHangUIParent::Init(const nsString& aPluginName) {
-  if (mHangUIProcessHandle) {
-    return false;
-  }
-
-  nsresult rv;
-  rv = mMiniShm.Init(this, ::IsDebuggerPresent() ? INFINITE : mIPCTimeoutMs);
-  NS_ENSURE_SUCCESS(rv, false);
-  nsCOMPtr<nsIProperties> directoryService(
-      do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID));
-  if (!directoryService) {
-    return false;
-  }
-  nsCOMPtr<nsIFile> greDir;
-  rv = directoryService->Get(NS_GRE_DIR, NS_GET_IID(nsIFile),
-                             getter_AddRefs(greDir));
-  if (NS_FAILED(rv)) {
-    return false;
-  }
-  nsAutoString path;
-  greDir->GetPath(path);
-
-  FilePath exePath(path.get());
-  exePath = exePath.AppendASCII(MOZ_HANGUI_PROCESS_NAME);
-  CommandLine commandLine(exePath.value());
-
-  nsAutoString localizedStr;
-  rv = nsContentUtils::FormatLocalizedString(
-      localizedStr, nsContentUtils::eDOM_PROPERTIES, "PluginHangUIMessage",
-      aPluginName);
-  if (NS_FAILED(rv)) {
-    return false;
-  }
-  commandLine.AppendLooseValue(localizedStr.get());
-
-  const char* keys[] = {"PluginHangUITitle", "PluginHangUIWaitButton",
-                        "PluginHangUIStopButton", "DontAskAgain"};
-  for (unsigned int i = 0; i < ArrayLength(keys); ++i) {
-    rv = nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
-                                            keys[i], localizedStr);
-    if (NS_FAILED(rv)) {
-      return false;
-    }
-    commandLine.AppendLooseValue(localizedStr.get());
-  }
-
-  rv = GetHangUIOwnerWindowHandle(mMainWindowHandle);
-  if (NS_FAILED(rv)) {
-    return false;
-  }
-  nsAutoString hwndStr;
-  hwndStr.AppendPrintf("%p", mMainWindowHandle);
-  commandLine.AppendLooseValue(hwndStr.get());
-
-  ScopedHandle procHandle(
-      ::OpenProcess(SYNCHRONIZE, TRUE, GetCurrentProcessId()));
-  if (!procHandle.IsValid()) {
-    return false;
-  }
-  nsAutoString procHandleStr;
-  procHandleStr.AppendPrintf("%p", procHandle.Get());
-  commandLine.AppendLooseValue(procHandleStr.get());
-
-  // On Win7+, pass the application user model to the child, so it can
-  // register with it. This insures windows created by the Hang UI
-  // properly group with the parent app on the Win7 taskbar.
-  nsCOMPtr<nsIWinTaskbar> taskbarInfo = do_GetService(NS_TASKBAR_CONTRACTID);
-  if (taskbarInfo) {
-    bool isSupported = false;
-    taskbarInfo->GetAvailable(&isSupported);
-    nsAutoString appId;
-    if (isSupported && NS_SUCCEEDED(taskbarInfo->GetDefaultGroupId(appId))) {
-      commandLine.AppendLooseValue(appId.get());
-    } else {
-      commandLine.AppendLooseValue(L"-");
-    }
-  } else {
-    commandLine.AppendLooseValue(L"-");
-  }
-
-  nsAutoString ipcTimeoutStr;
-  ipcTimeoutStr.AppendInt(mIPCTimeoutMs);
-  commandLine.AppendLooseValue(ipcTimeoutStr.get());
-
-  std::wstring ipcCookie;
-  rv = mMiniShm.GetCookie(ipcCookie);
-  if (NS_FAILED(rv)) {
-    return false;
-  }
-  commandLine.AppendLooseValue(ipcCookie);
-
-  ScopedHandle showEvent(::CreateEventW(nullptr, FALSE, FALSE, nullptr));
-  if (!showEvent.IsValid()) {
-    return false;
-  }
-  mShowEvent = showEvent.Get();
-
-  MutexAutoLock lock(mMutex);
-  STARTUPINFO startupInfo = {sizeof(STARTUPINFO)};
-  PROCESS_INFORMATION processInfo = {nullptr};
-  BOOL isProcessCreated = ::CreateProcess(
-      exePath.value().c_str(),
-      const_cast<wchar_t*>(commandLine.command_line_string().c_str()), nullptr,
-      nullptr, TRUE, DETACHED_PROCESS, nullptr, nullptr, &startupInfo,
-      &processInfo);
-  if (isProcessCreated) {
-    ::CloseHandle(processInfo.hThread);
-    mHangUIProcessHandle = processInfo.hProcess;
-    ::RegisterWaitForSingleObject(&mRegWait, processInfo.hProcess,
-                                  &SOnHangUIProcessExit, this, INFINITE,
-                                  WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE);
-    ::WaitForSingleObject(mShowEvent,
-                          ::IsDebuggerPresent() ? INFINITE : mIPCTimeoutMs);
-    // Setting this to true even if we time out on mShowEvent. This timeout
-    // typically occurs when the machine is thrashing so badly that
-    // plugin-hang-ui.exe is taking a while to start. If we didn't set
-    // this to true, Firefox would keep spawning additional plugin-hang-ui
-    // processes, which is not what we want.
-    mIsShowing = true;
-  }
-  mShowEvent = nullptr;
-  return !(!isProcessCreated);
-}
-
-// static
-VOID CALLBACK PluginHangUIParent::SOnHangUIProcessExit(PVOID aContext,
-                                                       BOOLEAN aIsTimer) {
-  PluginHangUIParent* object = static_cast<PluginHangUIParent*>(aContext);
-  MutexAutoLock lock(object->mMutex);
-  // If the Hang UI child process died unexpectedly, act as if the UI cancelled
-  if (object->IsShowing()) {
-    object->RecvUserResponse(HANGUI_USER_RESPONSE_CANCEL);
-    // Firefox window was disabled automatically when the Hang UI was shown.
-    // If plugin-hang-ui.exe was unexpectedly terminated, we need to re-enable.
-    ::EnableWindow(object->mMainWindowHandle, TRUE);
-  }
-}
-
-// A precondition for this function is that the caller has locked mMutex
-bool PluginHangUIParent::UnwatchHangUIChildProcess(bool aWait) {
-  mMutex.AssertCurrentThreadOwns();
-  if (mRegWait) {
-    // If aWait is false then we want to pass a nullptr (i.e. default
-    // constructor) completionEvent
-    ScopedHandle completionEvent;
-    if (aWait) {
-      completionEvent.Set(::CreateEventW(nullptr, FALSE, FALSE, nullptr));
-      if (!completionEvent.IsValid()) {
-        return false;
-      }
-    }
-
-    // if aWait == false and UnregisterWaitEx fails with ERROR_IO_PENDING,
-    // it is okay to clear mRegWait; Windows is telling us that the wait's
-    // callback is running but will be cleaned up once the callback returns.
-    if (::UnregisterWaitEx(mRegWait, completionEvent) ||
-        (!aWait && ::GetLastError() == ERROR_IO_PENDING)) {
-      mRegWait = nullptr;
-      if (aWait) {
-        // We must temporarily unlock mMutex while waiting for the registered
-        // wait callback to complete, or else we could deadlock.
-        MutexAutoUnlock unlock(mMutex);
-        ::WaitForSingleObject(completionEvent, INFINITE);
-      }
-      return true;
-    }
-  }
-  return false;
-}
-
-bool PluginHangUIParent::Cancel() {
-  MutexAutoLock lock(mMutex);
-  bool result = mIsShowing && SendCancel();
-  if (result) {
-    mIsShowing = false;
-  }
-  return result;
-}
-
-bool PluginHangUIParent::SendCancel() {
-  PluginHangUICommand* cmd = nullptr;
-  nsresult rv = mMiniShm.GetWritePtr(cmd);
-  if (NS_FAILED(rv)) {
-    return false;
-  }
-  cmd->mCode = PluginHangUICommand::HANGUI_CMD_CANCEL;
-  return NS_SUCCEEDED(mMiniShm.Send());
-}
-
-// A precondition for this function is that the caller has locked mMutex
-bool PluginHangUIParent::RecvUserResponse(const unsigned int& aResponse) {
-  mMutex.AssertCurrentThreadOwns();
-  if (!mIsShowing && !(aResponse & HANGUI_USER_RESPONSE_CANCEL)) {
-    // Don't process a user response if a cancellation is already pending
-    return true;
-  }
-  mLastUserResponse = aResponse;
-  mResponseTicks = ::GetTickCount();
-  mIsShowing = false;
-  // responseCode: 1 = Stop, 2 = Continue, 3 = Cancel
-  int responseCode;
-  if (aResponse & HANGUI_USER_RESPONSE_STOP) {
-    // User clicked Stop
-    mModule->TerminateChildProcess(mMainThreadMessageLoop,
-                                   mozilla::ipc::kInvalidProcessId,
-                                   "ModalHangUI"_ns, u""_ns);
-    responseCode = 1;
-  } else if (aResponse & HANGUI_USER_RESPONSE_CONTINUE) {
-    mModule->OnHangUIContinue();
-    // User clicked Continue
-    responseCode = 2;
-  } else {
-    // Dialog was cancelled
-    responseCode = 3;
-  }
-  int dontAskCode = (aResponse & HANGUI_USER_RESPONSE_DONT_SHOW_AGAIN) ? 1 : 0;
-  nsCOMPtr<nsIRunnable> workItem = new nsPluginHangUITelemetry(
-      responseCode, dontAskCode, LastShowDurationMs(), mTimeoutPrefMs);
-  NS_DispatchToMainThread(workItem);
-  return true;
-}
-
-nsresult PluginHangUIParent::GetHangUIOwnerWindowHandle(
-    NativeWindowHandle& windowHandle) {
-  windowHandle = nullptr;
-
-  nsresult rv;
-  nsCOMPtr<nsIWindowMediator> winMediator(
-      do_GetService(NS_WINDOWMEDIATOR_CONTRACTID, &rv));
-  NS_ENSURE_SUCCESS(rv, rv);
-
-  nsCOMPtr<mozIDOMWindowProxy> navWin;
-  rv = winMediator->GetMostRecentWindow(u"navigator:browser",
-                                        getter_AddRefs(navWin));
-  NS_ENSURE_SUCCESS(rv, rv);
-  if (!navWin) {
-    return NS_ERROR_FAILURE;
-  }
-
-  nsPIDOMWindowOuter* win = nsPIDOMWindowOuter::From(navWin);
-  nsCOMPtr<nsIWidget> widget = WidgetUtils::DOMWindowToWidget(win);
-  if (!widget) {
-    return NS_ERROR_FAILURE;
-  }
-
-  windowHandle = reinterpret_cast<NativeWindowHandle>(
-      widget->GetNativeData(NS_NATIVE_WINDOW));
-  if (!windowHandle) {
-    return NS_ERROR_FAILURE;
-  }
-
-  return NS_OK;
-}
-
-void PluginHangUIParent::OnMiniShmEvent(MiniShmBase* aMiniShmObj) {
-  const PluginHangUIResponse* response = nullptr;
-  nsresult rv = aMiniShmObj->GetReadPtr(response);
-  NS_ASSERTION(NS_SUCCEEDED(rv), "Couldn't obtain read pointer OnMiniShmEvent");
-  if (NS_SUCCEEDED(rv)) {
-    // The child process has returned a response so we shouldn't worry about
-    // its state anymore.
-    MutexAutoLock lock(mMutex);
-    UnwatchHangUIChildProcess(false);
-    RecvUserResponse(response->mResponseBits);
-  }
-}
-
-void PluginHangUIParent::OnMiniShmConnect(MiniShmBase* aMiniShmObj) {
-  PluginHangUICommand* cmd = nullptr;
-  nsresult rv = aMiniShmObj->GetWritePtr(cmd);
-  NS_ASSERTION(NS_SUCCEEDED(rv),
-               "Couldn't obtain write pointer OnMiniShmConnect");
-  if (NS_FAILED(rv)) {
-    return;
-  }
-  cmd->mCode = PluginHangUICommand::HANGUI_CMD_SHOW;
-  if (NS_SUCCEEDED(aMiniShmObj->Send())) {
-    mShowTicks = ::GetTickCount();
-  }
-  ::SetEvent(mShowEvent);
-}
-
-}  // namespace plugins
-}  // namespace mozilla
diff --git a/dom/plugins/ipc/PluginHangUIParent.h b/dom/plugins/ipc/PluginHangUIParent.h
deleted file mode 100644
index 8853d5c425eca..0000000000000
--- a/dom/plugins/ipc/PluginHangUIParent.h
+++ /dev/null
@@ -1,142 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_plugins_PluginHangUIParent_h
-#define mozilla_plugins_PluginHangUIParent_h
-
-#include "nsString.h"
-
-#include "base/process.h"
-#include "base/process_util.h"
-
-#include "mozilla/Mutex.h"
-#include "mozilla/plugins/PluginMessageUtils.h"
-
-#include "MiniShmParent.h"
-
-namespace mozilla {
-namespace plugins {
-
-class PluginModuleChromeParent;
-
-/**
- * This class is responsible for launching and communicating with the
- * plugin-hang-ui process.
- *
- * NOTE: PluginHangUIParent is *not* an IPDL actor! In this case, "Parent"
- *       is describing the fact that firefox is the parent process to the
- *       plugin-hang-ui process, which is the PluginHangUIChild.
- *       PluginHangUIParent and PluginHangUIChild are a matched pair.
- * @see PluginHangUIChild
- */
-class PluginHangUIParent : public MiniShmObserver {
- public:
-  PluginHangUIParent(PluginModuleChromeParent* aModule,
-                     const int32_t aHangUITimeoutPref,
-                     const int32_t aChildTimeoutPref);
-  virtual ~PluginHangUIParent();
-
-  /**
-   * Spawn the plugin-hang-ui.exe child process and terminate the given
-   * plugin container process if the user elects to stop the hung plugin.
-   *
-   * @param aPluginName Human-readable name of the affected plugin.
-   * @return true if the plugin hang ui process was successfully launched,
-   *         otherwise false.
-   */
-  bool Init(const nsString& aPluginName);
-
-  /**
-   * If the Plugin Hang UI is being shown, send a cancel notification to the
-   * Plugin Hang UI child process.
-   *
-   * @return true if the UI was shown and the cancel command was successfully
-   *              sent to the child process, otherwise false.
-   */
-  bool Cancel();
-
-  /**
-   * Returns whether the Plugin Hang UI is currently being displayed.
-   *
-   * @return true if the Plugin Hang UI is showing, otherwise false.
-   */
-  bool IsShowing() const { return mIsShowing; }
-
-  /**
-   * Returns whether this Plugin Hang UI instance has been shown. Note
-   * that this does not necessarily mean that the UI is showing right now.
-   *
-   * @return true if the Plugin Hang UI has shown, otherwise false.
-   */
-  bool WasShown() const { return mIsShowing || mLastUserResponse != 0; }
-
-  /**
-   * Returns whether the user checked the "Don't ask me again" checkbox.
-   *
-   * @return true if the user does not want to see the Hang UI again.
-   */
-  bool DontShowAgain() const;
-
-  /**
-   * Returns whether the user clicked stop during the last time that the
-   * Plugin Hang UI was displayed, if applicable.
-   *
-   * @return true if the UI was shown and the user chose to stop the
-   *         plugin, otherwise false
-   */
-  bool WasLastHangStopped() const;
-
-  /**
-   * @return unsigned int containing the response bits from the last
-   * time the Plugin Hang UI ran.
-   */
-  unsigned int LastUserResponse() const { return mLastUserResponse; }
-
-  /**
-   * @return unsigned int containing the number of milliseconds that
-   * the Plugin Hang UI was displayed before the user responded.
-   * Returns 0 if the Plugin Hang UI has not been shown or was cancelled.
-   */
-  unsigned int LastShowDurationMs() const;
-
-  virtual void OnMiniShmEvent(MiniShmBase* aMiniShmObj) override;
-
-  virtual void OnMiniShmConnect(MiniShmBase* aMiniShmObj) override;
-
- private:
-  nsresult GetHangUIOwnerWindowHandle(NativeWindowHandle& windowHandle);
-
-  bool SendCancel();
-
-  bool RecvUserResponse(const unsigned int& aResponse);
-
-  bool UnwatchHangUIChildProcess(bool aWait);
-
-  static VOID CALLBACK SOnHangUIProcessExit(PVOID aContext, BOOLEAN aIsTimer);
-
- private:
-  Mutex mMutex;
-  PluginModuleChromeParent* mModule;
-  const uint32_t mTimeoutPrefMs;
-  const uint32_t mIPCTimeoutMs;
-  MessageLoop* mMainThreadMessageLoop;
-  bool mIsShowing;
-  unsigned int mLastUserResponse;
-  base::ProcessHandle mHangUIProcessHandle;
-  NativeWindowHandle mMainWindowHandle;
-  HANDLE mRegWait;
-  HANDLE mShowEvent;
-  DWORD mShowTicks;
-  DWORD mResponseTicks;
-  MiniShmParent mMiniShm;
-
-  DISALLOW_COPY_AND_ASSIGN(PluginHangUIParent);
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // mozilla_plugins_PluginHangUIParent_h
diff --git a/dom/plugins/ipc/PluginInstanceChild.cpp b/dom/plugins/ipc/PluginInstanceChild.cpp
deleted file mode 100644
index 1bd49c15ca96b..0000000000000
--- a/dom/plugins/ipc/PluginInstanceChild.cpp
+++ /dev/null
@@ -1,3694 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "PluginBackgroundDestroyer.h"
-#include "PluginInstanceChild.h"
-#include "PluginModuleChild.h"
-#include "BrowserStreamChild.h"
-#include "StreamNotifyChild.h"
-#include "PluginProcessChild.h"
-#include "gfxASurface.h"
-#include "gfxPlatform.h"
-#include "gfx2DGlue.h"
-#include "nsNPAPIPluginInstance.h"
-#include "mozilla/gfx/2D.h"
-#include "mozilla/gfx/Logging.h"
-#ifdef MOZ_X11
-#  include "gfxXlibSurface.h"
-#endif
-#ifdef XP_WIN
-#  include "mozilla/D3DMessageUtils.h"
-#  include "nsCrashOnException.h"
-#  include "gfxWindowsPlatform.h"
-extern const wchar_t* kFlashFullscreenClass;
-#endif
-#include "gfxSharedImageSurface.h"
-#include "gfxUtils.h"
-#include "gfxAlphaRecovery.h"
-
-#include "mozilla/ArrayUtils.h"
-#include "mozilla/BasicEvents.h"
-#include "mozilla/ipc/MessageChannel.h"
-#include "mozilla/AutoRestore.h"
-#include "mozilla/StaticPtr.h"
-#include "mozilla/UniquePtr.h"
-#include "ImageContainer.h"
-
-using namespace mozilla;
-using namespace mozilla::plugins;
-using namespace mozilla::layers;
-using namespace mozilla::gfx;
-using namespace mozilla::widget;
-
-#ifdef MOZ_WIDGET_GTK
-
-#  include <gtk/gtk.h>
-#  include <gdk/gdkx.h>
-#  include <gdk/gdk.h>
-
-#elif defined(OS_WIN)
-
-#  include <windows.h>
-#  include <windowsx.h>
-
-#  include "mozilla/widget/WinMessages.h"
-#  include "nsWindowsDllInterceptor.h"
-#  include "X11UndefineNone.h"
-
-typedef BOOL(WINAPI* User32TrackPopupMenu)(HMENU hMenu, UINT uFlags, int x,
-                                           int y, int nReserved, HWND hWnd,
-                                           CONST RECT* prcRect);
-static WindowsDllInterceptor sUser32Intercept;
-static HWND sWinlessPopupSurrogateHWND = nullptr;
-static WindowsDllInterceptor::FuncHookType<User32TrackPopupMenu>
-    sUser32TrackPopupMenuStub;
-
-static WindowsDllInterceptor sImm32Intercept;
-static WindowsDllInterceptor::FuncHookType<decltype(&ImmGetContext)>
-    sImm32ImmGetContextStub;
-static WindowsDllInterceptor::FuncHookType<decltype(&ImmGetCompositionStringW)>
-    sImm32ImmGetCompositionStringStub;
-static WindowsDllInterceptor::FuncHookType<decltype(&ImmSetCandidateWindow)>
-    sImm32ImmSetCandidateWindowStub;
-static WindowsDllInterceptor::FuncHookType<decltype(&ImmNotifyIME)>
-    sImm32ImmNotifyIME;
-static WindowsDllInterceptor::FuncHookType<decltype(&ImmAssociateContextEx)>
-    sImm32ImmAssociateContextExStub;
-
-static PluginInstanceChild* sCurrentPluginInstance = nullptr;
-static const HIMC sHookIMC = (const HIMC)0xefefefef;
-
-// Flash WM_USER message delay time for PostDelayedTask. Borrowed
-// from Chromium's web plugin delegate src. See 'flash msg throttling
-// helpers' section for details.
-const int kFlashWMUSERMessageThrottleDelayMs = 5;
-
-static const TCHAR kPluginIgnoreSubclassProperty[] =
-    TEXT("PluginIgnoreSubclassProperty");
-
-#elif defined(XP_MACOSX)
-#  include <ApplicationServices/ApplicationServices.h>
-#  include "PluginUtilsOSX.h"
-#endif  // defined(XP_MACOSX)
-
-/**
- * We can't use gfxPlatform::CreateDrawTargetForSurface() because calling
- * gfxPlatform::GetPlatform() instantiates the prefs service, and that's not
- * allowed from processes other than the main process. So we have our own
- * version here.
- */
-static RefPtr<DrawTarget> CreateDrawTargetForSurface(gfxASurface* aSurface) {
-  SurfaceFormat format = aSurface->GetSurfaceFormat();
-  RefPtr<DrawTarget> drawTarget = Factory::CreateDrawTargetForCairoSurface(
-      aSurface->CairoSurface(), aSurface->GetSize(), &format);
-  if (!drawTarget) {
-    MOZ_CRASH("CreateDrawTargetForSurface failed in plugin");
-  }
-  return drawTarget;
-}
-
-PluginInstanceChild::PluginInstanceChild(const NPPluginFuncs* aPluginIface,
-                                         const nsCString& aMimeType,
-                                         const nsTArray<nsCString>& aNames,
-                                         const nsTArray<nsCString>& aValues)
-    : mPluginIface(aPluginIface),
-      mMimeType(aMimeType),
-      mNames(aNames.Clone()),
-      mValues(aValues.Clone())
-#if defined(XP_DARWIN) || defined(XP_WIN)
-      ,
-      mContentsScaleFactor(1.0)
-#endif
-      ,
-      mCSSZoomFactor(0.0),
-      mDrawingModel(kDefaultDrawingModel),
-      mCurrentDirectSurface(nullptr),
-      mAsyncInvalidateMutex("PluginInstanceChild::mAsyncInvalidateMutex"),
-      mAsyncInvalidateTask(0),
-      mCachedWindowActor(nullptr),
-      mCachedElementActor(nullptr)
-#if defined(OS_WIN)
-      ,
-      mPluginWindowHWND(0),
-      mPluginWndProc(0),
-      mPluginParentHWND(0),
-      mCachedWinlessPluginHWND(0),
-      mWinlessPopupSurrogateHWND(0),
-      mWinlessThrottleOldWndProc(0),
-      mWinlessHiddenMsgHWND(0)
-#endif  // OS_WIN
-#if defined(MOZ_WIDGET_COCOA)
-#  if defined(__i386__)
-      ,
-      mEventModel(NPEventModelCarbon)
-#  endif
-      ,
-      mShColorSpace(nullptr),
-      mShContext(nullptr),
-      mCGLayer(nullptr),
-      mCARefreshTimer(0),
-      mCurrentEvent(nullptr)
-#endif
-      ,
-      mLayersRendering(false)
-#ifdef XP_WIN
-      ,
-      mCurrentSurfaceActor(nullptr),
-      mBackSurfaceActor(nullptr)
-#endif
-      ,
-      mAccumulatedInvalidRect(0, 0, 0, 0),
-      mIsTransparent(false),
-      mSurfaceType(gfxSurfaceType::Max),
-      mPendingPluginCall(false),
-      mDoAlphaExtraction(false),
-      mHasPainted(false),
-      mSurfaceDifferenceRect(0, 0, 0, 0),
-      mDestroyed(false)
-#ifdef XP_WIN
-      ,
-      mLastEnableIMEState(true)
-#endif  // #ifdef XP_WIN
-      ,
-      mStackDepth(0) {
-  memset(&mWindow, 0, sizeof(mWindow));
-  mWindow.type = NPWindowTypeWindow;
-  mData.ndata = (void*)this;
-  mData.pdata = nullptr;
-#if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
-  mWindow.ws_info = &mWsInfo;
-  memset(&mWsInfo, 0, sizeof(mWsInfo));
-#  ifdef MOZ_WIDGET_GTK
-  mWsInfo.display = nullptr;
-#  else
-  mWsInfo.display = DefaultXDisplay();
-#  endif
-#endif  // MOZ_X11 && XP_UNIX && !XP_MACOSX
-#if defined(OS_WIN)
-  InitPopupMenuHook();
-  InitImm32Hook();
-#endif  // OS_WIN
-}
-
-PluginInstanceChild::~PluginInstanceChild() {
-#if defined(OS_WIN)
-  NS_ASSERTION(!mPluginWindowHWND,
-               "Destroying PluginInstanceChild without NPP_Destroy?");
-  // In the event that we registered for audio device changes, stop.
-  PluginModuleChild* chromeInstance = PluginModuleChild::GetChrome();
-  if (chromeInstance) {
-    chromeInstance->PluginRequiresAudioDeviceChanges(this, false);
-  }
-#endif
-#if defined(MOZ_WIDGET_COCOA)
-  if (mShColorSpace) {
-    ::CGColorSpaceRelease(mShColorSpace);
-  }
-  if (mShContext) {
-    ::CGContextRelease(mShContext);
-  }
-  if (mCGLayer) {
-    PluginUtilsOSX::ReleaseCGLayer(mCGLayer);
-  }
-  if (mDrawingModel == NPDrawingModelCoreAnimation) {
-    UnscheduleTimer(mCARefreshTimer);
-  }
-#endif
-}
-
-NPError PluginInstanceChild::DoNPP_New() {
-  // unpack the arguments into a C format
-  int argc = mNames.Length();
-  NS_ASSERTION(argc == (int)mValues.Length(), "argn.length != argv.length");
-
-  UniquePtr<char*[]> argn(new char*[1 + argc]);
-  UniquePtr<char*[]> argv(new char*[1 + argc]);
-  argn[argc] = 0;
-  argv[argc] = 0;
-
-  for (int i = 0; i < argc; ++i) {
-    argn[i] = const_cast<char*>(NullableStringGet(mNames[i]));
-    argv[i] = const_cast<char*>(NullableStringGet(mValues[i]));
-  }
-
-  NPP npp = GetNPP();
-
-  NPError rv = mPluginIface->newp((char*)NullableStringGet(mMimeType), npp,
-                                  NP_EMBED, argc, argn.get(), argv.get(), 0);
-  if (NPERR_NO_ERROR != rv) {
-    return rv;
-  }
-
-  if (!Initialize()) {
-    rv = NPERR_MODULE_LOAD_FAILED_ERROR;
-  }
-  return rv;
-}
-
-int PluginInstanceChild::GetQuirks() {
-  return PluginModuleChild::GetChrome()->GetQuirks();
-}
-
-NPError PluginInstanceChild::InternalGetNPObjectForValue(NPNVariable aValue,
-                                                         NPObject** aObject) {
-  PluginScriptableObjectChild* actor = nullptr;
-  NPError result = NPERR_NO_ERROR;
-
-  switch (aValue) {
-    case NPNVWindowNPObject:
-      if (!(actor = mCachedWindowActor)) {
-        result = NPERR_GENERIC_ERROR;
-        PPluginScriptableObjectChild* actorProtocol;
-        if (CallNPN_GetValue_NPNVWindowNPObject(&actorProtocol, &result) &&
-            (result == NPERR_NO_ERROR)) {
-          actor = mCachedWindowActor =
-              static_cast<PluginScriptableObjectChild*>(actorProtocol);
-          NS_ASSERTION(actor, "Null actor!");
-          if (!actor->GetObject(false)) {
-            return NPERR_GENERIC_ERROR;
-          }
-          PluginModuleChild::sBrowserFuncs.retainobject(
-              actor->GetObject(false));
-        }
-      }
-      break;
-
-    case NPNVPluginElementNPObject:
-      if (!(actor = mCachedElementActor)) {
-        result = NPERR_GENERIC_ERROR;
-        PPluginScriptableObjectChild* actorProtocol;
-        if (CallNPN_GetValue_NPNVPluginElementNPObject(&actorProtocol,
-                                                       &result) &&
-            (result == NPERR_NO_ERROR)) {
-          actor = mCachedElementActor =
-              static_cast<PluginScriptableObjectChild*>(actorProtocol);
-          NS_ASSERTION(actor, "Null actor!");
-          if (!actor->GetObject(false)) {
-            return NPERR_GENERIC_ERROR;
-          }
-          PluginModuleChild::sBrowserFuncs.retainobject(
-              actor->GetObject(false));
-        }
-      }
-      break;
-
-    default:
-      result = NPERR_GENERIC_ERROR;
-      MOZ_ASSERT_UNREACHABLE(
-          "Don't know what to do with this value "
-          "type!");
-  }
-
-#ifdef DEBUG
-  {
-    NPError currentResult;
-    PPluginScriptableObjectChild* currentActor = nullptr;
-
-    switch (aValue) {
-      case NPNVWindowNPObject:
-        CallNPN_GetValue_NPNVWindowNPObject(&currentActor, &currentResult);
-        break;
-      case NPNVPluginElementNPObject:
-        CallNPN_GetValue_NPNVPluginElementNPObject(&currentActor,
-                                                   &currentResult);
-        break;
-      default:
-        MOZ_ASSERT(false);
-    }
-
-    // Make sure that the current actor returned by the parent matches our
-    // cached actor!
-    NS_ASSERTION(!currentActor || static_cast<PluginScriptableObjectChild*>(
-                                      currentActor) == actor,
-                 "Cached actor is out of date!");
-  }
-#endif
-
-  if (result != NPERR_NO_ERROR) {
-    return result;
-  }
-
-  NPObject* object;
-  if (!(object = actor->GetObject(false))) {
-    return NPERR_GENERIC_ERROR;
-  }
-
-  *aObject = PluginModuleChild::sBrowserFuncs.retainobject(object);
-  return NPERR_NO_ERROR;
-}
-
-NPError PluginInstanceChild::NPN_GetValue(NPNVariable aVar, void* aValue) {
-  PLUGIN_LOG_DEBUG(("%s (aVar=%i)", FULLFUNCTION, (int)aVar));
-  AssertPluginThread();
-  AutoStackHelper guard(this);
-
-  switch (aVar) {
-#if defined(MOZ_X11)
-    case NPNVToolkit:
-      *((NPNToolkitType*)aValue) = NPNVGtk2;
-      return NPERR_NO_ERROR;
-
-    case NPNVxDisplay:
-      if (!mWsInfo.display) {
-        // We are called before Initialize() so we have to call it now.
-        if (!Initialize()) {
-          return NPERR_GENERIC_ERROR;
-        }
-        NS_ASSERTION(mWsInfo.display, "We should have a valid display!");
-      }
-      *(void**)aValue = mWsInfo.display;
-      return NPERR_NO_ERROR;
-
-#elif defined(OS_WIN)
-    case NPNVToolkit:
-      return NPERR_GENERIC_ERROR;
-#endif
-    case NPNVprivateModeBool: {
-      bool v = false;
-      NPError result;
-      if (!CallNPN_GetValue_NPNVprivateModeBool(&v, &result)) {
-        return NPERR_GENERIC_ERROR;
-      }
-      *static_cast<NPBool*>(aValue) = v;
-      return result;
-    }
-
-    case NPNVdocumentOrigin: {
-      nsCString v;
-      NPError result;
-      if (!CallNPN_GetValue_NPNVdocumentOrigin(&v, &result)) {
-        return NPERR_GENERIC_ERROR;
-      }
-      if (result == NPERR_NO_ERROR ||
-          (GetQuirks() & QUIRK_FLASH_RETURN_EMPTY_DOCUMENT_ORIGIN)) {
-        *static_cast<char**>(aValue) = ToNewCString(v);
-      }
-      return result;
-    }
-
-    case NPNVWindowNPObject:  // Intentional fall-through
-    case NPNVPluginElementNPObject: {
-      NPObject* object;
-      *((NPObject**)aValue) = nullptr;
-      NPError result = InternalGetNPObjectForValue(aVar, &object);
-      if (result == NPERR_NO_ERROR) {
-        *((NPObject**)aValue) = object;
-      }
-      return result;
-    }
-
-    case NPNVnetscapeWindow: {
-#ifdef XP_WIN
-      if (mWindow.type == NPWindowTypeDrawable) {
-        if (mCachedWinlessPluginHWND) {
-          *static_cast<HWND*>(aValue) = mCachedWinlessPluginHWND;
-          return NPERR_NO_ERROR;
-        }
-        NPError result;
-        if (!CallNPN_GetValue_NPNVnetscapeWindow(&mCachedWinlessPluginHWND,
-                                                 &result)) {
-          return NPERR_GENERIC_ERROR;
-        }
-        *static_cast<HWND*>(aValue) = mCachedWinlessPluginHWND;
-        return result;
-      } else {
-        *static_cast<HWND*>(aValue) = mPluginWindowHWND;
-        return NPERR_NO_ERROR;
-      }
-#elif defined(MOZ_X11)
-      NPError result;
-      CallNPN_GetValue_NPNVnetscapeWindow(static_cast<XID*>(aValue), &result);
-      return result;
-#else
-      return NPERR_GENERIC_ERROR;
-#endif
-    }
-
-    case NPNVsupportsAsyncBitmapSurfaceBool: {
-      bool value = false;
-      CallNPN_GetValue_SupportsAsyncBitmapSurface(&value);
-      *((NPBool*)aValue) = value;
-      return NPERR_NO_ERROR;
-    }
-
-#ifdef XP_WIN
-    case NPNVsupportsAsyncWindowsDXGISurfaceBool: {
-      bool value = false;
-      CallNPN_GetValue_SupportsAsyncDXGISurface(&value);
-      *((NPBool*)aValue) = value;
-      return NPERR_NO_ERROR;
-    }
-#endif
-
-#ifdef XP_WIN
-    case NPNVpreferredDXGIAdapter: {
-      DxgiAdapterDesc desc;
-      if (!CallNPN_GetValue_PreferredDXGIAdapter(&desc)) {
-        return NPERR_GENERIC_ERROR;
-      }
-      *reinterpret_cast<DXGI_ADAPTER_DESC*>(aValue) = desc.ToDesc();
-      return NPERR_NO_ERROR;
-    }
-#endif
-
-#ifdef XP_MACOSX
-    case NPNVsupportsCoreGraphicsBool: {
-      *((NPBool*)aValue) = true;
-      return NPERR_NO_ERROR;
-    }
-
-    case NPNVsupportsCoreAnimationBool: {
-      *((NPBool*)aValue) = true;
-      return NPERR_NO_ERROR;
-    }
-
-    case NPNVsupportsInvalidatingCoreAnimationBool: {
-      *((NPBool*)aValue) = true;
-      return NPERR_NO_ERROR;
-    }
-
-    case NPNVsupportsCompositingCoreAnimationPluginsBool: {
-      *((NPBool*)aValue) = true;
-      return NPERR_NO_ERROR;
-    }
-
-    case NPNVsupportsCocoaBool: {
-      *((NPBool*)aValue) = true;
-      return NPERR_NO_ERROR;
-    }
-
-#  ifndef NP_NO_CARBON
-    case NPNVsupportsCarbonBool: {
-      *((NPBool*)aValue) = false;
-      return NPERR_NO_ERROR;
-    }
-#  endif
-
-    case NPNVsupportsUpdatedCocoaTextInputBool: {
-      *static_cast<NPBool*>(aValue) = true;
-      return NPERR_NO_ERROR;
-    }
-
-#  ifndef NP_NO_QUICKDRAW
-    case NPNVsupportsQuickDrawBool: {
-      *((NPBool*)aValue) = false;
-      return NPERR_NO_ERROR;
-    }
-#  endif /* NP_NO_QUICKDRAW */
-#endif   /* XP_MACOSX */
-
-#if defined(XP_MACOSX) || defined(XP_WIN)
-    case NPNVcontentsScaleFactor: {
-      *static_cast<double*>(aValue) = mContentsScaleFactor;
-      return NPERR_NO_ERROR;
-    }
-#endif /* defined(XP_MACOSX) || defined(XP_WIN) */
-
-    case NPNVCSSZoomFactor: {
-      *static_cast<double*>(aValue) = mCSSZoomFactor;
-      return NPERR_NO_ERROR;
-    }
-
-#ifdef DEBUG
-    case NPNVjavascriptEnabledBool:
-    case NPNVasdEnabledBool:
-    case NPNVisOfflineBool:
-    case NPNVSupportsXEmbedBool:
-    case NPNVSupportsWindowless:
-      MOZ_FALLTHROUGH_ASSERT(
-          "NPNVariable should be handled in "
-          "PluginModuleChild.");
-#endif
-
-    default:
-      MOZ_LOG(GetPluginLog(), LogLevel::Warning,
-              ("In PluginInstanceChild::NPN_GetValue: Unhandled NPNVariable %i "
-               "(%s)",
-               (int)aVar, NPNVariableToString(aVar)));
-      return NPERR_GENERIC_ERROR;
-  }
-}
-
-#ifdef MOZ_WIDGET_COCOA
-#  define DEFAULT_REFRESH_MS 20  // CoreAnimation: 50 FPS
-
-void CAUpdate(NPP npp, uint32_t timerID) {
-  static_cast<PluginInstanceChild*>(npp->ndata)->Invalidate();
-}
-
-void PluginInstanceChild::Invalidate() {
-  NPRect windowRect = {0, 0, uint16_t(mWindow.height), uint16_t(mWindow.width)};
-
-  InvalidateRect(&windowRect);
-}
-#endif
-
-NPError PluginInstanceChild::NPN_SetValue(NPPVariable aVar, void* aValue) {
-  MOZ_LOG(GetPluginLog(), LogLevel::Debug,
-          ("%s (aVar=%i, aValue=%p)", FULLFUNCTION, (int)aVar, aValue));
-
-  AssertPluginThread();
-
-  AutoStackHelper guard(this);
-
-  switch (aVar) {
-    case NPPVpluginWindowBool: {
-      NPError rv;
-      bool windowed = (NPBool)(intptr_t)aValue;
-
-      if (windowed) {
-        return NPERR_GENERIC_ERROR;
-      }
-
-      if (!CallNPN_SetValue_NPPVpluginWindow(windowed, &rv))
-        return NPERR_GENERIC_ERROR;
-
-      mWindow.type = NPWindowTypeDrawable;
-      return rv;
-    }
-
-    case NPPVpluginTransparentBool: {
-      NPError rv;
-      mIsTransparent = (!!aValue);
-
-      if (!CallNPN_SetValue_NPPVpluginTransparent(mIsTransparent, &rv))
-        return NPERR_GENERIC_ERROR;
-
-      return rv;
-    }
-
-    case NPPVpluginUsesDOMForCursorBool: {
-      NPError rv = NPERR_GENERIC_ERROR;
-      if (!CallNPN_SetValue_NPPVpluginUsesDOMForCursor((NPBool)(intptr_t)aValue,
-                                                       &rv)) {
-        return NPERR_GENERIC_ERROR;
-      }
-      return rv;
-    }
-
-    case NPPVpluginDrawingModel: {
-      NPError rv;
-      int drawingModel = (int16_t)(intptr_t)aValue;
-
-      if (!CallNPN_SetValue_NPPVpluginDrawingModel(drawingModel, &rv))
-        return NPERR_GENERIC_ERROR;
-
-      mDrawingModel = drawingModel;
-
-#ifdef XP_MACOSX
-      if (drawingModel == NPDrawingModelCoreAnimation) {
-        mCARefreshTimer = ScheduleTimer(DEFAULT_REFRESH_MS, true, CAUpdate);
-      }
-#endif
-
-      PLUGIN_LOG_DEBUG(
-          ("  Plugin requested drawing model id  #%i\n", mDrawingModel));
-
-      return rv;
-    }
-
-#ifdef XP_MACOSX
-    case NPPVpluginEventModel: {
-      NPError rv;
-      int eventModel = (int16_t)(intptr_t)aValue;
-
-      if (!CallNPN_SetValue_NPPVpluginEventModel(eventModel, &rv))
-        return NPERR_GENERIC_ERROR;
-#  if defined(__i386__)
-      mEventModel = static_cast<NPEventModel>(eventModel);
-#  endif
-
-      PLUGIN_LOG_DEBUG(
-          ("  Plugin requested event model id # %i\n", eventModel));
-
-      return rv;
-    }
-#endif
-
-    case NPPVpluginIsPlayingAudio: {
-      NPError rv = NPERR_GENERIC_ERROR;
-      if (!CallNPN_SetValue_NPPVpluginIsPlayingAudio((NPBool)(intptr_t)aValue,
-                                                     &rv)) {
-        return NPERR_GENERIC_ERROR;
-      }
-      return rv;
-    }
-
-#ifdef XP_WIN
-    case NPPVpluginRequiresAudioDeviceChanges: {
-      // Many other NPN_SetValue variables are forwarded to our
-      // PluginInstanceParent, which runs on a content process.  We
-      // instead forward this message to the PluginModuleParent, which runs
-      // on the chrome process.  This is because our audio
-      // API calls should run the chrome proc, not content.
-      NPError rv = NPERR_GENERIC_ERROR;
-      PluginModuleChild* chromeInstance = PluginModuleChild::GetChrome();
-      if (chromeInstance) {
-        rv = chromeInstance->PluginRequiresAudioDeviceChanges(
-            this, (NPBool)(intptr_t)aValue);
-      }
-      return rv;
-    }
-#endif
-
-    default:
-      MOZ_LOG(GetPluginLog(), LogLevel::Warning,
-              ("In PluginInstanceChild::NPN_SetValue: Unhandled NPPVariable %i "
-               "(%s)",
-               (int)aVar, NPPVariableToString(aVar)));
-      return NPERR_GENERIC_ERROR;
-  }
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceChild::AnswerNPP_GetValue_NPPVpluginWantsAllNetworkStreams(
-    bool* wantsAllStreams, NPError* rv) {
-  AssertPluginThread();
-  AutoStackHelper guard(this);
-
-  uint32_t value = 0;
-  if (!mPluginIface->getvalue) {
-    *rv = NPERR_GENERIC_ERROR;
-  } else {
-    *rv = mPluginIface->getvalue(GetNPP(), NPPVpluginWantsAllNetworkStreams,
-                                 &value);
-  }
-  *wantsAllStreams = value;
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceChild::AnswerNPP_GetValue_NPPVpluginScriptableNPObject(
-    PPluginScriptableObjectChild** aValue, NPError* aResult) {
-  AssertPluginThread();
-  AutoStackHelper guard(this);
-
-  NPObject* object = nullptr;
-  NPError result = NPERR_GENERIC_ERROR;
-  if (mPluginIface->getvalue) {
-    result =
-        mPluginIface->getvalue(GetNPP(), NPPVpluginScriptableNPObject, &object);
-  }
-  if (result == NPERR_NO_ERROR && object) {
-    PluginScriptableObjectChild* actor = GetActorForNPObject(object);
-
-    // If we get an actor then it has retained. Otherwise we don't need it
-    // any longer.
-    PluginModuleChild::sBrowserFuncs.releaseobject(object);
-    if (actor) {
-      *aValue = actor;
-      *aResult = NPERR_NO_ERROR;
-      return IPC_OK();
-    }
-
-    NS_ERROR("Failed to get actor!");
-    result = NPERR_GENERIC_ERROR;
-  } else {
-    result = NPERR_GENERIC_ERROR;
-  }
-
-  *aValue = nullptr;
-  *aResult = result;
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceChild::AnswerNPP_GetValue_NPPVpluginNativeAccessibleAtkPlugId(
-    nsCString* aPlugId, NPError* aResult) {
-  AssertPluginThread();
-  AutoStackHelper guard(this);
-
-#if MOZ_ACCESSIBILITY_ATK
-
-  char* plugId = nullptr;
-  NPError result = NPERR_GENERIC_ERROR;
-  if (mPluginIface->getvalue) {
-    result = mPluginIface->getvalue(
-        GetNPP(), NPPVpluginNativeAccessibleAtkPlugId, &plugId);
-  }
-
-  *aPlugId = nsCString(plugId);
-  *aResult = result;
-  return IPC_OK();
-
-#else
-
-  MOZ_CRASH("shouldn't be called on non-ATK platforms");
-
-#endif
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceChild::AnswerNPP_SetValue_NPNVprivateModeBool(const bool& value,
-                                                            NPError* result) {
-  if (!mPluginIface->setvalue) {
-    *result = NPERR_GENERIC_ERROR;
-    return IPC_OK();
-  }
-
-  NPBool v = value;
-  *result = mPluginIface->setvalue(GetNPP(), NPNVprivateModeBool, &v);
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceChild::AnswerNPP_SetValue_NPNVCSSZoomFactor(const double& value,
-                                                          NPError* result) {
-  if (!mPluginIface->setvalue) {
-    *result = NPERR_GENERIC_ERROR;
-    return IPC_OK();
-  }
-
-  mCSSZoomFactor = value;
-  double v = value;
-  *result = mPluginIface->setvalue(GetNPP(), NPNVCSSZoomFactor, &v);
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceChild::AnswerNPP_SetValue_NPNVmuteAudioBool(const bool& value,
-                                                          NPError* result) {
-  if (!mPluginIface->setvalue) {
-    *result = NPERR_GENERIC_ERROR;
-    return IPC_OK();
-  }
-
-  NPBool v = value;
-  *result = mPluginIface->setvalue(GetNPP(), NPNVmuteAudioBool, &v);
-  return IPC_OK();
-}
-
-#if defined(XP_WIN)
-NPError PluginInstanceChild::DefaultAudioDeviceChanged(
-    NPAudioDeviceChangeDetails& details) {
-  if (!mPluginIface->setvalue) {
-    return NPERR_GENERIC_ERROR;
-  }
-  return mPluginIface->setvalue(GetNPP(), NPNVaudioDeviceChangeDetails,
-                                (void*)&details);
-}
-
-NPError PluginInstanceChild::AudioDeviceStateChanged(
-    NPAudioDeviceStateChanged& aDeviceState) {
-  if (!mPluginIface->setvalue) {
-    return NPERR_GENERIC_ERROR;
-  }
-  return mPluginIface->setvalue(GetNPP(), NPNVaudioDeviceStateChanged,
-                                (void*)&aDeviceState);
-}
-
-void SetMouseEventWParam(NPEvent* aEvent) {
-  // Fill in potentially missing key state info.  See
-  // nsPluginInstanceOwner::ProcessEvent for circumstances where this happens.
-  const auto kMouseMessages = mozilla::Array<int, 9>(
-      WM_LBUTTONDOWN, WM_MBUTTONDOWN, WM_RBUTTONDOWN, WM_LBUTTONUP,
-      WM_MBUTTONUP, WM_RBUTTONUP, WM_MOUSEMOVE, WM_MOUSEWHEEL, WM_MOUSEHWHEEL);
-
-  bool isInvalidWParam =
-      (aEvent->wParam == NPAPI_INVALID_WPARAM) &&
-      (std::find(kMouseMessages.begin(), kMouseMessages.end(),
-                 static_cast<int>(aEvent->event)) != kMouseMessages.end());
-
-  if (!isInvalidWParam) {
-    return;
-  }
-
-  aEvent->wParam = (::GetKeyState(VK_CONTROL) ? MK_CONTROL : 0) |
-                   (::GetKeyState(VK_SHIFT) ? MK_SHIFT : 0) |
-                   (::GetKeyState(VK_LBUTTON) ? MK_LBUTTON : 0) |
-                   (::GetKeyState(VK_MBUTTON) ? MK_MBUTTON : 0) |
-                   (::GetKeyState(VK_RBUTTON) ? MK_RBUTTON : 0) |
-                   (::GetKeyState(VK_XBUTTON1) ? MK_XBUTTON1 : 0) |
-                   (::GetKeyState(VK_XBUTTON2) ? MK_XBUTTON2 : 0);
-}
-#endif
-
-mozilla::ipc::IPCResult PluginInstanceChild::AnswerNPP_HandleEvent(
-    const NPRemoteEvent& event, int16_t* handled) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  AssertPluginThread();
-  AutoStackHelper guard(this);
-
-#if defined(MOZ_X11) && defined(DEBUG)
-  if (GraphicsExpose == event.event.type)
-    PLUGIN_LOG_DEBUG(
-        ("  received drawable 0x%lx\n", event.event.xgraphicsexpose.drawable));
-#endif
-
-#ifdef XP_MACOSX
-  // Mac OS X does not define an NPEvent structure. It defines more specific
-  // types.
-  NPCocoaEvent evcopy = event.event;
-
-  // Make sure we reset mCurrentEvent in case of an exception
-  AutoRestore<const NPCocoaEvent*> savePreviousEvent(mCurrentEvent);
-
-  // Track the current event for NPN_PopUpContextMenu.
-  mCurrentEvent = &event.event;
-#else
-  // Make a copy since we may modify values.
-  NPEvent evcopy = event.event;
-#endif
-
-#if defined(XP_MACOSX) || defined(XP_WIN)
-  // event.contentsScaleFactor <= 0 is a signal we shouldn't use it,
-  // for example when AnswerNPP_HandleEvent() is called from elsewhere
-  // in the child process (not via rpc code from the parent process).
-  if (event.contentsScaleFactor > 0) {
-    mContentsScaleFactor = event.contentsScaleFactor;
-  }
-#endif
-
-#ifdef OS_WIN
-  // FIXME/bug 567645: temporarily drop the "dummy event" on the floor
-  if (WM_NULL == evcopy.event) return IPC_OK();
-
-  SetMouseEventWParam(&evcopy);
-  *handled = WinlessHandleEvent(evcopy);
-  return IPC_OK();
-#endif
-
-  // XXX A previous call to mPluginIface->event might block, e.g. right click
-  // for context menu. Still, we might get here again, calling into the plugin
-  // a second time while it's in the previous call.
-  if (!mPluginIface->event)
-    *handled = false;
-  else
-    *handled = mPluginIface->event(&mData, reinterpret_cast<void*>(&evcopy));
-
-#ifdef XP_MACOSX
-  // Release any reference counted objects created in the child process.
-  if (evcopy.type == NPCocoaEventKeyDown || evcopy.type == NPCocoaEventKeyUp) {
-    ::CFRelease((CFStringRef)evcopy.data.key.characters);
-    ::CFRelease((CFStringRef)evcopy.data.key.charactersIgnoringModifiers);
-  } else if (evcopy.type == NPCocoaEventTextInput) {
-    ::CFRelease((CFStringRef)evcopy.data.text.text);
-  }
-#endif
-
-#ifdef MOZ_X11
-  if (GraphicsExpose == event.event.type) {
-    // Make sure the X server completes the drawing before the parent
-    // draws on top and destroys the Drawable.
-    //
-    // XSync() waits for the X server to complete.  Really this child
-    // process does not need to wait; the parent is the process that needs
-    // to wait.  A possibly-slightly-better alternative would be to send
-    // an X event to the parent that the parent would wait for.
-    XSync(mWsInfo.display, X11False);
-  }
-#endif
-
-  return IPC_OK();
-}
-
-#ifdef XP_MACOSX
-
-mozilla::ipc::IPCResult PluginInstanceChild::AnswerNPP_HandleEvent_Shmem(
-    const NPRemoteEvent& event, Shmem&& mem, int16_t* handled, Shmem* rtnmem) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  AssertPluginThread();
-  AutoStackHelper guard(this);
-
-  PaintTracker pt;
-
-  NPCocoaEvent evcopy = event.event;
-  mContentsScaleFactor = event.contentsScaleFactor;
-
-  if (evcopy.type == NPCocoaEventDrawRect) {
-    int scaleFactor = ceil(mContentsScaleFactor);
-    if (!mShColorSpace) {
-      mShColorSpace = CreateSystemColorSpace();
-      if (!mShColorSpace) {
-        PLUGIN_LOG_DEBUG(("Could not allocate ColorSpace."));
-        *handled = false;
-        *rtnmem = mem;
-        return IPC_OK();
-      }
-    }
-    if (!mShContext) {
-      void* cgContextByte = mem.get<char>();
-      mShContext = ::CGBitmapContextCreate(
-          cgContextByte, mWindow.width * scaleFactor,
-          mWindow.height * scaleFactor, 8, mWindow.width * 4 * scaleFactor,
-          mShColorSpace,
-          kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
-
-      if (!mShContext) {
-        PLUGIN_LOG_DEBUG(("Could not allocate CGBitmapContext."));
-        *handled = false;
-        *rtnmem = mem;
-        return IPC_OK();
-      }
-    }
-    CGRect clearRect = ::CGRectMake(0, 0, mWindow.width, mWindow.height);
-    ::CGContextClearRect(mShContext, clearRect);
-    evcopy.data.draw.context = mShContext;
-  } else {
-    PLUGIN_LOG_DEBUG(("Invalid event type for AnswerNNP_HandleEvent_Shmem."));
-    *handled = false;
-    *rtnmem = mem;
-    return IPC_OK();
-  }
-
-  if (!mPluginIface->event) {
-    *handled = false;
-  } else {
-    ::CGContextSaveGState(evcopy.data.draw.context);
-    *handled = mPluginIface->event(&mData, reinterpret_cast<void*>(&evcopy));
-    ::CGContextRestoreGState(evcopy.data.draw.context);
-  }
-
-  *rtnmem = mem;
-  return IPC_OK();
-}
-
-#else
-mozilla::ipc::IPCResult PluginInstanceChild::AnswerNPP_HandleEvent_Shmem(
-    const NPRemoteEvent& event, Shmem&& mem, int16_t* handled, Shmem* rtnmem) {
-  MOZ_CRASH("not reached.");
-  *rtnmem = mem;
-  return IPC_OK();
-}
-#endif
-
-#ifdef XP_MACOSX
-
-void CallCGDraw(CGContextRef ref, void* aPluginInstance,
-                nsIntRect aUpdateRect) {
-  PluginInstanceChild* pluginInstance = (PluginInstanceChild*)aPluginInstance;
-
-  pluginInstance->CGDraw(ref, aUpdateRect);
-}
-
-bool PluginInstanceChild::CGDraw(CGContextRef ref, nsIntRect aUpdateRect) {
-  NPCocoaEvent drawEvent;
-  drawEvent.type = NPCocoaEventDrawRect;
-  drawEvent.version = 0;
-  drawEvent.data.draw.x = aUpdateRect.x;
-  drawEvent.data.draw.y = aUpdateRect.y;
-  drawEvent.data.draw.width = aUpdateRect.width;
-  drawEvent.data.draw.height = aUpdateRect.height;
-  drawEvent.data.draw.context = ref;
-
-  NPRemoteEvent remoteDrawEvent = {drawEvent};
-  // Signal to AnswerNPP_HandleEvent() not to use this value
-  remoteDrawEvent.contentsScaleFactor = -1.0;
-
-  int16_t handled;
-  AnswerNPP_HandleEvent(remoteDrawEvent, &handled);
-  return handled == true;
-}
-
-mozilla::ipc::IPCResult PluginInstanceChild::AnswerNPP_HandleEvent_IOSurface(
-    const NPRemoteEvent& event, const uint32_t& surfaceid, int16_t* handled) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  AssertPluginThread();
-  AutoStackHelper guard(this);
-
-  PaintTracker pt;
-
-  NPCocoaEvent evcopy = event.event;
-  mContentsScaleFactor = event.contentsScaleFactor;
-  RefPtr<MacIOSurface> surf =
-      MacIOSurface::LookupSurface(surfaceid, mContentsScaleFactor);
-  if (!surf) {
-    NS_ERROR("Invalid IOSurface.");
-    *handled = false;
-    return IPC_FAIL_NO_REASON(this);
-  }
-
-  if (!mCARenderer) {
-    mCARenderer = new nsCARenderer();
-  }
-
-  if (evcopy.type == NPCocoaEventDrawRect) {
-    mCARenderer->AttachIOSurface(surf);
-    if (!mCARenderer->isInit()) {
-      void* caLayer = nullptr;
-      NPError result = mPluginIface->getvalue(
-          GetNPP(), NPPVpluginCoreAnimationLayer, &caLayer);
-
-      if (result != NPERR_NO_ERROR || !caLayer) {
-        PLUGIN_LOG_DEBUG(
-            ("Plugin requested CoreAnimation but did not "
-             "provide CALayer."));
-        *handled = false;
-        return IPC_FAIL_NO_REASON(this);
-      }
-
-      mCARenderer->SetupRenderer(caLayer, mWindow.width, mWindow.height,
-                                 mContentsScaleFactor,
-                                 GetQuirks() & QUIRK_ALLOW_OFFLINE_RENDERER
-                                     ? ALLOW_OFFLINE_RENDERER
-                                     : DISALLOW_OFFLINE_RENDERER);
-
-      // Flash needs to have the window set again after this step
-      if (mPluginIface->setwindow)
-        (void)mPluginIface->setwindow(&mData, &mWindow);
-    }
-  } else {
-    PLUGIN_LOG_DEBUG(
-        ("Invalid event type for "
-         "AnswerNNP_HandleEvent_IOSurface."));
-    *handled = false;
-    return IPC_FAIL_NO_REASON(this);
-  }
-
-  mCARenderer->Render(mWindow.width, mWindow.height, mContentsScaleFactor,
-                      nullptr);
-
-  return IPC_OK();
-}
-
-#else
-mozilla::ipc::IPCResult PluginInstanceChild::AnswerNPP_HandleEvent_IOSurface(
-    const NPRemoteEvent& event, const uint32_t& surfaceid, int16_t* handled) {
-  MOZ_CRASH("NPP_HandleEvent_IOSurface is a OSX-only message");
-}
-#endif
-
-mozilla::ipc::IPCResult PluginInstanceChild::RecvWindowPosChanged(
-    const NPRemoteEvent& event) {
-  NS_ASSERTION(!mLayersRendering && !mPendingPluginCall,
-               "Shouldn't be receiving WindowPosChanged with layer rendering");
-
-#ifdef OS_WIN
-  int16_t dontcare;
-  return AnswerNPP_HandleEvent(event, &dontcare);
-#else
-  MOZ_CRASH("WindowPosChanged is a windows-only message");
-#endif
-}
-
-mozilla::ipc::IPCResult PluginInstanceChild::RecvContentsScaleFactorChanged(
-    const double& aContentsScaleFactor) {
-#if defined(XP_MACOSX) || defined(XP_WIN)
-  mContentsScaleFactor = aContentsScaleFactor;
-#  if defined(XP_MACOSX)
-  if (mShContext) {
-    // Release the shared context so that it is reallocated
-    // with the new size.
-    ::CGContextRelease(mShContext);
-    mShContext = nullptr;
-  }
-#  endif
-  return IPC_OK();
-#else
-  MOZ_CRASH("ContentsScaleFactorChanged is an Windows or OSX only message");
-#endif
-}
-
-mozilla::ipc::IPCResult PluginInstanceChild::AnswerCreateChildPluginWindow(
-    NativeWindowHandle* aChildPluginWindow) {
-#if defined(XP_WIN)
-  MOZ_ASSERT(!mPluginWindowHWND);
-
-  if (!CreatePluginWindow()) {
-    return IPC_FAIL_NO_REASON(this);
-  }
-
-  MOZ_ASSERT(mPluginWindowHWND);
-
-  *aChildPluginWindow = mPluginWindowHWND;
-  return IPC_OK();
-#else
-  MOZ_ASSERT_UNREACHABLE("CreateChildPluginWindow not implemented!");
-  return IPC_FAIL_NO_REASON(this);
-#endif
-}
-
-mozilla::ipc::IPCResult PluginInstanceChild::RecvCreateChildPopupSurrogate(
-    const NativeWindowHandle& aNetscapeWindow) {
-#if defined(XP_WIN)
-  mCachedWinlessPluginHWND = aNetscapeWindow;
-  CreateWinlessPopupSurrogate();
-  return IPC_OK();
-#else
-  MOZ_ASSERT_UNREACHABLE("CreateChildPluginWindow not implemented!");
-  return IPC_FAIL_NO_REASON(this);
-#endif
-}
-
-mozilla::ipc::IPCResult PluginInstanceChild::AnswerNPP_SetWindow(
-    const NPRemoteWindow& aWindow) {
-  PLUGIN_LOG_DEBUG(("%s (aWindow=<window: 0x%" PRIx64
-                    ", x: %d, y: %d, width: %d, height: %d>)",
-                    FULLFUNCTION, aWindow.window, aWindow.x, aWindow.y,
-                    aWindow.width, aWindow.height));
-  NS_ASSERTION(!mLayersRendering && !mPendingPluginCall,
-               "Shouldn't be receiving NPP_SetWindow with layer rendering");
-  AssertPluginThread();
-  AutoStackHelper guard(this);
-
-#if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
-  NS_ASSERTION(mWsInfo.display, "We should have a valid display!");
-
-  // The minimum info is sent over IPC to allow this
-  // code to determine the rest.
-
-  mWindow.x = aWindow.x;
-  mWindow.y = aWindow.y;
-  mWindow.width = aWindow.width;
-  mWindow.height = aWindow.height;
-  mWindow.clipRect = aWindow.clipRect;
-  mWindow.type = aWindow.type;
-
-  mWsInfo.colormap = aWindow.colormap;
-  int depth;
-  FindVisualAndDepth(mWsInfo.display, aWindow.visualID, &mWsInfo.visual,
-                     &depth);
-  mWsInfo.depth = depth;
-
-  PLUGIN_LOG_DEBUG(
-      ("[InstanceChild][%p] Answer_SetWindow w=<x=%d,y=%d, w=%d,h=%d>, "
-       "clip=<l=%d,t=%d,r=%d,b=%d>",
-       this, mWindow.x, mWindow.y, mWindow.width, mWindow.height,
-       mWindow.clipRect.left, mWindow.clipRect.top, mWindow.clipRect.right,
-       mWindow.clipRect.bottom));
-
-  if (mPluginIface->setwindow) (void)mPluginIface->setwindow(&mData, &mWindow);
-
-#elif defined(OS_WIN)
-  switch (aWindow.type) {
-    case NPWindowTypeWindow: {
-      MOZ_ASSERT(mPluginWindowHWND,
-                 "Child plugin window must exist before call to SetWindow");
-
-      HWND parentHWND = reinterpret_cast<HWND>(aWindow.window);
-      if (mPluginWindowHWND != parentHWND) {
-        mPluginParentHWND = parentHWND;
-        ShowWindow(mPluginWindowHWND, SW_SHOWNA);
-      }
-
-      SizePluginWindow(aWindow.width, aWindow.height);
-
-      mWindow.window = (void*)mPluginWindowHWND;
-      mWindow.x = aWindow.x;
-      mWindow.y = aWindow.y;
-      mWindow.width = aWindow.width;
-      mWindow.height = aWindow.height;
-      mWindow.type = aWindow.type;
-      mContentsScaleFactor = aWindow.contentsScaleFactor;
-
-      if (mPluginIface->setwindow) {
-        SetProp(mPluginWindowHWND, kPluginIgnoreSubclassProperty, (HANDLE)1);
-        (void)mPluginIface->setwindow(&mData, &mWindow);
-        WNDPROC wndProc = reinterpret_cast<WNDPROC>(
-            GetWindowLongPtr(mPluginWindowHWND, GWLP_WNDPROC));
-        if (wndProc != PluginWindowProc) {
-          mPluginWndProc = reinterpret_cast<WNDPROC>(
-              SetWindowLongPtr(mPluginWindowHWND, GWLP_WNDPROC,
-                               reinterpret_cast<LONG_PTR>(PluginWindowProc)));
-          NS_ASSERTION(mPluginWndProc != PluginWindowProc, "WTF?");
-        }
-        RemoveProp(mPluginWindowHWND, kPluginIgnoreSubclassProperty);
-        HookSetWindowLongPtr();
-      }
-    } break;
-
-    default:
-      MOZ_ASSERT_UNREACHABLE("Bad plugin window type.");
-      return IPC_FAIL_NO_REASON(this);
-      break;
-  }
-
-#elif defined(XP_MACOSX)
-
-  mWindow.x = aWindow.x;
-  mWindow.y = aWindow.y;
-  mWindow.width = aWindow.width;
-  mWindow.height = aWindow.height;
-  mWindow.clipRect = aWindow.clipRect;
-  mWindow.type = aWindow.type;
-  mContentsScaleFactor = aWindow.contentsScaleFactor;
-
-  if (mShContext) {
-    // Release the shared context so that it is reallocated
-    // with the new size.
-    ::CGContextRelease(mShContext);
-    mShContext = nullptr;
-  }
-
-  if (mPluginIface->setwindow) (void)mPluginIface->setwindow(&mData, &mWindow);
-
-#elif defined(ANDROID)
-  // TODO: Need Android impl
-#elif defined(MOZ_WIDGET_UIKIT) || defined(MOZ_WAYLAND)
-  // Don't care
-#else
-#  error Implement me for your OS
-#endif
-
-  return IPC_OK();
-}
-
-bool PluginInstanceChild::Initialize() {
-#if defined(MOZ_WIDGET_GTK) && defined(MOZ_X11)
-  if (mWsInfo.display) {
-    // Already initialized
-    return true;
-  }
-
-  // Request for windowless plugins is set in newp(), before this call.
-  if (mWindow.type == NPWindowTypeWindow) {
-    return false;
-  }
-
-  mWsInfo.display = DefaultXDisplay();
-#endif
-
-#if defined(XP_MACOSX) && defined(__i386__)
-  // If an i386 Mac OS X plugin has selected the Carbon event model then
-  // we have to fail. We do not support putting Carbon event model plugins
-  // out of process. Note that Carbon is the default model so out of process
-  // plugins need to actively negotiate something else in order to work
-  // out of process.
-  if (EventModel() == NPEventModelCarbon) {
-    return false;
-  }
-#endif
-
-  return true;
-}
-
-#if defined(OS_WIN)
-
-static const TCHAR kWindowClassName[] = TEXT("GeckoPluginWindow");
-static const TCHAR kPluginInstanceChildProperty[] =
-    TEXT("PluginInstanceChildProperty");
-static const TCHAR kFlashThrottleProperty[] =
-    TEXT("MozillaFlashThrottleProperty");
-
-// static
-bool PluginInstanceChild::RegisterWindowClass() {
-  static bool alreadyRegistered = false;
-  if (alreadyRegistered) return true;
-
-  alreadyRegistered = true;
-
-  WNDCLASSEX wcex;
-  wcex.cbSize = sizeof(WNDCLASSEX);
-  wcex.style = CS_DBLCLKS;
-  wcex.lpfnWndProc = DummyWindowProc;
-  wcex.cbClsExtra = 0;
-  wcex.cbWndExtra = 0;
-  wcex.hInstance = GetModuleHandle(nullptr);
-  wcex.hIcon = 0;
-  wcex.hCursor = 0;
-  wcex.hbrBackground = reinterpret_cast<HBRUSH>(COLOR_WINDOW + 1);
-  wcex.lpszMenuName = 0;
-  wcex.lpszClassName = kWindowClassName;
-  wcex.hIconSm = 0;
-
-  return RegisterClassEx(&wcex);
-}
-
-bool PluginInstanceChild::CreatePluginWindow() {
-  // already initialized
-  if (mPluginWindowHWND) return true;
-
-  if (!RegisterWindowClass()) return false;
-
-  mPluginWindowHWND = CreateWindowEx(
-      WS_EX_LEFT | WS_EX_LTRREADING |
-          WS_EX_NOPARENTNOTIFY |  // XXXbent Get rid of this!
-          WS_EX_RIGHTSCROLLBAR,
-      kWindowClassName, 0, WS_POPUP | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, 0, 0,
-      0, 0, nullptr, 0, GetModuleHandle(nullptr), 0);
-  if (!mPluginWindowHWND) return false;
-  if (!SetProp(mPluginWindowHWND, kPluginInstanceChildProperty, this))
-    return false;
-
-  // Apparently some plugins require an ASCII WndProc.
-  SetWindowLongPtrA(mPluginWindowHWND, GWLP_WNDPROC,
-                    reinterpret_cast<LONG_PTR>(DefWindowProcA));
-
-  return true;
-}
-
-void PluginInstanceChild::DestroyPluginWindow() {
-  if (mPluginWindowHWND) {
-    // Unsubclass the window.
-    WNDPROC wndProc = reinterpret_cast<WNDPROC>(
-        GetWindowLongPtr(mPluginWindowHWND, GWLP_WNDPROC));
-    // Removed prior to SetWindowLongPtr, see HookSetWindowLongPtr.
-    RemoveProp(mPluginWindowHWND, kPluginInstanceChildProperty);
-    if (wndProc == PluginWindowProc) {
-      NS_ASSERTION(mPluginWndProc, "Should have old proc here!");
-      SetWindowLongPtr(mPluginWindowHWND, GWLP_WNDPROC,
-                       reinterpret_cast<LONG_PTR>(mPluginWndProc));
-      mPluginWndProc = 0;
-    }
-    DestroyWindow(mPluginWindowHWND);
-    mPluginWindowHWND = 0;
-  }
-}
-
-void PluginInstanceChild::SizePluginWindow(int width, int height) {
-  if (mPluginWindowHWND) {
-    mPluginSize.x = width;
-    mPluginSize.y = height;
-    SetWindowPos(mPluginWindowHWND, nullptr, 0, 0, width, height,
-                 SWP_NOZORDER | SWP_NOREPOSITION);
-  }
-}
-
-// See chromium's webplugin_delegate_impl.cc for explanation of this function.
-// static
-LRESULT CALLBACK PluginInstanceChild::DummyWindowProc(HWND hWnd, UINT message,
-                                                      WPARAM wParam,
-                                                      LPARAM lParam) {
-  return CallWindowProc(DefWindowProc, hWnd, message, wParam, lParam);
-}
-
-// static
-LRESULT CALLBACK PluginInstanceChild::PluginWindowProc(HWND hWnd, UINT message,
-                                                       WPARAM wParam,
-                                                       LPARAM lParam) {
-  return mozilla::CallWindowProcCrashProtected(PluginWindowProcInternal, hWnd,
-                                               message, wParam, lParam);
-}
-
-// static
-LRESULT CALLBACK PluginInstanceChild::PluginWindowProcInternal(HWND hWnd,
-                                                               UINT message,
-                                                               WPARAM wParam,
-                                                               LPARAM lParam) {
-  NS_ASSERTION(!mozilla::ipc::MessageChannel::IsPumpingMessages(),
-               "Failed to prevent a nonqueued message from running!");
-  PluginInstanceChild* self = reinterpret_cast<PluginInstanceChild*>(
-      GetProp(hWnd, kPluginInstanceChildProperty));
-  if (!self) {
-    MOZ_ASSERT_UNREACHABLE("Badness!");
-    return 0;
-  }
-
-  NS_ASSERTION(self->mPluginWindowHWND == hWnd, "Wrong window!");
-  NS_ASSERTION(
-      self->mPluginWndProc != PluginWindowProc,
-      "Self-referential windowproc. Infinite recursion will happen soon.");
-
-  bool isIMECompositionMessage = false;
-  switch (message) {
-    // Adobe's shockwave positions the plugin window relative to the browser
-    // frame when it initializes. With oopp disabled, this wouldn't have an
-    // effect. With oopp, GeckoPluginWindow is a child of the parent plugin
-    // window, so the move offsets the child within the parent. Generally
-    // we don't want plugins moving or sizing our window, so we prevent
-    // these changes here.
-    case WM_WINDOWPOSCHANGING: {
-      WINDOWPOS* pos = reinterpret_cast<WINDOWPOS*>(lParam);
-      if (pos && (!(pos->flags & SWP_NOMOVE) || !(pos->flags & SWP_NOSIZE))) {
-        pos->x = pos->y = 0;
-        pos->cx = self->mPluginSize.x;
-        pos->cy = self->mPluginSize.y;
-        LRESULT res =
-            CallWindowProc(self->mPluginWndProc, hWnd, message, wParam, lParam);
-        pos->x = pos->y = 0;
-        pos->cx = self->mPluginSize.x;
-        pos->cy = self->mPluginSize.y;
-        return res;
-      }
-      break;
-    }
-
-    case WM_IME_STARTCOMPOSITION:
-      isIMECompositionMessage = true;
-      break;
-    case WM_IME_ENDCOMPOSITION:
-      isIMECompositionMessage = true;
-      break;
-    case WM_IME_COMPOSITION:
-      isIMECompositionMessage = true;
-      // XXX Some old IME may not send WM_IME_COMPOSITION_START or
-      //     WM_IME_COMPSOITION_END properly.  So, we need to check
-      //     WM_IME_COMPSOITION and if it includes commit string.
-      break;
-
-    // The plugin received keyboard focus, let the parent know so the dom
-    // is up to date.
-    case WM_MOUSEACTIVATE:
-      self->CallPluginFocusChange(true);
-      break;
-  }
-
-  // Prevent lockups due to plugins making rpc calls when the parent
-  // is making a synchronous SendMessage call to the child window. Add
-  // more messages as needed.
-  if ((InSendMessageEx(nullptr) & (ISMEX_REPLIED | ISMEX_SEND)) == ISMEX_SEND) {
-    switch (message) {
-      case WM_CHILDACTIVATE:
-      case WM_KILLFOCUS:
-        ReplyMessage(0);
-        break;
-    }
-  }
-
-  if (message == WM_KILLFOCUS) {
-    self->CallPluginFocusChange(false);
-  }
-
-  if (message == WM_USER + 1 &&
-      (self->GetQuirks() & QUIRK_FLASH_THROTTLE_WMUSER_EVENTS)) {
-    self->FlashThrottleMessage(hWnd, message, wParam, lParam, true);
-    return 0;
-  }
-
-  NS_ASSERTION(self->mPluginWndProc != PluginWindowProc,
-               "Self-referential windowproc happened inside our hook proc. "
-               "Infinite recursion will happen soon.");
-
-  LRESULT res =
-      CallWindowProc(self->mPluginWndProc, hWnd, message, wParam, lParam);
-
-  // Make sure capture is released by the child on mouse events. Fixes a
-  // problem with flash full screen mode mouse input. Appears to be
-  // caused by a bug in flash, since we are not setting the capture
-  // on the window.
-  if (message == WM_LBUTTONDOWN &&
-      self->GetQuirks() & QUIRK_FLASH_FIXUP_MOUSE_CAPTURE) {
-    wchar_t szClass[26];
-    HWND hwnd = GetForegroundWindow();
-    if (hwnd &&
-        GetClassNameW(hwnd, szClass, sizeof(szClass) / sizeof(char16_t)) &&
-        !wcscmp(szClass, kFlashFullscreenClass)) {
-      ReleaseCapture();
-      SetFocus(hwnd);
-    }
-  }
-
-  if (message == WM_CLOSE) {
-    self->DestroyPluginWindow();
-  }
-
-  if (message == WM_NCDESTROY) {
-    RemoveProp(hWnd, kPluginInstanceChildProperty);
-  }
-
-  return res;
-}
-
-/* set window long ptr hook for flash */
-
-/*
- * Flash will reset the subclass of our widget at various times.
- * (Notably when entering and exiting full screen mode.) This
- * occurs independent of the main plugin window event procedure.
- * We trap these subclass calls to prevent our subclass hook from
- * getting dropped.
- * Note, ascii versions can be nixed once flash versions < 10.1
- * are considered obsolete.
- */
-
-#  ifdef _WIN64
-typedef LONG_PTR(WINAPI* User32SetWindowLongPtrA)(HWND hWnd, int nIndex,
-                                                  LONG_PTR dwNewLong);
-typedef LONG_PTR(WINAPI* User32SetWindowLongPtrW)(HWND hWnd, int nIndex,
-                                                  LONG_PTR dwNewLong);
-static WindowsDllInterceptor::FuncHookType<User32SetWindowLongPtrA>
-    sUser32SetWindowLongAHookStub;
-static WindowsDllInterceptor::FuncHookType<User32SetWindowLongPtrW>
-    sUser32SetWindowLongWHookStub;
-#  else
-typedef LONG(WINAPI* User32SetWindowLongA)(HWND hWnd, int nIndex,
-                                           LONG dwNewLong);
-typedef LONG(WINAPI* User32SetWindowLongW)(HWND hWnd, int nIndex,
-                                           LONG dwNewLong);
-static WindowsDllInterceptor::FuncHookType<User32SetWindowLongA>
-    sUser32SetWindowLongAHookStub;
-static WindowsDllInterceptor::FuncHookType<User32SetWindowLongW>
-    sUser32SetWindowLongWHookStub;
-#  endif
-
-extern LRESULT CALLBACK NeuteredWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam,
-                                           LPARAM lParam);
-
-const wchar_t kOldWndProcProp[] = L"MozillaIPCOldWndProc";
-
-// static
-bool PluginInstanceChild::SetWindowLongHookCheck(HWND hWnd, int nIndex,
-                                                 LONG_PTR newLong) {
-  // Let this go through if it's not a subclass
-  if (nIndex != GWLP_WNDPROC ||
-      // if it's not a subclassed plugin window
-      !GetProp(hWnd, kPluginInstanceChildProperty) ||
-      // if we're not disabled
-      GetProp(hWnd, kPluginIgnoreSubclassProperty) ||
-      // if the subclass is set to a known procedure
-      newLong == reinterpret_cast<LONG_PTR>(PluginWindowProc) ||
-      newLong == reinterpret_cast<LONG_PTR>(NeuteredWindowProc) ||
-      newLong == reinterpret_cast<LONG_PTR>(DefWindowProcA) ||
-      newLong == reinterpret_cast<LONG_PTR>(DefWindowProcW) ||
-      // if the subclass is a WindowsMessageLoop subclass restore
-      GetProp(hWnd, kOldWndProcProp))
-    return true;
-  // prevent the subclass
-  return false;
-}
-
-#  ifdef _WIN64
-LONG_PTR WINAPI PluginInstanceChild::SetWindowLongPtrAHook(HWND hWnd,
-                                                           int nIndex,
-                                                           LONG_PTR newLong)
-#  else
-LONG WINAPI PluginInstanceChild::SetWindowLongAHook(HWND hWnd, int nIndex,
-                                                    LONG newLong)
-#  endif
-{
-  if (SetWindowLongHookCheck(hWnd, nIndex, newLong))
-    return sUser32SetWindowLongAHookStub(hWnd, nIndex, newLong);
-
-  // Set flash's new subclass to get the result.
-  LONG_PTR proc = sUser32SetWindowLongAHookStub(hWnd, nIndex, newLong);
-
-  // We already checked this in SetWindowLongHookCheck
-  PluginInstanceChild* self = reinterpret_cast<PluginInstanceChild*>(
-      GetProp(hWnd, kPluginInstanceChildProperty));
-
-  // Hook our subclass back up, just like we do on setwindow.
-  WNDPROC currentProc =
-      reinterpret_cast<WNDPROC>(GetWindowLongPtr(hWnd, GWLP_WNDPROC));
-  if (currentProc != PluginWindowProc) {
-    self->mPluginWndProc =
-        reinterpret_cast<WNDPROC>(sUser32SetWindowLongWHookStub(
-            hWnd, nIndex, reinterpret_cast<LONG_PTR>(PluginWindowProc)));
-    NS_ASSERTION(self->mPluginWndProc != PluginWindowProc,
-                 "Infinite recursion coming up!");
-  }
-  return proc;
-}
-
-#  ifdef _WIN64
-LONG_PTR WINAPI PluginInstanceChild::SetWindowLongPtrWHook(HWND hWnd,
-                                                           int nIndex,
-                                                           LONG_PTR newLong)
-#  else
-LONG WINAPI PluginInstanceChild::SetWindowLongWHook(HWND hWnd, int nIndex,
-                                                    LONG newLong)
-#  endif
-{
-  if (SetWindowLongHookCheck(hWnd, nIndex, newLong))
-    return sUser32SetWindowLongWHookStub(hWnd, nIndex, newLong);
-
-  // Set flash's new subclass to get the result.
-  LONG_PTR proc = sUser32SetWindowLongWHookStub(hWnd, nIndex, newLong);
-
-  // We already checked this in SetWindowLongHookCheck
-  PluginInstanceChild* self = reinterpret_cast<PluginInstanceChild*>(
-      GetProp(hWnd, kPluginInstanceChildProperty));
-
-  // Hook our subclass back up, just like we do on setwindow.
-  WNDPROC currentProc =
-      reinterpret_cast<WNDPROC>(GetWindowLongPtr(hWnd, GWLP_WNDPROC));
-  if (currentProc != PluginWindowProc) {
-    self->mPluginWndProc =
-        reinterpret_cast<WNDPROC>(sUser32SetWindowLongWHookStub(
-            hWnd, nIndex, reinterpret_cast<LONG_PTR>(PluginWindowProc)));
-    NS_ASSERTION(self->mPluginWndProc != PluginWindowProc,
-                 "Infinite recursion coming up!");
-  }
-  return proc;
-}
-
-void PluginInstanceChild::HookSetWindowLongPtr() {
-  if (!(GetQuirks() & QUIRK_FLASH_HOOK_SETLONGPTR)) {
-    return;
-  }
-
-  sUser32Intercept.Init("user32.dll");
-#  ifdef _WIN64
-  sUser32SetWindowLongAHookStub.Set(sUser32Intercept, "SetWindowLongPtrA",
-                                    &SetWindowLongPtrAHook);
-  sUser32SetWindowLongWHookStub.Set(sUser32Intercept, "SetWindowLongPtrW",
-                                    &SetWindowLongPtrWHook);
-#  else
-  sUser32SetWindowLongAHookStub.Set(sUser32Intercept, "SetWindowLongA",
-                                    &SetWindowLongAHook);
-  sUser32SetWindowLongWHookStub.Set(sUser32Intercept, "SetWindowLongW",
-                                    &SetWindowLongWHook);
-#  endif
-}
-
-/* windowless track popup menu helpers */
-
-BOOL WINAPI PluginInstanceChild::TrackPopupHookProc(HMENU hMenu, UINT uFlags,
-                                                    int x, int y, int nReserved,
-                                                    HWND hWnd,
-                                                    CONST RECT* prcRect) {
-  if (!sUser32TrackPopupMenuStub) {
-    NS_ERROR("TrackPopupMenu stub isn't set! Badness!");
-    return 0;
-  }
-
-  // Only change the parent when we know this is a context on the plugin
-  // surface within the browser. Prevents resetting the parent on child ui
-  // displayed by plugins that have working parent-child relationships.
-  wchar_t szClass[21];
-  bool haveClass = GetClassNameW(hWnd, szClass, ArrayLength(szClass));
-  if (!haveClass || (wcscmp(szClass, L"MozillaWindowClass") &&
-                     wcscmp(szClass, L"SWFlash_Placeholder"))) {
-    // Unrecognized parent
-    return sUser32TrackPopupMenuStub(hMenu, uFlags, x, y, nReserved, hWnd,
-                                     prcRect);
-  }
-
-  // Called on an unexpected event, warn.
-  if (!sWinlessPopupSurrogateHWND) {
-    NS_WARNING("Untraced TrackPopupHookProc call! Menu might not work right!");
-    return sUser32TrackPopupMenuStub(hMenu, uFlags, x, y, nReserved, hWnd,
-                                     prcRect);
-  }
-
-  HWND surrogateHwnd = sWinlessPopupSurrogateHWND;
-  sWinlessPopupSurrogateHWND = nullptr;
-
-  // Popups that don't use TPM_RETURNCMD expect a final command message
-  // when an item is selected and the context closes. Since we replace
-  // the parent, we need to forward this back to the real parent so it
-  // can act on the menu item selected.
-  bool isRetCmdCall = (uFlags & TPM_RETURNCMD);
-
-  DWORD res = sUser32TrackPopupMenuStub(hMenu, uFlags | TPM_RETURNCMD, x, y,
-                                        nReserved, surrogateHwnd, prcRect);
-
-  if (!isRetCmdCall && res) {
-    SendMessage(hWnd, WM_COMMAND, MAKEWPARAM(res, 0), 0);
-  }
-
-  return res;
-}
-
-void PluginInstanceChild::InitPopupMenuHook() {
-  if (!(GetQuirks() & QUIRK_WINLESS_TRACKPOPUP_HOOK)) {
-    return;
-  }
-
-  // Note, once WindowsDllInterceptor is initialized for a module,
-  // it remains initialized for that particular module for it's
-  // lifetime. Additional instances are needed if other modules need
-  // to be hooked.
-  sUser32Intercept.Init("user32.dll");
-  sUser32TrackPopupMenuStub.Set(sUser32Intercept, "TrackPopupMenu",
-                                &TrackPopupHookProc);
-}
-
-void PluginInstanceChild::CreateWinlessPopupSurrogate() {
-  // already initialized
-  if (mWinlessPopupSurrogateHWND) return;
-
-  mWinlessPopupSurrogateHWND =
-      CreateWindowEx(WS_EX_NOPARENTNOTIFY, L"Static", nullptr, WS_POPUP, 0, 0,
-                     0, 0, nullptr, 0, GetModuleHandle(nullptr), 0);
-  if (!mWinlessPopupSurrogateHWND) {
-    NS_ERROR("CreateWindowEx failed for winless placeholder!");
-    return;
-  }
-
-  SendSetNetscapeWindowAsParent(mWinlessPopupSurrogateHWND);
-}
-
-// static
-HIMC PluginInstanceChild::ImmGetContextProc(HWND aWND) {
-  if (!sCurrentPluginInstance) {
-    return sImm32ImmGetContextStub(aWND);
-  }
-
-  wchar_t szClass[21];
-  int haveClass = GetClassNameW(aWND, szClass, ArrayLength(szClass));
-  if (!haveClass || wcscmp(szClass, L"SWFlash_PlaceholderX")) {
-    NS_WARNING("We cannot recongnize hooked window class");
-    return sImm32ImmGetContextStub(aWND);
-  }
-
-  return sHookIMC;
-}
-
-// static
-LONG PluginInstanceChild::ImmGetCompositionStringProc(HIMC aIMC, DWORD aIndex,
-                                                      LPVOID aBuf, DWORD aLen) {
-  if (aIMC != sHookIMC) {
-    return sImm32ImmGetCompositionStringStub(aIMC, aIndex, aBuf, aLen);
-  }
-  if (!sCurrentPluginInstance) {
-    return IMM_ERROR_GENERAL;
-  }
-  AutoTArray<uint8_t, 16> dist;
-  int32_t length = 0;  // IMM_ERROR_NODATA
-  sCurrentPluginInstance->SendGetCompositionString(aIndex, &dist, &length);
-  if (length == IMM_ERROR_NODATA || length == IMM_ERROR_GENERAL) {
-    return length;
-  }
-
-  if (aBuf && aLen >= static_cast<DWORD>(length)) {
-    memcpy(aBuf, dist.Elements(), length);
-  }
-  return length;
-}
-
-// staitc
-BOOL PluginInstanceChild::ImmSetCandidateWindowProc(HIMC aIMC,
-                                                    LPCANDIDATEFORM aForm) {
-  return FALSE;
-}
-
-// static
-BOOL PluginInstanceChild::ImmNotifyIME(HIMC aIMC, DWORD aAction, DWORD aIndex,
-                                       DWORD aValue) {
-  if (aIMC != sHookIMC) {
-    return sImm32ImmNotifyIME(aIMC, aAction, aIndex, aValue);
-  }
-
-  // We only supports NI_COMPOSITIONSTR because Flash uses it only
-  if (!sCurrentPluginInstance || aAction != NI_COMPOSITIONSTR ||
-      (aIndex != CPS_COMPLETE && aIndex != CPS_CANCEL)) {
-    return FALSE;
-  }
-
-  sCurrentPluginInstance->SendRequestCommitOrCancel(aAction == CPS_COMPLETE);
-  return TRUE;
-}
-
-// static
-BOOL PluginInstanceChild::ImmAssociateContextExProc(HWND hWND, HIMC hImc,
-                                                    DWORD dwFlags) {
-  PluginInstanceChild* self = sCurrentPluginInstance;
-  if (!self) {
-    // If ImmAssociateContextEx calls unexpected window message,
-    // we can use child instance object from window property if available.
-    self = reinterpret_cast<PluginInstanceChild*>(
-        GetProp(hWND, kFlashThrottleProperty));
-    NS_WARNING_ASSERTION(self, "Cannot find PluginInstanceChild");
-  }
-
-  // HIMC is always nullptr on Flash's windowless
-  if (!hImc && self) {
-    // Store the last IME state since Flash may call ImmAssociateContextEx
-    // before taking focus.
-    self->mLastEnableIMEState = !!(dwFlags & IACE_DEFAULT);
-  }
-  return sImm32ImmAssociateContextExStub(hWND, hImc, dwFlags);
-}
-
-void PluginInstanceChild::InitImm32Hook() {
-  if (!(GetQuirks() & QUIRK_WINLESS_HOOK_IME)) {
-    return;
-  }
-
-  // When using windowless plugin, IMM API won't work due to OOP.
-  //
-  // ImmReleaseContext on Windows 7+ just returns TRUE only, so we don't
-  // need to hook this.
-
-  sImm32Intercept.Init("imm32.dll");
-  sImm32ImmGetContextStub.Set(sImm32Intercept, "ImmGetContext",
-                              &ImmGetContextProc);
-  sImm32ImmGetCompositionStringStub.Set(sImm32Intercept,
-                                        "ImmGetCompositionStringW",
-                                        &ImmGetCompositionStringProc);
-  sImm32ImmSetCandidateWindowStub.Set(sImm32Intercept, "ImmSetCandidateWindow",
-                                      &ImmSetCandidateWindowProc);
-  sImm32ImmNotifyIME.Set(sImm32Intercept, "ImmNotifyIME", &ImmNotifyIME);
-  sImm32ImmAssociateContextExStub.Set(sImm32Intercept, "ImmAssociateContextEx",
-                                      &ImmAssociateContextExProc);
-}
-
-void PluginInstanceChild::DestroyWinlessPopupSurrogate() {
-  if (mWinlessPopupSurrogateHWND) DestroyWindow(mWinlessPopupSurrogateHWND);
-  mWinlessPopupSurrogateHWND = nullptr;
-}
-
-int16_t PluginInstanceChild::WinlessHandleEvent(NPEvent& event) {
-  if (!mPluginIface->event) return false;
-
-  // Events that might generate nested event dispatch loops need
-  // special handling during delivery.
-  int16_t handled;
-
-  HWND focusHwnd = nullptr;
-
-  // TrackPopupMenu will fail if the parent window is not associated with
-  // our ui thread. So we hook TrackPopupMenu so we can hand in a surrogate
-  // parent created in the child process.
-  if ((GetQuirks() &
-       QUIRK_WINLESS_TRACKPOPUP_HOOK) &&  // XXX turn on by default?
-      (event.event == WM_RBUTTONDOWN ||   // flash
-       event.event == WM_RBUTTONUP)) {    // silverlight
-    sWinlessPopupSurrogateHWND = mWinlessPopupSurrogateHWND;
-
-    // A little trick scrounged from chromium's code - set the focus
-    // to our surrogate parent so keyboard nav events go to the menu.
-    focusHwnd = SetFocus(mWinlessPopupSurrogateHWND);
-  }
-
-  AutoRestore<PluginInstanceChild*> pluginInstance(sCurrentPluginInstance);
-  if (event.event == WM_IME_STARTCOMPOSITION ||
-      event.event == WM_IME_COMPOSITION || event.event == WM_LBUTTONDOWN ||
-      event.event == WM_KILLFOCUS) {
-    sCurrentPluginInstance = this;
-  }
-
-  MessageLoop* loop = MessageLoop::current();
-  AutoRestore<bool> modalLoop(loop->os_modal_loop());
-
-  handled = mPluginIface->event(&mData, reinterpret_cast<void*>(&event));
-
-  sWinlessPopupSurrogateHWND = nullptr;
-
-  if (IsWindow(focusHwnd)) {
-    SetFocus(focusHwnd);
-  }
-
-  // This is hack of Flash's behaviour.
-  //
-  // When moving focus from chrome to plugin by mouse click, Gecko sends
-  // mouse message (such as WM_LBUTTONDOWN etc) at first, then sends
-  // WM_SETFOCUS. But Flash will call ImmAssociateContextEx on WM_LBUTTONDOWN
-  // even if it doesn't receive WM_SETFOCUS.
-  //
-  // In this situation, after sending mouse message, content process will be
-  // activated and set input context with PLUGIN.  So after activating
-  // content process, we have to set current IME state again.
-
-  if (event.event == WM_KILLFOCUS) {
-    // Flash always calls ImmAssociateContextEx by taking focus.
-    // Although this flag doesn't have to be reset, I add it for safety.
-    mLastEnableIMEState = true;
-  }
-
-  return handled;
-}
-
-/* flash msg throttling helpers */
-
-// Flash has the unfortunate habit of flooding dispatch loops with custom
-// windowing events they use for timing. We throttle these by dropping the
-// delivery priority below any other event, including pending ipc io
-// notifications. We do this for both windowed and windowless controls.
-// Note flash's windowless msg window can last longer than our instance,
-// so we try to unhook when the window is destroyed and in NPP_Destroy.
-
-void PluginInstanceChild::UnhookWinlessFlashThrottle() {
-  // We may have already unhooked
-  if (!mWinlessThrottleOldWndProc) return;
-
-  WNDPROC tmpProc = mWinlessThrottleOldWndProc;
-  mWinlessThrottleOldWndProc = nullptr;
-
-  NS_ASSERTION(mWinlessHiddenMsgHWND,
-               "Missing mWinlessHiddenMsgHWND w/subclass set??");
-
-  // reset the subclass
-  SetWindowLongPtr(mWinlessHiddenMsgHWND, GWLP_WNDPROC,
-                   reinterpret_cast<LONG_PTR>(tmpProc));
-
-  // Remove our instance prop
-  RemoveProp(mWinlessHiddenMsgHWND, kFlashThrottleProperty);
-  mWinlessHiddenMsgHWND = nullptr;
-}
-
-// static
-LRESULT CALLBACK PluginInstanceChild::WinlessHiddenFlashWndProc(HWND hWnd,
-                                                                UINT message,
-                                                                WPARAM wParam,
-                                                                LPARAM lParam) {
-  PluginInstanceChild* self = reinterpret_cast<PluginInstanceChild*>(
-      GetProp(hWnd, kFlashThrottleProperty));
-  if (!self) {
-    MOZ_ASSERT_UNREACHABLE("Badness!");
-    return 0;
-  }
-
-  NS_ASSERTION(self->mWinlessThrottleOldWndProc,
-               "Missing subclass procedure!!");
-
-  // Throttle
-  if (message == WM_USER + 1) {
-    self->FlashThrottleMessage(hWnd, message, wParam, lParam, false);
-    return 0;
-  }
-
-  // Unhook
-  if (message == WM_CLOSE || message == WM_NCDESTROY) {
-    WNDPROC tmpProc = self->mWinlessThrottleOldWndProc;
-    self->UnhookWinlessFlashThrottle();
-    LRESULT res = CallWindowProc(tmpProc, hWnd, message, wParam, lParam);
-    return res;
-  }
-
-  return CallWindowProc(self->mWinlessThrottleOldWndProc, hWnd, message, wParam,
-                        lParam);
-}
-
-// Enumerate all thread windows looking for flash's hidden message window.
-// Once we find it, sub class it so we can throttle user msgs.
-// static
-BOOL CALLBACK PluginInstanceChild::EnumThreadWindowsCallback(HWND hWnd,
-                                                             LPARAM aParam) {
-  PluginInstanceChild* self = reinterpret_cast<PluginInstanceChild*>(aParam);
-  if (!self) {
-    MOZ_ASSERT_UNREACHABLE("Enum befuddled!");
-    return FALSE;
-  }
-
-  wchar_t className[64];
-  if (!GetClassNameW(hWnd, className, sizeof(className) / sizeof(char16_t)))
-    return TRUE;
-
-  if (!wcscmp(className, L"SWFlash_PlaceholderX")) {
-    WNDPROC oldWndProc =
-        reinterpret_cast<WNDPROC>(GetWindowLongPtr(hWnd, GWLP_WNDPROC));
-    // Only set this if we haven't already.
-    if (oldWndProc != WinlessHiddenFlashWndProc) {
-      if (self->mWinlessThrottleOldWndProc) {
-        NS_WARNING("mWinlessThrottleWndProc already set???");
-        return FALSE;
-      }
-      // Subsclass and store self as a property
-      self->mWinlessHiddenMsgHWND = hWnd;
-      self->mWinlessThrottleOldWndProc =
-          reinterpret_cast<WNDPROC>(SetWindowLongPtr(
-              hWnd, GWLP_WNDPROC,
-              reinterpret_cast<LONG_PTR>(WinlessHiddenFlashWndProc)));
-      SetProp(hWnd, kFlashThrottleProperty, self);
-      NS_ASSERTION(self->mWinlessThrottleOldWndProc,
-                   "SetWindowLongPtr failed?!");
-    }
-    // Return no matter what once we find the right window.
-    return FALSE;
-  }
-
-  return TRUE;
-}
-
-void PluginInstanceChild::SetupFlashMsgThrottle() {
-  if (mWindow.type == NPWindowTypeDrawable) {
-    // Search for the flash hidden message window and subclass it. Only
-    // search for flash windows belonging to our ui thread!
-    if (mWinlessThrottleOldWndProc) return;
-    EnumThreadWindows(GetCurrentThreadId(), EnumThreadWindowsCallback,
-                      reinterpret_cast<LPARAM>(this));
-  } else {
-    // Already setup through quirks and the subclass.
-    return;
-  }
-}
-
-WNDPROC
-PluginInstanceChild::FlashThrottleMsg::GetProc() {
-  if (mInstance) {
-    return mWindowed ? mInstance->mPluginWndProc
-                     : mInstance->mWinlessThrottleOldWndProc;
-  }
-  return nullptr;
-}
-
-NS_IMETHODIMP
-PluginInstanceChild::FlashThrottleMsg::Run() {
-  if (!mInstance) {
-    return NS_OK;
-  }
-
-  mInstance->mPendingFlashThrottleMsgs.RemoveElement(this);
-
-  // GetProc() checks mInstance, and pulls the procedure from
-  // PluginInstanceChild. We don't transport sub-class procedure
-  // ptrs around in FlashThrottleMsg msgs.
-  if (!GetProc()) return NS_OK;
-
-  // deliver the event to flash
-  CallWindowProc(GetProc(), GetWnd(), GetMsg(), GetWParam(), GetLParam());
-  return NS_OK;
-}
-
-nsresult PluginInstanceChild::FlashThrottleMsg::Cancel() {
-  MOZ_ASSERT(mInstance);
-  mInstance = nullptr;
-  return NS_OK;
-}
-
-void PluginInstanceChild::FlashThrottleMessage(HWND aWnd, UINT aMsg,
-                                               WPARAM aWParam, LPARAM aLParam,
-                                               bool isWindowed) {
-  // We save a reference to the FlashThrottleMsg so we can cancel it in
-  // Destroy if it's still alive.
-  RefPtr<FlashThrottleMsg> task =
-      new FlashThrottleMsg(this, aWnd, aMsg, aWParam, aLParam, isWindowed);
-
-  mPendingFlashThrottleMsgs.AppendElement(task);
-
-  MessageLoop::current()->PostDelayedTask(task.forget(),
-                                          kFlashWMUSERMessageThrottleDelayMs);
-}
-
-#endif  // OS_WIN
-
-mozilla::ipc::IPCResult PluginInstanceChild::AnswerSetPluginFocus() {
-  MOZ_LOG(GetPluginLog(), LogLevel::Debug, ("%s", FULLFUNCTION));
-
-#if defined(OS_WIN)
-  // Parent is letting us know the dom set focus to the plugin. Note,
-  // focus can change during transit in certain edge cases, for example
-  // when a button click brings up a full screen window. Since we send
-  // this in response to a WM_SETFOCUS event on our parent, the parent
-  // should have focus when we receive this. If not, ignore the call.
-  if (::GetFocus() == mPluginWindowHWND) return IPC_OK();
-  ::SetFocus(mPluginWindowHWND);
-  return IPC_OK();
-#else
-  MOZ_ASSERT_UNREACHABLE("AnswerSetPluginFocus not implemented!");
-  return IPC_FAIL_NO_REASON(this);
-#endif
-}
-
-mozilla::ipc::IPCResult PluginInstanceChild::AnswerUpdateWindow() {
-  MOZ_LOG(GetPluginLog(), LogLevel::Debug, ("%s", FULLFUNCTION));
-
-#if defined(OS_WIN)
-  if (mPluginWindowHWND) {
-    RECT rect;
-    if (GetUpdateRect(GetParent(mPluginWindowHWND), &rect, FALSE)) {
-      ::InvalidateRect(mPluginWindowHWND, &rect, FALSE);
-    }
-    UpdateWindow(mPluginWindowHWND);
-  }
-  return IPC_OK();
-#else
-  MOZ_ASSERT_UNREACHABLE("AnswerUpdateWindow not implemented!");
-  return IPC_FAIL_NO_REASON(this);
-#endif
-}
-
-mozilla::ipc::IPCResult PluginInstanceChild::RecvNPP_DidComposite() {
-  if (mPluginIface->didComposite) {
-    mPluginIface->didComposite(GetNPP());
-  }
-  return IPC_OK();
-}
-
-PPluginScriptableObjectChild*
-PluginInstanceChild::AllocPPluginScriptableObjectChild() {
-  AssertPluginThread();
-  return new PluginScriptableObjectChild(Proxy);
-}
-
-bool PluginInstanceChild::DeallocPPluginScriptableObjectChild(
-    PPluginScriptableObjectChild* aObject) {
-  AssertPluginThread();
-  delete aObject;
-  return true;
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceChild::RecvPPluginScriptableObjectConstructor(
-    PPluginScriptableObjectChild* aActor) {
-  AssertPluginThread();
-
-  // This is only called in response to the parent process requesting the
-  // creation of an actor. This actor will represent an NPObject that is
-  // created by the browser and returned to the plugin.
-  PluginScriptableObjectChild* actor =
-      static_cast<PluginScriptableObjectChild*>(aActor);
-  NS_ASSERTION(!actor->GetObject(false), "Actor already has an object?!");
-
-  actor->InitializeProxy();
-  NS_ASSERTION(actor->GetObject(false), "Actor should have an object!");
-
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginInstanceChild::RecvPBrowserStreamConstructor(
-    PBrowserStreamChild* aActor, const nsCString& url, const uint32_t& length,
-    const uint32_t& lastmodified, PStreamNotifyChild* notifyData,
-    const nsCString& headers) {
-  return IPC_OK();
-}
-
-NPError PluginInstanceChild::DoNPP_NewStream(BrowserStreamChild* actor,
-                                             const nsCString& mimeType,
-                                             const bool& seekable,
-                                             uint16_t* stype) {
-  AssertPluginThread();
-  AutoStackHelper guard(this);
-  NPError rv = actor->StreamConstructed(mimeType, seekable, stype);
-  return rv;
-}
-
-mozilla::ipc::IPCResult PluginInstanceChild::AnswerNPP_NewStream(
-    PBrowserStreamChild* actor, const nsCString& mimeType, const bool& seekable,
-    NPError* rv, uint16_t* stype) {
-  *rv = DoNPP_NewStream(static_cast<BrowserStreamChild*>(actor), mimeType,
-                        seekable, stype);
-  return IPC_OK();
-}
-
-PBrowserStreamChild* PluginInstanceChild::AllocPBrowserStreamChild(
-    const nsCString& url, const uint32_t& length, const uint32_t& lastmodified,
-    PStreamNotifyChild* notifyData, const nsCString& headers) {
-  AssertPluginThread();
-  return new BrowserStreamChild(this, url, length, lastmodified,
-                                static_cast<StreamNotifyChild*>(notifyData),
-                                headers);
-}
-
-bool PluginInstanceChild::DeallocPBrowserStreamChild(
-    PBrowserStreamChild* stream) {
-  AssertPluginThread();
-  delete stream;
-  return true;
-}
-
-PStreamNotifyChild* PluginInstanceChild::AllocPStreamNotifyChild(
-    const nsCString& url, const nsCString& target, const bool& post,
-    const nsCString& buffer, const bool& file, NPError* result) {
-  AssertPluginThread();
-  MOZ_CRASH("not reached");
-  return nullptr;
-}
-
-void StreamNotifyChild::ActorDestroy(ActorDestroyReason why) {
-  if (AncestorDeletion == why && mBrowserStream) {
-    NS_ERROR("Pending NPP_URLNotify not called when closing an instance.");
-
-    // reclaim responsibility for deleting ourself
-    mBrowserStream->mStreamNotify = nullptr;
-    mBrowserStream = nullptr;
-  }
-}
-
-void StreamNotifyChild::SetAssociatedStream(BrowserStreamChild* bs) {
-  NS_ASSERTION(!mBrowserStream, "Two streams for one streamnotify?");
-
-  mBrowserStream = bs;
-}
-
-mozilla::ipc::IPCResult StreamNotifyChild::Recv__delete__(
-    const NPReason& reason) {
-  AssertPluginThread();
-
-  if (mBrowserStream)
-    mBrowserStream->NotifyPending();
-  else
-    NPP_URLNotify(reason);
-
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult StreamNotifyChild::RecvRedirectNotify(
-    const nsCString& url, const int32_t& status) {
-  // NPP_URLRedirectNotify requires a non-null closure. Since core logic
-  // assumes that all out-of-process notify streams have non-null closure
-  // data it will assume that the plugin was notified at this point and
-  // expect a response otherwise the redirect will hang indefinitely.
-  if (!mClosure) {
-    SendRedirectNotifyResponse(false);
-  }
-
-  PluginInstanceChild* instance = static_cast<PluginInstanceChild*>(Manager());
-  if (instance->mPluginIface->urlredirectnotify)
-    instance->mPluginIface->urlredirectnotify(instance->GetNPP(), url.get(),
-                                              status, mClosure);
-
-  return IPC_OK();
-}
-
-void StreamNotifyChild::NPP_URLNotify(NPReason reason) {
-  PluginInstanceChild* instance = static_cast<PluginInstanceChild*>(Manager());
-
-  if (mClosure)
-    instance->mPluginIface->urlnotify(instance->GetNPP(), mURL.get(), reason,
-                                      mClosure);
-}
-
-bool PluginInstanceChild::DeallocPStreamNotifyChild(
-    PStreamNotifyChild* notifyData) {
-  AssertPluginThread();
-
-  if (!static_cast<StreamNotifyChild*>(notifyData)->mBrowserStream)
-    delete notifyData;
-  return true;
-}
-
-PluginScriptableObjectChild* PluginInstanceChild::GetActorForNPObject(
-    NPObject* aObject) {
-  AssertPluginThread();
-  NS_ASSERTION(aObject, "Null pointer!");
-
-  if (aObject->_class == PluginScriptableObjectChild::GetClass()) {
-    // One of ours! It's a browser-provided object.
-    ChildNPObject* object = static_cast<ChildNPObject*>(aObject);
-    NS_ASSERTION(object->parent, "Null actor!");
-    return object->parent;
-  }
-
-  PluginScriptableObjectChild* actor =
-      PluginScriptableObjectChild::GetActorForNPObject(aObject);
-  if (actor) {
-    // Plugin-provided object that we've previously wrapped.
-    return actor;
-  }
-
-  actor = new PluginScriptableObjectChild(LocalObject);
-  if (!SendPPluginScriptableObjectConstructor(actor)) {
-    NS_ERROR("Failed to send constructor message!");
-    return nullptr;
-  }
-
-  actor->InitializeLocal(aObject);
-  return actor;
-}
-
-void PluginInstanceChild::NPN_URLRedirectResponse(void* notifyData,
-                                                  NPBool allow) {
-  if (!notifyData) {
-    return;
-  }
-
-  nsTArray<PStreamNotifyChild*> notifyStreams;
-  ManagedPStreamNotifyChild(notifyStreams);
-  uint32_t notifyStreamCount = notifyStreams.Length();
-  for (uint32_t i = 0; i < notifyStreamCount; i++) {
-    StreamNotifyChild* sn = static_cast<StreamNotifyChild*>(notifyStreams[i]);
-    if (sn->mClosure == notifyData) {
-      sn->SendRedirectNotifyResponse(static_cast<bool>(allow));
-      return;
-    }
-  }
-  NS_ASSERTION(false, "Couldn't find stream for redirect response!");
-}
-
-bool PluginInstanceChild::IsUsingDirectDrawing() {
-  return IsDrawingModelDirect(mDrawingModel);
-}
-
-PluginInstanceChild::DirectBitmap::DirectBitmap(PluginInstanceChild* aOwner,
-                                                const Shmem& shmem,
-                                                const IntSize& size,
-                                                uint32_t stride,
-                                                SurfaceFormat format)
-    : mOwner(aOwner),
-      mShmem(shmem),
-      mFormat(format),
-      mSize(size),
-      mStride(stride) {}
-
-PluginInstanceChild::DirectBitmap::~DirectBitmap() {
-  mOwner->DeallocShmem(mShmem);
-}
-
-static inline SurfaceFormat NPImageFormatToSurfaceFormat(
-    NPImageFormat aFormat) {
-  switch (aFormat) {
-    case NPImageFormatBGRA32:
-      return SurfaceFormat::B8G8R8A8;
-    case NPImageFormatBGRX32:
-      return SurfaceFormat::B8G8R8X8;
-    default:
-      MOZ_ASSERT_UNREACHABLE("unknown NPImageFormat");
-      return SurfaceFormat::UNKNOWN;
-  }
-}
-
-static inline gfx::IntRect NPRectToIntRect(const NPRect& in) {
-  return IntRect(in.left, in.top, in.right - in.left, in.bottom - in.top);
-}
-
-NPError PluginInstanceChild::NPN_InitAsyncSurface(NPSize* size,
-                                                  NPImageFormat format,
-                                                  void* initData,
-                                                  NPAsyncSurface* surface) {
-  AssertPluginThread();
-  AutoStackHelper guard(this);
-
-  if (!IsUsingDirectDrawing()) {
-    return NPERR_INVALID_PARAM;
-  }
-  if (format != NPImageFormatBGRA32 && format != NPImageFormatBGRX32) {
-    return NPERR_INVALID_PARAM;
-  }
-
-  PodZero(surface);
-
-  // NPAPI guarantees that the SetCurrentAsyncSurface call will release the
-  // previous surface if it was different. However, no functionality exists
-  // within content to synchronize a non-shadow-layers transaction with the
-  // compositor.
-  //
-  // To get around this, we allocate two surfaces: a child copy, which we
-  // hand off to the plugin, and a parent copy, which we will hand off to
-  // the compositor. Each call to SetCurrentAsyncSurface will copy the
-  // invalid region from the child surface to its parent.
-  switch (mDrawingModel) {
-    case NPDrawingModelAsyncBitmapSurface: {
-      // Validate that the caller does not expect initial data to be set.
-      if (initData) {
-        return NPERR_INVALID_PARAM;
-      }
-
-      // Validate that we're not double-allocating a surface.
-      RefPtr<DirectBitmap> holder;
-      if (mDirectBitmaps.Get(surface, getter_AddRefs(holder))) {
-        return NPERR_INVALID_PARAM;
-      }
-
-      SurfaceFormat mozformat = NPImageFormatToSurfaceFormat(format);
-      int32_t bytesPerPixel = BytesPerPixel(mozformat);
-
-      if (size->width <= 0 || size->height <= 0) {
-        return NPERR_INVALID_PARAM;
-      }
-
-      CheckedInt<uint32_t> nbytes =
-          SafeBytesForBitmap(size->width, size->height, bytesPerPixel);
-      if (!nbytes.isValid()) {
-        return NPERR_INVALID_PARAM;
-      }
-
-      Shmem shmem;
-      if (!AllocUnsafeShmem(nbytes.value(), SharedMemory::TYPE_BASIC, &shmem)) {
-        return NPERR_OUT_OF_MEMORY_ERROR;
-      }
-      MOZ_ASSERT(shmem.Size<uint8_t>() == nbytes.value());
-
-      surface->version = 0;
-      surface->size = *size;
-      surface->format = format;
-      surface->bitmap.data = shmem.get<unsigned char>();
-      surface->bitmap.stride = size->width * bytesPerPixel;
-
-      // Hold the shmem alive until Finalize() is called or this actor dies.
-      holder = new DirectBitmap(this, shmem, IntSize(size->width, size->height),
-                                surface->bitmap.stride, mozformat);
-      mDirectBitmaps.InsertOrUpdate(surface, std::move(holder));
-      return NPERR_NO_ERROR;
-    }
-#if defined(XP_WIN)
-    case NPDrawingModelAsyncWindowsDXGISurface: {
-      // Validate that the caller does not expect initial data to be set.
-      if (initData) {
-        return NPERR_INVALID_PARAM;
-      }
-
-      // Validate that we're not double-allocating a surface.
-      WindowsHandle handle = 0;
-      if (mDxgiSurfaces.Get(surface, &handle)) {
-        return NPERR_INVALID_PARAM;
-      }
-
-      NPError error = NPERR_NO_ERROR;
-      SurfaceFormat mozformat = NPImageFormatToSurfaceFormat(format);
-      if (!SendInitDXGISurface(mozformat, IntSize(size->width, size->height),
-                               &handle, &error)) {
-        return NPERR_GENERIC_ERROR;
-      }
-      if (error != NPERR_NO_ERROR) {
-        return error;
-      }
-
-      surface->version = 0;
-      surface->size = *size;
-      surface->format = format;
-      surface->sharedHandle = reinterpret_cast<HANDLE>(handle);
-
-      mDxgiSurfaces.InsertOrUpdate(surface, handle);
-      return NPERR_NO_ERROR;
-    }
-#endif
-    default:
-      MOZ_ASSERT_UNREACHABLE("unknown drawing model");
-  }
-
-  return NPERR_INVALID_PARAM;
-}
-
-NPError PluginInstanceChild::NPN_FinalizeAsyncSurface(NPAsyncSurface* surface) {
-  AssertPluginThread();
-
-  if (!IsUsingDirectDrawing()) {
-    return NPERR_GENERIC_ERROR;
-  }
-
-  switch (mDrawingModel) {
-    case NPDrawingModelAsyncBitmapSurface: {
-      RefPtr<DirectBitmap> bitmap;
-      if (!mDirectBitmaps.Get(surface, getter_AddRefs(bitmap))) {
-        return NPERR_INVALID_PARAM;
-      }
-
-      PodZero(surface);
-      mDirectBitmaps.Remove(surface);
-      return NPERR_NO_ERROR;
-    }
-#if defined(XP_WIN)
-    case NPDrawingModelAsyncWindowsDXGISurface: {
-      WindowsHandle handle;
-      if (!mDxgiSurfaces.Get(surface, &handle)) {
-        return NPERR_INVALID_PARAM;
-      }
-
-      SendFinalizeDXGISurface(handle);
-      mDxgiSurfaces.Remove(surface);
-      return NPERR_NO_ERROR;
-    }
-#endif
-    default:
-      MOZ_ASSERT_UNREACHABLE("unknown drawing model");
-  }
-
-  return NPERR_INVALID_PARAM;
-}
-
-void PluginInstanceChild::NPN_SetCurrentAsyncSurface(NPAsyncSurface* surface,
-                                                     NPRect* changed) {
-  AssertPluginThread();
-
-  if (!IsUsingDirectDrawing()) {
-    return;
-  }
-
-  mCurrentDirectSurface = surface;
-
-  if (!surface) {
-    SendRevokeCurrentDirectSurface();
-    return;
-  }
-
-  switch (mDrawingModel) {
-    case NPDrawingModelAsyncBitmapSurface: {
-      RefPtr<DirectBitmap> bitmap;
-      if (!mDirectBitmaps.Get(surface, getter_AddRefs(bitmap))) {
-        return;
-      }
-
-      IntRect dirty = changed ? NPRectToIntRect(*changed)
-                              : IntRect(IntPoint(0, 0), bitmap->mSize);
-
-      // Need a holder since IPDL zaps the object for mysterious reasons.
-      Shmem shmemHolder = bitmap->mShmem;
-      SendShowDirectBitmap(std::move(shmemHolder), bitmap->mFormat,
-                           bitmap->mStride, bitmap->mSize, dirty);
-      break;
-    }
-#if defined(XP_WIN)
-    case NPDrawingModelAsyncWindowsDXGISurface: {
-      WindowsHandle handle;
-      if (!mDxgiSurfaces.Get(surface, &handle)) {
-        return;
-      }
-
-      IntRect dirty =
-          changed ? NPRectToIntRect(*changed)
-                  : IntRect(IntPoint(0, 0),
-                            IntSize(surface->size.width, surface->size.height));
-
-      SendShowDirectDXGISurface(handle, dirty);
-      break;
-    }
-#endif
-    default:
-      MOZ_ASSERT_UNREACHABLE("unknown drawing model");
-  }
-}
-
-void PluginInstanceChild::DoAsyncRedraw() {
-  {
-    MutexAutoLock autoLock(mAsyncInvalidateMutex);
-    mAsyncInvalidateTask = nullptr;
-  }
-
-  SendRedrawPlugin();
-}
-
-mozilla::ipc::IPCResult PluginInstanceChild::RecvAsyncSetWindow(
-    const gfxSurfaceType& aSurfaceType, const NPRemoteWindow& aWindow) {
-  AssertPluginThread();
-
-  AutoStackHelper guard(this);
-  NS_ASSERTION(!aWindow.window, "Remote window should be null.");
-
-  if (mCurrentAsyncSetWindowTask) {
-    mCurrentAsyncSetWindowTask->Cancel();
-    mCurrentAsyncSetWindowTask = nullptr;
-  }
-
-  // We shouldn't process this now because it may be received within a nested
-  // RPC call, and both Flash and Java don't expect to receive setwindow calls
-  // at arbitrary times.
-  mCurrentAsyncSetWindowTask =
-      NewNonOwningCancelableRunnableMethod<gfxSurfaceType, NPRemoteWindow,
-                                           bool>(
-          "plugins::PluginInstanceChild::DoAsyncSetWindow", this,
-          &PluginInstanceChild::DoAsyncSetWindow, aSurfaceType, aWindow, true);
-  RefPtr<Runnable> addrefedTask = mCurrentAsyncSetWindowTask;
-  MessageLoop::current()->PostTask(addrefedTask.forget());
-
-  return IPC_OK();
-}
-
-void PluginInstanceChild::DoAsyncSetWindow(const gfxSurfaceType& aSurfaceType,
-                                           const NPRemoteWindow& aWindow,
-                                           bool aIsAsync) {
-  PLUGIN_LOG_DEBUG(
-      ("[InstanceChild][%p] AsyncSetWindow to <x=%d,y=%d, w=%d,h=%d>", this,
-       aWindow.x, aWindow.y, aWindow.width, aWindow.height));
-
-  AssertPluginThread();
-  NS_ASSERTION(!aWindow.window, "Remote window should be null.");
-  NS_ASSERTION(!mPendingPluginCall, "Can't do SetWindow during plugin call!");
-
-  if (aIsAsync) {
-    if (!mCurrentAsyncSetWindowTask) {
-      return;
-    }
-    mCurrentAsyncSetWindowTask = nullptr;
-  }
-
-  mWindow.window = nullptr;
-  if (mWindow.width != aWindow.width || mWindow.height != aWindow.height ||
-      mWindow.clipRect.top != aWindow.clipRect.top ||
-      mWindow.clipRect.left != aWindow.clipRect.left ||
-      mWindow.clipRect.bottom != aWindow.clipRect.bottom ||
-      mWindow.clipRect.right != aWindow.clipRect.right)
-    mAccumulatedInvalidRect = nsIntRect(0, 0, aWindow.width, aWindow.height);
-
-  mWindow.x = aWindow.x;
-  mWindow.y = aWindow.y;
-  mWindow.width = aWindow.width;
-  mWindow.height = aWindow.height;
-  mWindow.clipRect = aWindow.clipRect;
-  mWindow.type = aWindow.type;
-#if defined(XP_MACOSX) || defined(XP_WIN)
-  mContentsScaleFactor = aWindow.contentsScaleFactor;
-#endif
-
-  mLayersRendering = true;
-  mSurfaceType = aSurfaceType;
-  UpdateWindowAttributes(true);
-
-#ifdef XP_WIN
-  if (GetQuirks() & QUIRK_FLASH_THROTTLE_WMUSER_EVENTS) SetupFlashMsgThrottle();
-#endif
-
-  if (!mAccumulatedInvalidRect.IsEmpty()) {
-    AsyncShowPluginFrame();
-  }
-}
-
-bool PluginInstanceChild::CreateOptSurface(void) {
-  MOZ_ASSERT(mSurfaceType != gfxSurfaceType::Max,
-             "Need a valid surface type here");
-  NS_ASSERTION(!mCurrentSurface, "mCurrentSurfaceActor can get out of sync.");
-
-  // Use an opaque surface unless we're transparent and *don't* have
-  // a background to source from.
-  gfxImageFormat format = (mIsTransparent && !mBackground)
-                              ? SurfaceFormat::A8R8G8B8_UINT32
-                              : SurfaceFormat::X8R8G8B8_UINT32;
-
-#ifdef MOZ_X11
-  Display* dpy = mWsInfo.display;
-  Screen* screen = DefaultScreenOfDisplay(dpy);
-  if (format == SurfaceFormat::X8R8G8B8_UINT32 &&
-      DefaultDepth(dpy, DefaultScreen(dpy)) == 16) {
-    format = SurfaceFormat::R5G6B5_UINT16;
-  }
-
-  if (mSurfaceType == gfxSurfaceType::Xlib) {
-    if (!mIsTransparent || mBackground) {
-      Visual* defaultVisual = DefaultVisualOfScreen(screen);
-      mCurrentSurface = gfxXlibSurface::Create(
-          screen, defaultVisual, IntSize(mWindow.width, mWindow.height));
-      return mCurrentSurface != nullptr;
-    }
-
-    XRenderPictFormat* xfmt =
-        XRenderFindStandardFormat(dpy, PictStandardARGB32);
-    if (!xfmt) {
-      NS_ERROR("Need X falback surface, but FindRenderFormat failed");
-      return false;
-    }
-    mCurrentSurface = gfxXlibSurface::Create(
-        screen, xfmt, IntSize(mWindow.width, mWindow.height));
-    return mCurrentSurface != nullptr;
-  }
-#endif
-
-#ifdef XP_WIN
-  MOZ_CRASH("Shared-memory drawing not expected on Windows.");
-#endif
-
-  // Make common shmem implementation working for any platform
-  mCurrentSurface = gfxSharedImageSurface::CreateUnsafe(
-      this, IntSize(mWindow.width, mWindow.height), format);
-  return !!mCurrentSurface;
-}
-
-bool PluginInstanceChild::MaybeCreatePlatformHelperSurface(void) {
-  if (!mCurrentSurface) {
-    NS_ERROR("Cannot create helper surface without mCurrentSurface");
-    return false;
-  }
-
-#ifdef MOZ_X11
-  bool supportNonDefaultVisual = false;
-  Screen* screen = DefaultScreenOfDisplay(mWsInfo.display);
-  Visual* defaultVisual = DefaultVisualOfScreen(screen);
-  Visual* visual = nullptr;
-  Colormap colormap = 0;
-  mDoAlphaExtraction = false;
-  bool createHelperSurface = false;
-
-  if (mCurrentSurface->GetType() == gfxSurfaceType::Xlib) {
-    static_cast<gfxXlibSurface*>(mCurrentSurface.get())
-        ->GetColormapAndVisual(&colormap, &visual);
-    // Create helper surface if layer surface visual not same as default
-    // and we don't support non-default visual rendering
-    if (!visual || (defaultVisual != visual && !supportNonDefaultVisual)) {
-      createHelperSurface = true;
-      visual = defaultVisual;
-      mDoAlphaExtraction = mIsTransparent;
-    }
-  } else if (mCurrentSurface->GetType() == gfxSurfaceType::Image) {
-    // For image layer surface we should always create helper surface
-    createHelperSurface = true;
-    // Check if we can create helper surface with non-default visual
-    visual = gfxXlibSurface::FindVisual(
-        screen, static_cast<gfxImageSurface*>(mCurrentSurface.get())->Format());
-    if (!visual || (defaultVisual != visual && !supportNonDefaultVisual)) {
-      visual = defaultVisual;
-      mDoAlphaExtraction = mIsTransparent;
-    }
-  }
-
-  if (createHelperSurface) {
-    if (!visual) {
-      NS_ERROR("Need X falback surface, but visual failed");
-      return false;
-    }
-    mHelperSurface =
-        gfxXlibSurface::Create(screen, visual, mCurrentSurface->GetSize());
-    if (!mHelperSurface) {
-      NS_WARNING("Fail to create create helper surface");
-      return false;
-    }
-  }
-#elif defined(XP_WIN)
-  mDoAlphaExtraction = mIsTransparent && !mBackground;
-#endif
-
-  return true;
-}
-
-bool PluginInstanceChild::EnsureCurrentBuffer(void) {
-#ifndef XP_DARWIN
-  nsIntRect toInvalidate(0, 0, 0, 0);
-  IntSize winSize = IntSize(mWindow.width, mWindow.height);
-
-  if (mBackground && mBackground->GetSize() != winSize) {
-    // It would be nice to keep the old background here, but doing
-    // so can lead to cases in which we permanently keep the old
-    // background size.
-    mBackground = nullptr;
-    toInvalidate.UnionRect(toInvalidate,
-                           nsIntRect(0, 0, winSize.width, winSize.height));
-  }
-
-  if (mCurrentSurface) {
-    IntSize surfSize = mCurrentSurface->GetSize();
-    if (winSize != surfSize || (mBackground && !CanPaintOnBackground()) ||
-        (mBackground &&
-         gfxContentType::COLOR != mCurrentSurface->GetContentType()) ||
-        (!mBackground && mIsTransparent &&
-         gfxContentType::COLOR == mCurrentSurface->GetContentType())) {
-      // Don't try to use an old, invalid DC.
-      mWindow.window = nullptr;
-      ClearCurrentSurface();
-      toInvalidate.UnionRect(toInvalidate,
-                             nsIntRect(0, 0, winSize.width, winSize.height));
-    }
-  }
-
-  mAccumulatedInvalidRect.UnionRect(mAccumulatedInvalidRect, toInvalidate);
-
-  if (mCurrentSurface) {
-    return true;
-  }
-
-  if (!CreateOptSurface()) {
-    NS_ERROR("Cannot create optimized surface");
-    return false;
-  }
-
-  if (!MaybeCreatePlatformHelperSurface()) {
-    NS_ERROR("Cannot create helper surface");
-    return false;
-  }
-#elif defined(XP_MACOSX)
-
-  if (!mDoubleBufferCARenderer.HasCALayer()) {
-    void* caLayer = nullptr;
-    if (mDrawingModel == NPDrawingModelCoreGraphics) {
-      if (!mCGLayer) {
-        caLayer = mozilla::plugins::PluginUtilsOSX::GetCGLayer(
-            CallCGDraw, this, mContentsScaleFactor);
-
-        if (!caLayer) {
-          PLUGIN_LOG_DEBUG(("GetCGLayer failed."));
-          return false;
-        }
-      }
-      mCGLayer = caLayer;
-    } else {
-      NPError result = mPluginIface->getvalue(
-          GetNPP(), NPPVpluginCoreAnimationLayer, &caLayer);
-      if (result != NPERR_NO_ERROR || !caLayer) {
-        PLUGIN_LOG_DEBUG(
-            ("Plugin requested CoreAnimation but did not "
-             "provide CALayer."));
-        return false;
-      }
-    }
-    mDoubleBufferCARenderer.SetCALayer(caLayer);
-  }
-
-  if (mDoubleBufferCARenderer.HasFrontSurface() &&
-      (mDoubleBufferCARenderer.GetFrontSurfaceWidth() != mWindow.width ||
-       mDoubleBufferCARenderer.GetFrontSurfaceHeight() != mWindow.height ||
-       mDoubleBufferCARenderer.GetContentsScaleFactor() !=
-           mContentsScaleFactor)) {
-    mDoubleBufferCARenderer.ClearFrontSurface();
-  }
-
-  if (!mDoubleBufferCARenderer.HasFrontSurface()) {
-    bool allocSurface = mDoubleBufferCARenderer.InitFrontSurface(
-        mWindow.width, mWindow.height, mContentsScaleFactor,
-        GetQuirks() & QUIRK_ALLOW_OFFLINE_RENDERER ? ALLOW_OFFLINE_RENDERER
-                                                   : DISALLOW_OFFLINE_RENDERER);
-    if (!allocSurface) {
-      PLUGIN_LOG_DEBUG(("Fail to allocate front IOSurface"));
-      return false;
-    }
-
-    if (mPluginIface->setwindow)
-      (void)mPluginIface->setwindow(&mData, &mWindow);
-
-    nsIntRect toInvalidate(0, 0, mWindow.width, mWindow.height);
-    mAccumulatedInvalidRect.UnionRect(mAccumulatedInvalidRect, toInvalidate);
-  }
-#endif
-
-  return true;
-}
-
-void PluginInstanceChild::UpdateWindowAttributes(bool aForceSetWindow) {
-#if defined(MOZ_X11) || defined(XP_WIN)
-  RefPtr<gfxASurface> curSurface =
-      mHelperSurface ? mHelperSurface : mCurrentSurface;
-#endif  // Only used within MOZ_X11 or XP_WIN blocks. Unused variable otherwise
-  bool needWindowUpdate = aForceSetWindow;
-#ifdef MOZ_X11
-  Visual* visual = nullptr;
-  Colormap colormap = 0;
-  if (curSurface && curSurface->GetType() == gfxSurfaceType::Xlib) {
-    static_cast<gfxXlibSurface*>(curSurface.get())
-        ->GetColormapAndVisual(&colormap, &visual);
-    if (visual != mWsInfo.visual || colormap != mWsInfo.colormap) {
-      mWsInfo.visual = visual;
-      mWsInfo.colormap = colormap;
-      needWindowUpdate = true;
-    }
-  }
-#endif  // MOZ_X11
-
-  if (!needWindowUpdate) {
-    return;
-  }
-
-#ifndef XP_MACOSX
-  // Adjusting the window isn't needed for OSX
-#  ifndef XP_WIN
-  // On Windows, we translate the device context, in order for the window
-  // origin to be correct.
-  mWindow.x = mWindow.y = 0;
-#  endif
-
-  if (IsVisible()) {
-    // The clip rect is relative to drawable top-left.
-    nsIntRect clipRect;
-
-    // Don't ask the plugin to draw outside the drawable. The clip rect
-    // is in plugin coordinates, not window coordinates.
-    // This also ensures that the unsigned clip rectangle offsets won't be -ve.
-    clipRect.SetRect(0, 0, mWindow.width, mWindow.height);
-
-    mWindow.clipRect.left = 0;
-    mWindow.clipRect.top = 0;
-    mWindow.clipRect.right = clipRect.XMost();
-    mWindow.clipRect.bottom = clipRect.YMost();
-  }
-#endif  // XP_MACOSX
-
-#ifdef XP_WIN
-  // Windowless plugins on Windows need a WM_WINDOWPOSCHANGED event to update
-  // their location... or at least Flash does: Silverlight uses the
-  // window.x/y passed to NPP_SetWindow
-
-  if (mPluginIface->event) {
-    // width and height are stored as units, but narrow to ints here
-    MOZ_RELEASE_ASSERT(mWindow.width <= INT_MAX);
-    MOZ_RELEASE_ASSERT(mWindow.height <= INT_MAX);
-
-    WINDOWPOS winpos = {0,
-                        0,
-                        mWindow.x,
-                        mWindow.y,
-                        (int32_t)mWindow.width,
-                        (int32_t)mWindow.height,
-                        0};
-    NPEvent pluginEvent = {WM_WINDOWPOSCHANGED, 0, (LPARAM)&winpos};
-    mPluginIface->event(&mData, &pluginEvent);
-  }
-#endif
-
-  PLUGIN_LOG_DEBUG(
-      ("[InstanceChild][%p] UpdateWindow w=<x=%d,y=%d, w=%d,h=%d>, "
-       "clip=<l=%d,t=%d,r=%d,b=%d>",
-       this, mWindow.x, mWindow.y, mWindow.width, mWindow.height,
-       mWindow.clipRect.left, mWindow.clipRect.top, mWindow.clipRect.right,
-       mWindow.clipRect.bottom));
-
-  if (mPluginIface->setwindow) {
-    mPluginIface->setwindow(&mData, &mWindow);
-  }
-}
-
-void PluginInstanceChild::PaintRectToPlatformSurface(const nsIntRect& aRect,
-                                                     gfxASurface* aSurface) {
-  UpdateWindowAttributes();
-
-  // We should not send an async surface if we're using direct rendering.
-  MOZ_ASSERT(!IsUsingDirectDrawing());
-
-#ifdef MOZ_X11
-  {
-    NS_ASSERTION(aSurface->GetType() == gfxSurfaceType::Xlib,
-                 "Non supported platform surface type");
-
-    NPEvent pluginEvent;
-    XGraphicsExposeEvent& exposeEvent = pluginEvent.xgraphicsexpose;
-    exposeEvent.type = GraphicsExpose;
-    exposeEvent.display = mWsInfo.display;
-    exposeEvent.drawable = static_cast<gfxXlibSurface*>(aSurface)->XDrawable();
-    exposeEvent.x = aRect.x;
-    exposeEvent.y = aRect.y;
-    exposeEvent.width = aRect.width;
-    exposeEvent.height = aRect.height;
-    exposeEvent.count = 0;
-    // information not set:
-    exposeEvent.serial = 0;
-    exposeEvent.send_event = X11False;
-    exposeEvent.major_code = 0;
-    exposeEvent.minor_code = 0;
-    mPluginIface->event(&mData, reinterpret_cast<void*>(&exposeEvent));
-  }
-#else
-  MOZ_CRASH("Surface type not implemented.");
-#endif
-}
-
-void PluginInstanceChild::PaintRectToSurface(const nsIntRect& aRect,
-                                             gfxASurface* aSurface,
-                                             const DeviceColor& aColor) {
-  // Render using temporary X surface, with copy to image surface
-  nsIntRect plPaintRect(aRect);
-  RefPtr<gfxASurface> renderSurface = aSurface;
-#ifdef MOZ_X11
-  if (mIsTransparent && (GetQuirks() & QUIRK_FLASH_EXPOSE_COORD_TRANSLATION)) {
-    // Work around a bug in Flash up to 10.1 d51 at least, where expose event
-    // top left coordinates within the plugin-rect and not at the drawable
-    // origin are misinterpreted.  (We can move the top left coordinate
-    // provided it is within the clipRect.), see bug 574583
-    plPaintRect.SetRect(0, 0, aRect.XMost(), aRect.YMost());
-  }
-  if (mHelperSurface) {
-    // On X11 we can paint to non Xlib surface only with HelperSurface
-    renderSurface = mHelperSurface;
-  }
-#endif
-
-  if (mIsTransparent && !CanPaintOnBackground()) {
-    RefPtr<DrawTarget> dt = CreateDrawTargetForSurface(renderSurface);
-    gfx::Rect rect(plPaintRect.x, plPaintRect.y, plPaintRect.width,
-                   plPaintRect.height);
-    // Moz2D treats OP_SOURCE operations as unbounded, so we need to
-    // clip to the rect that we want to fill:
-    dt->PushClipRect(rect);
-    dt->FillRect(rect,
-                 ColorPattern(aColor),  // aColor is already a device color
-                 DrawOptions(1.f, CompositionOp::OP_SOURCE));
-    dt->PopClip();
-    dt->Flush();
-  }
-
-  PaintRectToPlatformSurface(plPaintRect, renderSurface);
-
-  if (renderSurface != aSurface) {
-    RefPtr<DrawTarget> dt;
-    if (aSurface == mCurrentSurface &&
-        aSurface->GetType() == gfxSurfaceType::Image &&
-        aSurface->GetSurfaceFormat() == SurfaceFormat::B8G8R8X8) {
-      gfxImageSurface* imageSurface = static_cast<gfxImageSurface*>(aSurface);
-      // Bug 1196927 - Reinterpret target surface as BGRA to fill alpha with
-      // opaque. Certain backends (i.e. Skia) may not truly support BGRX
-      // formats, so they must be emulated by filling the alpha channel opaque
-      // as if it was BGRA data. Cairo leaves the alpha zeroed out for BGRX, so
-      // we cause Cairo to fill it as opaque by handling the copy target as a
-      // BGRA surface.
-      dt = Factory::CreateDrawTargetForData(
-          BackendType::CAIRO, imageSurface->Data(), imageSurface->GetSize(),
-          imageSurface->Stride(), SurfaceFormat::B8G8R8A8);
-    } else {
-      // Copy helper surface content to target
-      dt = CreateDrawTargetForSurface(aSurface);
-    }
-    if (dt && dt->IsValid()) {
-      RefPtr<SourceSurface> surface =
-          gfxPlatform::GetSourceSurfaceForSurface(dt, renderSurface);
-      dt->CopySurface(surface, aRect, aRect.TopLeft());
-    } else {
-      gfxWarning() << "PluginInstanceChild::PaintRectToSurface failure";
-    }
-  }
-}
-
-void PluginInstanceChild::PaintRectWithAlphaExtraction(const nsIntRect& aRect,
-                                                       gfxASurface* aSurface) {
-  MOZ_ASSERT(aSurface->GetContentType() == gfxContentType::COLOR_ALPHA,
-             "Refusing to pointlessly recover alpha");
-
-  nsIntRect rect(aRect);
-  // If |aSurface| can be used to paint and can have alpha values
-  // recovered directly to it, do that to save a tmp surface and
-  // copy.
-  bool useSurfaceSubimageForBlack = false;
-  if (gfxSurfaceType::Image == aSurface->GetType()) {
-    gfxImageSurface* surfaceAsImage = static_cast<gfxImageSurface*>(aSurface);
-    useSurfaceSubimageForBlack =
-        (surfaceAsImage->Format() == SurfaceFormat::A8R8G8B8_UINT32);
-    // If we're going to use a subimage, nudge the rect so that we
-    // can use optimal alpha recovery.  If we're not using a
-    // subimage, the temporaries should automatically get
-    // fast-path alpha recovery so we don't need to do anything.
-    if (useSurfaceSubimageForBlack) {
-      rect =
-          gfxAlphaRecovery::AlignRectForSubimageRecovery(aRect, surfaceAsImage);
-    }
-  }
-
-  RefPtr<gfxImageSurface> whiteImage;
-  RefPtr<gfxImageSurface> blackImage;
-  gfxRect targetRect(rect.x, rect.y, rect.width, rect.height);
-  IntSize targetSize(rect.width, rect.height);
-
-  // We always use a temporary "white image"
-  whiteImage = new gfxImageSurface(targetSize, SurfaceFormat::X8R8G8B8_UINT32);
-  if (whiteImage->CairoStatus()) {
-    return;
-  }
-
-  gfxPoint deviceOffset = -targetRect.TopLeft();
-  // Paint onto white background
-  whiteImage->SetDeviceOffset(deviceOffset);
-  PaintRectToSurface(rect, whiteImage, DeviceColor::MaskOpaqueWhite());
-
-  if (useSurfaceSubimageForBlack) {
-    gfxImageSurface* surface = static_cast<gfxImageSurface*>(aSurface);
-    blackImage = surface->GetSubimage(targetRect);
-  } else {
-    blackImage =
-        new gfxImageSurface(targetSize, SurfaceFormat::A8R8G8B8_UINT32);
-  }
-
-  // Paint onto black background
-  blackImage->SetDeviceOffset(deviceOffset);
-  PaintRectToSurface(rect, blackImage, DeviceColor::MaskOpaqueBlack());
-
-  MOZ_ASSERT(whiteImage && blackImage, "Didn't paint enough!");
-
-  // Extract alpha from black and white image and store to black
-  // image
-  if (!gfxAlphaRecovery::RecoverAlpha(blackImage, whiteImage)) {
-    return;
-  }
-
-  // If we had to use a temporary black surface, copy the pixels
-  // with alpha back to the target
-  if (!useSurfaceSubimageForBlack) {
-    RefPtr<DrawTarget> dt = CreateDrawTargetForSurface(aSurface);
-    RefPtr<SourceSurface> surface =
-        gfxPlatform::GetSourceSurfaceForSurface(dt, blackImage);
-    dt->CopySurface(surface, IntRect(0, 0, rect.width, rect.height),
-                    rect.TopLeft());
-  }
-}
-
-bool PluginInstanceChild::CanPaintOnBackground() {
-  return (mBackground && mCurrentSurface &&
-          mCurrentSurface->GetSize() == mBackground->GetSize());
-}
-
-bool PluginInstanceChild::ShowPluginFrame() {
-  // mLayersRendering can be false if we somehow get here without
-  // receiving AsyncSetWindow() first.  mPendingPluginCall is our
-  // re-entrancy guard; we can't paint while nested inside another
-  // paint.
-  if (!mLayersRendering || mPendingPluginCall) {
-    return false;
-  }
-
-  // We should not attempt to asynchronously show the plugin if we're using
-  // direct rendering.
-  MOZ_ASSERT(!IsUsingDirectDrawing());
-
-  AutoRestore<bool> pending(mPendingPluginCall);
-  mPendingPluginCall = true;
-
-  bool temporarilyMakeVisible = !IsVisible() && !mHasPainted;
-  if (temporarilyMakeVisible && mWindow.width && mWindow.height) {
-    mWindow.clipRect.right = mWindow.width;
-    mWindow.clipRect.bottom = mWindow.height;
-  } else if (!IsVisible()) {
-    // If we're not visible, don't bother painting a <0,0,0,0>
-    // rect.  If we're eventually made visible, the visibility
-    // change will invalidate our window.
-    ClearCurrentSurface();
-    return true;
-  }
-
-  if (!EnsureCurrentBuffer()) {
-    return false;
-  }
-
-#ifdef MOZ_WIDGET_COCOA
-  // We can't use the thebes code with CoreAnimation so we will
-  // take a different code path.
-  if (mDrawingModel == NPDrawingModelCoreAnimation ||
-      mDrawingModel == NPDrawingModelInvalidatingCoreAnimation ||
-      mDrawingModel == NPDrawingModelCoreGraphics) {
-    if (!IsVisible()) {
-      return true;
-    }
-
-    if (!mDoubleBufferCARenderer.HasFrontSurface()) {
-      NS_ERROR("CARenderer not initialized for rendering");
-      return false;
-    }
-
-    // Clear accRect here to be able to pass
-    // test_invalidate_during_plugin_paint  test
-    nsIntRect rect = mAccumulatedInvalidRect;
-    mAccumulatedInvalidRect.SetEmpty();
-
-    // Fix up old invalidations that might have been made when our
-    // surface was a different size
-    rect.IntersectRect(
-        rect, nsIntRect(0, 0, mDoubleBufferCARenderer.GetFrontSurfaceWidth(),
-                        mDoubleBufferCARenderer.GetFrontSurfaceHeight()));
-
-    if (mDrawingModel == NPDrawingModelCoreGraphics) {
-      mozilla::plugins::PluginUtilsOSX::Repaint(mCGLayer, rect);
-    }
-
-    mDoubleBufferCARenderer.Render();
-
-    NPRect r = {(uint16_t)rect.y, (uint16_t)rect.x, (uint16_t)rect.YMost(),
-                (uint16_t)rect.XMost()};
-    SurfaceDescriptor currSurf;
-    currSurf =
-        IOSurfaceDescriptor(mDoubleBufferCARenderer.GetFrontSurfaceID(),
-                            mDoubleBufferCARenderer.GetContentsScaleFactor());
-
-    mHasPainted = true;
-
-    SurfaceDescriptor returnSurf;
-
-    if (!SendShow(r, currSurf, &returnSurf)) {
-      return false;
-    }
-
-    SwapSurfaces();
-    return true;
-  } else {
-    NS_ERROR("Unsupported drawing model for async layer rendering");
-    return false;
-  }
-#endif
-
-  NS_ASSERTION(mWindow.width == uint32_t(mWindow.clipRect.right -
-                                         mWindow.clipRect.left) &&
-                   mWindow.height ==
-                       uint32_t(mWindow.clipRect.bottom - mWindow.clipRect.top),
-               "Clip rect should be same size as window when using layers");
-
-  // Clear accRect here to be able to pass
-  // test_invalidate_during_plugin_paint  test
-  nsIntRect rect = mAccumulatedInvalidRect;
-  mAccumulatedInvalidRect.SetEmpty();
-
-  // Fix up old invalidations that might have been made when our
-  // surface was a different size
-  IntSize surfaceSize = mCurrentSurface->GetSize();
-  rect.IntersectRect(rect,
-                     nsIntRect(0, 0, surfaceSize.width, surfaceSize.height));
-
-  if (!ReadbackDifferenceRect(rect)) {
-    // We couldn't read back the pixels that differ between the
-    // current surface and last, so we have to invalidate the
-    // entire window.
-    rect.SetRect(0, 0, mWindow.width, mWindow.height);
-  }
-
-  bool haveTransparentPixels =
-      gfxContentType::COLOR_ALPHA == mCurrentSurface->GetContentType();
-  PLUGIN_LOG_DEBUG(
-      ("[InstanceChild][%p] Painting%s <x=%d,y=%d, w=%d,h=%d> on surface "
-       "<w=%d,h=%d>",
-       this, haveTransparentPixels ? " with alpha" : "", rect.x, rect.y,
-       rect.width, rect.height, mCurrentSurface->GetSize().width,
-       mCurrentSurface->GetSize().height));
-
-  if (CanPaintOnBackground()) {
-    PLUGIN_LOG_DEBUG(("  (on background)"));
-    // Source the background pixels ...
-    {
-      RefPtr<gfxASurface> surface =
-          mHelperSurface ? mHelperSurface : mCurrentSurface;
-      RefPtr<DrawTarget> dt = CreateDrawTargetForSurface(surface);
-      RefPtr<SourceSurface> backgroundSurface =
-          gfxPlatform::GetSourceSurfaceForSurface(dt, mBackground);
-      dt->CopySurface(backgroundSurface, rect, rect.TopLeft());
-    }
-    // ... and hand off to the plugin
-    // BEWARE: mBackground may die during this call
-    PaintRectToSurface(rect, mCurrentSurface, DeviceColor());
-  } else if (!temporarilyMakeVisible && mDoAlphaExtraction) {
-    // We don't want to pay the expense of alpha extraction for
-    // phony paints.
-    PLUGIN_LOG_DEBUG(("  (with alpha recovery)"));
-    PaintRectWithAlphaExtraction(rect, mCurrentSurface);
-  } else {
-    PLUGIN_LOG_DEBUG(("  (onto opaque surface)"));
-
-    // If we're on a platform that needs helper surfaces for
-    // plugins, and we're forcing a throwaway paint of a
-    // wmode=transparent plugin, then make sure to use the helper
-    // surface here.
-    RefPtr<gfxASurface> target = (temporarilyMakeVisible && mHelperSurface)
-                                     ? mHelperSurface
-                                     : mCurrentSurface;
-
-    PaintRectToSurface(rect, target, DeviceColor());
-  }
-  mHasPainted = true;
-
-  if (temporarilyMakeVisible) {
-    mWindow.clipRect.right = mWindow.clipRect.bottom = 0;
-
-    PLUGIN_LOG_DEBUG(
-        ("[InstanceChild][%p] Undoing temporary clipping w=<x=%d,y=%d, "
-         "w=%d,h=%d>, clip=<l=%d,t=%d,r=%d,b=%d>",
-         this, mWindow.x, mWindow.y, mWindow.width, mWindow.height,
-         mWindow.clipRect.left, mWindow.clipRect.top, mWindow.clipRect.right,
-         mWindow.clipRect.bottom));
-
-    if (mPluginIface->setwindow) {
-      mPluginIface->setwindow(&mData, &mWindow);
-    }
-
-    // Skip forwarding the results of the phony paint to the
-    // browser.  We may have painted a transparent plugin using
-    // the opaque-plugin path, which can result in wrong pixels.
-    // We also don't want to pay the expense of forwarding the
-    // surface for plugins that might really be invisible.
-    mAccumulatedInvalidRect.SetRect(0, 0, mWindow.width, mWindow.height);
-    return true;
-  }
-
-  NPRect r = {(uint16_t)rect.y, (uint16_t)rect.x, (uint16_t)rect.YMost(),
-              (uint16_t)rect.XMost()};
-  SurfaceDescriptor currSurf;
-#ifdef MOZ_X11
-  if (mCurrentSurface->GetType() == gfxSurfaceType::Xlib) {
-    gfxXlibSurface* xsurf = static_cast<gfxXlibSurface*>(mCurrentSurface.get());
-    currSurf = SurfaceDescriptorX11(xsurf);
-    // Need to sync all pending x-paint requests
-    // before giving drawable to another process
-    XSync(mWsInfo.display, X11False);
-  } else
-#endif
-      if (gfxSharedImageSurface::IsSharedImage(mCurrentSurface)) {
-    currSurf = std::move(
-        static_cast<gfxSharedImageSurface*>(mCurrentSurface.get())->GetShmem());
-  } else {
-    MOZ_CRASH("Surface type is not remotable");
-    return false;
-  }
-
-  // Unused, except to possibly return a shmem to us
-  SurfaceDescriptor returnSurf;
-
-  if (!SendShow(r, currSurf, &returnSurf)) {
-    return false;
-  }
-
-  SwapSurfaces();
-  mSurfaceDifferenceRect = rect;
-  return true;
-}
-
-bool PluginInstanceChild::ReadbackDifferenceRect(const nsIntRect& rect) {
-  if (!mBackSurface) return false;
-
-#if defined(MOZ_X11)
-  if (mBackSurface->GetType() != gfxSurfaceType::Xlib &&
-      !gfxSharedImageSurface::IsSharedImage(mBackSurface))
-    return false;
-#endif
-
-#if defined(MOZ_X11) || defined(XP_WIN)
-  if (mCurrentSurface->GetContentType() != mBackSurface->GetContentType())
-    return false;
-
-  if (mSurfaceDifferenceRect.IsEmpty()) return true;
-
-  PLUGIN_LOG_DEBUG(
-      ("[InstanceChild][%p] Reading back part of <x=%d,y=%d, w=%d,h=%d>", this,
-       mSurfaceDifferenceRect.x, mSurfaceDifferenceRect.y,
-       mSurfaceDifferenceRect.width, mSurfaceDifferenceRect.height));
-
-  // Read back previous content
-  RefPtr<DrawTarget> dt = CreateDrawTargetForSurface(mCurrentSurface);
-  RefPtr<SourceSurface> source =
-      gfxPlatform::GetSourceSurfaceForSurface(dt, mBackSurface);
-  // Subtract from mSurfaceDifferenceRect area which is overlapping with rect
-  nsIntRegion result;
-  result.Sub(mSurfaceDifferenceRect, nsIntRegion(rect));
-  for (auto iter = result.RectIter(); !iter.Done(); iter.Next()) {
-    const nsIntRect& r = iter.Get();
-    dt->CopySurface(source, r, r.TopLeft());
-  }
-
-  return true;
-#else
-  return false;
-#endif
-}
-
-void PluginInstanceChild::InvalidateRectDelayed(void) {
-  if (!mCurrentInvalidateTask) {
-    return;
-  }
-
-  mCurrentInvalidateTask = nullptr;
-
-  // When this method is run asynchronously, we can end up switching to
-  // direct drawing before while we wait to run.  In that case, bail.
-  if (IsUsingDirectDrawing()) {
-    return;
-  }
-
-  if (mAccumulatedInvalidRect.IsEmpty()) {
-    return;
-  }
-
-  if (!ShowPluginFrame()) {
-    AsyncShowPluginFrame();
-  }
-}
-
-void PluginInstanceChild::AsyncShowPluginFrame(void) {
-  if (mCurrentInvalidateTask) {
-    return;
-  }
-
-  // When the plugin is using direct surfaces to draw, it is not driving
-  // paints via paint events - it will drive painting via its own events
-  // and/or DidComposite callbacks.
-  if (IsUsingDirectDrawing()) {
-    return;
-  }
-
-  mCurrentInvalidateTask = NewNonOwningCancelableRunnableMethod(
-      "plugins::PluginInstanceChild::InvalidateRectDelayed", this,
-      &PluginInstanceChild::InvalidateRectDelayed);
-  RefPtr<Runnable> addrefedTask = mCurrentInvalidateTask;
-  MessageLoop::current()->PostTask(addrefedTask.forget());
-}
-
-void PluginInstanceChild::InvalidateRect(NPRect* aInvalidRect) {
-  NS_ASSERTION(aInvalidRect, "Null pointer!");
-
-#ifdef OS_WIN
-  // Invalidate and draw locally for windowed plugins.
-  if (mWindow.type == NPWindowTypeWindow) {
-    NS_ASSERTION(IsWindow(mPluginWindowHWND), "Bad window?!");
-    RECT rect = {aInvalidRect->left, aInvalidRect->top, aInvalidRect->right,
-                 aInvalidRect->bottom};
-    ::InvalidateRect(mPluginWindowHWND, &rect, FALSE);
-    return;
-  }
-#endif
-
-  if (IsUsingDirectDrawing()) {
-    NS_ASSERTION(false,
-                 "Should not call InvalidateRect() in direct surface mode!");
-    return;
-  }
-
-  if (mLayersRendering) {
-    nsIntRect r(aInvalidRect->left, aInvalidRect->top,
-                aInvalidRect->right - aInvalidRect->left,
-                aInvalidRect->bottom - aInvalidRect->top);
-
-    mAccumulatedInvalidRect.UnionRect(r, mAccumulatedInvalidRect);
-    // If we are able to paint and invalidate sent, then reset
-    // accumulated rectangle
-    AsyncShowPluginFrame();
-    return;
-  }
-
-  // If we were going to use layers rendering but it's not set up
-  // yet, and the plugin happens to call this first, we'll forward
-  // the invalidation to the browser.  It's unclear whether
-  // non-layers plugins need this rect forwarded when their window
-  // width or height is 0, which it would be for layers plugins
-  // before their first SetWindow().
-  SendNPN_InvalidateRect(*aInvalidRect);
-}
-
-mozilla::ipc::IPCResult PluginInstanceChild::RecvUpdateBackground(
-    const SurfaceDescriptor& aBackground, const nsIntRect& aRect) {
-  MOZ_ASSERT(mIsTransparent, "Only transparent plugins use backgrounds");
-
-  if (!mBackground) {
-    // XXX refactor me
-    switch (aBackground.type()) {
-#ifdef MOZ_X11
-      case SurfaceDescriptor::TSurfaceDescriptorX11: {
-        mBackground = aBackground.get_SurfaceDescriptorX11().OpenForeign();
-        break;
-      }
-#endif
-      case SurfaceDescriptor::TShmem: {
-        mBackground = gfxSharedImageSurface::Open(aBackground.get_Shmem());
-        break;
-      }
-      default:
-        MOZ_CRASH("Unexpected background surface descriptor");
-    }
-
-    if (!mBackground) {
-      return IPC_FAIL_NO_REASON(this);
-    }
-
-    IntSize bgSize = mBackground->GetSize();
-    mAccumulatedInvalidRect.UnionRect(
-        mAccumulatedInvalidRect, nsIntRect(0, 0, bgSize.width, bgSize.height));
-    AsyncShowPluginFrame();
-    return IPC_OK();
-  }
-
-  // XXX refactor me
-  mAccumulatedInvalidRect.UnionRect(aRect, mAccumulatedInvalidRect);
-
-  // This must be asynchronous, because we may be nested within RPC messages
-  // which do not expect to receiving paint events.
-  AsyncShowPluginFrame();
-
-  return IPC_OK();
-}
-
-PPluginBackgroundDestroyerChild*
-PluginInstanceChild::AllocPPluginBackgroundDestroyerChild() {
-  return new PluginBackgroundDestroyerChild();
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceChild::RecvPPluginBackgroundDestroyerConstructor(
-    PPluginBackgroundDestroyerChild* aActor) {
-  // Our background changed, so we have to invalidate the area
-  // painted with the old background.  If the background was
-  // destroyed because we have a new background, then we expect to
-  // be notified of that "soon", before processing the asynchronous
-  // invalidation here.  If we're *not* getting a new background,
-  // our current front surface is stale and we want to repaint
-  // "soon" so that we can hand the browser back a surface with
-  // alpha values.  (We should be notified of that invalidation soon
-  // too, but we don't assume that here.)
-  if (mBackground) {
-    IntSize bgsize = mBackground->GetSize();
-    mAccumulatedInvalidRect.UnionRect(
-        nsIntRect(0, 0, bgsize.width, bgsize.height), mAccumulatedInvalidRect);
-
-    // NB: we don't have to XSync here because only ShowPluginFrame()
-    // uses mBackground, and it always XSyncs after finishing.
-    mBackground = nullptr;
-    AsyncShowPluginFrame();
-  }
-
-  if (!PPluginBackgroundDestroyerChild::Send__delete__(aActor)) {
-    return IPC_FAIL_NO_REASON(this);
-  }
-  return IPC_OK();
-}
-
-bool PluginInstanceChild::DeallocPPluginBackgroundDestroyerChild(
-    PPluginBackgroundDestroyerChild* aActor) {
-  delete aActor;
-  return true;
-}
-
-uint32_t PluginInstanceChild::ScheduleTimer(uint32_t interval, bool repeat,
-                                            TimerFunc func) {
-  auto* t = new ChildTimer(this, interval, repeat, func);
-  if (0 == t->ID()) {
-    delete t;
-    return 0;
-  }
-
-  mTimers.AppendElement(t);
-  return t->ID();
-}
-
-void PluginInstanceChild::UnscheduleTimer(uint32_t id) {
-  if (0 == id) return;
-
-  mTimers.RemoveElement(id, ChildTimer::IDComparator());
-}
-
-void PluginInstanceChild::SwapSurfaces() {
-  RefPtr<gfxASurface> tmpsurf = mCurrentSurface;
-
-  mCurrentSurface = mBackSurface;
-#ifdef XP_WIN
-  mCurrentSurfaceActor = mBackSurfaceActor;
-#endif
-
-  mBackSurface = tmpsurf;
-
-#ifdef MOZ_WIDGET_COCOA
-  mDoubleBufferCARenderer.SwapSurfaces();
-
-  // Outdated back surface... not usable anymore due to changed plugin size.
-  // Dropping obsolete surface
-  if (mDoubleBufferCARenderer.HasFrontSurface() &&
-      mDoubleBufferCARenderer.HasBackSurface() &&
-      (mDoubleBufferCARenderer.GetFrontSurfaceWidth() !=
-           mDoubleBufferCARenderer.GetBackSurfaceWidth() ||
-       mDoubleBufferCARenderer.GetFrontSurfaceHeight() !=
-           mDoubleBufferCARenderer.GetBackSurfaceHeight() ||
-       mDoubleBufferCARenderer.GetFrontSurfaceContentsScaleFactor() !=
-           mDoubleBufferCARenderer.GetBackSurfaceContentsScaleFactor())) {
-    mDoubleBufferCARenderer.ClearFrontSurface();
-  }
-#else
-  if (mCurrentSurface && mBackSurface &&
-      (mCurrentSurface->GetSize() != mBackSurface->GetSize() ||
-       mCurrentSurface->GetContentType() != mBackSurface->GetContentType())) {
-    ClearCurrentSurface();
-  }
-#endif
-}
-
-void PluginInstanceChild::ClearCurrentSurface() {
-  mCurrentSurface = nullptr;
-#ifdef MOZ_WIDGET_COCOA
-  if (mDoubleBufferCARenderer.HasFrontSurface()) {
-    mDoubleBufferCARenderer.ClearFrontSurface();
-  }
-#endif
-  mHelperSurface = nullptr;
-}
-
-void PluginInstanceChild::ClearAllSurfaces() {
-  if (mBackSurface) {
-    // Get last surface back, and drop it
-    SurfaceDescriptor temp = null_t();
-    NPRect r = {0, 0, 1, 1};
-    SendShow(r, temp, &temp);
-  }
-
-  if (gfxSharedImageSurface::IsSharedImage(mCurrentSurface))
-    DeallocShmem(
-        static_cast<gfxSharedImageSurface*>(mCurrentSurface.get())->GetShmem());
-  if (gfxSharedImageSurface::IsSharedImage(mBackSurface))
-    DeallocShmem(
-        static_cast<gfxSharedImageSurface*>(mBackSurface.get())->GetShmem());
-  mCurrentSurface = nullptr;
-  mBackSurface = nullptr;
-
-#ifdef MOZ_WIDGET_COCOA
-  if (mDoubleBufferCARenderer.HasBackSurface()) {
-    // Get last surface back, and drop it
-    SurfaceDescriptor temp = null_t();
-    NPRect r = {0, 0, 1, 1};
-    SendShow(r, temp, &temp);
-  }
-
-  if (mCGLayer) {
-    mozilla::plugins::PluginUtilsOSX::ReleaseCGLayer(mCGLayer);
-    mCGLayer = nullptr;
-  }
-
-  mDoubleBufferCARenderer.ClearFrontSurface();
-  mDoubleBufferCARenderer.ClearBackSurface();
-#endif
-}
-
-static void InvalidateObjects(nsTHashtable<DeletingObjectEntry>& aEntries) {
-  for (const auto& e : aEntries) {
-    NPObject* o = e.GetKey();
-    if (!e.mDeleted && o->_class && o->_class->invalidate) {
-      o->_class->invalidate(o);
-    }
-  }
-}
-
-static void DeleteObjects(nsTHashtable<DeletingObjectEntry>& aEntries) {
-  for (auto iter = aEntries.Iter(); !iter.Done(); iter.Next()) {
-    DeletingObjectEntry* e = iter.Get();
-    NPObject* o = e->GetKey();
-    if (!e->mDeleted) {
-      e->mDeleted = true;
-
-#ifdef NS_BUILD_REFCNT_LOGGING
-      {
-        int32_t refcnt = o->referenceCount;
-        while (refcnt) {
-          --refcnt;
-          NS_LOG_RELEASE(o, refcnt, "NPObject");
-        }
-      }
-#endif
-
-      PluginModuleChild::DeallocNPObject(o);
-    }
-  }
-}
-
-void PluginInstanceChild::Destroy() {
-  if (mDestroyed) {
-    return;
-  }
-  if (mStackDepth != 0) {
-    MOZ_CRASH("Destroying plugin instance on the stack.");
-  }
-  mDestroyed = true;
-
-#if defined(OS_WIN)
-  SetProp(mPluginWindowHWND, kPluginIgnoreSubclassProperty, (HANDLE)1);
-#endif
-
-  nsTArray<PBrowserStreamChild*> streams;
-  ManagedPBrowserStreamChild(streams);
-
-  // First make sure none of these streams become deleted
-  streams.RemoveElementsBy([](const auto& stream) {
-    return !static_cast<BrowserStreamChild*>(stream)->InstanceDying();
-  });
-  for (uint32_t i = 0; i < streams.Length(); ++i)
-    static_cast<BrowserStreamChild*>(streams[i])->FinishDelivery();
-
-  mTimers.Clear();
-
-  // NPP_Destroy() should be a synchronization point for plugin threads
-  // calling NPN_AsyncCall: after this function returns, they are no longer
-  // allowed to make async calls on this instance.
-  static_cast<PluginModuleChild*>(Manager())->NPP_Destroy(this);
-  mData.ndata = 0;
-
-  if (mCurrentInvalidateTask) {
-    mCurrentInvalidateTask->Cancel();
-    mCurrentInvalidateTask = nullptr;
-  }
-  if (mCurrentAsyncSetWindowTask) {
-    mCurrentAsyncSetWindowTask->Cancel();
-    mCurrentAsyncSetWindowTask = nullptr;
-  }
-  {
-    MutexAutoLock autoLock(mAsyncInvalidateMutex);
-    if (mAsyncInvalidateTask) {
-      mAsyncInvalidateTask->Cancel();
-      mAsyncInvalidateTask = nullptr;
-    }
-  }
-
-  ClearAllSurfaces();
-  mDirectBitmaps.Clear();
-
-  mDeletingHash = MakeUnique<nsTHashtable<DeletingObjectEntry>>();
-  PluginScriptableObjectChild::NotifyOfInstanceShutdown(this);
-
-  InvalidateObjects(*mDeletingHash);
-  DeleteObjects(*mDeletingHash);
-
-  // Null out our cached actors as they should have been killed in the
-  // PluginInstanceDestroyed call above.
-  mCachedWindowActor = nullptr;
-  mCachedElementActor = nullptr;
-
-#if defined(OS_WIN)
-  DestroyWinlessPopupSurrogate();
-  UnhookWinlessFlashThrottle();
-  DestroyPluginWindow();
-
-  for (uint32_t i = 0; i < mPendingFlashThrottleMsgs.Length(); ++i) {
-    mPendingFlashThrottleMsgs[i]->Cancel();
-  }
-  mPendingFlashThrottleMsgs.Clear();
-#endif
-}
-
-mozilla::ipc::IPCResult PluginInstanceChild::AnswerNPP_Destroy(
-    NPError* aResult) {
-  PLUGIN_LOG_DEBUG_METHOD;
-  AssertPluginThread();
-  *aResult = NPERR_NO_ERROR;
-
-  Destroy();
-
-  return IPC_OK();
-}
-
-void PluginInstanceChild::ActorDestroy(ActorDestroyReason why) {
-#ifdef XP_WIN
-  // ClearAllSurfaces() should not try to send anything after ActorDestroy.
-  mCurrentSurfaceActor = nullptr;
-  mBackSurfaceActor = nullptr;
-#endif
-
-  Destroy();
-}
diff --git a/dom/plugins/ipc/PluginInstanceChild.h b/dom/plugins/ipc/PluginInstanceChild.h
deleted file mode 100644
index ce29c65120483..0000000000000
--- a/dom/plugins/ipc/PluginInstanceChild.h
+++ /dev/null
@@ -1,577 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef dom_plugins_PluginInstanceChild_h
-#define dom_plugins_PluginInstanceChild_h 1
-
-#include "mozilla/EventForwards.h"
-#include "mozilla/plugins/PPluginInstanceChild.h"
-#include "mozilla/plugins/PluginScriptableObjectChild.h"
-#include "mozilla/plugins/StreamNotifyChild.h"
-#include "mozilla/ipc/CrossProcessMutex.h"
-#include "nsRefPtrHashtable.h"
-#if defined(MOZ_WIDGET_COCOA)
-#  include "PluginUtilsOSX.h"
-#  include "mozilla/gfx/QuartzSupport.h"
-#  include "base/timer.h"
-
-#endif
-
-#include "npfunctions.h"
-#include "mozilla/UniquePtr.h"
-#include "nsTArray.h"
-#include "ChildTimer.h"
-#include "nsRect.h"
-#include "nsTHashtable.h"
-#include "mozilla/PaintTracker.h"
-#include "mozilla/gfx/Types.h"
-
-#include <map>
-
-class gfxASurface;
-
-namespace mozilla {
-namespace plugins {
-
-class PBrowserStreamChild;
-class BrowserStreamChild;
-class StreamNotifyChild;
-
-class PluginInstanceChild : public PPluginInstanceChild {
-  friend class BrowserStreamChild;
-  friend class PluginStreamChild;
-  friend class StreamNotifyChild;
-  friend class PluginScriptableObjectChild;
-  friend class PPluginInstanceChild;
-
-#ifdef OS_WIN
-  friend LRESULT CALLBACK PluginWindowProc(HWND hWnd, UINT message,
-                                           WPARAM wParam, LPARAM lParam);
-  static LRESULT CALLBACK PluginWindowProcInternal(HWND hWnd, UINT message,
-                                                   WPARAM wParam,
-                                                   LPARAM lParam);
-#endif
-
- protected:
-  mozilla::ipc::IPCResult AnswerCreateChildPluginWindow(
-      NativeWindowHandle* aChildPluginWindow);
-
-  mozilla::ipc::IPCResult RecvCreateChildPopupSurrogate(
-      const NativeWindowHandle& aNetscapeWindow);
-
-  mozilla::ipc::IPCResult AnswerNPP_SetWindow(const NPRemoteWindow& window);
-
-  mozilla::ipc::IPCResult AnswerNPP_GetValue_NPPVpluginWantsAllNetworkStreams(
-      bool* wantsAllStreams, NPError* rv);
-  mozilla::ipc::IPCResult AnswerNPP_GetValue_NPPVpluginScriptableNPObject(
-      PPluginScriptableObjectChild** value, NPError* result);
-  mozilla::ipc::IPCResult
-  AnswerNPP_GetValue_NPPVpluginNativeAccessibleAtkPlugId(nsCString* aPlugId,
-                                                         NPError* aResult);
-  mozilla::ipc::IPCResult AnswerNPP_SetValue_NPNVprivateModeBool(
-      const bool& value, NPError* result);
-  mozilla::ipc::IPCResult AnswerNPP_SetValue_NPNVmuteAudioBool(
-      const bool& value, NPError* result);
-  mozilla::ipc::IPCResult AnswerNPP_SetValue_NPNVCSSZoomFactor(
-      const double& value, NPError* result);
-
-  mozilla::ipc::IPCResult AnswerNPP_HandleEvent(const NPRemoteEvent& event,
-                                                int16_t* handled);
-  mozilla::ipc::IPCResult AnswerNPP_HandleEvent_Shmem(
-      const NPRemoteEvent& event, Shmem&& mem, int16_t* handled, Shmem* rtnmem);
-  mozilla::ipc::IPCResult AnswerNPP_HandleEvent_IOSurface(
-      const NPRemoteEvent& event, const uint32_t& surface, int16_t* handled);
-
-  // Async rendering
-  mozilla::ipc::IPCResult RecvAsyncSetWindow(const gfxSurfaceType& aSurfaceType,
-                                             const NPRemoteWindow& aWindow);
-
-  virtual void DoAsyncSetWindow(const gfxSurfaceType& aSurfaceType,
-                                const NPRemoteWindow& aWindow, bool aIsAsync);
-
-  mozilla::ipc::IPCResult AnswerPaint(const NPRemoteEvent& event,
-                                      int16_t* handled) {
-    PaintTracker pt;
-    if (!AnswerNPP_HandleEvent(event, handled)) {
-      return IPC_FAIL_NO_REASON(this);
-    }
-    return IPC_OK();
-  }
-
-  mozilla::ipc::IPCResult RecvWindowPosChanged(const NPRemoteEvent& event);
-
-  mozilla::ipc::IPCResult RecvContentsScaleFactorChanged(
-      const double& aContentsScaleFactor);
-
-  mozilla::ipc::IPCResult AnswerNPP_Destroy(NPError* result);
-
-  PPluginScriptableObjectChild* AllocPPluginScriptableObjectChild();
-
-  bool DeallocPPluginScriptableObjectChild(
-      PPluginScriptableObjectChild* aObject);
-
-  virtual mozilla::ipc::IPCResult RecvPPluginScriptableObjectConstructor(
-      PPluginScriptableObjectChild* aActor) override;
-
-  virtual mozilla::ipc::IPCResult RecvPBrowserStreamConstructor(
-      PBrowserStreamChild* aActor, const nsCString& aURL,
-      const uint32_t& aLength, const uint32_t& aLastmodified,
-      PStreamNotifyChild* aNotifyData, const nsCString& aHeaders) override;
-
-  mozilla::ipc::IPCResult AnswerNPP_NewStream(PBrowserStreamChild* actor,
-                                              const nsCString& mimeType,
-                                              const bool& seekable, NPError* rv,
-                                              uint16_t* stype);
-
-  PBrowserStreamChild* AllocPBrowserStreamChild(const nsCString& url,
-                                                const uint32_t& length,
-                                                const uint32_t& lastmodified,
-                                                PStreamNotifyChild* notifyData,
-                                                const nsCString& headers);
-
-  bool DeallocPBrowserStreamChild(PBrowserStreamChild* stream);
-
-  PStreamNotifyChild* AllocPStreamNotifyChild(
-      const nsCString& url, const nsCString& target, const bool& post,
-      const nsCString& buffer, const bool& file, NPError* result);
-
-  bool DeallocPStreamNotifyChild(PStreamNotifyChild* notifyData);
-
-  mozilla::ipc::IPCResult AnswerSetPluginFocus();
-
-  mozilla::ipc::IPCResult AnswerUpdateWindow();
-
-  mozilla::ipc::IPCResult RecvNPP_DidComposite();
-
- public:
-  PluginInstanceChild(const NPPluginFuncs* aPluginIface,
-                      const nsCString& aMimeType,
-                      const nsTArray<nsCString>& aNames,
-                      const nsTArray<nsCString>& aValues);
-
-  virtual ~PluginInstanceChild();
-
-  NPError DoNPP_New();
-
-  // Common sync+async implementation of NPP_NewStream
-  NPError DoNPP_NewStream(BrowserStreamChild* actor, const nsCString& mimeType,
-                          const bool& seekable, uint16_t* stype);
-
-  bool Initialize();
-
-  NPP GetNPP() { return &mData; }
-
-  NPError NPN_GetValue(NPNVariable aVariable, void* aValue);
-
-  NPError NPN_SetValue(NPPVariable aVariable, void* aValue);
-
-  PluginScriptableObjectChild* GetActorForNPObject(NPObject* aObject);
-
-  NPError NPN_NewStream(NPMIMEType aMIMEType, const char* aWindow,
-                        NPStream** aStream);
-
-  void InvalidateRect(NPRect* aInvalidRect);
-
-#ifdef MOZ_WIDGET_COCOA
-  void Invalidate();
-#endif  // definied(MOZ_WIDGET_COCOA)
-
-  uint32_t ScheduleTimer(uint32_t interval, bool repeat, TimerFunc func);
-  void UnscheduleTimer(uint32_t id);
-
-  int GetQuirks();
-
-  void NPN_URLRedirectResponse(void* notifyData, NPBool allow);
-
-  NPError NPN_InitAsyncSurface(NPSize* size, NPImageFormat format,
-                               void* initData, NPAsyncSurface* surface);
-  NPError NPN_FinalizeAsyncSurface(NPAsyncSurface* surface);
-
-  void NPN_SetCurrentAsyncSurface(NPAsyncSurface* surface, NPRect* changed);
-
-  void DoAsyncRedraw();
-
-#if defined(XP_WIN)
-  NPError DefaultAudioDeviceChanged(NPAudioDeviceChangeDetails& details);
-  NPError AudioDeviceStateChanged(NPAudioDeviceStateChanged& aDeviceState);
-#endif
-
- private:
-  friend class PluginModuleChild;
-
-  NPError InternalGetNPObjectForValue(NPNVariable aValue, NPObject** aObject);
-
-  bool IsUsingDirectDrawing();
-
-  mozilla::ipc::IPCResult RecvUpdateBackground(
-      const SurfaceDescriptor& aBackground, const nsIntRect& aRect);
-
-  PPluginBackgroundDestroyerChild* AllocPPluginBackgroundDestroyerChild();
-
-  mozilla::ipc::IPCResult RecvPPluginBackgroundDestroyerConstructor(
-      PPluginBackgroundDestroyerChild* aActor) override;
-
-  bool DeallocPPluginBackgroundDestroyerChild(
-      PPluginBackgroundDestroyerChild* aActor);
-
-#if defined(OS_WIN)
-  static bool RegisterWindowClass();
-  bool CreatePluginWindow();
-  void DestroyPluginWindow();
-  void SizePluginWindow(int width, int height);
-  int16_t WinlessHandleEvent(NPEvent& event);
-  void CreateWinlessPopupSurrogate();
-  void DestroyWinlessPopupSurrogate();
-  void InitPopupMenuHook();
-  void SetupFlashMsgThrottle();
-  void UnhookWinlessFlashThrottle();
-  void HookSetWindowLongPtr();
-  void InitImm32Hook();
-  static inline bool SetWindowLongHookCheck(HWND hWnd, int nIndex,
-                                            LONG_PTR newLong);
-  void FlashThrottleMessage(HWND, UINT, WPARAM, LPARAM, bool);
-  static LRESULT CALLBACK DummyWindowProc(HWND hWnd, UINT message,
-                                          WPARAM wParam, LPARAM lParam);
-  static LRESULT CALLBACK PluginWindowProc(HWND hWnd, UINT message,
-                                           WPARAM wParam, LPARAM lParam);
-  static BOOL WINAPI TrackPopupHookProc(HMENU hMenu, UINT uFlags, int x, int y,
-                                        int nReserved, HWND hWnd,
-                                        CONST RECT* prcRect);
-  static BOOL CALLBACK EnumThreadWindowsCallback(HWND hWnd, LPARAM aParam);
-  static LRESULT CALLBACK WinlessHiddenFlashWndProc(HWND hWnd, UINT message,
-                                                    WPARAM wParam,
-                                                    LPARAM lParam);
-#  ifdef _WIN64
-  static LONG_PTR WINAPI SetWindowLongPtrAHook(HWND hWnd, int nIndex,
-                                               LONG_PTR newLong);
-  static LONG_PTR WINAPI SetWindowLongPtrWHook(HWND hWnd, int nIndex,
-                                               LONG_PTR newLong);
-
-#  else
-  static LONG WINAPI SetWindowLongAHook(HWND hWnd, int nIndex, LONG newLong);
-  static LONG WINAPI SetWindowLongWHook(HWND hWnd, int nIndex, LONG newLong);
-#  endif
-
-  static HIMC WINAPI ImmGetContextProc(HWND aWND);
-  static LONG WINAPI ImmGetCompositionStringProc(HIMC aIMC, DWORD aIndex,
-                                                 LPVOID aBuf, DWORD aLen);
-  static BOOL WINAPI ImmSetCandidateWindowProc(HIMC hIMC,
-                                               LPCANDIDATEFORM plCandidate);
-  static BOOL WINAPI ImmNotifyIME(HIMC aIMC, DWORD aAction, DWORD aIndex,
-                                  DWORD aValue);
-  static BOOL WINAPI ImmAssociateContextExProc(HWND hWnd, HIMC aIMC,
-                                               DWORD dwFlags);
-
-  class FlashThrottleMsg : public CancelableRunnable {
-   public:
-    FlashThrottleMsg(PluginInstanceChild* aInstance, HWND aWnd, UINT aMsg,
-                     WPARAM aWParam, LPARAM aLParam, bool isWindowed)
-        : CancelableRunnable("FlashThrottleMsg"),
-          mInstance(aInstance),
-          mWnd(aWnd),
-          mMsg(aMsg),
-          mWParam(aWParam),
-          mLParam(aLParam),
-          mWindowed(isWindowed) {}
-
-    NS_IMETHOD Run() override;
-    nsresult Cancel() override;
-
-    WNDPROC GetProc();
-    HWND GetWnd() { return mWnd; }
-    UINT GetMsg() { return mMsg; }
-    WPARAM GetWParam() { return mWParam; }
-    LPARAM GetLParam() { return mLParam; }
-
-   private:
-    PluginInstanceChild* mInstance;
-    HWND mWnd;
-    UINT mMsg;
-    WPARAM mWParam;
-    LPARAM mLParam;
-    bool mWindowed;
-  };
-
-#endif  // #if defined(OS_WIN)
-  const NPPluginFuncs* mPluginIface;
-  nsCString mMimeType;
-  nsTArray<nsCString> mNames;
-  nsTArray<nsCString> mValues;
-  NPP_t mData;
-  NPWindow mWindow;
-#if defined(XP_DARWIN) || defined(XP_WIN)
-  double mContentsScaleFactor;
-#endif
-  double mCSSZoomFactor;
-  int16_t mDrawingModel;
-
-  NPAsyncSurface* mCurrentDirectSurface;
-
-  // The surface hashtables below serve a few purposes. They let us verify
-  // and retain extra information about plugin surfaces, and they let us
-  // free shared memory that the plugin might forget to release.
-  struct DirectBitmap {
-    DirectBitmap(PluginInstanceChild* aOwner, const Shmem& shmem,
-                 const gfx::IntSize& size, uint32_t stride,
-                 SurfaceFormat format);
-
-   private:
-    ~DirectBitmap();
-
-   public:
-    NS_INLINE_DECL_THREADSAFE_REFCOUNTING(DirectBitmap);
-
-    PluginInstanceChild* mOwner;
-    Shmem mShmem;
-    gfx::SurfaceFormat mFormat;
-    gfx::IntSize mSize;
-    uint32_t mStride;
-  };
-  nsRefPtrHashtable<nsPtrHashKey<NPAsyncSurface>, DirectBitmap> mDirectBitmaps;
-
-#if defined(XP_WIN)
-  nsTHashMap<nsPtrHashKey<NPAsyncSurface>, WindowsHandle> mDxgiSurfaces;
-#endif
-
-  mozilla::Mutex mAsyncInvalidateMutex;
-  CancelableRunnable* mAsyncInvalidateTask;
-
-  // Cached scriptable actors to avoid IPC churn
-  PluginScriptableObjectChild* mCachedWindowActor;
-  PluginScriptableObjectChild* mCachedElementActor;
-
-#if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
-  NPSetWindowCallbackStruct mWsInfo;
-#elif defined(OS_WIN)
-  HWND mPluginWindowHWND;
-  WNDPROC mPluginWndProc;
-  HWND mPluginParentHWND;
-  int mNestedEventLevelDepth;
-  HWND mCachedWinlessPluginHWND;
-  HWND mWinlessPopupSurrogateHWND;
-  nsIntPoint mPluginSize;
-  WNDPROC mWinlessThrottleOldWndProc;
-  HWND mWinlessHiddenMsgHWND;
-#endif
-
-#if defined(OS_WIN)
-  nsTArray<FlashThrottleMsg*> mPendingFlashThrottleMsgs;
-#endif
-  nsTArray<UniquePtr<ChildTimer> > mTimers;
-
-  /**
-   * During destruction we enumerate all remaining scriptable objects and
-   * invalidate/delete them. Enumeration can re-enter, so maintain a
-   * hash separate from PluginModuleChild.mObjectMap.
-   */
-  UniquePtr<nsTHashtable<DeletingObjectEntry> > mDeletingHash;
-
-#if defined(MOZ_WIDGET_COCOA)
- private:
-#  if defined(__i386__)
-  NPEventModel mEventModel;
-#  endif
-  CGColorSpaceRef mShColorSpace;
-  CGContextRef mShContext;
-  RefPtr<nsCARenderer> mCARenderer;
-  void* mCGLayer;
-
-  // Core Animation drawing model requires a refresh timer.
-  uint32_t mCARefreshTimer;
-
- public:
-  const NPCocoaEvent* getCurrentEvent() { return mCurrentEvent; }
-
-  bool CGDraw(CGContextRef ref, nsIntRect aUpdateRect);
-
-#  if defined(__i386__)
-  NPEventModel EventModel() { return mEventModel; }
-#  endif
-
- private:
-  const NPCocoaEvent* mCurrentEvent;
-#endif
-
-  bool CanPaintOnBackground();
-
-  bool IsVisible() {
-#ifdef XP_MACOSX
-    return mWindow.clipRect.top != mWindow.clipRect.bottom &&
-           mWindow.clipRect.left != mWindow.clipRect.right;
-#else
-    return mWindow.clipRect.top != 0 || mWindow.clipRect.left != 0 ||
-           mWindow.clipRect.bottom != 0 || mWindow.clipRect.right != 0;
-#endif
-  }
-
-  // ShowPluginFrame - in general does four things:
-  // 1) Create mCurrentSurface optimized for rendering to parent process
-  // 2) Updated mCurrentSurface to be a complete copy of mBackSurface
-  // 3) Draw the invalidated plugin area into mCurrentSurface
-  // 4) Send it to parent process.
-  bool ShowPluginFrame(void);
-
-  // If we can read back safely from mBackSurface, copy
-  // mSurfaceDifferenceRect from mBackSurface to mFrontSurface.
-  // @return Whether the back surface could be read.
-  bool ReadbackDifferenceRect(const nsIntRect& rect);
-
-  // Post ShowPluginFrame task
-  void AsyncShowPluginFrame(void);
-
-  // In the PaintRect functions, aSurface is the size of the full plugin
-  // window. Each PaintRect function renders into the subrectangle aRect of
-  // aSurface (possibly more if we're working around a Flash bug).
-
-  // Paint plugin content rectangle to surface with bg color filling
-  void PaintRectToSurface(const nsIntRect& aRect, gfxASurface* aSurface,
-                          const gfx::DeviceColor& aColor);
-
-  // Render plugin content to surface using
-  // white/black image alpha extraction algorithm
-  void PaintRectWithAlphaExtraction(const nsIntRect& aRect,
-                                    gfxASurface* aSurface);
-
-  // Call plugin NPAPI function to render plugin content to surface
-  // @param - aSurface - should be compatible with current platform plugin
-  // rendering
-  // @return - FALSE if plugin not painted to surface
-  void PaintRectToPlatformSurface(const nsIntRect& aRect,
-                                  gfxASurface* aSurface);
-
-  // Update NPWindow platform attributes and call plugin "setwindow"
-  // @param - aForceSetWindow - call setwindow even if platform attributes are
-  // the same
-  void UpdateWindowAttributes(bool aForceSetWindow = false);
-
-  // Create optimized mCurrentSurface for parent process rendering
-  // @return FALSE if optimized surface not created
-  bool CreateOptSurface(void);
-
-  // Create mHelperSurface if mCurrentSurface non compatible with plugins
-  // @return TRUE if helper surface created successfully, or not needed
-  bool MaybeCreatePlatformHelperSurface(void);
-
-  // Make sure that we have surface for rendering
-  bool EnsureCurrentBuffer(void);
-
-  // Helper function for delayed InvalidateRect call
-  // non null mCurrentInvalidateTask will call this function
-  void InvalidateRectDelayed(void);
-
-  // Clear mCurrentSurface/mCurrentSurfaceActor/mHelperSurface
-  void ClearCurrentSurface();
-
-  // Swap mCurrentSurface/mBackSurface and their associated actors
-  void SwapSurfaces();
-
-  // Clear all surfaces in response to NPP_Destroy
-  void ClearAllSurfaces();
-
-  void Destroy();
-
-  void ActorDestroy(ActorDestroyReason aWhy) override;
-
-  // Set as true when SetupLayer called
-  // and go with different path in InvalidateRect function
-  bool mLayersRendering;
-
-  // Current surface available for rendering
-  RefPtr<gfxASurface> mCurrentSurface;
-
-  // Back surface, just keeping reference to
-  // surface which is on ParentProcess side
-  RefPtr<gfxASurface> mBackSurface;
-
-#ifdef XP_MACOSX
-  // Current IOSurface available for rendering
-  // We can't use thebes gfxASurface like other platforms.
-  PluginUtilsOSX::nsDoubleBufferCARenderer mDoubleBufferCARenderer;
-#endif
-
-  // (Not to be confused with mBackSurface).  This is a recent copy
-  // of the opaque pixels under our object frame, if
-  // |mIsTransparent|.  We ask the plugin render directly onto a
-  // copy of the background pixels if available, and fall back on
-  // alpha recovery otherwise.
-  RefPtr<gfxASurface> mBackground;
-
-  // Accumulated invalidate rect, while back buffer is not accessible,
-  // in plugin coordinates.
-  nsIntRect mAccumulatedInvalidRect;
-
-  // Plugin only call SetTransparent
-  // and does not remember their transparent state
-  // and p->getvalue return always false
-  bool mIsTransparent;
-
-  // Surface type optimized of parent process
-  gfxSurfaceType mSurfaceType;
-
-  // Keep InvalidateRect task pointer to be able Cancel it on Destroy
-  RefPtr<CancelableRunnable> mCurrentInvalidateTask;
-
-  // Keep AsyncSetWindow task pointer to be able to Cancel it on Destroy
-  RefPtr<CancelableRunnable> mCurrentAsyncSetWindowTask;
-
-  // True while plugin-child in plugin call
-  // Use to prevent plugin paint re-enter
-  bool mPendingPluginCall;
-
-  // On some platforms, plugins may not support rendering to a surface with
-  // alpha, or not support rendering to an image surface.
-  // In those cases we need to draw to a temporary platform surface; we cache
-  // that surface here.
-  RefPtr<gfxASurface> mHelperSurface;
-
-  // true when plugin does not support painting to ARGB32
-  // surface this is false if plugin supports
-  // NPPVpluginTransparentAlphaBool (which is not part of
-  // NPAPI yet)
-  bool mDoAlphaExtraction;
-
-  // true when the plugin has painted at least once. We use this to ensure
-  // that we ask a plugin to paint at least once even if it's invisible;
-  // some plugin (instances) rely on this in order to work properly.
-  bool mHasPainted;
-
-  // Cached rectangle rendered to previous surface(mBackSurface)
-  // Used for reading back to current surface and syncing data,
-  // in plugin coordinates.
-  nsIntRect mSurfaceDifferenceRect;
-
-  // Has this instance been destroyed, either by ActorDestroy or NPP_Destroy?
-  bool mDestroyed;
-
-#ifdef XP_WIN
-  // Store the last IME state by ImmAssociateContextEx.  This will reset by
-  // WM_KILLFOCUS;
-  bool mLastEnableIMEState;
-#endif  // #ifdef XP_WIN
-
-  // A counter is incremented by AutoStackHelper to indicate that there is an
-  // active plugin call which should be preventing shutdown.
- public:
-  class AutoStackHelper {
-   public:
-    explicit AutoStackHelper(PluginInstanceChild* instance)
-        : mInstance(instance) {
-      ++mInstance->mStackDepth;
-    }
-    ~AutoStackHelper() { --mInstance->mStackDepth; }
-
-   private:
-    PluginInstanceChild* const mInstance;
-  };
-
- private:
-  int32_t mStackDepth;
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // ifndef dom_plugins_PluginInstanceChild_h
diff --git a/dom/plugins/ipc/PluginInstanceParent.cpp b/dom/plugins/ipc/PluginInstanceParent.cpp
deleted file mode 100644
index 6acfe1ac6ed59..0000000000000
--- a/dom/plugins/ipc/PluginInstanceParent.cpp
+++ /dev/null
@@ -1,2277 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "mozilla/DebugOnly.h"
-#include <stdint.h>  // for intptr_t
-
-#include "mozilla/BasicEvents.h"
-#include "mozilla/D3DMessageUtils.h"  // for DxgiAdapterDesc
-#include "mozilla/Preferences.h"
-#include "mozilla/StaticPrefs_dom.h"
-#include "mozilla/Telemetry.h"
-#include "mozilla/ToString.h"
-#include "mozilla/dom/Element.h"
-#include "PluginInstanceParent.h"
-#include "BrowserStreamParent.h"
-#include "PluginBackgroundDestroyer.h"
-#include "PluginModuleParent.h"
-#include "StreamNotifyParent.h"
-#include "npfunctions.h"
-#include "gfxASurface.h"
-#include "gfxContext.h"
-#include "gfxPlatform.h"
-#include "gfxSharedImageSurface.h"
-#include "nsNetUtil.h"
-#include "nsNPAPIPluginInstance.h"
-#include "nsPluginInstanceOwner.h"
-#include "nsFocusManager.h"
-#ifdef MOZ_X11
-#  include "gfxXlibSurface.h"
-#endif
-#include "gfxUtils.h"
-#include "mozilla/gfx/2D.h"
-#include "Layers.h"
-#include "ImageContainer.h"
-#include "GLContext.h"
-#include "GLContextProvider.h"
-#include "mozilla/layers/TextureWrapperImage.h"
-#include "mozilla/layers/TextureClientRecycleAllocator.h"
-#include "mozilla/layers/ImageBridgeChild.h"
-#if defined(XP_WIN)
-#  include "mozilla/layers/D3D11ShareHandleImage.h"
-#  include "mozilla/gfx/DeviceManagerDx.h"
-#  include "mozilla/layers/TextureD3D11.h"
-#endif
-
-#ifdef XP_MACOSX
-#  include "MacIOSurfaceImage.h"
-#endif
-
-#if defined(OS_WIN)
-#  include <windowsx.h>
-#  include "gfxWindowsPlatform.h"
-#  include "nsClassHashtable.h"
-#  include "nsHashKeys.h"
-#  include "nsIWidget.h"
-#  include "nsPluginNativeWindow.h"
-#  include "PluginQuirks.h"
-#  include "mozilla/layers/CompositorBridgeChild.h"
-#  include "GPUVideoImage.h"
-#  include "mozilla/layers/SynchronousTask.h"
-extern const wchar_t* kFlashFullscreenClass;
-#elif defined(MOZ_WIDGET_GTK)
-#  include "mozilla/dom/ContentChild.h"
-#  include <gdk/gdk.h>
-#elif defined(XP_MACOSX)
-#  include <ApplicationServices/ApplicationServices.h>
-#endif  // defined(XP_MACOSX)
-
-using namespace mozilla::plugins;
-using namespace mozilla::layers;
-using namespace mozilla::gl;
-
-void StreamNotifyParent::ActorDestroy(ActorDestroyReason aWhy) {
-  // Implement me! Bug 1005162
-}
-
-mozilla::ipc::IPCResult StreamNotifyParent::RecvRedirectNotifyResponse(
-    const bool& allow) {
-  PluginInstanceParent* instance =
-      static_cast<PluginInstanceParent*>(Manager());
-  instance->mNPNIface->urlredirectresponse(instance->mNPP, this,
-                                           static_cast<NPBool>(allow));
-  return IPC_OK();
-}
-
-#if defined(XP_WIN)
-namespace mozilla {
-namespace plugins {
-/**
- * e10s specific, used in cross referencing hwnds with plugin instances so we
- * can access methods here from PluginWidgetChild.
- */
-static nsClassHashtable<nsVoidPtrHashKey, PluginInstanceParent>*
-    sPluginInstanceList;
-
-// static
-PluginInstanceParent* PluginInstanceParent::LookupPluginInstanceByID(
-    uintptr_t aId) {
-  MOZ_ASSERT(NS_IsMainThread());
-  if (sPluginInstanceList) {
-    return sPluginInstanceList->Get((void*)aId);
-  }
-  return nullptr;
-}
-}  // namespace plugins
-}  // namespace mozilla
-#endif
-
-PluginInstanceParent::PluginInstanceParent(PluginModuleParent* parent, NPP npp,
-                                           const nsCString& aMimeType,
-                                           const NPNetscapeFuncs* npniface)
-    : mParent(parent),
-      mNPP(npp),
-      mNPNIface(npniface),
-      mWindowType(NPWindowTypeWindow),
-      mDrawingModel(kDefaultDrawingModel),
-      mLastRecordedDrawingModel(-1),
-      mFrameID(0)
-#if defined(OS_WIN)
-      ,
-      mPluginHWND(nullptr),
-      mChildPluginHWND(nullptr),
-      mChildPluginsParentHWND(nullptr),
-      mPluginWndProc(nullptr)
-#endif  // defined(XP_WIN)
-#if defined(XP_MACOSX)
-      ,
-      mShWidth(0),
-      mShHeight(0),
-      mShColorSpace(nullptr)
-#endif
-{
-#if defined(OS_WIN)
-  if (!sPluginInstanceList) {
-    sPluginInstanceList =
-        new nsClassHashtable<nsVoidPtrHashKey, PluginInstanceParent>();
-  }
-#endif
-}
-
-PluginInstanceParent::~PluginInstanceParent() {
-  if (mNPP) mNPP->pdata = nullptr;
-
-#if defined(OS_WIN)
-  NS_ASSERTION(!(mPluginHWND || mPluginWndProc),
-               "Subclass was not reset correctly before the dtor was reached!");
-#endif
-#if defined(MOZ_WIDGET_COCOA)
-  if (mShWidth != 0 && mShHeight != 0) {
-    DeallocShmem(mShSurface);
-  }
-  if (mShColorSpace) ::CGColorSpaceRelease(mShColorSpace);
-#endif
-}
-
-bool PluginInstanceParent::InitMetadata(const nsACString& aMimeType,
-                                        const nsACString& aSrcAttribute) {
-  if (aSrcAttribute.IsEmpty()) {
-    return false;
-  }
-  // Ensure that the src attribute is absolute
-  RefPtr<nsPluginInstanceOwner> owner = GetOwner();
-  if (!owner) {
-    return false;
-  }
-  return NS_SUCCEEDED(
-      NS_MakeAbsoluteURI(mSrcAttribute, aSrcAttribute, owner->GetBaseURI()));
-}
-
-void PluginInstanceParent::ActorDestroy(ActorDestroyReason why) {
-#if defined(OS_WIN)
-  if (why == AbnormalShutdown) {
-    // If the plugin process crashes, this is the only
-    // chance we get to destroy resources.
-    UnsubclassPluginWindow();
-  }
-#endif
-  if (mFrontSurface) {
-    mFrontSurface = nullptr;
-    if (mImageContainer) {
-      mImageContainer->ClearAllImages();
-    }
-#ifdef MOZ_X11
-    FinishX(DefaultXDisplay());
-#endif
-  }
-  if (IsUsingDirectDrawing() && mImageContainer) {
-    mImageContainer->ClearAllImages();
-  }
-}
-
-NPError PluginInstanceParent::Destroy() {
-  NPError retval;
-  if (!CallNPP_Destroy(&retval)) {
-    retval = NPERR_GENERIC_ERROR;
-  }
-
-#if defined(OS_WIN)
-  UnsubclassPluginWindow();
-#endif
-
-  return retval;
-}
-
-bool PluginInstanceParent::IsUsingDirectDrawing() {
-  return IsDrawingModelDirect(mDrawingModel);
-}
-
-PBrowserStreamParent* PluginInstanceParent::AllocPBrowserStreamParent(
-    const nsCString& url, const uint32_t& length, const uint32_t& lastmodified,
-    PStreamNotifyParent* notifyData, const nsCString& headers) {
-  MOZ_CRASH("Not reachable");
-  return nullptr;
-}
-
-bool PluginInstanceParent::DeallocPBrowserStreamParent(
-    PBrowserStreamParent* stream) {
-  delete stream;
-  return true;
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceParent::AnswerNPN_GetValue_NPNVnetscapeWindow(
-    NativeWindowHandle* value, NPError* result) {
-#ifdef XP_WIN
-  HWND id;
-#elif defined(MOZ_X11)
-  XID id;
-#elif defined(XP_DARWIN)
-  intptr_t id;
-#elif defined(ANDROID) || defined(MOZ_WAYLAND)
-  // TODO: Need impl
-  int id;
-#else
-#  warning Implement me
-#endif
-
-  *result = mNPNIface->getvalue(mNPP, NPNVnetscapeWindow, &id);
-  *value = id;
-  return IPC_OK();
-}
-
-bool PluginInstanceParent::InternalGetValueForNPObject(
-    NPNVariable aVariable, PPluginScriptableObjectParent** aValue,
-    NPError* aResult) {
-  NPObject* npobject;
-  NPError result = mNPNIface->getvalue(mNPP, aVariable, (void*)&npobject);
-  if (result == NPERR_NO_ERROR) {
-    NS_ASSERTION(npobject, "Shouldn't return null and NPERR_NO_ERROR!");
-
-    PluginScriptableObjectParent* actor = GetActorForNPObject(npobject);
-    mNPNIface->releaseobject(npobject);
-    if (actor) {
-      *aValue = actor;
-      *aResult = NPERR_NO_ERROR;
-      return true;
-    }
-
-    NS_ERROR("Failed to get actor!");
-    result = NPERR_GENERIC_ERROR;
-  }
-
-  *aValue = nullptr;
-  *aResult = result;
-  return true;
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceParent::AnswerNPN_GetValue_NPNVWindowNPObject(
-    PPluginScriptableObjectParent** aValue, NPError* aResult) {
-  if (!InternalGetValueForNPObject(NPNVWindowNPObject, aValue, aResult)) {
-    return IPC_FAIL_NO_REASON(this);
-  }
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceParent::AnswerNPN_GetValue_NPNVPluginElementNPObject(
-    PPluginScriptableObjectParent** aValue, NPError* aResult) {
-  if (!InternalGetValueForNPObject(NPNVPluginElementNPObject, aValue,
-                                   aResult)) {
-    return IPC_FAIL_NO_REASON(this);
-  }
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceParent::AnswerNPN_GetValue_NPNVprivateModeBool(bool* value,
-                                                             NPError* result) {
-  NPBool v;
-  *result = mNPNIface->getvalue(mNPP, NPNVprivateModeBool, &v);
-  *value = v;
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceParent::AnswerNPN_GetValue_DrawingModelSupport(
-    const NPNVariable& model, bool* value) {
-  *value = false;
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceParent::AnswerNPN_GetValue_NPNVdocumentOrigin(nsCString* value,
-                                                            NPError* result) {
-  void* v = nullptr;
-  *result = mNPNIface->getvalue(mNPP, NPNVdocumentOrigin, &v);
-  if (*result == NPERR_NO_ERROR && v) {
-    value->Adopt(static_cast<char*>(v));
-  }
-  return IPC_OK();
-}
-
-static inline bool AllowDirectBitmapSurfaceDrawing() {
-  if (!mozilla::StaticPrefs::dom_ipc_plugins_asyncdrawing_enabled()) {
-    return false;
-  }
-  return gfxPlatform::GetPlatform()->SupportsPluginDirectBitmapDrawing();
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceParent::AnswerNPN_GetValue_SupportsAsyncBitmapSurface(
-    bool* value) {
-  *value = AllowDirectBitmapSurfaceDrawing();
-  return IPC_OK();
-}
-
-/* static */
-bool PluginInstanceParent::SupportsPluginDirectDXGISurfaceDrawing() {
-  bool value = false;
-#if defined(XP_WIN)
-  // When WebRender does not use ANGLE, DXGISurface could not be used.
-  bool useAsyncDXGISurface =
-      StaticPrefs::dom_ipc_plugins_allow_dxgi_surface() &&
-      !(gfx::gfxVars::UseWebRender() && !gfx::gfxVars::UseWebRenderANGLE());
-  if (useAsyncDXGISurface) {
-    auto cbc = CompositorBridgeChild::Get();
-    if (cbc) {
-      cbc->SendSupportsAsyncDXGISurface(&value);
-    }
-  }
-#endif
-  return value;
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceParent::AnswerNPN_GetValue_PreferredDXGIAdapter(
-    DxgiAdapterDesc* aOutDesc) {
-  PodZero(aOutDesc);
-#if defined(XP_WIN)
-  auto cbc = CompositorBridgeChild::Get();
-  if (cbc) {
-    cbc->SendPreferredDXGIAdapter(aOutDesc);
-  }
-#endif
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceParent::AnswerNPN_SetValue_NPPVpluginWindow(const bool& windowed,
-                                                          NPError* result) {
-  // Yes, we are passing a boolean as a void*.  We have to cast to intptr_t
-  // first to avoid gcc warnings about casting to a pointer from a
-  // non-pointer-sized integer.
-  *result = mNPNIface->setvalue(mNPP, NPPVpluginWindowBool,
-                                (void*)(intptr_t)windowed);
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceParent::AnswerNPN_SetValue_NPPVpluginTransparent(
-    const bool& transparent, NPError* result) {
-  *result = mNPNIface->setvalue(mNPP, NPPVpluginTransparentBool,
-                                (void*)(intptr_t)transparent);
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceParent::AnswerNPN_SetValue_NPPVpluginUsesDOMForCursor(
-    const bool& useDOMForCursor, NPError* result) {
-  *result = mNPNIface->setvalue(mNPP, NPPVpluginUsesDOMForCursorBool,
-                                (void*)(intptr_t)useDOMForCursor);
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceParent::AnswerNPN_SetValue_NPPVpluginDrawingModel(
-    const int& drawingModel, NPError* result) {
-  bool allowed = false;
-
-  switch (drawingModel) {
-#if defined(XP_MACOSX)
-    case NPDrawingModelCoreAnimation:
-    case NPDrawingModelInvalidatingCoreAnimation:
-    case NPDrawingModelOpenGL:
-    case NPDrawingModelCoreGraphics:
-      allowed = true;
-      break;
-#elif defined(XP_WIN)
-    case NPDrawingModelSyncWin:
-      allowed = true;
-      break;
-    case NPDrawingModelAsyncWindowsDXGISurface:
-      allowed = SupportsPluginDirectDXGISurfaceDrawing();
-      break;
-#elif defined(MOZ_X11)
-    case NPDrawingModelSyncX:
-      allowed = true;
-      break;
-#endif
-    case NPDrawingModelAsyncBitmapSurface:
-      allowed = AllowDirectBitmapSurfaceDrawing();
-      break;
-    default:
-      allowed = false;
-      break;
-  }
-
-  if (!allowed) {
-    *result = NPERR_GENERIC_ERROR;
-    return IPC_OK();
-  }
-
-  mDrawingModel = drawingModel;
-
-  int requestModel = drawingModel;
-
-#ifdef XP_MACOSX
-  if (drawingModel == NPDrawingModelCoreAnimation ||
-      drawingModel == NPDrawingModelInvalidatingCoreAnimation) {
-    // We need to request CoreGraphics otherwise
-    // the nsPluginFrame will try to draw a CALayer
-    // that can not be shared across process.
-    requestModel = NPDrawingModelCoreGraphics;
-  }
-#endif
-
-  *result = mNPNIface->setvalue(mNPP, NPPVpluginDrawingModel,
-                                (void*)(intptr_t)requestModel);
-
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceParent::AnswerNPN_SetValue_NPPVpluginEventModel(
-    const int& eventModel, NPError* result) {
-#ifdef XP_MACOSX
-  *result = mNPNIface->setvalue(mNPP, NPPVpluginEventModel,
-                                (void*)(intptr_t)eventModel);
-  return IPC_OK();
-#else
-  *result = NPERR_GENERIC_ERROR;
-  return IPC_OK();
-#endif
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceParent::AnswerNPN_SetValue_NPPVpluginIsPlayingAudio(
-    const bool& isAudioPlaying, NPError* result) {
-  *result = mNPNIface->setvalue(mNPP, NPPVpluginIsPlayingAudio,
-                                (void*)(intptr_t)isAudioPlaying);
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginInstanceParent::AnswerNPN_GetURL(
-    const nsCString& url, const nsCString& target, NPError* result) {
-  *result = mNPNIface->geturl(mNPP, NullableStringGet(url),
-                              NullableStringGet(target));
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginInstanceParent::AnswerNPN_PostURL(
-    const nsCString& url, const nsCString& target, const nsCString& buffer,
-    const bool& file, NPError* result) {
-  *result = mNPNIface->posturl(mNPP, url.get(), NullableStringGet(target),
-                               buffer.Length(), buffer.get(), file);
-  return IPC_OK();
-}
-
-PStreamNotifyParent* PluginInstanceParent::AllocPStreamNotifyParent(
-    const nsCString& url, const nsCString& target, const bool& post,
-    const nsCString& buffer, const bool& file, NPError* result) {
-  return new StreamNotifyParent();
-}
-
-mozilla::ipc::IPCResult PluginInstanceParent::AnswerPStreamNotifyConstructor(
-    PStreamNotifyParent* actor, const nsCString& url, const nsCString& target,
-    const bool& post, const nsCString& buffer, const bool& file,
-    NPError* result) {
-  bool streamDestroyed = false;
-  static_cast<StreamNotifyParent*>(actor)->SetDestructionFlag(&streamDestroyed);
-
-  if (!post) {
-    *result = mNPNIface->geturlnotify(mNPP, NullableStringGet(url),
-                                      NullableStringGet(target), actor);
-  } else {
-    *result = mNPNIface->posturlnotify(
-        mNPP, NullableStringGet(url), NullableStringGet(target),
-        buffer.Length(), NullableStringGet(buffer), file, actor);
-  }
-
-  if (streamDestroyed) {
-    // If the stream was destroyed, we must return an error code in the
-    // constructor.
-    *result = NPERR_GENERIC_ERROR;
-  } else {
-    static_cast<StreamNotifyParent*>(actor)->ClearDestructionFlag();
-    if (*result != NPERR_NO_ERROR) {
-      if (!PStreamNotifyParent::Send__delete__(actor, NPERR_GENERIC_ERROR)) {
-        return IPC_FAIL_NO_REASON(this);
-      }
-      return IPC_OK();
-    }
-  }
-
-  return IPC_OK();
-}
-
-bool PluginInstanceParent::DeallocPStreamNotifyParent(
-    PStreamNotifyParent* notifyData) {
-  delete notifyData;
-  return true;
-}
-
-mozilla::ipc::IPCResult PluginInstanceParent::RecvNPN_InvalidateRect(
-    const NPRect& rect) {
-  mNPNIface->invalidaterect(mNPP, const_cast<NPRect*>(&rect));
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginInstanceParent::RecvRevokeCurrentDirectSurface() {
-  ImageContainer* container = GetImageContainer();
-  if (!container) {
-    return IPC_OK();
-  }
-
-  container->ClearAllImages();
-
-  PLUGIN_LOG_DEBUG(("   (RecvRevokeCurrentDirectSurface)"));
-  return IPC_OK();
-}
-
-#if defined(XP_WIN)
-// Uses the ImageBridge to perform IGPUVideoSurfaceManager operations
-// in the GPU process.
-class AsyncPluginSurfaceManager : public IGPUVideoSurfaceManager {
- public:
-  NS_INLINE_DECL_THREADSAFE_REFCOUNTING(AsyncPluginSurfaceManager, override)
-
-  already_AddRefed<gfx::SourceSurface> Readback(
-      const SurfaceDescriptorGPUVideo& aSD) override {
-    SurfaceDescriptorPlugin pluginSD = aSD;
-    if (!InImageBridgeChildThread()) {
-      SynchronousTask task("AsyncPluginSurfaceManager readback sync");
-      RefPtr<gfx::SourceSurface> result;
-      ImageBridgeChild::GetSingleton()->GetThread()->Dispatch(
-          NewRunnableFunction("AsyncPluginSurfaceManager readback",
-                              &DoSyncReadback, &pluginSD, &result, &task));
-      task.Wait();
-      return result.forget();
-    }
-
-    return DoReadback(pluginSD);
-  }
-
-  void DeallocateSurfaceDescriptor(
-      const SurfaceDescriptorGPUVideo& aSD) override {
-    SurfaceDescriptorPlugin pluginSD = aSD;
-    if (!InImageBridgeChildThread()) {
-      ImageBridgeChild::GetSingleton()->GetThread()->Dispatch(
-          NewRunnableFunction("AsyncPluginSurfaceManager dealloc", &DoDealloc,
-                              &pluginSD));
-      return;
-    }
-
-    return DoDealloc(&pluginSD);
-  }
-
-  // Set of display surfaces for which the related plugin surface has been
-  // freed.  They are freed when the AsyncPluginSurfaceManager is told it is
-  // safe.
-  static HashSet<WindowsHandle> sOrphanedDisplaySurfaces;
-
- private:
-  ~AsyncPluginSurfaceManager() {}
-
-  struct SurfaceDescriptorUserData {
-    explicit SurfaceDescriptorUserData(layers::SurfaceDescriptor& aSD)
-        : mSD(aSD) {}
-
-    ~SurfaceDescriptorUserData() {
-      auto ibc = ImageBridgeChild::GetSingleton();
-      if (!ibc) {
-        return;
-      }
-      DestroySurfaceDescriptor(ibc, &mSD);
-    }
-
-    layers::SurfaceDescriptor mSD;
-  };
-
-  static void DeleteSurfaceDescriptorUserData(void* aClosure) {
-    SurfaceDescriptorUserData* sd =
-        reinterpret_cast<SurfaceDescriptorUserData*>(aClosure);
-    delete sd;
-  }
-
-  static already_AddRefed<gfx::SourceSurface> DoReadback(
-      const SurfaceDescriptorPlugin& aSD) {
-    MOZ_ASSERT(InImageBridgeChildThread());
-
-    RefPtr<DataSourceSurface> source;
-    auto ibc = ImageBridgeChild::GetSingleton();
-    if (!ibc) {
-      return nullptr;
-    }
-
-    layers::SurfaceDescriptor dataSD = null_t();
-    ibc->SendReadbackAsyncPluginSurface(aSD, &dataSD);
-    if (!IsSurfaceDescriptorValid(dataSD)) {
-      NS_WARNING("Bad SurfaceDescriptor received in Readback");
-      return nullptr;
-    }
-
-    source = GetSurfaceForDescriptor(dataSD);
-    if (!source) {
-      DestroySurfaceDescriptor(ibc, &dataSD);
-      NS_WARNING("Failed to map SurfaceDescriptor in Readback");
-      return nullptr;
-    }
-
-    static UserDataKey sSurfaceDescriptor;
-    source->AddUserData(&sSurfaceDescriptor,
-                        new SurfaceDescriptorUserData(dataSD),
-                        DeleteSurfaceDescriptorUserData);
-
-    return source.forget();
-  }
-
-  static void DoSyncReadback(const SurfaceDescriptorPlugin* aSD,
-                             RefPtr<gfx::SourceSurface>* aResult,
-                             SynchronousTask* aTask) {
-    AutoCompleteTask act(aTask);
-    *aResult = DoReadback(*aSD);
-  }
-
-  static void DoDealloc(const SurfaceDescriptorPlugin* aSD) {
-    MOZ_ASSERT(InImageBridgeChildThread());
-
-    // If the plugin already Finalized and freed its surface then, since the
-    // compositor is now also done with the display surface, we can free
-    // it too.
-    WindowsHandle handle = aSD->displaySurf().handle();
-    auto surfIt = sOrphanedDisplaySurfaces.lookup(handle);
-    if (!surfIt) {
-      // We wil continue to use the surfaces with future GPUVideoImages.
-      return;
-    }
-
-    sOrphanedDisplaySurfaces.remove(surfIt);
-    auto ibc = ImageBridgeChild::GetSingleton();
-    if (!ibc) {
-      return;
-    }
-    ibc->SendRemoveAsyncPluginSurface(*aSD, true);
-  }
-};
-
-/* static */ HashSet<WindowsHandle>
-    AsyncPluginSurfaceManager::sOrphanedDisplaySurfaces;
-
-void InitDXGISurface(const gfx::SurfaceFormat& aFormat,
-                     const gfx::IntSize& aSize,
-                     SurfaceDescriptorPlugin* aSDPlugin,
-                     SynchronousTask* aTask) {
-  MOZ_ASSERT(InImageBridgeChildThread());
-
-  AutoCompleteTask act(aTask);
-  auto ibc = ImageBridgeChild::GetSingleton();
-  if (!ibc) {
-    return;
-  }
-
-  layers::SurfaceDescriptorPlugin sd;
-  if (!ibc->SendMakeAsyncPluginSurfaces(aFormat, aSize, &sd)) {
-    return;
-  }
-  *aSDPlugin = sd;
-}
-
-void FinalizeDXGISurface(const SurfaceDescriptorPlugin& aSD) {
-  MOZ_ASSERT(InImageBridgeChildThread());
-
-  Unused << AsyncPluginSurfaceManager::sOrphanedDisplaySurfaces.put(
-      aSD.displaySurf().handle());
-
-  auto ibc = ImageBridgeChild::GetSingleton();
-  if (!ibc) {
-    return;
-  }
-  ibc->SendRemoveAsyncPluginSurface(aSD, false);
-}
-
-void CopyDXGISurface(const SurfaceDescriptorPlugin& aSD,
-                     SynchronousTask* aTask) {
-  MOZ_ASSERT(InImageBridgeChildThread());
-
-  AutoCompleteTask act(aTask);
-  auto ibc = ImageBridgeChild::GetSingleton();
-  if (!ibc) {
-    return;
-  }
-  ibc->SendUpdateAsyncPluginSurface(aSD);
-}
-
-#endif  //  defined(XP_WIN)
-
-mozilla::ipc::IPCResult PluginInstanceParent::RecvInitDXGISurface(
-    const gfx::SurfaceFormat& format, const gfx::IntSize& size,
-    WindowsHandle* outHandle, NPError* outError) {
-  *outHandle = 0;
-  *outError = NPERR_GENERIC_ERROR;
-
-#if defined(XP_WIN)
-  MOZ_ASSERT(NS_IsMainThread());
-  if (format != SurfaceFormat::B8G8R8A8 && format != SurfaceFormat::B8G8R8X8) {
-    *outError = NPERR_INVALID_PARAM;
-    return IPC_OK();
-  }
-  if (size.width <= 0 || size.height <= 0) {
-    *outError = NPERR_INVALID_PARAM;
-    return IPC_OK();
-  }
-
-  if (!ImageBridgeChild::GetSingleton()) {
-    return IPC_OK();
-  }
-
-  // Ask the ImageBridge thread to generate two SurfaceDescriptorPlugins --
-  // one for the GPU process to display and one for the Plugin process to
-  // render to.
-  SurfaceDescriptorPlugin sd;
-  SynchronousTask task("SendMakeAsyncPluginSurfaces sync");
-  ImageBridgeChild::GetSingleton()->GetThread()->Dispatch(
-      NewRunnableFunction("SendingMakeAsyncPluginSurfaces", &InitDXGISurface,
-                          format, size, &sd, &task));
-  task.Wait();
-
-  if (!sd.id()) {
-    NS_WARNING("SendMakeAsyncPluginSurfaces failed");
-    return IPC_OK();
-  }
-
-  WindowsHandle pluginSurfHandle = sd.pluginSurf().handle();
-  bool ok = mAsyncSurfaceMap.put(pluginSurfHandle, AsyncSurfaceInfo{sd, size});
-  if (!ok) {
-    return IPC_OK();
-  }
-
-  *outHandle = pluginSurfHandle;
-  *outError = NPERR_NO_ERROR;
-#endif
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginInstanceParent::RecvFinalizeDXGISurface(
-    const WindowsHandle& pluginSurfHandle) {
-#if defined(XP_WIN)
-  MOZ_ASSERT(NS_IsMainThread());
-
-  if (!ImageBridgeChild::GetSingleton()) {
-    return IPC_OK();
-  }
-
-  auto asiIt = mAsyncSurfaceMap.lookup(pluginSurfHandle);
-  if (!asiIt) {
-    NS_WARNING("Plugin surface did not exist to finalize");
-    return IPC_OK();
-  }
-
-  AsyncSurfaceInfo& asi = asiIt->value();
-
-  // Release the plugin surface but keep the display surface since it may
-  // still be displayed.  Also let the display surface know that it should
-  // not receive further requests to copy from the plugin surface.
-  ImageBridgeChild::GetSingleton()->GetThread()->Dispatch(NewRunnableFunction(
-      "SendingRemoveAsyncPluginSurface", &FinalizeDXGISurface, asi.mSD));
-
-  mAsyncSurfaceMap.remove(asiIt);
-#endif
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginInstanceParent::RecvShowDirectBitmap(
-    Shmem&& buffer, const SurfaceFormat& format, const uint32_t& stride,
-    const IntSize& size, const IntRect& dirty) {
-  // Validate format.
-  if (format != SurfaceFormat::B8G8R8A8 && format != SurfaceFormat::B8G8R8X8) {
-    MOZ_ASSERT_UNREACHABLE("bad format type");
-    return IPC_FAIL_NO_REASON(this);
-  }
-  if (size.width <= 0 || size.height <= 0) {
-    MOZ_ASSERT_UNREACHABLE("bad image size");
-    return IPC_FAIL_NO_REASON(this);
-  }
-  if (mDrawingModel != NPDrawingModelAsyncBitmapSurface) {
-    MOZ_ASSERT_UNREACHABLE("plugin did not set a bitmap drawing model");
-    return IPC_FAIL_NO_REASON(this);
-  }
-
-  // Validate buffer and size.
-  CheckedInt<uint32_t> nbytes =
-      CheckedInt<uint32_t>(uint32_t(size.height)) * stride;
-  if (!nbytes.isValid() || nbytes.value() != buffer.Size<uint8_t>()) {
-    MOZ_ASSERT_UNREACHABLE("bad shmem size");
-    return IPC_FAIL_NO_REASON(this);
-  }
-
-  ImageContainer* container = GetImageContainer();
-  if (!container) {
-    return IPC_FAIL_NO_REASON(this);
-  }
-
-  RefPtr<gfx::DataSourceSurface> source =
-      gfx::Factory::CreateWrappingDataSourceSurface(buffer.get<uint8_t>(),
-                                                    stride, size, format);
-  if (!source) {
-    return IPC_FAIL_NO_REASON(this);
-  }
-
-  // Allocate a texture for the compositor.
-  RefPtr<TextureClientRecycleAllocator> allocator =
-      mParent->EnsureTextureAllocatorForDirectBitmap();
-  RefPtr<TextureClient> texture = allocator->CreateOrRecycle(
-      format, size, BackendSelector::Content, TextureFlags::NO_FLAGS,
-      TextureAllocationFlags(ALLOC_FOR_OUT_OF_BAND_CONTENT |
-                             ALLOC_UPDATE_FROM_SURFACE));
-  if (!texture) {
-    NS_WARNING("Could not allocate a TextureClient for plugin!");
-    return IPC_FAIL_NO_REASON(this);
-  }
-
-  // Upload the plugin buffer.
-  {
-    TextureClientAutoLock autoLock(texture, OpenMode::OPEN_WRITE_ONLY);
-    if (!autoLock.Succeeded()) {
-      return IPC_FAIL_NO_REASON(this);
-    }
-    texture->UpdateFromSurface(source);
-  }
-
-  // Wrap the texture in an image and ship it off.
-  RefPtr<TextureWrapperImage> image =
-      new TextureWrapperImage(texture, gfx::IntRect(gfx::IntPoint(0, 0), size));
-  SetCurrentImage(image);
-
-  PLUGIN_LOG_DEBUG(
-      ("   (RecvShowDirectBitmap received shmem=%p stride=%d size=%s dirty=%s)",
-       buffer.get<unsigned char>(), stride, ToString(size).c_str(),
-       ToString(dirty).c_str()));
-  return IPC_OK();
-}
-
-void PluginInstanceParent::SetCurrentImage(Image* aImage) {
-  MOZ_ASSERT(IsUsingDirectDrawing());
-  ImageContainer::NonOwningImage holder(aImage);
-  holder.mFrameID = ++mFrameID;
-
-  AutoTArray<ImageContainer::NonOwningImage, 1> imageList;
-  imageList.AppendElement(holder);
-  mImageContainer->SetCurrentImages(imageList);
-
-  // Invalidate our area in the page so the image gets flushed.
-  gfx::IntRect rect = aImage->GetPictureRect();
-  NPRect nprect = {uint16_t(rect.x), uint16_t(rect.y), uint16_t(rect.width),
-                   uint16_t(rect.height)};
-  RecvNPN_InvalidateRect(nprect);
-
-  RecordDrawingModel();
-}
-
-mozilla::ipc::IPCResult PluginInstanceParent::RecvShowDirectDXGISurface(
-    const WindowsHandle& pluginSurfHandle, const gfx::IntRect& dirty) {
-#if defined(XP_WIN)
-  MOZ_ASSERT(NS_IsMainThread());
-
-  if (!ImageBridgeChild::GetSingleton()) {
-    return IPC_OK();
-  }
-
-  auto asiIt = mAsyncSurfaceMap.lookup(pluginSurfHandle);
-  if (!asiIt) {
-    NS_WARNING("Plugin surface did not exist to finalize");
-    return IPC_OK();
-  }
-
-  AsyncSurfaceInfo& asi = asiIt->value();
-
-  // Tell the ImageBridge to copy from the plugin surface to the display surface
-  SynchronousTask task("SendUpdateAsyncPluginSurface sync");
-  ImageBridgeChild::GetSingleton()->GetThread()->Dispatch(NewRunnableFunction(
-      "SendingUpdateAsyncPluginSurface", &CopyDXGISurface, asi.mSD, &task));
-  task.Wait();
-
-  // Make sure we have an ImageContainer for SetCurrentImage.
-  ImageContainer* container = GetImageContainer();
-  if (!container) {
-    return IPC_OK();
-  }
-
-  SetCurrentImage(
-      new GPUVideoImage(new AsyncPluginSurfaceManager(), asi.mSD, asi.mSize));
-
-  PLUGIN_LOG_DEBUG(("   (RecvShowDirectDXGISurface received handle=%p rect=%s)",
-                    reinterpret_cast<void*>(pluginSurfHandle),
-                    ToString(dirty).c_str()));
-#endif
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginInstanceParent::RecvShow(
-    const NPRect& updatedRect, const SurfaceDescriptor& newSurface,
-    SurfaceDescriptor* prevSurface) {
-  PLUGIN_LOG_DEBUG(("[InstanceParent][%p] RecvShow for <x=%d,y=%d, w=%d,h=%d>",
-                    this, updatedRect.left, updatedRect.top,
-                    updatedRect.right - updatedRect.left,
-                    updatedRect.bottom - updatedRect.top));
-
-  MOZ_ASSERT(!IsUsingDirectDrawing());
-
-  // XXXjwatt rewrite to use Moz2D
-  RefPtr<gfxASurface> surface;
-  if (newSurface.type() == SurfaceDescriptor::TShmem) {
-    if (!newSurface.get_Shmem().IsReadable()) {
-      NS_WARNING("back surface not readable");
-      return IPC_FAIL_NO_REASON(this);
-    }
-    surface = gfxSharedImageSurface::Open(newSurface.get_Shmem());
-  }
-#ifdef XP_MACOSX
-  else if (newSurface.type() == SurfaceDescriptor::TIOSurfaceDescriptor) {
-    IOSurfaceDescriptor iodesc = newSurface.get_IOSurfaceDescriptor();
-
-    RefPtr<MacIOSurface> newIOSurface = MacIOSurface::LookupSurface(
-        iodesc.surfaceId(), iodesc.contentsScaleFactor());
-
-    if (!newIOSurface) {
-      NS_WARNING("Got bad IOSurfaceDescriptor in RecvShow");
-      return IPC_FAIL_NO_REASON(this);
-    }
-
-    if (mFrontIOSurface)
-      *prevSurface =
-          IOSurfaceDescriptor(mFrontIOSurface->GetIOSurfaceID(),
-                              mFrontIOSurface->GetContentsScaleFactor());
-    else
-      *prevSurface = null_t();
-
-    mFrontIOSurface = newIOSurface;
-
-    RecvNPN_InvalidateRect(updatedRect);
-
-    PLUGIN_LOG_DEBUG(
-        ("   (RecvShow invalidated for surface %p)", mFrontSurface.get()));
-
-    return IPC_OK();
-  }
-#endif
-#ifdef MOZ_X11
-  else if (newSurface.type() == SurfaceDescriptor::TSurfaceDescriptorX11) {
-    surface = newSurface.get_SurfaceDescriptorX11().OpenForeign();
-  }
-#endif
-
-  if (mFrontSurface) {
-    // This is the "old front buffer" we're about to hand back to
-    // the plugin.  We might still have drawing operations
-    // referencing it.
-#ifdef MOZ_X11
-    if (mFrontSurface->GetType() == gfxSurfaceType::Xlib) {
-      // Finish with the surface and XSync here to ensure the server has
-      // finished operations on the surface before the plugin starts
-      // scribbling on it again, or worse, destroys it.
-      mFrontSurface->Finish();
-      FinishX(DefaultXDisplay());
-    } else
-#endif
-    {
-      mFrontSurface->Flush();
-    }
-  }
-
-  if (mFrontSurface && gfxSharedImageSurface::IsSharedImage(mFrontSurface))
-    *prevSurface = std::move(
-        static_cast<gfxSharedImageSurface*>(mFrontSurface.get())->GetShmem());
-  else
-    *prevSurface = null_t();
-
-  if (surface) {
-    // Notify the cairo backend that this surface has changed behind
-    // its back.
-    gfxRect ur(updatedRect.left, updatedRect.top,
-               updatedRect.right - updatedRect.left,
-               updatedRect.bottom - updatedRect.top);
-    surface->MarkDirty(ur);
-
-    bool isPlugin = true;
-    RefPtr<gfx::SourceSurface> sourceSurface =
-        gfxPlatform::GetSourceSurfaceForSurface(nullptr, surface, isPlugin);
-    RefPtr<SourceSurfaceImage> image =
-        new SourceSurfaceImage(surface->GetSize(), sourceSurface);
-
-    AutoTArray<ImageContainer::NonOwningImage, 1> imageList;
-    imageList.AppendElement(ImageContainer::NonOwningImage(image));
-
-    ImageContainer* container = GetImageContainer();
-    container->SetCurrentImages(imageList);
-  } else if (mImageContainer) {
-    mImageContainer->ClearAllImages();
-  }
-
-  mFrontSurface = surface;
-  RecvNPN_InvalidateRect(updatedRect);
-
-  PLUGIN_LOG_DEBUG(
-      ("   (RecvShow invalidated for surface %p)", mFrontSurface.get()));
-
-  RecordDrawingModel();
-  return IPC_OK();
-}
-
-nsresult PluginInstanceParent::AsyncSetWindow(NPWindow* aWindow) {
-  NPRemoteWindow window;
-  mWindowType = aWindow->type;
-  window.window = reinterpret_cast<uint64_t>(aWindow->window);
-  window.x = aWindow->x;
-  window.y = aWindow->y;
-  window.width = aWindow->width;
-  window.height = aWindow->height;
-  window.clipRect = aWindow->clipRect;
-  window.type = aWindow->type;
-#if defined(XP_MACOSX) || defined(XP_WIN)
-  double scaleFactor = 1.0;
-  mNPNIface->getvalue(mNPP, NPNVcontentsScaleFactor, &scaleFactor);
-  window.contentsScaleFactor = scaleFactor;
-#endif
-
-#if defined(OS_WIN)
-  MaybeCreateChildPopupSurrogate();
-#endif
-
-#if defined(OS_WIN)
-  // Windows async surfaces must be Win32.  In particular, it is incompatible
-  // with in-memory surface types.
-  gfxSurfaceType surfType = gfxSurfaceType::Win32;
-#else
-  gfxSurfaceType surfType =
-      gfxPlatform::GetPlatform()->ScreenReferenceSurface()->GetType();
-#endif
-
-  if (surfType == (gfxSurfaceType)-1) {
-    return NS_ERROR_FAILURE;
-  }
-
-  if (!SendAsyncSetWindow(surfType, window)) return NS_ERROR_FAILURE;
-
-  return NS_OK;
-}
-
-nsresult PluginInstanceParent::GetImageContainer(ImageContainer** aContainer) {
-  if (IsUsingDirectDrawing()) {
-    // Use the image container created by the most recent direct surface
-    // call, if any. We don't create one if no surfaces were presented
-    // yet.
-    ImageContainer* container = mImageContainer;
-    NS_IF_ADDREF(container);
-    *aContainer = container;
-    return NS_OK;
-  }
-
-#ifdef XP_MACOSX
-  MacIOSurface* ioSurface = nullptr;
-
-  if (mFrontIOSurface) {
-    ioSurface = mFrontIOSurface;
-  } else if (mIOSurface) {
-    ioSurface = mIOSurface;
-  }
-
-  if (!mFrontSurface && !ioSurface)
-#else
-  if (!mFrontSurface)
-#endif
-    return NS_ERROR_NOT_AVAILABLE;
-
-  ImageContainer* container = GetImageContainer();
-
-  if (!container) {
-    return NS_ERROR_FAILURE;
-  }
-
-#ifdef XP_MACOSX
-  if (ioSurface) {
-    RefPtr<Image> image = new MacIOSurfaceImage(ioSurface);
-    container->SetCurrentImageInTransaction(image);
-
-    NS_IF_ADDREF(container);
-    *aContainer = container;
-    return NS_OK;
-  }
-#endif
-
-  NS_IF_ADDREF(container);
-  *aContainer = container;
-  return NS_OK;
-}
-
-nsresult PluginInstanceParent::GetImageSize(nsIntSize* aSize) {
-  if (IsUsingDirectDrawing()) {
-    if (!mImageContainer) {
-      return NS_ERROR_NOT_AVAILABLE;
-    }
-    *aSize = mImageContainer->GetCurrentSize();
-    return NS_OK;
-  }
-
-  if (mFrontSurface) {
-    mozilla::gfx::IntSize size = mFrontSurface->GetSize();
-    *aSize = nsIntSize(size.width, size.height);
-    return NS_OK;
-  }
-
-#ifdef XP_MACOSX
-  if (mFrontIOSurface) {
-    *aSize =
-        nsIntSize(mFrontIOSurface->GetWidth(), mFrontIOSurface->GetHeight());
-    return NS_OK;
-  } else if (mIOSurface) {
-    *aSize = nsIntSize(mIOSurface->GetWidth(), mIOSurface->GetHeight());
-    return NS_OK;
-  }
-#endif
-
-  return NS_ERROR_NOT_AVAILABLE;
-}
-
-void PluginInstanceParent::DidComposite() {
-  if (!IsUsingDirectDrawing()) {
-    return;
-  }
-  Unused << SendNPP_DidComposite();
-}
-
-#ifdef XP_MACOSX
-nsresult PluginInstanceParent::IsRemoteDrawingCoreAnimation(bool* aDrawing) {
-  *aDrawing = (NPDrawingModelCoreAnimation == (NPDrawingModel)mDrawingModel ||
-               NPDrawingModelInvalidatingCoreAnimation ==
-                   (NPDrawingModel)mDrawingModel);
-  return NS_OK;
-}
-#endif
-#if defined(XP_MACOSX) || defined(XP_WIN)
-nsresult PluginInstanceParent::ContentsScaleFactorChanged(
-    double aContentsScaleFactor) {
-  bool rv = SendContentsScaleFactorChanged(aContentsScaleFactor);
-  return rv ? NS_OK : NS_ERROR_FAILURE;
-}
-#endif  // #ifdef XP_MACOSX
-
-nsresult PluginInstanceParent::SetBackgroundUnknown() {
-  PLUGIN_LOG_DEBUG(("[InstanceParent][%p] SetBackgroundUnknown", this));
-
-  if (mBackground) {
-    DestroyBackground();
-    MOZ_ASSERT(!mBackground, "Background not destroyed");
-  }
-
-  return NS_OK;
-}
-
-nsresult PluginInstanceParent::BeginUpdateBackground(const nsIntRect& aRect,
-                                                     DrawTarget** aDrawTarget) {
-  PLUGIN_LOG_DEBUG(
-      ("[InstanceParent][%p] BeginUpdateBackground for <x=%d,y=%d, w=%d,h=%d>",
-       this, aRect.x, aRect.y, aRect.width, aRect.height));
-
-  if (!mBackground) {
-    // XXX if we failed to create a background surface on one
-    // update, there's no guarantee that later updates will be for
-    // the entire background area until successful.  We might want
-    // to fix that eventually.
-    MOZ_ASSERT(aRect.TopLeft() == nsIntPoint(0, 0),
-               "Expecting rect for whole frame");
-    if (!CreateBackground(aRect.Size())) {
-      *aDrawTarget = nullptr;
-      return NS_OK;
-    }
-  }
-
-  mozilla::gfx::IntSize sz = mBackground->GetSize();
-#ifdef DEBUG
-  MOZ_ASSERT(nsIntRect(0, 0, sz.width, sz.height).Contains(aRect),
-             "Update outside of background area");
-#endif
-
-  RefPtr<gfx::DrawTarget> dt = gfxPlatform::CreateDrawTargetForSurface(
-      mBackground, gfx::IntSize(sz.width, sz.height));
-  dt.forget(aDrawTarget);
-
-  return NS_OK;
-}
-
-nsresult PluginInstanceParent::EndUpdateBackground(const nsIntRect& aRect) {
-  PLUGIN_LOG_DEBUG(
-      ("[InstanceParent][%p] EndUpdateBackground for <x=%d,y=%d, w=%d,h=%d>",
-       this, aRect.x, aRect.y, aRect.width, aRect.height));
-
-#ifdef MOZ_X11
-  // Have to XSync here to avoid the plugin trying to draw with this
-  // surface racing with its creation in the X server.  We also want
-  // to avoid the plugin drawing onto stale pixels, then handing us
-  // back a front surface from those pixels that we might
-  // recomposite for "a while" until the next update.  This XSync
-  // still doesn't guarantee that the plugin draws onto a consistent
-  // view of its background, but it does mean that the plugin is
-  // drawing onto pixels no older than those in the latest
-  // EndUpdateBackground().
-  XSync(DefaultXDisplay(), X11False);
-#endif
-
-  Unused << SendUpdateBackground(BackgroundDescriptor(), aRect);
-
-  return NS_OK;
-}
-
-#if defined(XP_WIN)
-nsresult PluginInstanceParent::SetScrollCaptureId(uint64_t aScrollCaptureId) {
-  if (aScrollCaptureId == ImageContainer::sInvalidAsyncContainerId) {
-    return NS_ERROR_FAILURE;
-  }
-
-  mImageContainer = new ImageContainer(CompositableHandle(aScrollCaptureId));
-  return NS_OK;
-}
-
-nsresult PluginInstanceParent::GetScrollCaptureContainer(
-    ImageContainer** aContainer) {
-  if (!aContainer || !mImageContainer) {
-    return NS_ERROR_FAILURE;
-  }
-
-  RefPtr<ImageContainer> container = GetImageContainer();
-  container.forget(aContainer);
-
-  return NS_OK;
-}
-#endif  // XP_WIN
-
-bool PluginInstanceParent::CreateBackground(const nsIntSize& aSize) {
-  MOZ_ASSERT(!mBackground, "Already have a background");
-
-  // XXX refactor me
-
-#if defined(MOZ_X11)
-  Screen* screen = DefaultScreenOfDisplay(DefaultXDisplay());
-  Visual* visual = DefaultVisualOfScreen(screen);
-  mBackground = gfxXlibSurface::Create(
-      screen, visual, mozilla::gfx::IntSize(aSize.width, aSize.height));
-  return !!mBackground;
-
-#elif defined(XP_WIN)
-  // We have chosen to create an unsafe surface in which the plugin
-  // can read from the region while we're writing to it.
-  mBackground = gfxSharedImageSurface::CreateUnsafe(
-      this, mozilla::gfx::IntSize(aSize.width, aSize.height),
-      mozilla::gfx::SurfaceFormat::X8R8G8B8_UINT32);
-  return !!mBackground;
-#else
-  return false;
-#endif
-}
-
-void PluginInstanceParent::DestroyBackground() {
-  if (!mBackground) {
-    return;
-  }
-
-  // Relinquish ownership of |mBackground| to its destroyer
-  PPluginBackgroundDestroyerParent* pbd =
-      new PluginBackgroundDestroyerParent(mBackground);
-  mBackground = nullptr;
-
-  // If this fails, there's no problem: |bd| will be destroyed along
-  // with the old background surface.
-  Unused << SendPPluginBackgroundDestroyerConstructor(pbd);
-}
-
-mozilla::plugins::SurfaceDescriptor
-PluginInstanceParent::BackgroundDescriptor() {
-  MOZ_ASSERT(mBackground, "Need a background here");
-
-  // XXX refactor me
-
-#ifdef MOZ_X11
-  gfxXlibSurface* xsurf = static_cast<gfxXlibSurface*>(mBackground.get());
-  return SurfaceDescriptorX11(xsurf);
-#endif
-
-#ifdef XP_WIN
-  MOZ_ASSERT(gfxSharedImageSurface::IsSharedImage(mBackground),
-             "Expected shared image surface");
-  gfxSharedImageSurface* shmem =
-      static_cast<gfxSharedImageSurface*>(mBackground.get());
-  return mozilla::plugins::SurfaceDescriptor(std::move(shmem->GetShmem()));
-#endif
-
-  // If this is ever used, which it shouldn't be, it will trigger a
-  // hard assertion in IPDL-generated code.
-  return mozilla::plugins::SurfaceDescriptor();
-}
-
-ImageContainer* PluginInstanceParent::GetImageContainer() {
-  if (mImageContainer) {
-    return mImageContainer;
-  }
-
-  if (IsUsingDirectDrawing()) {
-    mImageContainer =
-        LayerManager::CreateImageContainer(ImageContainer::ASYNCHRONOUS);
-  } else {
-    mImageContainer = LayerManager::CreateImageContainer();
-  }
-  return mImageContainer;
-}
-
-PPluginBackgroundDestroyerParent*
-PluginInstanceParent::AllocPPluginBackgroundDestroyerParent() {
-  MOZ_CRASH("'Power-user' ctor is used exclusively");
-  return nullptr;
-}
-
-bool PluginInstanceParent::DeallocPPluginBackgroundDestroyerParent(
-    PPluginBackgroundDestroyerParent* aActor) {
-  delete aActor;
-  return true;
-}
-
-NPError PluginInstanceParent::NPP_SetWindow(const NPWindow* aWindow) {
-  PLUGIN_LOG_DEBUG(("%s (aWindow=%p)", FULLFUNCTION, (void*)aWindow));
-
-  NS_ENSURE_TRUE(aWindow, NPERR_GENERIC_ERROR);
-
-  NPRemoteWindow window;
-  mWindowType = aWindow->type;
-
-#if defined(OS_WIN)
-  // On windowless controls, reset the shared memory surface as needed.
-  if (mWindowType == NPWindowTypeDrawable) {
-    MaybeCreateChildPopupSurrogate();
-  } else {
-    SubclassPluginWindow(reinterpret_cast<HWND>(aWindow->window));
-
-    window.window = reinterpret_cast<uint64_t>(aWindow->window);
-    window.x = aWindow->x;
-    window.y = aWindow->y;
-    window.width = aWindow->width;
-    window.height = aWindow->height;
-    window.type = aWindow->type;
-
-    // On Windows we need to create and set the parent before we set the
-    // window on the plugin, or keyboard interaction will not work.
-    if (!MaybeCreateAndParentChildPluginWindow()) {
-      return NPERR_GENERIC_ERROR;
-    }
-  }
-#else
-  window.window = reinterpret_cast<uint64_t>(aWindow->window);
-  window.x = aWindow->x;
-  window.y = aWindow->y;
-  window.width = aWindow->width;
-  window.height = aWindow->height;
-  window.clipRect = aWindow->clipRect;  // MacOS specific
-  window.type = aWindow->type;
-#endif
-
-#if defined(XP_MACOSX) || defined(XP_WIN)
-  double floatScaleFactor = 1.0;
-  mNPNIface->getvalue(mNPP, NPNVcontentsScaleFactor, &floatScaleFactor);
-  window.contentsScaleFactor = floatScaleFactor;
-#endif
-#if defined(XP_MACOSX)
-  int scaleFactor = ceil(floatScaleFactor);
-  if (mShWidth != window.width * scaleFactor ||
-      mShHeight != window.height * scaleFactor) {
-    if (mDrawingModel == NPDrawingModelCoreAnimation ||
-        mDrawingModel == NPDrawingModelInvalidatingCoreAnimation) {
-      mIOSurface = MacIOSurface::CreateIOSurface(window.width, window.height,
-                                                 floatScaleFactor);
-    } else if (uint32_t(mShWidth * mShHeight) !=
-               window.width * scaleFactor * window.height * scaleFactor) {
-      if (mShWidth != 0 && mShHeight != 0) {
-        DeallocShmem(mShSurface);
-        mShWidth = 0;
-        mShHeight = 0;
-      }
-
-      if (window.width != 0 && window.height != 0) {
-        if (!AllocShmem(
-                window.width * scaleFactor * window.height * 4 * scaleFactor,
-                SharedMemory::TYPE_BASIC, &mShSurface)) {
-          PLUGIN_LOG_DEBUG(("Shared memory could not be allocated."));
-          return NPERR_GENERIC_ERROR;
-        }
-      }
-    }
-    mShWidth = window.width * scaleFactor;
-    mShHeight = window.height * scaleFactor;
-  }
-#endif
-
-#if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
-  const NPSetWindowCallbackStruct* ws_info =
-      static_cast<NPSetWindowCallbackStruct*>(aWindow->ws_info);
-  window.visualID = ws_info->visual ? ws_info->visual->visualid : 0;
-  window.colormap = ws_info->colormap;
-#endif
-
-  if (!CallNPP_SetWindow(window)) {
-    return NPERR_GENERIC_ERROR;
-  }
-
-  RecordDrawingModel();
-  return NPERR_NO_ERROR;
-}
-
-NPError PluginInstanceParent::NPP_GetValue(NPPVariable aVariable,
-                                           void* _retval) {
-  switch (aVariable) {
-    case NPPVpluginWantsAllNetworkStreams: {
-      bool wantsAllStreams;
-      NPError rv;
-
-      if (!CallNPP_GetValue_NPPVpluginWantsAllNetworkStreams(&wantsAllStreams,
-                                                             &rv)) {
-        return NPERR_GENERIC_ERROR;
-      }
-
-      if (NPERR_NO_ERROR != rv) {
-        return rv;
-      }
-
-      (*(NPBool*)_retval) = wantsAllStreams;
-      return NPERR_NO_ERROR;
-    }
-
-    case NPPVpluginScriptableNPObject: {
-      PPluginScriptableObjectParent* actor;
-      NPError rv;
-      if (!CallNPP_GetValue_NPPVpluginScriptableNPObject(&actor, &rv)) {
-        return NPERR_GENERIC_ERROR;
-      }
-
-      if (NPERR_NO_ERROR != rv) {
-        return rv;
-      }
-
-      if (!actor) {
-        NS_ERROR("NPPVpluginScriptableNPObject succeeded but null.");
-        return NPERR_GENERIC_ERROR;
-      }
-
-      const NPNetscapeFuncs* npn = mParent->GetNetscapeFuncs();
-      if (!npn) {
-        NS_WARNING("No netscape functions?!");
-        return NPERR_GENERIC_ERROR;
-      }
-
-      NPObject* object =
-          static_cast<PluginScriptableObjectParent*>(actor)->GetObject(true);
-      NS_ASSERTION(object, "This shouldn't ever be null!");
-
-      (*(NPObject**)_retval) = npn->retainobject(object);
-      return NPERR_NO_ERROR;
-    }
-
-#ifdef MOZ_ACCESSIBILITY_ATK
-    case NPPVpluginNativeAccessibleAtkPlugId: {
-      nsCString plugId;
-      NPError rv;
-      if (!CallNPP_GetValue_NPPVpluginNativeAccessibleAtkPlugId(&plugId, &rv)) {
-        return NPERR_GENERIC_ERROR;
-      }
-
-      if (NPERR_NO_ERROR != rv) {
-        return rv;
-      }
-
-      (*(nsCString*)_retval) = plugId;
-      return NPERR_NO_ERROR;
-    }
-#endif
-
-    default:
-      MOZ_LOG(GetPluginLog(), LogLevel::Warning,
-              ("In PluginInstanceParent::NPP_GetValue: Unhandled NPPVariable "
-               "%i (%s)",
-               (int)aVariable, NPPVariableToString(aVariable)));
-      return NPERR_GENERIC_ERROR;
-  }
-}
-
-NPError PluginInstanceParent::NPP_SetValue(NPNVariable variable, void* value) {
-  NPError result;
-  switch (variable) {
-    case NPNVprivateModeBool:
-      if (!CallNPP_SetValue_NPNVprivateModeBool(*static_cast<NPBool*>(value),
-                                                &result))
-        return NPERR_GENERIC_ERROR;
-
-      return result;
-
-    case NPNVmuteAudioBool:
-      if (!CallNPP_SetValue_NPNVmuteAudioBool(*static_cast<NPBool*>(value),
-                                              &result))
-        return NPERR_GENERIC_ERROR;
-
-      return result;
-
-    case NPNVCSSZoomFactor:
-      if (!CallNPP_SetValue_NPNVCSSZoomFactor(*static_cast<double*>(value),
-                                              &result))
-        return NPERR_GENERIC_ERROR;
-
-      return result;
-
-    default:
-      NS_ERROR("Unhandled NPNVariable in NPP_SetValue");
-      MOZ_LOG(GetPluginLog(), LogLevel::Warning,
-              ("In PluginInstanceParent::NPP_SetValue: Unhandled NPNVariable "
-               "%i (%s)",
-               (int)variable, NPNVariableToString(variable)));
-      return NPERR_GENERIC_ERROR;
-  }
-}
-
-void PluginInstanceParent::NPP_URLRedirectNotify(const char* url,
-                                                 int32_t status,
-                                                 void* notifyData) {
-  if (!notifyData) return;
-
-  PStreamNotifyParent* streamNotify =
-      static_cast<PStreamNotifyParent*>(notifyData);
-  Unused << streamNotify->SendRedirectNotify(NullableString(url), status);
-}
-
-int16_t PluginInstanceParent::NPP_HandleEvent(void* event) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-
-#if defined(XP_MACOSX)
-  NPCocoaEvent* npevent = reinterpret_cast<NPCocoaEvent*>(event);
-#else
-  NPEvent* npevent = reinterpret_cast<NPEvent*>(event);
-#endif
-  NPRemoteEvent npremoteevent;
-  npremoteevent.event = *npevent;
-#if defined(XP_MACOSX) || defined(XP_WIN)
-  double scaleFactor = 1.0;
-  mNPNIface->getvalue(mNPP, NPNVcontentsScaleFactor, &scaleFactor);
-  npremoteevent.contentsScaleFactor = scaleFactor;
-#endif
-  int16_t handled = 0;
-
-#if defined(OS_WIN)
-  if (mWindowType == NPWindowTypeDrawable) {
-    switch (npevent->event) {
-      case WM_KILLFOCUS: {
-        // When the user selects fullscreen mode in Flash video players,
-        // WM_KILLFOCUS will be delayed by deferred event processing:
-        // WM_LBUTTONUP results in a call to CreateWindow within Flash,
-        // which fires WM_KILLFOCUS. Delayed delivery causes Flash to
-        // misinterpret the event, dropping back out of fullscreen. Trap
-        // this event and drop it.
-        // mPluginHWND is always NULL for non-windowed plugins.
-        if (mPluginHWND) {
-          wchar_t szClass[26];
-          HWND hwnd = GetForegroundWindow();
-          if (hwnd && hwnd != mPluginHWND &&
-              GetClassNameW(hwnd, szClass,
-                            sizeof(szClass) / sizeof(char16_t)) &&
-              !wcscmp(szClass, kFlashFullscreenClass)) {
-            return 0;
-          }
-        }
-      } break;
-
-      case WM_WINDOWPOSCHANGED: {
-        // We send this in nsPluginFrame just before painting
-        return SendWindowPosChanged(npremoteevent);
-      }
-
-      case WM_IME_STARTCOMPOSITION:
-      case WM_IME_COMPOSITION:
-      case WM_IME_ENDCOMPOSITION:
-        if (!(mParent->GetQuirks() & QUIRK_WINLESS_HOOK_IME)) {
-          // IME message will be posted on allowed plugins only such as
-          // Flash.  Because if we cannot know that plugin can handle
-          // IME correctly.
-          return 0;
-        }
-        break;
-    }
-  }
-#endif
-
-#if defined(MOZ_X11)
-  switch (npevent->type) {
-    case GraphicsExpose:
-      PLUGIN_LOG_DEBUG(("  schlepping drawable 0x%lx across the pipe\n",
-                        npevent->xgraphicsexpose.drawable));
-      // Make sure the X server has created the Drawable and completes any
-      // drawing before the plugin draws on top.
-      //
-      // XSync() waits for the X server to complete.  Really this parent
-      // process does not need to wait; the child is the process that needs
-      // to wait.  A possibly-slightly-better alternative would be to send
-      // an X event to the child that the child would wait for.
-      FinishX(DefaultXDisplay());
-
-      return CallPaint(npremoteevent, &handled) ? handled : 0;
-
-    case ButtonPress:
-      // Release any active pointer grab so that the plugin X client can
-      // grab the pointer if it wishes.
-      Display* dpy = DefaultXDisplay();
-#  ifdef MOZ_WIDGET_GTK
-      // GDK attempts to (asynchronously) track whether there is an active
-      // grab so ungrab through GDK.
-      //
-      // This call needs to occur in the same process that receives the event in
-      // the first place (chrome process)
-      if (XRE_IsContentProcess()) {
-        dom::ContentChild* cp = dom::ContentChild::GetSingleton();
-        cp->SendUngrabPointer(npevent->xbutton.time);
-      } else {
-        gdk_pointer_ungrab(npevent->xbutton.time);
-      }
-#  else
-      XUngrabPointer(dpy, npevent->xbutton.time);
-#  endif
-      // Wait for the ungrab to complete.
-      XSync(dpy, X11False);
-      break;
-  }
-#endif
-
-#ifdef XP_MACOSX
-  if (npevent->type == NPCocoaEventDrawRect) {
-    if (mDrawingModel == NPDrawingModelCoreAnimation ||
-        mDrawingModel == NPDrawingModelInvalidatingCoreAnimation) {
-      if (!mIOSurface) {
-        NS_ERROR("No IOSurface allocated.");
-        return false;
-      }
-      if (!CallNPP_HandleEvent_IOSurface(
-              npremoteevent, mIOSurface->GetIOSurfaceID(), &handled))
-        return false;  // no good way to handle errors here...
-
-      CGContextRef cgContext = npevent->data.draw.context;
-      if (!mShColorSpace) {
-        mShColorSpace = CreateSystemColorSpace();
-      }
-      if (!mShColorSpace) {
-        PLUGIN_LOG_DEBUG(("Could not allocate ColorSpace."));
-        return false;
-      }
-      if (cgContext) {
-        nsCARenderer::DrawSurfaceToCGContext(
-            cgContext, mIOSurface, mShColorSpace, npevent->data.draw.x,
-            npevent->data.draw.y, npevent->data.draw.width,
-            npevent->data.draw.height);
-      }
-      return true;
-    } else if (mFrontIOSurface) {
-      CGContextRef cgContext = npevent->data.draw.context;
-      if (!mShColorSpace) {
-        mShColorSpace = CreateSystemColorSpace();
-      }
-      if (!mShColorSpace) {
-        PLUGIN_LOG_DEBUG(("Could not allocate ColorSpace."));
-        return false;
-      }
-      if (cgContext) {
-        nsCARenderer::DrawSurfaceToCGContext(
-            cgContext, mFrontIOSurface, mShColorSpace, npevent->data.draw.x,
-            npevent->data.draw.y, npevent->data.draw.width,
-            npevent->data.draw.height);
-      }
-      return true;
-    } else {
-      if (mShWidth == 0 && mShHeight == 0) {
-        PLUGIN_LOG_DEBUG(("NPCocoaEventDrawRect on window of size 0."));
-        return false;
-      }
-      if (!mShSurface.IsReadable()) {
-        PLUGIN_LOG_DEBUG(("Shmem is not readable."));
-        return false;
-      }
-
-      if (!CallNPP_HandleEvent_Shmem(npremoteevent, std::move(mShSurface),
-                                     &handled, &mShSurface))
-        return false;  // no good way to handle errors here...
-
-      if (!mShSurface.IsReadable()) {
-        PLUGIN_LOG_DEBUG(
-            ("Shmem not returned. Either the plugin crashed "
-             "or we have a bug."));
-        return false;
-      }
-
-      char* shContextByte = mShSurface.get<char>();
-
-      if (!mShColorSpace) {
-        mShColorSpace = CreateSystemColorSpace();
-      }
-      if (!mShColorSpace) {
-        PLUGIN_LOG_DEBUG(("Could not allocate ColorSpace."));
-        return false;
-      }
-      CGContextRef shContext = ::CGBitmapContextCreate(
-          shContextByte, mShWidth, mShHeight, 8, mShWidth * 4, mShColorSpace,
-          kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host);
-      if (!shContext) {
-        PLUGIN_LOG_DEBUG(("Could not allocate CGBitmapContext."));
-        return false;
-      }
-
-      CGImageRef shImage = ::CGBitmapContextCreateImage(shContext);
-      if (shImage) {
-        CGContextRef cgContext = npevent->data.draw.context;
-
-        ::CGContextDrawImage(cgContext, CGRectMake(0, 0, mShWidth, mShHeight),
-                             shImage);
-        ::CGImageRelease(shImage);
-      } else {
-        ::CGContextRelease(shContext);
-        return false;
-      }
-      ::CGContextRelease(shContext);
-      return true;
-    }
-  }
-#endif
-
-  if (!CallNPP_HandleEvent(npremoteevent, &handled))
-    return 0;  // no good way to handle errors here...
-
-  return handled;
-}
-
-NPError PluginInstanceParent::NPP_NewStream(NPMIMEType type, NPStream* stream,
-                                            NPBool seekable, uint16_t* stype) {
-  PLUGIN_LOG_DEBUG(("%s (type=%s, stream=%p, seekable=%i)", FULLFUNCTION,
-                    (char*)type, (void*)stream, (int)seekable));
-
-  BrowserStreamParent* bs = new BrowserStreamParent(this, stream);
-
-  if (!SendPBrowserStreamConstructor(
-          bs, NullableString(stream->url), stream->end, stream->lastmodified,
-          static_cast<PStreamNotifyParent*>(stream->notifyData),
-          NullableString(stream->headers))) {
-    return NPERR_GENERIC_ERROR;
-  }
-
-  NPError err = NPERR_NO_ERROR;
-  bs->SetAlive();
-  if (!CallNPP_NewStream(bs, NullableString(type), seekable, &err, stype)) {
-    err = NPERR_GENERIC_ERROR;
-  }
-  if (NPERR_NO_ERROR != err) {
-    Unused << PBrowserStreamParent::Send__delete__(bs);
-  }
-
-  return err;
-}
-
-NPError PluginInstanceParent::NPP_DestroyStream(NPStream* stream,
-                                                NPReason reason) {
-  PLUGIN_LOG_DEBUG(
-      ("%s (stream=%p, reason=%i)", FULLFUNCTION, (void*)stream, (int)reason));
-
-  AStream* s = static_cast<AStream*>(stream->pdata);
-  if (!s) {
-    // The stream has already been deleted by other means.
-    // With async plugin init this could happen if async NPP_NewStream
-    // returns an error code.
-    return NPERR_NO_ERROR;
-  }
-  MOZ_ASSERT(s->IsBrowserStream());
-  BrowserStreamParent* sp = static_cast<BrowserStreamParent*>(s);
-  if (sp->mNPP != this) MOZ_CRASH("Mismatched plugin data");
-  sp->NPP_DestroyStream(reason);
-  return NPERR_NO_ERROR;
-}
-
-void PluginInstanceParent::NPP_Print(NPPrint* platformPrint) {
-  // TODO: implement me
-  NS_ERROR("Not implemented");
-}
-
-PPluginScriptableObjectParent*
-PluginInstanceParent::AllocPPluginScriptableObjectParent() {
-  return new PluginScriptableObjectParent(Proxy);
-}
-
-bool PluginInstanceParent::DeallocPPluginScriptableObjectParent(
-    PPluginScriptableObjectParent* aObject) {
-  PluginScriptableObjectParent* actor =
-      static_cast<PluginScriptableObjectParent*>(aObject);
-
-  NPObject* object = actor->GetObject(false);
-  if (object) {
-    NS_ASSERTION(mScriptableObjects.Get(object, nullptr),
-                 "NPObject not in the hash!");
-    mScriptableObjects.Remove(object);
-  }
-#ifdef DEBUG
-  else {
-    for (auto iter = mScriptableObjects.Iter(); !iter.Done(); iter.Next()) {
-      NS_ASSERTION(actor != iter.UserData(),
-                   "Actor in the hash with a null NPObject!");
-    }
-  }
-#endif
-
-  delete actor;
-  return true;
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceParent::RecvPPluginScriptableObjectConstructor(
-    PPluginScriptableObjectParent* aActor) {
-  // This is only called in response to the child process requesting the
-  // creation of an actor. This actor will represent an NPObject that is
-  // created by the plugin and returned to the browser.
-  PluginScriptableObjectParent* actor =
-      static_cast<PluginScriptableObjectParent*>(aActor);
-  NS_ASSERTION(!actor->GetObject(false), "Actor already has an object?!");
-
-  actor->InitializeProxy();
-  NS_ASSERTION(actor->GetObject(false), "Actor should have an object!");
-
-  return IPC_OK();
-}
-
-void PluginInstanceParent::NPP_URLNotify(const char* url, NPReason reason,
-                                         void* notifyData) {
-  PLUGIN_LOG_DEBUG(
-      ("%s (%s, %i, %p)", FULLFUNCTION, url, (int)reason, notifyData));
-
-  PStreamNotifyParent* streamNotify =
-      static_cast<PStreamNotifyParent*>(notifyData);
-  Unused << PStreamNotifyParent::Send__delete__(streamNotify, reason);
-}
-
-bool PluginInstanceParent::RegisterNPObjectForActor(
-    NPObject* aObject, PluginScriptableObjectParent* aActor) {
-  NS_ASSERTION(aObject && aActor, "Null pointers!");
-  NS_ASSERTION(!mScriptableObjects.Contains(aObject), "Duplicate entry!");
-  mScriptableObjects.InsertOrUpdate(aObject, aActor);
-  return true;
-}
-
-void PluginInstanceParent::UnregisterNPObject(NPObject* aObject) {
-  NS_ASSERTION(aObject, "Null pointer!");
-  NS_ASSERTION(mScriptableObjects.Contains(aObject), "Unknown entry!");
-  mScriptableObjects.Remove(aObject);
-}
-
-PluginScriptableObjectParent* PluginInstanceParent::GetActorForNPObject(
-    NPObject* aObject) {
-  NS_ASSERTION(aObject, "Null pointer!");
-
-  if (aObject->_class == PluginScriptableObjectParent::GetClass()) {
-    // One of ours!
-    ParentNPObject* object = static_cast<ParentNPObject*>(aObject);
-    NS_ASSERTION(object->parent, "Null actor!");
-    return object->parent;
-  }
-
-  PluginScriptableObjectParent* actor;
-  if (mScriptableObjects.Get(aObject, &actor)) {
-    return actor;
-  }
-
-  actor = new PluginScriptableObjectParent(LocalObject);
-  if (!SendPPluginScriptableObjectConstructor(actor)) {
-    NS_WARNING("Failed to send constructor message!");
-    return nullptr;
-  }
-
-  actor->InitializeLocal(aObject);
-  return actor;
-}
-
-mozilla::ipc::IPCResult PluginInstanceParent::AnswerNPN_PushPopupsEnabledState(
-    const bool& aState) {
-  mNPNIface->pushpopupsenabledstate(mNPP, aState ? 1 : 0);
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult
-PluginInstanceParent::AnswerNPN_PopPopupsEnabledState() {
-  mNPNIface->poppopupsenabledstate(mNPP);
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginInstanceParent::AnswerNPN_GetValueForURL(
-    const NPNURLVariable& variable, const nsCString& url, nsCString* value,
-    NPError* result) {
-  char* v;
-  uint32_t len;
-
-  *result = mNPNIface->getvalueforurl(mNPP, (NPNURLVariable)variable, url.get(),
-                                      &v, &len);
-  if (NPERR_NO_ERROR == *result) value->Adopt(v, len);
-
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginInstanceParent::AnswerNPN_SetValueForURL(
-    const NPNURLVariable& variable, const nsCString& url,
-    const nsCString& value, NPError* result) {
-  *result = mNPNIface->setvalueforurl(mNPP, (NPNURLVariable)variable, url.get(),
-                                      value.get(), value.Length());
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginInstanceParent::AnswerNPN_ConvertPoint(
-    const double& sourceX, const bool& ignoreDestX, const double& sourceY,
-    const bool& ignoreDestY, const NPCoordinateSpace& sourceSpace,
-    const NPCoordinateSpace& destSpace, double* destX, double* destY,
-    bool* result) {
-  *result = mNPNIface->convertpoint(mNPP, sourceX, sourceY, sourceSpace,
-                                    ignoreDestX ? nullptr : destX,
-                                    ignoreDestY ? nullptr : destY, destSpace);
-
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginInstanceParent::RecvRedrawPlugin() {
-  nsNPAPIPluginInstance* inst =
-      static_cast<nsNPAPIPluginInstance*>(mNPP->ndata);
-  if (!inst) {
-    return IPC_FAIL_NO_REASON(this);
-  }
-
-  inst->RedrawPlugin();
-  return IPC_OK();
-}
-
-nsPluginInstanceOwner* PluginInstanceParent::GetOwner() {
-  nsNPAPIPluginInstance* inst =
-      static_cast<nsNPAPIPluginInstance*>(mNPP->ndata);
-  if (!inst) {
-    return nullptr;
-  }
-  return inst->GetOwner();
-}
-
-mozilla::ipc::IPCResult PluginInstanceParent::RecvSetNetscapeWindowAsParent(
-    const NativeWindowHandle& childWindow) {
-#if defined(XP_WIN)
-  nsPluginInstanceOwner* owner = GetOwner();
-  if (!owner || NS_FAILED(owner->SetNetscapeWindowAsParent(childWindow))) {
-    NS_WARNING("Failed to set Netscape window as parent.");
-  }
-
-  return IPC_OK();
-#else
-  MOZ_ASSERT_UNREACHABLE("RecvSetNetscapeWindowAsParent not implemented!");
-  return IPC_FAIL_NO_REASON(this);
-#endif
-}
-
-#if defined(OS_WIN)
-
-/*
-  plugin focus changes between processes
-
-  focus from dom -> child:
-    Focus manager calls on widget to set the focus on the window.
-    We pick up the resulting wm_setfocus event here, and forward
-    that over ipc to the child which calls set focus on itself.
-
-  focus from child -> focus manager:
-    Child picks up the local wm_setfocus and sends it via ipc over
-    here. We then post a custom event to widget/windows/nswindow
-    which fires off a gui event letting the browser know.
-*/
-
-static const wchar_t kPluginInstanceParentProperty[] =
-    L"PluginInstanceParentProperty";
-
-// static
-LRESULT CALLBACK PluginInstanceParent::PluginWindowHookProc(HWND hWnd,
-                                                            UINT message,
-                                                            WPARAM wParam,
-                                                            LPARAM lParam) {
-  PluginInstanceParent* self = reinterpret_cast<PluginInstanceParent*>(
-      ::GetPropW(hWnd, kPluginInstanceParentProperty));
-  if (!self) {
-    MOZ_ASSERT_UNREACHABLE(
-        "PluginInstanceParent::PluginWindowHookProc null this ptr!");
-    return DefWindowProc(hWnd, message, wParam, lParam);
-  }
-
-  NS_ASSERTION(self->mPluginHWND == hWnd, "Wrong window!");
-
-  switch (message) {
-    case WM_SETFOCUS:
-      // Let the child plugin window know it should take focus.
-      Unused << self->CallSetPluginFocus();
-      break;
-
-    case WM_CLOSE:
-      self->UnsubclassPluginWindow();
-      break;
-  }
-
-  if (self->mPluginWndProc == PluginWindowHookProc) {
-    MOZ_ASSERT_UNREACHABLE(
-        "PluginWindowHookProc invoking mPluginWndProc w/"
-        "mPluginWndProc == PluginWindowHookProc????");
-    return DefWindowProc(hWnd, message, wParam, lParam);
-  }
-  return ::CallWindowProc(self->mPluginWndProc, hWnd, message, wParam, lParam);
-}
-
-void PluginInstanceParent::SubclassPluginWindow(HWND aWnd) {
-  if ((aWnd && mPluginHWND == aWnd) || (!aWnd && mPluginHWND)) {
-    return;
-  }
-
-  if (XRE_IsContentProcess()) {
-    if (!aWnd) {
-      NS_WARNING(
-          "PluginInstanceParent::SubclassPluginWindow unexpected null window");
-      return;
-    }
-    mPluginHWND = aWnd;  // now a remote window, we can't subclass this
-    mPluginWndProc = nullptr;
-    // Note sPluginInstanceList wil delete 'this' if we do not remove
-    // it on shutdown.
-    sPluginInstanceList->InsertOrUpdate((void*)mPluginHWND,
-                                        UniquePtr<PluginInstanceParent>(this));
-    return;
-  }
-
-  NS_ASSERTION(
-      !(mPluginHWND && aWnd != mPluginHWND),
-      "PluginInstanceParent::SubclassPluginWindow hwnd is not our window!");
-
-  mPluginHWND = aWnd;
-  mPluginWndProc = (WNDPROC)::SetWindowLongPtrA(
-      mPluginHWND, GWLP_WNDPROC,
-      reinterpret_cast<LONG_PTR>(PluginWindowHookProc));
-  DebugOnly<bool> bRes =
-      ::SetPropW(mPluginHWND, kPluginInstanceParentProperty, this);
-  NS_ASSERTION(
-      mPluginWndProc,
-      "PluginInstanceParent::SubclassPluginWindow failed to set subclass!");
-  NS_ASSERTION(
-      bRes, "PluginInstanceParent::SubclassPluginWindow failed to set prop!");
-}
-
-void PluginInstanceParent::UnsubclassPluginWindow() {
-  if (XRE_IsContentProcess()) {
-    if (mPluginHWND) {
-      // Remove 'this' from the plugin list safely
-      mozilla::UniquePtr<PluginInstanceParent> tmp;
-      MOZ_ASSERT(sPluginInstanceList);
-      sPluginInstanceList->Remove((void*)mPluginHWND, &tmp);
-      mozilla::Unused << tmp.release();
-      if (!sPluginInstanceList->Count()) {
-        delete sPluginInstanceList;
-        sPluginInstanceList = nullptr;
-      }
-    }
-    mPluginHWND = nullptr;
-    return;
-  }
-
-  if (mPluginHWND && mPluginWndProc) {
-    ::SetWindowLongPtrA(mPluginHWND, GWLP_WNDPROC,
-                        reinterpret_cast<LONG_PTR>(mPluginWndProc));
-
-    ::RemovePropW(mPluginHWND, kPluginInstanceParentProperty);
-
-    mPluginWndProc = nullptr;
-    mPluginHWND = nullptr;
-  }
-}
-
-/* windowless drawing helpers */
-
-/*
- * Origin info:
- *
- * windowless, offscreen:
- *
- * WM_WINDOWPOSCHANGED: origin is relative to container
- * setwindow: origin is 0,0
- * WM_PAINT: origin is 0,0
- *
- * windowless, native:
- *
- * WM_WINDOWPOSCHANGED: origin is relative to container
- * setwindow: origin is relative to container
- * WM_PAINT: origin is relative to container
- *
- * PluginInstanceParent:
- *
- * painting: mPluginPort (nsIntRect, saved in SetWindow)
- */
-
-bool PluginInstanceParent::MaybeCreateAndParentChildPluginWindow() {
-  // On Windows we need to create and set the parent before we set the
-  // window on the plugin, or keyboard interaction will not work.
-  if (!mChildPluginHWND) {
-    if (!CallCreateChildPluginWindow(&mChildPluginHWND) || !mChildPluginHWND) {
-      return false;
-    }
-  }
-
-  // It's not clear if the parent window would ever change, but when this
-  // was done in the NPAPI child it used to allow for this.
-  if (mPluginHWND == mChildPluginsParentHWND) {
-    return true;
-  }
-
-  nsPluginInstanceOwner* owner = GetOwner();
-  if (!owner) {
-    // We can't reparent without an owner, the plugin is probably shutting
-    // down, just return true to allow any calls to continue.
-    return true;
-  }
-
-  // Note that this call will probably cause a sync native message to the
-  // process that owns the child window.
-  owner->SetWidgetWindowAsParent(mChildPluginHWND);
-  mChildPluginsParentHWND = mPluginHWND;
-  return true;
-}
-
-void PluginInstanceParent::MaybeCreateChildPopupSurrogate() {
-  // Already created or not required for this plugin.
-  if (mChildPluginHWND || mWindowType != NPWindowTypeDrawable ||
-      !(mParent->GetQuirks() & QUIRK_WINLESS_TRACKPOPUP_HOOK)) {
-    return;
-  }
-
-  // We need to pass the netscape window down to be cached as part of the call
-  // to create the surrogate, because the reparenting of the surrogate in the
-  // main process can cause sync Windows messages to the plugin process, which
-  // then cause sync messages from the plugin child for the netscape window
-  // which causes a deadlock.
-  NativeWindowHandle netscapeWindow;
-  NPError result =
-      mNPNIface->getvalue(mNPP, NPNVnetscapeWindow, &netscapeWindow);
-  if (NPERR_NO_ERROR != result) {
-    NS_WARNING("Can't get netscape window to pass to plugin child.");
-    return;
-  }
-
-  if (!SendCreateChildPopupSurrogate(netscapeWindow)) {
-    NS_WARNING("Failed to create popup surrogate in child.");
-  }
-}
-
-#endif  // defined(OS_WIN)
-
-mozilla::ipc::IPCResult PluginInstanceParent::AnswerPluginFocusChange(
-    const bool& gotFocus) {
-  PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
-
-  // Currently only in use on windows - an event we receive from the child
-  // when it's plugin window (or one of it's children) receives keyboard
-  // focus. We detect this and forward a notification here so we can update
-  // focus.
-#if defined(OS_WIN)
-  if (gotFocus) {
-    nsPluginInstanceOwner* owner = GetOwner();
-    if (owner) {
-      RefPtr<nsFocusManager> fm = nsFocusManager::GetFocusManager();
-      RefPtr<dom::Element> element;
-      owner->GetDOMElement(getter_AddRefs(element));
-      if (fm && element) {
-        fm->SetFocus(element, 0);
-      }
-    }
-  }
-  return IPC_OK();
-#else
-  MOZ_ASSERT_UNREACHABLE("AnswerPluginFocusChange not implemented!");
-  return IPC_FAIL_NO_REASON(this);
-#endif
-}
-
-PluginInstanceParent* PluginInstanceParent::Cast(NPP aInstance) {
-  auto ip = static_cast<PluginInstanceParent*>(aInstance->pdata);
-
-  // If the plugin crashed and the PluginInstanceParent was deleted,
-  // aInstance->pdata will be nullptr.
-  if (!ip) {
-    return nullptr;
-  }
-
-  if (aInstance != ip->mNPP) {
-    MOZ_CRASH("Corrupted plugin data.");
-  }
-
-  return ip;
-}
-
-mozilla::ipc::IPCResult PluginInstanceParent::RecvGetCompositionString(
-    const uint32_t& aIndex, nsTArray<uint8_t>* aDist, int32_t* aLength) {
-#if defined(OS_WIN)
-  nsPluginInstanceOwner* owner = GetOwner();
-  if (!owner) {
-    *aLength = IMM_ERROR_GENERAL;
-    return IPC_OK();
-  }
-
-  if (!owner->GetCompositionString(aIndex, aDist, aLength)) {
-    *aLength = IMM_ERROR_NODATA;
-  }
-#endif
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginInstanceParent::RecvRequestCommitOrCancel(
-    const bool& aCommitted) {
-#if defined(OS_WIN)
-  nsPluginInstanceOwner* owner = GetOwner();
-  if (owner) {
-    owner->RequestCommitOrCancel(aCommitted);
-  }
-#endif
-  return IPC_OK();
-}
-
-void PluginInstanceParent::RecordDrawingModel() {
-  int mode = -1;
-  switch (mWindowType) {
-    case NPWindowTypeWindow:
-      // We use 0=windowed since there is no specific NPDrawingModel value.
-      mode = 0;
-      break;
-    case NPWindowTypeDrawable:
-      mode = mDrawingModel + 1;
-      break;
-    default:
-      MOZ_ASSERT_UNREACHABLE("bad window type");
-      return;
-  }
-
-  if (mode == mLastRecordedDrawingModel) {
-    return;
-  }
-  MOZ_ASSERT(mode >= 0);
-
-  Telemetry::Accumulate(Telemetry::PLUGIN_DRAWING_MODEL, mode);
-  mLastRecordedDrawingModel = mode;
-}
diff --git a/dom/plugins/ipc/PluginInstanceParent.h b/dom/plugins/ipc/PluginInstanceParent.h
deleted file mode 100644
index db210694bad93..0000000000000
--- a/dom/plugins/ipc/PluginInstanceParent.h
+++ /dev/null
@@ -1,391 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef dom_plugins_PluginInstanceParent_h
-#define dom_plugins_PluginInstanceParent_h 1
-
-#include "mozilla/plugins/PPluginInstanceParent.h"
-#include "mozilla/plugins/PluginScriptableObjectParent.h"
-#if defined(OS_WIN)
-#  include "mozilla/gfx/SharedDIBWin.h"
-#  include <d3d10_1.h>
-#  include "nsRefPtrHashtable.h"
-#  include "mozilla/layers/LayersSurfaces.h"
-#elif defined(MOZ_WIDGET_COCOA)
-#  include "mozilla/gfx/QuartzSupport.h"
-#endif
-
-#include "npfunctions.h"
-#include "nsTHashMap.h"
-#include "nsHashKeys.h"
-#include "nsRect.h"
-
-#include "mozilla/Unused.h"
-#include "mozilla/EventForwards.h"
-
-class gfxASurface;
-class gfxContext;
-class nsPluginInstanceOwner;
-
-namespace mozilla {
-namespace layers {
-class Image;
-class ImageContainer;
-class TextureClientRecycleAllocator;
-}  // namespace layers
-namespace plugins {
-
-class PBrowserStreamParent;
-class PluginModuleParent;
-class D3D11SurfaceHolder;
-
-class PluginInstanceParent : public PPluginInstanceParent {
-  friend class PluginModuleParent;
-  friend class BrowserStreamParent;
-  friend class StreamNotifyParent;
-  friend class PPluginInstanceParent;
-
-#if defined(XP_WIN)
- public:
-  /**
-   * Helper method for looking up instances based on a supplied id.
-   */
-  static PluginInstanceParent* LookupPluginInstanceByID(uintptr_t aId);
-#endif  // defined(XP_WIN)
-
- public:
-  typedef mozilla::gfx::DrawTarget DrawTarget;
-
-  PluginInstanceParent(PluginModuleParent* parent, NPP npp,
-                       const nsCString& mimeType,
-                       const NPNetscapeFuncs* npniface);
-
-  virtual ~PluginInstanceParent();
-
-  bool InitMetadata(const nsACString& aMimeType,
-                    const nsACString& aSrcAttribute);
-  NPError Destroy();
-
-  virtual void ActorDestroy(ActorDestroyReason why) override;
-
-  PPluginScriptableObjectParent* AllocPPluginScriptableObjectParent();
-
-  virtual mozilla::ipc::IPCResult RecvPPluginScriptableObjectConstructor(
-      PPluginScriptableObjectParent* aActor) override;
-
-  bool DeallocPPluginScriptableObjectParent(
-      PPluginScriptableObjectParent* aObject);
-  PBrowserStreamParent* AllocPBrowserStreamParent(
-      const nsCString& url, const uint32_t& length,
-      const uint32_t& lastmodified, PStreamNotifyParent* notifyData,
-      const nsCString& headers);
-  bool DeallocPBrowserStreamParent(PBrowserStreamParent* stream);
-
-  mozilla::ipc::IPCResult AnswerNPN_GetValue_NPNVnetscapeWindow(
-      NativeWindowHandle* value, NPError* result);
-  mozilla::ipc::IPCResult AnswerNPN_GetValue_NPNVWindowNPObject(
-      PPluginScriptableObjectParent** value, NPError* result);
-  mozilla::ipc::IPCResult AnswerNPN_GetValue_NPNVPluginElementNPObject(
-      PPluginScriptableObjectParent** value, NPError* result);
-  mozilla::ipc::IPCResult AnswerNPN_GetValue_NPNVprivateModeBool(
-      bool* value, NPError* result);
-
-  mozilla::ipc::IPCResult AnswerNPN_GetValue_DrawingModelSupport(
-      const NPNVariable& model, bool* value);
-
-  mozilla::ipc::IPCResult AnswerNPN_GetValue_NPNVdocumentOrigin(
-      nsCString* value, NPError* result);
-
-  mozilla::ipc::IPCResult AnswerNPN_GetValue_SupportsAsyncBitmapSurface(
-      bool* value);
-
-  static bool SupportsPluginDirectDXGISurfaceDrawing();
-  mozilla::ipc::IPCResult AnswerNPN_GetValue_SupportsAsyncDXGISurface(
-      bool* value) {
-    *value = SupportsPluginDirectDXGISurfaceDrawing();
-    return IPC_OK();
-  }
-
-  mozilla::ipc::IPCResult AnswerNPN_GetValue_PreferredDXGIAdapter(
-      DxgiAdapterDesc* desc);
-
-  mozilla::ipc::IPCResult AnswerNPN_SetValue_NPPVpluginWindow(
-      const bool& windowed, NPError* result);
-  mozilla::ipc::IPCResult AnswerNPN_SetValue_NPPVpluginTransparent(
-      const bool& transparent, NPError* result);
-  mozilla::ipc::IPCResult AnswerNPN_SetValue_NPPVpluginUsesDOMForCursor(
-      const bool& useDOMForCursor, NPError* result);
-  mozilla::ipc::IPCResult AnswerNPN_SetValue_NPPVpluginDrawingModel(
-      const int& drawingModel, NPError* result);
-  mozilla::ipc::IPCResult AnswerNPN_SetValue_NPPVpluginEventModel(
-      const int& eventModel, NPError* result);
-  mozilla::ipc::IPCResult AnswerNPN_SetValue_NPPVpluginIsPlayingAudio(
-      const bool& isAudioPlaying, NPError* result);
-
-  mozilla::ipc::IPCResult AnswerNPN_GetURL(const nsCString& url,
-                                           const nsCString& target,
-                                           NPError* result);
-
-  mozilla::ipc::IPCResult AnswerNPN_PostURL(const nsCString& url,
-                                            const nsCString& target,
-                                            const nsCString& buffer,
-                                            const bool& file, NPError* result);
-
-  PStreamNotifyParent* AllocPStreamNotifyParent(
-      const nsCString& url, const nsCString& target, const bool& post,
-      const nsCString& buffer, const bool& file, NPError* result);
-
-  virtual mozilla::ipc::IPCResult AnswerPStreamNotifyConstructor(
-      PStreamNotifyParent* actor, const nsCString& url, const nsCString& target,
-      const bool& post, const nsCString& buffer, const bool& file,
-      NPError* result) override;
-
-  bool DeallocPStreamNotifyParent(PStreamNotifyParent* notifyData);
-
-  mozilla::ipc::IPCResult RecvNPN_InvalidateRect(const NPRect& rect);
-
-  mozilla::ipc::IPCResult RecvRevokeCurrentDirectSurface();
-
-  /**
-   * Windows async plugin rendering uses DXGI surface objects, entirely
-   * maintained by the compositor process, to back the rendering of plugins.
-   * The expected mechanics are:
-   * - The PluginInstanceChild (PIC) in the plugin process sends
-   *   InitDXGISurface to us, the content process' PluginInstanceParent (PIP).
-   * - The PIP uses the ImageBridge to tell the compositor to create 2
-   *   surfaces -- one to be written to by the plugin process and another
-   *   to be displayed by the compositor.  The PIP returns the plugin
-   *   surface to the PIC.
-   * - The PIC repeatedly issues ShowDirectDXGISurface calls to tell the
-   *   PIP to blit the plugin surface to the display surface.  These
-   *   requests are forwarded to the compositor via the ImageBridge.
-   * - The PIC sends FinalizeDXGISurface tio the PIP when it no longer needs
-   *   the surface.  The PIP then tells the compositor to destroy the
-   *   plugin surface.  After this, the PIP will tell the compositor to
-   *   also destroy the display surface as soon as the ImageBridge says it
-   *   no longer needs it.
-   */
-  mozilla::ipc::IPCResult RecvInitDXGISurface(const gfx::SurfaceFormat& format,
-                                              const gfx::IntSize& size,
-                                              WindowsHandle* outHandle,
-                                              NPError* outError);
-  mozilla::ipc::IPCResult RecvShowDirectDXGISurface(const WindowsHandle& handle,
-                                                    const gfx::IntRect& rect);
-
-  mozilla::ipc::IPCResult RecvFinalizeDXGISurface(const WindowsHandle& handle);
-
-  // --
-
-  mozilla::ipc::IPCResult RecvShowDirectBitmap(Shmem&& buffer,
-                                               const gfx::SurfaceFormat& format,
-                                               const uint32_t& stride,
-                                               const gfx::IntSize& size,
-                                               const gfx::IntRect& dirty);
-
-  mozilla::ipc::IPCResult RecvShow(const NPRect& updatedRect,
-                                   const SurfaceDescriptor& newSurface,
-                                   SurfaceDescriptor* prevSurface);
-
-  mozilla::ipc::IPCResult AnswerNPN_PushPopupsEnabledState(const bool& aState);
-
-  mozilla::ipc::IPCResult AnswerNPN_PopPopupsEnabledState();
-
-  mozilla::ipc::IPCResult AnswerNPN_GetValueForURL(
-      const NPNURLVariable& variable, const nsCString& url, nsCString* value,
-      NPError* result);
-
-  mozilla::ipc::IPCResult AnswerNPN_SetValueForURL(
-      const NPNURLVariable& variable, const nsCString& url,
-      const nsCString& value, NPError* result);
-
-  mozilla::ipc::IPCResult AnswerNPN_ConvertPoint(
-      const double& sourceX, const bool& ignoreDestX, const double& sourceY,
-      const bool& ignoreDestY, const NPCoordinateSpace& sourceSpace,
-      const NPCoordinateSpace& destSpace, double* destX, double* destY,
-      bool* result);
-
-  mozilla::ipc::IPCResult RecvRedrawPlugin();
-
-  mozilla::ipc::IPCResult RecvSetNetscapeWindowAsParent(
-      const NativeWindowHandle& childWindow);
-
-  NPError NPP_SetWindow(const NPWindow* aWindow);
-
-  NPError NPP_GetValue(NPPVariable variable, void* retval);
-  NPError NPP_SetValue(NPNVariable variable, void* value);
-
-  void NPP_URLRedirectNotify(const char* url, int32_t status, void* notifyData);
-
-  NPError NPP_NewStream(NPMIMEType type, NPStream* stream, NPBool seekable,
-                        uint16_t* stype);
-  NPError NPP_DestroyStream(NPStream* stream, NPReason reason);
-
-  void NPP_Print(NPPrint* platformPrint);
-
-  int16_t NPP_HandleEvent(void* event);
-
-  void NPP_URLNotify(const char* url, NPReason reason, void* notifyData);
-
-  PluginModuleParent* Module() { return mParent; }
-
-  const NPNetscapeFuncs* GetNPNIface() { return mNPNIface; }
-
-  bool RegisterNPObjectForActor(NPObject* aObject,
-                                PluginScriptableObjectParent* aActor);
-
-  void UnregisterNPObject(NPObject* aObject);
-
-  PluginScriptableObjectParent* GetActorForNPObject(NPObject* aObject);
-
-  NPP GetNPP() { return mNPP; }
-
-  void GetSrcAttribute(nsACString& aOutput) const { aOutput = mSrcAttribute; }
-
-  MOZ_CAN_RUN_SCRIPT_BOUNDARY mozilla::ipc::IPCResult AnswerPluginFocusChange(
-      const bool& gotFocus);
-
-  nsresult AsyncSetWindow(NPWindow* window);
-  nsresult GetImageContainer(mozilla::layers::ImageContainer** aContainer);
-  nsresult GetImageSize(nsIntSize* aSize);
-#ifdef XP_MACOSX
-  nsresult IsRemoteDrawingCoreAnimation(bool* aDrawing);
-#endif
-#if defined(XP_MACOSX) || defined(XP_WIN)
-  nsresult ContentsScaleFactorChanged(double aContentsScaleFactor);
-#endif
-  nsresult SetBackgroundUnknown();
-  nsresult BeginUpdateBackground(const nsIntRect& aRect,
-                                 DrawTarget** aDrawTarget);
-  nsresult EndUpdateBackground(const nsIntRect& aRect);
-#if defined(XP_WIN)
-  nsresult SetScrollCaptureId(uint64_t aScrollCaptureId);
-  nsresult GetScrollCaptureContainer(
-      mozilla::layers::ImageContainer** aContainer);
-#endif
-  void DidComposite();
-
-  bool IsUsingDirectDrawing();
-
-  static PluginInstanceParent* Cast(NPP instance);
-
-  // for IME hook
-  mozilla::ipc::IPCResult RecvGetCompositionString(const uint32_t& aIndex,
-                                                   nsTArray<uint8_t>* aBuffer,
-                                                   int32_t* aLength);
-  mozilla::ipc::IPCResult RecvRequestCommitOrCancel(const bool& aCommitted);
-
- private:
-  // Create an appropriate platform surface for a background of size
-  // |aSize|.  Return true if successful.
-  bool CreateBackground(const nsIntSize& aSize);
-  void DestroyBackground();
-  SurfaceDescriptor BackgroundDescriptor() /*const*/;
-
-  typedef mozilla::layers::ImageContainer ImageContainer;
-  ImageContainer* GetImageContainer();
-
-  PPluginBackgroundDestroyerParent* AllocPPluginBackgroundDestroyerParent();
-
-  bool DeallocPPluginBackgroundDestroyerParent(
-      PPluginBackgroundDestroyerParent* aActor);
-
-  bool InternalGetValueForNPObject(NPNVariable aVariable,
-                                   PPluginScriptableObjectParent** aValue,
-                                   NPError* aResult);
-
-  nsPluginInstanceOwner* GetOwner();
-
-  void SetCurrentImage(layers::Image* aImage);
-
-  // Update Telemetry with the current drawing model.
-  void RecordDrawingModel();
-
- private:
-  PluginModuleParent* mParent;
-  NPP mNPP;
-  const NPNetscapeFuncs* mNPNIface;
-  nsCString mSrcAttribute;
-  NPWindowType mWindowType;
-  int16_t mDrawingModel;
-
-  // Since plugins may request different drawing models to find a compatible
-  // one, we only record the drawing model after a SetWindow call and if the
-  // drawing model has changed.
-  int mLastRecordedDrawingModel;
-
-  nsTHashMap<nsPtrHashKey<NPObject>, PluginScriptableObjectParent*>
-      mScriptableObjects;
-
-  // This is used to tell the compositor that it should invalidate the
-  // ImageLayer.
-  uint32_t mFrameID;
-
-#if defined(XP_WIN)
-  // Note: DXGI 1.1 surface handles are global across all processes, and are not
-  // marshaled. As long as we haven't freed a texture its handle should be valid
-  // as a unique cross-process identifier for the texture.
-  nsRefPtrHashtable<nsPtrHashKey<void>, D3D11SurfaceHolder> mD3D11Surfaces;
-#endif
-
-#if defined(OS_WIN)
- private:
-  // Used in handling parent/child forwarding of events.
-  static LRESULT CALLBACK PluginWindowHookProc(HWND hWnd, UINT message,
-                                               WPARAM wParam, LPARAM lParam);
-  void SubclassPluginWindow(HWND aWnd);
-  void UnsubclassPluginWindow();
-
-  bool MaybeCreateAndParentChildPluginWindow();
-  void MaybeCreateChildPopupSurrogate();
-
- private:
-  nsIntRect mPluginPort;
-  nsIntRect mSharedSize;
-  HWND mPluginHWND;
-  // This is used for the normal child plugin HWND for windowed plugins and,
-  // if needed, also the child popup surrogate HWND for windowless plugins.
-  HWND mChildPluginHWND;
-  HWND mChildPluginsParentHWND;
-  WNDPROC mPluginWndProc;
-
-  struct AsyncSurfaceInfo {
-    layers::SurfaceDescriptorPlugin mSD;
-    gfx::IntSize mSize;
-  };
-  // Key is plugin surface's texture's handle
-  HashMap<WindowsHandle, AsyncSurfaceInfo> mAsyncSurfaceMap;
-#endif  // defined(OS_WIN)
-
-#if defined(MOZ_WIDGET_COCOA)
- private:
-  Shmem mShSurface;
-  uint16_t mShWidth;
-  uint16_t mShHeight;
-  CGColorSpaceRef mShColorSpace;
-  RefPtr<MacIOSurface> mIOSurface;
-  RefPtr<MacIOSurface> mFrontIOSurface;
-#endif  // definied(MOZ_WIDGET_COCOA)
-
-  // ObjectFrame layer wrapper
-  RefPtr<gfxASurface> mFrontSurface;
-  // For windowless+transparent instances, this surface contains a
-  // "pretty recent" copy of the pixels under its <object> frame.
-  // On the plugin side, we use this surface to avoid doing alpha
-  // recovery when possible.  This surface is created and owned by
-  // the browser, but a "read-only" reference is sent to the plugin.
-  //
-  // We have explicitly chosen not to provide any guarantees about
-  // the consistency of the pixels in |mBackground|.  A plugin may
-  // be able to observe partial updates to the background.
-  RefPtr<gfxASurface> mBackground;
-
-  RefPtr<ImageContainer> mImageContainer;
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // ifndef dom_plugins_PluginInstanceParent_h
diff --git a/dom/plugins/ipc/PluginLibrary.h b/dom/plugins/ipc/PluginLibrary.h
deleted file mode 100644
index 3b045d5cb8d83..0000000000000
--- a/dom/plugins/ipc/PluginLibrary.h
+++ /dev/null
@@ -1,122 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_PluginLibrary_h
-#define mozilla_PluginLibrary_h 1
-
-#include "prlink.h"
-#include "npapi.h"
-#include "npfunctions.h"
-#include "nscore.h"
-#include "nsStringFwd.h"
-#include "nsTArray.h"
-#include "nsError.h"
-#include "mozilla/EventForwards.h"
-#include "nsSize.h"
-#include "nsRect.h"
-
-class nsNPAPIPlugin;
-
-namespace mozilla {
-namespace gfx {
-class DrawTarget;
-}
-namespace layers {
-class Image;
-class ImageContainer;
-}  // namespace layers
-}  // namespace mozilla
-
-class nsIClearSiteDataCallback;
-
-#define nsIGetSitesWithDataCallback_CID              \
-  {                                                  \
-    0xd0028b83, 0xfdf9, 0x4c53, {                    \
-      0xb7, 0xbb, 0x47, 0x46, 0x0f, 0x6b, 0x83, 0x6c \
-    }                                                \
-  }
-class nsIGetSitesWithDataCallback : public nsISupports {
- public:
-  NS_IMETHOD SitesWithData(nsTArray<nsCString>& result) = 0;
-  NS_DECLARE_STATIC_IID_ACCESSOR(nsIGetSitesWithDataCallback_CID)
-};
-NS_DEFINE_STATIC_IID_ACCESSOR(nsIGetSitesWithDataCallback,
-                              nsIGetSitesWithDataCallback_CID)
-
-namespace mozilla {
-
-class PluginLibrary {
- public:
-  typedef mozilla::gfx::DrawTarget DrawTarget;
-
-  virtual ~PluginLibrary() = default;
-
-  /**
-   * Inform this library about the nsNPAPIPlugin which owns it. This
-   * object will hold a weak pointer to the plugin.
-   */
-  virtual void SetPlugin(nsNPAPIPlugin* plugin) = 0;
-
-  virtual bool HasRequiredFunctions() = 0;
-
-#if defined(XP_UNIX) && !defined(XP_MACOSX)
-  virtual nsresult NP_Initialize(NPNetscapeFuncs* bFuncs, NPPluginFuncs* pFuncs,
-                                 NPError* error) = 0;
-#else
-  virtual nsresult NP_Initialize(NPNetscapeFuncs* bFuncs, NPError* error) = 0;
-#endif
-  virtual nsresult NP_Shutdown(NPError* error) = 0;
-  virtual nsresult NP_GetMIMEDescription(const char** mimeDesc) = 0;
-  virtual nsresult NP_GetValue(void* future, NPPVariable aVariable,
-                               void* aValue, NPError* error) = 0;
-#if defined(XP_WIN) || defined(XP_MACOSX)
-  virtual nsresult NP_GetEntryPoints(NPPluginFuncs* pFuncs, NPError* error) = 0;
-#endif
-  virtual nsresult NPP_New(NPMIMEType pluginType, NPP instance, int16_t argc,
-                           char* argn[], char* argv[], NPSavedData* saved,
-                           NPError* error) = 0;
-
-  virtual nsresult NPP_ClearSiteData(
-      const char* site, uint64_t flags, uint64_t maxAge,
-      nsCOMPtr<nsIClearSiteDataCallback> callback) = 0;
-  virtual nsresult NPP_GetSitesWithData(
-      nsCOMPtr<nsIGetSitesWithDataCallback> callback) = 0;
-
-  virtual nsresult AsyncSetWindow(NPP instance, NPWindow* window) = 0;
-  virtual nsresult GetImageContainer(
-      NPP instance, mozilla::layers::ImageContainer** aContainer) = 0;
-  virtual nsresult GetImageSize(NPP instance, nsIntSize* aSize) = 0;
-  virtual void DidComposite(NPP instance) = 0;
-  virtual bool IsOOP() = 0;
-#if defined(XP_MACOSX)
-  virtual nsresult IsRemoteDrawingCoreAnimation(NPP instance,
-                                                bool* aDrawing) = 0;
-#endif
-#if defined(XP_MACOSX) || defined(XP_WIN)
-  virtual nsresult ContentsScaleFactorChanged(NPP instance,
-                                              double aContentsScaleFactor) = 0;
-#endif
-#if defined(XP_WIN)
-  virtual nsresult GetScrollCaptureContainer(
-      NPP aInstance, mozilla::layers::ImageContainer** aContainer) = 0;
-#endif
-
-  /**
-   * The next three methods are the third leg in the trip to
-   * PluginInstanceParent.  They approximately follow the ReadbackSink
-   * API.
-   */
-  virtual nsresult SetBackgroundUnknown(NPP instance) = 0;
-  virtual nsresult BeginUpdateBackground(NPP instance, const nsIntRect&,
-                                         DrawTarget**) = 0;
-  virtual nsresult EndUpdateBackground(NPP instance, const nsIntRect&) = 0;
-  virtual nsresult GetRunID(uint32_t* aRunID) = 0;
-  virtual void SetHasLocalInstance() = 0;
-};
-
-}  // namespace mozilla
-
-#endif  // ifndef mozilla_PluginLibrary_h
diff --git a/dom/plugins/ipc/PluginMessageUtils.cpp b/dom/plugins/ipc/PluginMessageUtils.cpp
deleted file mode 100644
index 4d639b6f391ba..0000000000000
--- a/dom/plugins/ipc/PluginMessageUtils.cpp
+++ /dev/null
@@ -1,141 +0,0 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8; -*- */
-/* vim: set sw=2 ts=8 et tw=80 : */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "PluginMessageUtils.h"
-#include "nsThreadUtils.h"
-
-#include "PluginInstanceParent.h"
-#include "PluginInstanceChild.h"
-#include "PluginScriptableObjectParent.h"
-#include "PluginScriptableObjectChild.h"
-
-using std::string;
-
-using mozilla::ipc::MessageChannel;
-
-namespace {
-
-class DeferNPObjectReleaseRunnable : public mozilla::Runnable {
- public:
-  DeferNPObjectReleaseRunnable(const NPNetscapeFuncs* f, NPObject* o)
-      : Runnable("DeferNPObjectReleaseRunnable"), mFuncs(f), mObject(o) {
-    NS_ASSERTION(o, "no release null objects");
-  }
-
-  NS_IMETHOD Run() override;
-
- private:
-  const NPNetscapeFuncs* mFuncs;
-  NPObject* mObject;
-};
-
-NS_IMETHODIMP
-DeferNPObjectReleaseRunnable::Run() {
-  mFuncs->releaseobject(mObject);
-  return NS_OK;
-}
-
-}  // namespace
-
-namespace mozilla::plugins {
-
-NPRemoteWindow::NPRemoteWindow()
-    : window(0),
-      x(0),
-      y(0),
-      width(0),
-      height(0),
-      type(NPWindowTypeDrawable)
-#if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
-      ,
-      visualID(0),
-      colormap(0)
-#endif /* XP_UNIX */
-#if defined(XP_MACOSX)
-      ,
-      contentsScaleFactor(1.0)
-#endif
-{
-  clipRect.top = 0;
-  clipRect.left = 0;
-  clipRect.bottom = 0;
-  clipRect.right = 0;
-}
-
-ipc::RacyInterruptPolicy MediateRace(const MessageChannel::MessageInfo& parent,
-                                     const MessageChannel::MessageInfo& child) {
-  switch (parent.type()) {
-    case PPluginInstance::Msg_Paint__ID:
-    case PPluginInstance::Msg_NPP_SetWindow__ID:
-    case PPluginInstance::Msg_NPP_HandleEvent_Shmem__ID:
-    case PPluginInstance::Msg_NPP_HandleEvent_IOSurface__ID:
-      // our code relies on the frame list not changing during paints and
-      // reflows
-      return ipc::RIPParentWins;
-
-    default:
-      return ipc::RIPChildWins;
-  }
-}
-
-#if defined(OS_LINUX) || defined(OS_SOLARIS)
-static string ReplaceAll(const string& haystack, const string& needle,
-                         const string& with) {
-  string munged = haystack;
-  string::size_type i = 0;
-
-  while (string::npos != (i = munged.find(needle, i))) {
-    munged.replace(i, needle.length(), with);
-    i += with.length();
-  }
-
-  return munged;
-}
-#endif
-
-string MungePluginDsoPath(const string& path) {
-#if defined(OS_LINUX) || defined(OS_SOLARIS)
-  // https://bugzilla.mozilla.org/show_bug.cgi?id=519601
-  return ReplaceAll(path, "netscape", "netsc@pe");
-#else
-  return path;
-#endif
-}
-
-string UnmungePluginDsoPath(const string& munged) {
-#if defined(OS_LINUX) || defined(OS_SOLARIS)
-  return ReplaceAll(munged, "netsc@pe", "netscape");
-#else
-  return munged;
-#endif
-}
-
-LogModule* GetPluginLog() {
-  static LazyLogModule sLog("IPCPlugins");
-  return sLog;
-}
-
-void DeferNPObjectLastRelease(const NPNetscapeFuncs* f, NPObject* o) {
-  if (!o) return;
-
-  if (o->referenceCount > 1) {
-    f->releaseobject(o);
-    return;
-  }
-
-  NS_DispatchToCurrentThread(new DeferNPObjectReleaseRunnable(f, o));
-}
-
-void DeferNPVariantLastRelease(const NPNetscapeFuncs* f, NPVariant* v) {
-  if (!NPVARIANT_IS_OBJECT(*v)) {
-    f->releasevariantvalue(v);
-    return;
-  }
-  DeferNPObjectLastRelease(f, v->value.objectValue);
-  VOID_TO_NPVARIANT(*v);
-}
-
-}  // namespace mozilla::plugins
diff --git a/dom/plugins/ipc/PluginMessageUtils.h b/dom/plugins/ipc/PluginMessageUtils.h
deleted file mode 100644
index d4f932be5f175..0000000000000
--- a/dom/plugins/ipc/PluginMessageUtils.h
+++ /dev/null
@@ -1,562 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef DOM_PLUGINS_PLUGINMESSAGEUTILS_H
-#define DOM_PLUGINS_PLUGINMESSAGEUTILS_H
-
-#include "ipc/EnumSerializer.h"
-#include "base/message_loop.h"
-#include "base/shared_memory.h"
-
-#include "mozilla/ipc/CrossProcessMutex.h"
-#include "mozilla/ipc/MessageChannel.h"
-#include "mozilla/ipc/ProtocolUtils.h"
-#include "mozilla/UniquePtr.h"
-#include "gfxipc/SurfaceDescriptor.h"
-
-#include "npapi.h"
-#include "npruntime.h"
-#include "npfunctions.h"
-#include "nsString.h"
-#include "nsTArray.h"
-#include "mozilla/Logging.h"
-#include "nsHashKeys.h"
-
-namespace mozilla {
-namespace plugins {
-
-using layers::SurfaceDescriptorX11;
-
-enum ScriptableObjectType { LocalObject, Proxy };
-
-mozilla::ipc::RacyInterruptPolicy MediateRace(
-    const mozilla::ipc::MessageChannel::MessageInfo& parent,
-    const mozilla::ipc::MessageChannel::MessageInfo& child);
-
-std::string MungePluginDsoPath(const std::string& path);
-std::string UnmungePluginDsoPath(const std::string& munged);
-
-extern mozilla::LogModule* GetPluginLog();
-
-#if defined(_MSC_VER)
-#  define FULLFUNCTION __FUNCSIG__
-#elif defined(__GNUC__)
-#  define FULLFUNCTION __PRETTY_FUNCTION__
-#else
-#  define FULLFUNCTION __FUNCTION__
-#endif
-
-#define PLUGIN_LOG_DEBUG(args) \
-  MOZ_LOG(GetPluginLog(), mozilla::LogLevel::Debug, args)
-#define PLUGIN_LOG_DEBUG_FUNCTION \
-  MOZ_LOG(GetPluginLog(), mozilla::LogLevel::Debug, ("%s", FULLFUNCTION))
-#define PLUGIN_LOG_DEBUG_METHOD                     \
-  MOZ_LOG(GetPluginLog(), mozilla::LogLevel::Debug, \
-          ("%s [%p]", FULLFUNCTION, (void*)this))
-
-/**
- * This is NPByteRange without the linked list.
- */
-struct IPCByteRange {
-  int32_t offset;
-  uint32_t length;
-};
-
-typedef nsTArray<IPCByteRange> IPCByteRanges;
-
-typedef nsCString Buffer;
-
-struct NPRemoteWindow {
-  NPRemoteWindow();
-  uint64_t window;
-  int32_t x;
-  int32_t y;
-  uint32_t width;
-  uint32_t height;
-  NPRect clipRect;
-  NPWindowType type;
-#if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
-  VisualID visualID;
-  Colormap colormap;
-#endif /* XP_UNIX */
-#if defined(XP_MACOSX) || defined(XP_WIN)
-  double contentsScaleFactor;
-#endif
-};
-
-// This struct is like NPAudioDeviceChangeDetails, only it uses a
-// std::wstring instead of a const wchar_t* for the defaultDevice.
-// This gives us the necessary memory-ownership semantics without
-// requiring C++ objects in npapi.h.
-struct NPAudioDeviceChangeDetailsIPC {
-  int32_t flow;
-  int32_t role;
-  std::wstring defaultDevice;
-};
-
-struct NPAudioDeviceStateChangedIPC {
-  std::wstring device;
-  uint32_t state;
-};
-
-#ifdef XP_WIN
-typedef HWND NativeWindowHandle;
-#elif defined(MOZ_X11)
-typedef XID NativeWindowHandle;
-#elif defined(XP_DARWIN) || defined(ANDROID) || defined(MOZ_WAYLAND)
-typedef intptr_t NativeWindowHandle;  // never actually used, will always be 0
-#else
-#  error Need NativeWindowHandle for this platform
-#endif
-
-#ifdef XP_WIN
-typedef base::SharedMemoryHandle WindowsSharedMemoryHandle;
-typedef HANDLE DXGISharedSurfaceHandle;
-#else  // XP_WIN
-typedef mozilla::null_t WindowsSharedMemoryHandle;
-typedef mozilla::null_t DXGISharedSurfaceHandle;
-#endif
-
-// XXX maybe not the best place for these. better one?
-
-#define VARSTR(v_) \
-  case v_:         \
-    return #v_
-inline const char* NPPVariableToString(NPPVariable aVar) {
-  switch (aVar) {
-    VARSTR(NPPVpluginNameString);
-    VARSTR(NPPVpluginDescriptionString);
-    VARSTR(NPPVpluginWindowBool);
-    VARSTR(NPPVpluginTransparentBool);
-    VARSTR(NPPVjavaClass);
-    VARSTR(NPPVpluginWindowSize);
-    VARSTR(NPPVpluginTimerInterval);
-
-    VARSTR(NPPVpluginScriptableInstance);
-    VARSTR(NPPVpluginScriptableIID);
-
-    VARSTR(NPPVjavascriptPushCallerBool);
-
-    VARSTR(NPPVpluginKeepLibraryInMemory);
-    VARSTR(NPPVpluginNeedsXEmbed);
-
-    VARSTR(NPPVpluginScriptableNPObject);
-
-    VARSTR(NPPVformValue);
-
-    VARSTR(NPPVpluginUrlRequestsDisplayedBool);
-
-    VARSTR(NPPVpluginWantsAllNetworkStreams);
-
-#ifdef XP_MACOSX
-    VARSTR(NPPVpluginDrawingModel);
-    VARSTR(NPPVpluginEventModel);
-#endif
-
-#ifdef XP_WIN
-    VARSTR(NPPVpluginRequiresAudioDeviceChanges);
-#endif
-
-    default:
-      return "???";
-  }
-}
-
-inline const char* NPNVariableToString(NPNVariable aVar) {
-  switch (aVar) {
-    VARSTR(NPNVxDisplay);
-    VARSTR(NPNVxtAppContext);
-    VARSTR(NPNVnetscapeWindow);
-    VARSTR(NPNVjavascriptEnabledBool);
-    VARSTR(NPNVasdEnabledBool);
-    VARSTR(NPNVisOfflineBool);
-
-    VARSTR(NPNVserviceManager);
-    VARSTR(NPNVDOMElement);
-    VARSTR(NPNVDOMWindow);
-    VARSTR(NPNVToolkit);
-    VARSTR(NPNVSupportsXEmbedBool);
-
-    VARSTR(NPNVWindowNPObject);
-
-    VARSTR(NPNVPluginElementNPObject);
-
-    VARSTR(NPNVSupportsWindowless);
-
-    VARSTR(NPNVprivateModeBool);
-    VARSTR(NPNVdocumentOrigin);
-
-#ifdef XP_WIN
-    VARSTR(NPNVaudioDeviceChangeDetails);
-#endif
-
-    default:
-      return "???";
-  }
-}
-#undef VARSTR
-
-inline bool IsPluginThread() {
-  MessageLoop* loop = MessageLoop::current();
-  if (!loop) return false;
-  return (loop->type() == MessageLoop::TYPE_UI);
-}
-
-inline void AssertPluginThread() {
-  MOZ_RELEASE_ASSERT(IsPluginThread(),
-                     "Should be on the plugin's main thread!");
-}
-
-#define ENSURE_PLUGIN_THREAD(retval)                        \
-  PR_BEGIN_MACRO                                            \
-  if (!IsPluginThread()) {                                  \
-    NS_WARNING("Not running on the plugin's main thread!"); \
-    return (retval);                                        \
-  }                                                         \
-  PR_END_MACRO
-
-#define ENSURE_PLUGIN_THREAD_VOID()                         \
-  PR_BEGIN_MACRO                                            \
-  if (!IsPluginThread()) {                                  \
-    NS_WARNING("Not running on the plugin's main thread!"); \
-    return;                                                 \
-  }                                                         \
-  PR_END_MACRO
-
-void DeferNPObjectLastRelease(const NPNetscapeFuncs* f, NPObject* o);
-void DeferNPVariantLastRelease(const NPNetscapeFuncs* f, NPVariant* v);
-
-inline bool IsDrawingModelDirect(int16_t aModel) {
-  return aModel == NPDrawingModelAsyncBitmapSurface
-#if defined(XP_WIN)
-         || aModel == NPDrawingModelAsyncWindowsDXGISurface
-#endif
-      ;
-}
-
-// in NPAPI, char* == nullptr is sometimes meaningful.  the following is
-// helper code for dealing with nullable nsCString's
-inline nsCString NullableString(const char* aString) {
-  if (!aString) {
-    return VoidCString();
-  }
-  return nsCString(aString);
-}
-
-inline const char* NullableStringGet(const nsCString& str) {
-  if (str.IsVoid()) return nullptr;
-
-  return str.get();
-}
-
-struct DeletingObjectEntry : public nsPtrHashKey<NPObject> {
-  explicit DeletingObjectEntry(const NPObject* key)
-      : nsPtrHashKey<NPObject>(key), mDeleted(false) {}
-
-  bool mDeleted;
-};
-
-} /* namespace plugins */
-
-} /* namespace mozilla */
-
-namespace IPC {
-
-template <>
-struct ParamTraits<NPRect> {
-  typedef NPRect paramType;
-
-  static void Write(Message* aMsg, const paramType& aParam) {
-    WriteParam(aMsg, aParam.top);
-    WriteParam(aMsg, aParam.left);
-    WriteParam(aMsg, aParam.bottom);
-    WriteParam(aMsg, aParam.right);
-  }
-
-  static bool Read(const Message* aMsg, PickleIterator* aIter,
-                   paramType* aResult) {
-    uint16_t top, left, bottom, right;
-    if (ReadParam(aMsg, aIter, &top) && ReadParam(aMsg, aIter, &left) &&
-        ReadParam(aMsg, aIter, &bottom) && ReadParam(aMsg, aIter, &right)) {
-      aResult->top = top;
-      aResult->left = left;
-      aResult->bottom = bottom;
-      aResult->right = right;
-      return true;
-    }
-    return false;
-  }
-
-  static void Log(const paramType& aParam, std::wstring* aLog) {
-    aLog->append(StringPrintf(L"[%u, %u, %u, %u]", aParam.top, aParam.left,
-                              aParam.bottom, aParam.right));
-  }
-};
-
-template <>
-struct ParamTraits<NPWindowType>
-    : public ContiguousEnumSerializerInclusive<
-          NPWindowType, NPWindowType::NPWindowTypeWindow,
-          NPWindowType::NPWindowTypeDrawable> {};
-
-template <>
-struct ParamTraits<mozilla::plugins::NPRemoteWindow> {
-  typedef mozilla::plugins::NPRemoteWindow paramType;
-
-  static void Write(Message* aMsg, const paramType& aParam) {
-    aMsg->WriteUInt64(aParam.window);
-    WriteParam(aMsg, aParam.x);
-    WriteParam(aMsg, aParam.y);
-    WriteParam(aMsg, aParam.width);
-    WriteParam(aMsg, aParam.height);
-    WriteParam(aMsg, aParam.clipRect);
-    WriteParam(aMsg, aParam.type);
-#if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
-    aMsg->WriteULong(aParam.visualID);
-    aMsg->WriteULong(aParam.colormap);
-#endif
-#if defined(XP_MACOSX) || defined(XP_WIN)
-    aMsg->WriteDouble(aParam.contentsScaleFactor);
-#endif
-  }
-
-  static bool Read(const Message* aMsg, PickleIterator* aIter,
-                   paramType* aResult) {
-    uint64_t window;
-    int32_t x, y;
-    uint32_t width, height;
-    NPRect clipRect;
-    NPWindowType type;
-    if (!(aMsg->ReadUInt64(aIter, &window) && ReadParam(aMsg, aIter, &x) &&
-          ReadParam(aMsg, aIter, &y) && ReadParam(aMsg, aIter, &width) &&
-          ReadParam(aMsg, aIter, &height) &&
-          ReadParam(aMsg, aIter, &clipRect) && ReadParam(aMsg, aIter, &type)))
-      return false;
-
-#if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
-    unsigned long visualID;
-    unsigned long colormap;
-    if (!(aMsg->ReadULong(aIter, &visualID) &&
-          aMsg->ReadULong(aIter, &colormap)))
-      return false;
-#endif
-
-#if defined(XP_MACOSX) || defined(XP_WIN)
-    double contentsScaleFactor;
-    if (!aMsg->ReadDouble(aIter, &contentsScaleFactor)) return false;
-#endif
-
-    aResult->window = window;
-    aResult->x = x;
-    aResult->y = y;
-    aResult->width = width;
-    aResult->height = height;
-    aResult->clipRect = clipRect;
-    aResult->type = type;
-#if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
-    aResult->visualID = visualID;
-    aResult->colormap = colormap;
-#endif
-#if defined(XP_MACOSX) || defined(XP_WIN)
-    aResult->contentsScaleFactor = contentsScaleFactor;
-#endif
-    return true;
-  }
-
-  static void Log(const paramType& aParam, std::wstring* aLog) {
-    aLog->append(StringPrintf(L"[%u, %d, %d, %u, %u, %d",
-                              (unsigned long)aParam.window, aParam.x, aParam.y,
-                              aParam.width, aParam.height, (long)aParam.type));
-  }
-};
-
-#ifdef XP_MACOSX
-template <>
-struct ParamTraits<NPNSString*> {
-  // Empty string writes a length of 0 and no buffer.
-  // We don't write a nullptr terminating character in buffers.
-  static void Write(Message* aMsg, NPNSString* aParam) {
-    CFStringRef cfString = (CFStringRef)aParam;
-
-    // Write true if we have a string, false represents nullptr.
-    aMsg->WriteBool(!!cfString);
-    if (!cfString) {
-      return;
-    }
-
-    long length = ::CFStringGetLength(cfString);
-    WriteParam(aMsg, length);
-    if (length == 0) {
-      return;
-    }
-
-    // Attempt to get characters without any allocation/conversion.
-    if (::CFStringGetCharactersPtr(cfString)) {
-      aMsg->WriteBytes(::CFStringGetCharactersPtr(cfString),
-                       length * sizeof(UniChar));
-    } else {
-      UniChar* buffer = (UniChar*)moz_xmalloc(length * sizeof(UniChar));
-      ::CFStringGetCharacters(cfString, ::CFRangeMake(0, length), buffer);
-      aMsg->WriteBytes(buffer, length * sizeof(UniChar));
-      free(buffer);
-    }
-  }
-
-  static bool Read(const Message* aMsg, PickleIterator* aIter,
-                   NPNSString** aResult) {
-    bool haveString = false;
-    if (!aMsg->ReadBool(aIter, &haveString)) {
-      return false;
-    }
-    if (!haveString) {
-      *aResult = nullptr;
-      return true;
-    }
-
-    long length;
-    if (!ReadParam(aMsg, aIter, &length)) {
-      return false;
-    }
-
-    // Avoid integer multiplication overflow.
-    if (length > INT_MAX / static_cast<long>(sizeof(UniChar))) {
-      return false;
-    }
-
-    auto chars = mozilla::MakeUnique<UniChar[]>(length);
-    if (length != 0) {
-      if (!aMsg->ReadBytesInto(aIter, chars.get(), length * sizeof(UniChar))) {
-        return false;
-      }
-    }
-
-    *aResult = (NPNSString*)::CFStringCreateWithBytes(
-        kCFAllocatorDefault, (UInt8*)chars.get(), length * sizeof(UniChar),
-        kCFStringEncodingUTF16, false);
-    if (!*aResult) {
-      return false;
-    }
-
-    return true;
-  }
-};
-#endif
-
-template <>
-struct ParamTraits<mozilla::plugins::IPCByteRange> {
-  typedef mozilla::plugins::IPCByteRange paramType;
-
-  static void Write(Message* aMsg, const paramType& aParam) {
-    WriteParam(aMsg, aParam.offset);
-    WriteParam(aMsg, aParam.length);
-  }
-
-  static bool Read(const Message* aMsg, PickleIterator* aIter,
-                   paramType* aResult) {
-    paramType p;
-    if (ReadParam(aMsg, aIter, &p.offset) &&
-        ReadParam(aMsg, aIter, &p.length)) {
-      *aResult = p;
-      return true;
-    }
-    return false;
-  }
-};
-
-template <>
-struct ParamTraits<NPNVariable>
-    : public ContiguousEnumSerializer<NPNVariable, NPNVariable::NPNVxDisplay,
-                                      NPNVariable::NPNVLast> {};
-
-// The only accepted value is NPNURLVariable::NPNURLVProxy
-template <>
-struct ParamTraits<NPNURLVariable>
-    : public ContiguousEnumSerializerInclusive<NPNURLVariable,
-                                               NPNURLVariable::NPNURLVProxy,
-                                               NPNURLVariable::NPNURLVProxy> {};
-
-template <>
-struct ParamTraits<NPCoordinateSpace>
-    : public ContiguousEnumSerializerInclusive<
-          NPCoordinateSpace, NPCoordinateSpace::NPCoordinateSpacePlugin,
-          NPCoordinateSpace::NPCoordinateSpaceFlippedScreen> {};
-
-template <>
-struct ParamTraits<mozilla::plugins::NPAudioDeviceChangeDetailsIPC> {
-  typedef mozilla::plugins::NPAudioDeviceChangeDetailsIPC paramType;
-
-  static void Write(Message* aMsg, const paramType& aParam) {
-    WriteParam(aMsg, aParam.flow);
-    WriteParam(aMsg, aParam.role);
-    WriteParam(aMsg, aParam.defaultDevice);
-  }
-
-  static bool Read(const Message* aMsg, PickleIterator* aIter,
-                   paramType* aResult) {
-    int32_t flow, role;
-    std::wstring defaultDevice;
-    if (ReadParam(aMsg, aIter, &flow) && ReadParam(aMsg, aIter, &role) &&
-        ReadParam(aMsg, aIter, &defaultDevice)) {
-      aResult->flow = flow;
-      aResult->role = role;
-      aResult->defaultDevice = defaultDevice;
-      return true;
-    }
-    return false;
-  }
-
-  static void Log(const paramType& aParam, std::wstring* aLog) {
-    aLog->append(StringPrintf(L"[%d, %d, %S]", aParam.flow, aParam.role,
-                              aParam.defaultDevice.c_str()));
-  }
-};
-
-template <>
-struct ParamTraits<mozilla::plugins::NPAudioDeviceStateChangedIPC> {
-  typedef mozilla::plugins::NPAudioDeviceStateChangedIPC paramType;
-
-  static void Write(Message* aMsg, const paramType& aParam) {
-    WriteParam(aMsg, aParam.device);
-    WriteParam(aMsg, aParam.state);
-  }
-
-  static bool Read(const Message* aMsg, PickleIterator* aIter,
-                   paramType* aResult) {
-    int32_t state;
-    std::wstring device;
-    if (ReadParam(aMsg, aIter, &device) && ReadParam(aMsg, aIter, &state)) {
-      aResult->device = device;
-      aResult->state = state;
-      return true;
-    }
-    return false;
-  }
-
-  static void Log(const paramType& aParam, std::wstring* aLog) {
-    aLog->append(StringPrintf(L"[%S,%d]", aParam.device.c_str(), aParam.state));
-  }
-};
-} /* namespace IPC */
-
-// Serializing NPEvents is completely platform-specific and can be rather
-// intricate depending on the platform.  So for readability we split it
-// into separate files and have the only macro crud live here.
-//
-// NB: these guards are based on those where struct NPEvent is defined
-// in npapi.h.  They should be kept in sync.
-#if defined(XP_MACOSX)
-#  include "mozilla/plugins/NPEventOSX.h"
-#elif defined(XP_WIN)
-#  include "mozilla/plugins/NPEventWindows.h"
-#elif defined(ANDROID)
-#  include "mozilla/plugins/NPEventAndroid.h"
-#elif defined(XP_UNIX)
-#  include "mozilla/plugins/NPEventUnix.h"
-#else
-#  error Unsupported platform
-#endif
-
-#endif /* DOM_PLUGINS_PLUGINMESSAGEUTILS_H */
diff --git a/dom/plugins/ipc/PluginModuleChild.cpp b/dom/plugins/ipc/PluginModuleChild.cpp
deleted file mode 100644
index 0d00f020df357..0000000000000
--- a/dom/plugins/ipc/PluginModuleChild.cpp
+++ /dev/null
@@ -1,1978 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set sw=2 ts=4 et : */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "mozilla/plugins/PluginModuleChild.h"
-
-/* This must occur *after* plugins/PluginModuleChild.h to avoid typedefs
- * conflicts. */
-#include "mozilla/ArrayUtils.h"
-
-#include "mozilla/ipc/MessageChannel.h"
-
-#ifdef MOZ_WIDGET_GTK
-#  include "mozilla/WidgetUtilsGtk.h"
-#  include <gtk/gtk.h>
-#  include <gdk/gdkx.h>
-#endif
-
-#include "nsIFile.h"
-
-#include "pratom.h"
-#include "nsDebug.h"
-#include "nsCOMPtr.h"
-#include "nsPluginsDir.h"
-#include "nsXULAppAPI.h"
-
-#ifdef MOZ_X11
-#  include "nsX11ErrorHandler.h"
-#  include "mozilla/X11Util.h"
-#endif
-
-#include "mozilla/ipc/CrashReporterClient.h"
-#include "mozilla/ipc/Endpoint.h"
-#include "mozilla/ipc/ProcessChild.h"
-#include "mozilla/plugins/PluginInstanceChild.h"
-#include "mozilla/plugins/StreamNotifyChild.h"
-#include "mozilla/plugins/BrowserStreamChild.h"
-#include "mozilla/Sprintf.h"
-#include "mozilla/Unused.h"
-
-#include "nsNPAPIPlugin.h"
-#include "FunctionHook.h"
-#include "FunctionBrokerChild.h"
-
-#ifdef XP_WIN
-#  include "mozilla/widget/AudioSession.h"
-#  include <knownfolders.h>
-#endif
-
-#ifdef MOZ_WIDGET_COCOA
-#  include "PluginUtilsOSX.h"
-#endif
-
-#ifdef MOZ_GECKO_PROFILER
-#  include "ChildProfilerController.h"
-#endif
-
-#if defined(XP_MACOSX) && defined(MOZ_SANDBOX)
-#  include "mozilla/Sandbox.h"
-#endif
-
-using namespace mozilla;
-using namespace mozilla::ipc;
-using namespace mozilla::plugins;
-using namespace mozilla::widget;
-
-#if defined(XP_WIN)
-const wchar_t* kFlashFullscreenClass = L"ShockwaveFlashFullScreen";
-#  if defined(MOZ_SANDBOX)
-std::wstring sRoamingPath;
-#  endif
-#endif
-
-namespace {
-// see PluginModuleChild::GetChrome()
-PluginModuleChild* gChromeInstance = nullptr;
-}  // namespace
-
-#ifdef XP_WIN
-// Used with fix for flash fullscreen window loosing focus.
-static bool gDelayFlashFocusReplyUntilEval = false;
-#endif
-
-/* static */
-bool PluginModuleChild::CreateForContentProcess(
-    Endpoint<PPluginModuleChild>&& aEndpoint) {
-  auto* child = new PluginModuleChild(false);
-  return child->InitForContent(std::move(aEndpoint));
-}
-
-PluginModuleChild::PluginModuleChild(bool aIsChrome)
-    : mLibrary(0),
-      mPluginFilename(""),
-      mQuirks(QUIRKS_NOT_INITIALIZED),
-      mIsChrome(aIsChrome),
-      mHasShutdown(false),
-      mShutdownFunc(0),
-      mInitializeFunc(0)
-#if defined(OS_WIN) || defined(OS_MACOSX)
-      ,
-      mGetEntryPointsFunc(0)
-#elif defined(MOZ_WIDGET_GTK)
-      ,
-      mNestedLoopTimerId(0)
-#endif
-#ifdef OS_WIN
-      ,
-      mNestedEventHook(nullptr),
-      mGlobalCallWndProcHook(nullptr),
-      mAsyncRenderSupport(false)
-#endif
-#if defined(XP_MACOSX) && defined(MOZ_SANDBOX)
-      ,
-      mFlashSandboxLevel(0),
-      mEnableFlashSandboxLogging(false)
-#endif
-{
-  memset(&mFunctions, 0, sizeof(mFunctions));
-  if (mIsChrome) {
-    MOZ_ASSERT(!gChromeInstance);
-    gChromeInstance = this;
-  }
-}
-
-PluginModuleChild::~PluginModuleChild() {
-  if (mIsChrome) {
-    MOZ_ASSERT(gChromeInstance == this);
-
-    // We don't unload the plugin library in case it uses atexit handlers or
-    // other similar hooks.
-
-    DeinitGraphics();
-    PluginScriptableObjectChild::ClearIdentifiers();
-
-    gChromeInstance = nullptr;
-  }
-}
-
-// static
-PluginModuleChild* PluginModuleChild::GetChrome() {
-  // A special PluginModuleChild instance that talks to the chrome process
-  // during startup and shutdown. Synchronous messages to or from this actor
-  // should be avoided because they may lead to hangs.
-  MOZ_ASSERT(gChromeInstance);
-  return gChromeInstance;
-}
-
-void PluginModuleChild::CommonInit() {
-  PLUGIN_LOG_DEBUG_METHOD;
-
-  // Request Windows message deferral behavior on our channel. This
-  // applies to the top level and all sub plugin protocols since they
-  // all share the same channel.
-  // Bug 1090573 - Don't do this for connections to content processes.
-  GetIPCChannel()->SetChannelFlags(
-      MessageChannel::REQUIRE_DEFERRED_MESSAGE_PROTECTION);
-
-  memset((void*)&mFunctions, 0, sizeof(mFunctions));
-  mFunctions.size = sizeof(mFunctions);
-  mFunctions.version = (NP_VERSION_MAJOR << 8) | NP_VERSION_MINOR;
-}
-
-bool PluginModuleChild::InitForContent(
-    Endpoint<PPluginModuleChild>&& aEndpoint) {
-  CommonInit();
-
-  if (!aEndpoint.Bind(this)) {
-    return false;
-  }
-
-  mLibrary = GetChrome()->mLibrary;
-  mFunctions = GetChrome()->mFunctions;
-
-  return true;
-}
-
-mozilla::ipc::IPCResult PluginModuleChild::RecvInitProfiler(
-    Endpoint<mozilla::PProfilerChild>&& aEndpoint) {
-#ifdef MOZ_GECKO_PROFILER
-  mProfilerController = ChildProfilerController::Create(std::move(aEndpoint));
-#endif
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginModuleChild::RecvDisableFlashProtectedMode() {
-  MOZ_ASSERT(mIsChrome);
-#ifdef XP_WIN
-  FunctionHook::HookProtectedMode();
-#else
-  MOZ_ASSERT(false, "Should not be called");
-#endif
-  return IPC_OK();
-}
-
-#if defined(XP_MACOSX) && defined(MOZ_SANDBOX)
-void PluginModuleChild::EnableFlashSandbox(int aLevel,
-                                           bool aShouldEnableLogging) {
-  mFlashSandboxLevel = aLevel;
-  mEnableFlashSandboxLogging = aShouldEnableLogging;
-}
-#endif
-
-#if defined(OS_WIN) && defined(MOZ_SANDBOX)
-/* static */
-void PluginModuleChild::SetFlashRoamingPath(const std::wstring& aRoamingPath) {
-  MOZ_ASSERT(sRoamingPath.empty());
-  sRoamingPath = aRoamingPath;
-}
-
-/* static */ std::wstring PluginModuleChild::GetFlashRoamingPath() {
-  return sRoamingPath;
-}
-#endif
-
-bool PluginModuleChild::InitForChrome(const std::string& aPluginFilename,
-                                      base::ProcessId aParentPid,
-                                      MessageLoop* aIOLoop,
-                                      UniquePtr<IPC::Channel> aChannel) {
-  NS_ASSERTION(aChannel, "need a channel");
-
-#if defined(OS_WIN) && defined(MOZ_SANDBOX)
-  MOZ_ASSERT(!sRoamingPath.empty(),
-             "Should have already called SetFlashRoamingPath");
-#endif
-
-  if (!InitGraphics()) return false;
-
-  mPluginFilename = aPluginFilename.c_str();
-  nsCOMPtr<nsIFile> localFile;
-  NS_NewLocalFile(NS_ConvertUTF8toUTF16(mPluginFilename), true,
-                  getter_AddRefs(localFile));
-
-  if (!localFile) return false;
-
-  bool exists;
-  localFile->Exists(&exists);
-  NS_ASSERTION(exists, "plugin file ain't there");
-
-  nsPluginFile pluginFile(localFile);
-
-  nsPluginInfo info = nsPluginInfo();
-  if (NS_FAILED(pluginFile.GetPluginInfo(info, &mLibrary))) {
-    return false;
-  }
-
-#if defined(XP_WIN)
-  // XXX quirks isn't initialized yet
-  mAsyncRenderSupport = info.fSupportsAsyncRender;
-#endif
-#if defined(MOZ_X11)
-  constexpr auto flash10Head = "Shockwave Flash 10."_ns;
-  if (StringBeginsWith(nsDependentCString(info.fDescription), flash10Head)) {
-    AddQuirk(QUIRK_FLASH_EXPOSE_COORD_TRANSLATION);
-  }
-#endif
-#if defined(XP_MACOSX)
-  const char* namePrefix = "Plugin Content";
-  char nameBuffer[80];
-  SprintfLiteral(nameBuffer, "%s (%s)", namePrefix, info.fName);
-  mozilla::plugins::PluginUtilsOSX::SetProcessName(nameBuffer);
-#endif
-  pluginFile.FreePluginInfo(info);
-#if defined(MOZ_X11) || defined(XP_MACOSX)
-  if (!mLibrary)
-#endif
-  {
-    nsresult rv = pluginFile.LoadPlugin(&mLibrary);
-    if (NS_FAILED(rv)) return false;
-  }
-  NS_ASSERTION(mLibrary, "couldn't open shared object");
-
-  CommonInit();
-
-  if (!Open(std::move(aChannel), aParentPid, aIOLoop)) {
-    return false;
-  }
-
-  GetIPCChannel()->SetAbortOnError(true);
-
-#if defined(OS_LINUX) || defined(OS_BSD) || defined(OS_SOLARIS)
-  mShutdownFunc =
-      (NP_PLUGINSHUTDOWN)PR_FindFunctionSymbol(mLibrary, "NP_Shutdown");
-
-  // create the new plugin handler
-
-  mInitializeFunc =
-      (NP_PLUGINUNIXINIT)PR_FindFunctionSymbol(mLibrary, "NP_Initialize");
-  NS_ASSERTION(mInitializeFunc, "couldn't find NP_Initialize()");
-
-#elif defined(OS_WIN) || defined(OS_MACOSX)
-  mShutdownFunc =
-      (NP_PLUGINSHUTDOWN)PR_FindFunctionSymbol(mLibrary, "NP_Shutdown");
-
-  mGetEntryPointsFunc =
-      (NP_GETENTRYPOINTS)PR_FindSymbol(mLibrary, "NP_GetEntryPoints");
-  NS_ENSURE_TRUE(mGetEntryPointsFunc, false);
-
-  mInitializeFunc =
-      (NP_PLUGININIT)PR_FindFunctionSymbol(mLibrary, "NP_Initialize");
-  NS_ENSURE_TRUE(mInitializeFunc, false);
-#else
-
-#  error Please copy the initialization code from nsNPAPIPlugin.cpp
-
-#endif
-
-#if defined(XP_MACOSX) && defined(MOZ_SANDBOX)
-  if (mFlashSandboxLevel > 0) {
-    MacSandboxInfo flashSandboxInfo;
-    flashSandboxInfo.type = MacSandboxType_Flash;
-    flashSandboxInfo.pluginBinaryPath = aPluginFilename;
-    flashSandboxInfo.level = mFlashSandboxLevel;
-    flashSandboxInfo.shouldLog = mEnableFlashSandboxLogging;
-
-    std::string sbError;
-    if (!mozilla::StartMacSandbox(flashSandboxInfo, sbError)) {
-      fprintf(stderr, "Failed to start sandbox:\n%s\n", sbError.c_str());
-      return false;
-    }
-  }
-#endif
-
-  return true;
-}
-
-#if defined(MOZ_WIDGET_GTK)
-
-typedef void (*GObjectDisposeFn)(GObject*);
-typedef gboolean (*GtkWidgetScrollEventFn)(GtkWidget*, GdkEventScroll*);
-typedef void (*GtkPlugEmbeddedFn)(GtkPlug*);
-
-static GObjectDisposeFn real_gtk_plug_dispose;
-static GtkPlugEmbeddedFn real_gtk_plug_embedded;
-
-static void undo_bogus_unref(gpointer data, GObject* object,
-                             gboolean is_last_ref) {
-  if (!is_last_ref)  // recursion in g_object_ref
-    return;
-
-  g_object_ref(object);
-}
-
-static void wrap_gtk_plug_dispose(GObject* object) {
-  // Work around Flash Player bug described in bug 538914.
-  //
-  // This function is called during gtk_widget_destroy and/or before
-  // the object's last reference is removed.  A reference to the
-  // object is held during the call so the ref count should not drop
-  // to zero.  However, Flash Player tries to destroy the GtkPlug
-  // using g_object_unref instead of gtk_widget_destroy.  The
-  // reference that Flash is removing actually belongs to the
-  // GtkPlug.  During real_gtk_plug_dispose, the GtkPlug removes its
-  // reference.
-  //
-  // A toggle ref is added to prevent premature deletion of the object
-  // caused by Flash Player's extra unref, and to detect when there are
-  // unexpectedly no other references.
-  g_object_add_toggle_ref(object, undo_bogus_unref, nullptr);
-  (*real_gtk_plug_dispose)(object);
-  g_object_remove_toggle_ref(object, undo_bogus_unref, nullptr);
-}
-
-static gboolean gtk_plug_scroll_event(GtkWidget* widget,
-                                      GdkEventScroll* gdk_event) {
-  if (!gtk_widget_is_toplevel(widget))  // in same process as its GtkSocket
-    return FALSE;  // event not handled; propagate to GtkSocket
-
-  GdkWindow* socket_window = gtk_plug_get_socket_window(GTK_PLUG(widget));
-  if (!socket_window) return FALSE;
-
-  // Propagate the event to the embedder.
-  GdkScreen* screen = gdk_window_get_screen(socket_window);
-  GdkWindow* plug_window = gtk_widget_get_window(widget);
-  GdkWindow* event_window = gdk_event->window;
-  gint x = gdk_event->x;
-  gint y = gdk_event->y;
-  unsigned int button;
-  unsigned int button_mask = 0;
-  XEvent xevent;
-  Display* dpy = GDK_WINDOW_XDISPLAY(socket_window);
-
-  /* Translate the event coordinates to the plug window,
-   * which should be aligned with the socket window.
-   */
-  while (event_window != plug_window) {
-    gint dx, dy;
-
-    gdk_window_get_position(event_window, &dx, &dy);
-    x += dx;
-    y += dy;
-
-    event_window = gdk_window_get_parent(event_window);
-    if (!event_window) return FALSE;
-  }
-
-  switch (gdk_event->direction) {
-    case GDK_SCROLL_UP:
-      button = 4;
-      button_mask = Button4Mask;
-      break;
-    case GDK_SCROLL_DOWN:
-      button = 5;
-      button_mask = Button5Mask;
-      break;
-    case GDK_SCROLL_LEFT:
-      button = 6;
-      break;
-    case GDK_SCROLL_RIGHT:
-      button = 7;
-      break;
-    default:
-      return FALSE;  // unknown GdkScrollDirection
-  }
-
-  memset(&xevent, 0, sizeof(xevent));
-  xevent.xbutton.type = ButtonPress;
-  xevent.xbutton.window = gdk_x11_window_get_xid(socket_window);
-  xevent.xbutton.root =
-      gdk_x11_window_get_xid(gdk_screen_get_root_window(screen));
-  xevent.xbutton.subwindow = gdk_x11_window_get_xid(plug_window);
-  xevent.xbutton.time = gdk_event->time;
-  xevent.xbutton.x = x;
-  xevent.xbutton.y = y;
-  xevent.xbutton.x_root = gdk_event->x_root;
-  xevent.xbutton.y_root = gdk_event->y_root;
-  xevent.xbutton.state = gdk_event->state;
-  xevent.xbutton.button = button;
-  xevent.xbutton.same_screen = X11True;
-
-  gdk_error_trap_push();
-
-  XSendEvent(dpy, xevent.xbutton.window, X11True, ButtonPressMask, &xevent);
-
-  xevent.xbutton.type = ButtonRelease;
-  xevent.xbutton.state |= button_mask;
-  XSendEvent(dpy, xevent.xbutton.window, X11True, ButtonReleaseMask, &xevent);
-
-  gdk_display_sync(gdk_screen_get_display(screen));
-  gdk_error_trap_pop();
-
-  return TRUE;  // event handled
-}
-
-static void wrap_gtk_plug_embedded(GtkPlug* plug) {
-  GdkWindow* socket_window = gtk_plug_get_socket_window(plug);
-  if (socket_window) {
-    if (gtk_check_version(2, 18, 7) != nullptr  // older
-        && g_object_get_data(G_OBJECT(socket_window),
-                             "moz-existed-before-set-window")) {
-      // Add missing reference for
-      // https://bugzilla.gnome.org/show_bug.cgi?id=607061
-      g_object_ref(socket_window);
-    }
-
-    // Ensure the window exists to make this GtkPlug behave like an
-    // in-process GtkPlug for Flash Player.  (Bugs 561308 and 539138).
-    gtk_widget_realize(GTK_WIDGET(plug));
-  }
-
-  if (*real_gtk_plug_embedded) {
-    (*real_gtk_plug_embedded)(plug);
-  }
-}
-
-//
-// The next four constants are knobs that can be tuned.  They trade
-// off potential UI lag from delayed event processing with CPU time.
-//
-static const gint kNestedLoopDetectorPriority = G_PRIORITY_HIGH_IDLE;
-// 90ms so that we can hopefully break livelocks before the user
-// notices UI lag (100ms)
-static const guint kNestedLoopDetectorIntervalMs = 90;
-
-static const gint kBrowserEventPriority = G_PRIORITY_HIGH_IDLE;
-static const guint kBrowserEventIntervalMs = 10;
-
-// static
-gboolean PluginModuleChild::DetectNestedEventLoop(gpointer data) {
-  PluginModuleChild* pmc = static_cast<PluginModuleChild*>(data);
-
-  MOZ_ASSERT(0 != pmc->mNestedLoopTimerId, "callback after descheduling");
-  MOZ_ASSERT(pmc->mTopLoopDepth < g_main_depth(),
-             "not canceled before returning to main event loop!");
-
-  PLUGIN_LOG_DEBUG(("Detected nested glib event loop"));
-
-  // just detected a nested loop; start a timer that will
-  // periodically rpc-call back into the browser and process some
-  // events
-  pmc->mNestedLoopTimerId = g_timeout_add_full(
-      kBrowserEventPriority, kBrowserEventIntervalMs,
-      PluginModuleChild::ProcessBrowserEvents, data, nullptr);
-  // cancel the nested-loop detection timer
-  return FALSE;
-}
-
-// static
-gboolean PluginModuleChild::ProcessBrowserEvents(gpointer data) {
-  PluginModuleChild* pmc = static_cast<PluginModuleChild*>(data);
-
-  MOZ_ASSERT(pmc->mTopLoopDepth < g_main_depth(),
-             "not canceled before returning to main event loop!");
-
-  pmc->CallProcessSomeEvents();
-
-  return TRUE;
-}
-
-void PluginModuleChild::EnteredCxxStack() {
-  MOZ_ASSERT(0 == mNestedLoopTimerId, "previous timer not descheduled");
-
-  mNestedLoopTimerId = g_timeout_add_full(
-      kNestedLoopDetectorPriority, kNestedLoopDetectorIntervalMs,
-      PluginModuleChild::DetectNestedEventLoop, this, nullptr);
-
-#  ifdef DEBUG
-  mTopLoopDepth = g_main_depth();
-#  endif
-}
-
-void PluginModuleChild::ExitedCxxStack() {
-  MOZ_ASSERT(0 < mNestedLoopTimerId, "nested loop timeout not scheduled");
-
-  g_source_remove(mNestedLoopTimerId);
-  mNestedLoopTimerId = 0;
-}
-
-#endif
-
-mozilla::ipc::IPCResult PluginModuleChild::RecvSetParentHangTimeout(
-    const uint32_t& aSeconds) {
-#ifdef XP_WIN
-  SetReplyTimeoutMs(((aSeconds > 0) ? (1000 * aSeconds) : 0));
-#endif
-  return IPC_OK();
-}
-
-bool PluginModuleChild::ShouldContinueFromReplyTimeout() {
-#ifdef XP_WIN
-  MOZ_CRASH("terminating child process");
-#endif
-  return true;
-}
-
-bool PluginModuleChild::InitGraphics() {
-#if defined(MOZ_WIDGET_GTK)
-  // Work around plugins that don't interact well with GDK
-  // client-side windows.
-  PR_SetEnv("GDK_NATIVE_WINDOWS=1");
-
-  gtk_init(0, 0);
-
-  // GtkPlug is a static class so will leak anyway but this ref makes sure.
-  gpointer gtk_plug_class = g_type_class_ref(GTK_TYPE_PLUG);
-
-  // The dispose method is a good place to hook into the destruction process
-  // because the reference count should be 1 the last time dispose is
-  // called.  (Toggle references wouldn't detect if the reference count
-  // might be higher.)
-  GObjectDisposeFn* dispose = &G_OBJECT_CLASS(gtk_plug_class)->dispose;
-  MOZ_ASSERT(*dispose != wrap_gtk_plug_dispose, "InitGraphics called twice");
-  real_gtk_plug_dispose = *dispose;
-  *dispose = wrap_gtk_plug_dispose;
-
-  // If we ever stop setting GDK_NATIVE_WINDOWS, we'll also need to
-  // gtk_widget_add_events GDK_SCROLL_MASK or GDK client-side windows will
-  // not tell us about the scroll events that it intercepts.  With native
-  // windows, this is called when GDK intercepts the events; if GDK doesn't
-  // intercept the events, then the X server will instead send them directly
-  // to an ancestor (embedder) window.
-  GtkWidgetScrollEventFn* scroll_event =
-      &GTK_WIDGET_CLASS(gtk_plug_class)->scroll_event;
-  if (!*scroll_event) {
-    *scroll_event = gtk_plug_scroll_event;
-  }
-
-  GtkPlugEmbeddedFn* embedded = &GTK_PLUG_CLASS(gtk_plug_class)->embedded;
-  real_gtk_plug_embedded = *embedded;
-  *embedded = wrap_gtk_plug_embedded;
-
-#else
-  // may not be necessary on all platforms
-#endif
-#ifdef MOZ_X11
-  // Do this after initializing GDK, or GDK will install its own handler.
-  InstallX11ErrorHandler();
-#endif
-  return true;
-}
-
-void PluginModuleChild::DeinitGraphics() {
-#if defined(MOZ_X11) && defined(NS_FREE_PERMANENT_DATA)
-  // We free some data off of XDisplay close hooks, ensure they're
-  // run.  Closing the display is pretty scary, so we only do it to
-  // silence leak checkers.
-  XCloseDisplay(DefaultXDisplay());
-#endif
-}
-
-NPError PluginModuleChild::NP_Shutdown() {
-  AssertPluginThread();
-  MOZ_ASSERT(mIsChrome);
-
-  if (mHasShutdown) {
-    return NPERR_NO_ERROR;
-  }
-
-#if defined XP_WIN
-  mozilla::widget::StopAudioSession();
-#endif
-
-  // the PluginModuleParent shuts down this process after this interrupt
-  // call pops off its stack
-
-  NPError rv = mShutdownFunc ? mShutdownFunc() : NPERR_NO_ERROR;
-
-  // weakly guard against re-entry after NP_Shutdown
-  memset(&mFunctions, 0, sizeof(mFunctions));
-
-#ifdef OS_WIN
-  ResetEventHooks();
-#endif
-
-  GetIPCChannel()->SetAbortOnError(false);
-
-  mHasShutdown = true;
-
-  return rv;
-}
-
-mozilla::ipc::IPCResult PluginModuleChild::AnswerNP_Shutdown(NPError* rv) {
-  *rv = NP_Shutdown();
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginModuleChild::AnswerOptionalFunctionsSupported(
-    bool* aURLRedirectNotify, bool* aClearSiteData, bool* aGetSitesWithData) {
-  *aURLRedirectNotify = !!mFunctions.urlredirectnotify;
-  *aClearSiteData = !!mFunctions.clearsitedata;
-  *aGetSitesWithData = !!mFunctions.getsiteswithdata;
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginModuleChild::RecvNPP_ClearSiteData(
-    const nsCString& aSite, const uint64_t& aFlags, const uint64_t& aMaxAge,
-    const uint64_t& aCallbackId) {
-  NPError result =
-      mFunctions.clearsitedata(NullableStringGet(aSite), aFlags, aMaxAge);
-  SendReturnClearSiteData(result, aCallbackId);
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginModuleChild::RecvNPP_GetSitesWithData(
-    const uint64_t& aCallbackId) {
-  char** result = mFunctions.getsiteswithdata();
-  nsTArray<nsCString> array;
-  if (!result) {
-    SendReturnSitesWithData(array, aCallbackId);
-    return IPC_OK();
-  }
-  char** iterator = result;
-  while (*iterator) {
-    array.AppendElement(*iterator);
-    free(*iterator);
-    ++iterator;
-  }
-  SendReturnSitesWithData(array, aCallbackId);
-  free(result);
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginModuleChild::RecvSetAudioSessionData(
-    const nsID& aId, const nsString& aDisplayName, const nsString& aIconPath) {
-#if !defined XP_WIN
-  MOZ_CRASH("Not Reached!");
-#else
-  nsresult rv =
-      mozilla::widget::RecvAudioSessionData(aId, aDisplayName, aIconPath);
-  NS_ENSURE_SUCCESS(rv, IPC_OK());  // Bail early if this fails
-
-  // Ignore failures here; we can't really do anything about them
-  mozilla::widget::StartAudioSession();
-  return IPC_OK();
-#endif
-}
-
-mozilla::ipc::IPCResult PluginModuleChild::RecvInitPluginModuleChild(
-    Endpoint<PPluginModuleChild>&& aEndpoint) {
-  if (!CreateForContentProcess(std::move(aEndpoint))) {
-    return IPC_FAIL(this, "CreateForContentProcess failed");
-  }
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginModuleChild::RecvInitPluginFunctionBroker(
-    Endpoint<PFunctionBrokerChild>&& aEndpoint) {
-#if defined(XP_WIN)
-  MOZ_ASSERT(mIsChrome);
-  if (!FunctionBrokerChild::Initialize(std::move(aEndpoint))) {
-    return IPC_FAIL(
-        this, "InitPluginFunctionBroker failed to initialize broker child.");
-  }
-  return IPC_OK();
-#else
-  return IPC_FAIL(this,
-                  "InitPluginFunctionBroker not supported on this platform.");
-#endif
-}
-
-mozilla::ipc::IPCResult PluginModuleChild::AnswerInitCrashReporter(
-    mozilla::dom::NativeThreadId* aOutId) {
-  CrashReporterClient::InitSingleton();
-  *aOutId = CrashReporter::CurrentThreadId();
-
-  return IPC_OK();
-}
-
-void PluginModuleChild::ActorDestroy(ActorDestroyReason why) {
-#ifdef MOZ_GECKO_PROFILER
-  if (mProfilerController) {
-    mProfilerController->Shutdown();
-    mProfilerController = nullptr;
-  }
-#endif
-
-  if (!mIsChrome) {
-    PluginModuleChild* chromeInstance = PluginModuleChild::GetChrome();
-    if (chromeInstance) {
-      chromeInstance->SendNotifyContentModuleDestroyed();
-    }
-
-    // Destroy ourselves once we finish other teardown activities.
-    RefPtr<DeleteTask<PluginModuleChild>> task =
-        new DeleteTask<PluginModuleChild>(this);
-    MessageLoop::current()->PostTask(task.forget());
-    return;
-  }
-
-  if (AbnormalShutdown == why) {
-    NS_WARNING("shutting down early because of crash!");
-    ProcessChild::QuickExit();
-  }
-
-  if (!mHasShutdown) {
-    MOZ_ASSERT(gChromeInstance == this);
-    NP_Shutdown();
-  }
-
-#if defined(XP_WIN)
-  FunctionBrokerChild::Destroy();
-  FunctionHook::ClearDllInterceptorCache();
-#endif
-
-  // doesn't matter why we're being destroyed; it's up to us to
-  // initiate (clean) shutdown
-  CrashReporterClient::DestroySingleton();
-
-  XRE_ShutdownChildProcess();
-}
-
-void PluginModuleChild::CleanUp() {}
-
-const char* PluginModuleChild::GetUserAgent() {
-  return NullableStringGet(Settings().userAgent());
-}
-
-//-----------------------------------------------------------------------------
-// FIXME/cjones: just getting this out of the way for the moment ...
-
-namespace mozilla::plugins::child {
-
-static NPError _requestread(NPStream* pstream, NPByteRange* rangeList);
-
-static NPError _geturlnotify(NPP aNPP, const char* relativeURL,
-                             const char* target, void* notifyData);
-
-static NPError _getvalue(NPP aNPP, NPNVariable variable, void* r_value);
-
-static NPError _setvalue(NPP aNPP, NPPVariable variable, void* r_value);
-
-static NPError _geturl(NPP aNPP, const char* relativeURL, const char* target);
-
-static NPError _posturlnotify(NPP aNPP, const char* relativeURL,
-                              const char* target, uint32_t len, const char* buf,
-                              NPBool file, void* notifyData);
-
-static NPError _posturl(NPP aNPP, const char* relativeURL, const char* target,
-                        uint32_t len, const char* buf, NPBool file);
-
-static void _status(NPP aNPP, const char* message);
-
-static void _memfree(void* ptr);
-
-static uint32_t _memflush(uint32_t size);
-
-static void _reloadplugins(NPBool reloadPages);
-
-static void _invalidaterect(NPP aNPP, NPRect* invalidRect);
-
-static void _invalidateregion(NPP aNPP, NPRegion invalidRegion);
-
-static void _forceredraw(NPP aNPP);
-
-static const char* _useragent(NPP aNPP);
-
-static void* _memalloc(uint32_t size);
-
-// Deprecated entry points for the old Java plugin.
-static void* /* OJI type: JRIEnv* */
-_getjavaenv(void);
-
-// Deprecated entry points for the old Java plugin.
-static void* /* OJI type: jref */
-_getjavapeer(NPP aNPP);
-
-static bool _invoke(NPP aNPP, NPObject* npobj, NPIdentifier method,
-                    const NPVariant* args, uint32_t argCount,
-                    NPVariant* result);
-
-static bool _invokedefault(NPP aNPP, NPObject* npobj, const NPVariant* args,
-                           uint32_t argCount, NPVariant* result);
-
-static bool _evaluate(NPP aNPP, NPObject* npobj, NPString* script,
-                      NPVariant* result);
-
-static bool _getproperty(NPP aNPP, NPObject* npobj, NPIdentifier property,
-                         NPVariant* result);
-
-static bool _setproperty(NPP aNPP, NPObject* npobj, NPIdentifier property,
-                         const NPVariant* value);
-
-static bool _removeproperty(NPP aNPP, NPObject* npobj, NPIdentifier property);
-
-static bool _hasproperty(NPP aNPP, NPObject* npobj, NPIdentifier propertyName);
-
-static bool _hasmethod(NPP aNPP, NPObject* npobj, NPIdentifier methodName);
-
-static bool _enumerate(NPP aNPP, NPObject* npobj, NPIdentifier** identifier,
-                       uint32_t* count);
-
-static bool _construct(NPP aNPP, NPObject* npobj, const NPVariant* args,
-                       uint32_t argCount, NPVariant* result);
-
-static void _releasevariantvalue(NPVariant* variant);
-
-static void _setexception(NPObject* npobj, const NPUTF8* message);
-
-static void _pushpopupsenabledstate(NPP aNPP, NPBool enabled);
-
-static void _poppopupsenabledstate(NPP aNPP);
-
-static NPError _getvalueforurl(NPP npp, NPNURLVariable variable,
-                               const char* url, char** value, uint32_t* len);
-
-static NPError _setvalueforurl(NPP npp, NPNURLVariable variable,
-                               const char* url, const char* value,
-                               uint32_t len);
-
-static uint32_t _scheduletimer(NPP instance, uint32_t interval, NPBool repeat,
-                               void (*timerFunc)(NPP npp, uint32_t timerID));
-
-static void _unscheduletimer(NPP instance, uint32_t timerID);
-
-static NPError _popupcontextmenu(NPP instance, NPMenu* menu);
-
-static NPBool _convertpoint(NPP instance, double sourceX, double sourceY,
-                            NPCoordinateSpace sourceSpace, double* destX,
-                            double* destY, NPCoordinateSpace destSpace);
-
-static void _urlredirectresponse(NPP instance, void* notifyData, NPBool allow);
-
-static NPError _initasyncsurface(NPP instance, NPSize* size,
-                                 NPImageFormat format, void* initData,
-                                 NPAsyncSurface* surface);
-
-static NPError _finalizeasyncsurface(NPP instance, NPAsyncSurface* surface);
-
-static void _setcurrentasyncsurface(NPP instance, NPAsyncSurface* surface,
-                                    NPRect* changed);
-
-}  // namespace mozilla::plugins::child
-
-const NPNetscapeFuncs PluginModuleChild::sBrowserFuncs = {
-    sizeof(sBrowserFuncs),
-    (NP_VERSION_MAJOR << 8) + NP_VERSION_MINOR,
-    mozilla::plugins::child::_geturl,
-    mozilla::plugins::child::_posturl,
-    mozilla::plugins::child::_requestread,
-    nullptr,  // _newstream, unimplemented
-    nullptr,  // _write, unimplemented
-    nullptr,  // _destroystream, unimplemented
-    mozilla::plugins::child::_status,
-    mozilla::plugins::child::_useragent,
-    mozilla::plugins::child::_memalloc,
-    mozilla::plugins::child::_memfree,
-    mozilla::plugins::child::_memflush,
-    mozilla::plugins::child::_reloadplugins,
-    mozilla::plugins::child::_getjavaenv,
-    mozilla::plugins::child::_getjavapeer,
-    mozilla::plugins::child::_geturlnotify,
-    mozilla::plugins::child::_posturlnotify,
-    mozilla::plugins::child::_getvalue,
-    mozilla::plugins::child::_setvalue,
-    mozilla::plugins::child::_invalidaterect,
-    mozilla::plugins::child::_invalidateregion,
-    mozilla::plugins::child::_forceredraw,
-    PluginModuleChild::NPN_GetStringIdentifier,
-    PluginModuleChild::NPN_GetStringIdentifiers,
-    PluginModuleChild::NPN_GetIntIdentifier,
-    PluginModuleChild::NPN_IdentifierIsString,
-    PluginModuleChild::NPN_UTF8FromIdentifier,
-    PluginModuleChild::NPN_IntFromIdentifier,
-    PluginModuleChild::NPN_CreateObject,
-    PluginModuleChild::NPN_RetainObject,
-    PluginModuleChild::NPN_ReleaseObject,
-    mozilla::plugins::child::_invoke,
-    mozilla::plugins::child::_invokedefault,
-    mozilla::plugins::child::_evaluate,
-    mozilla::plugins::child::_getproperty,
-    mozilla::plugins::child::_setproperty,
-    mozilla::plugins::child::_removeproperty,
-    mozilla::plugins::child::_hasproperty,
-    mozilla::plugins::child::_hasmethod,
-    mozilla::plugins::child::_releasevariantvalue,
-    mozilla::plugins::child::_setexception,
-    mozilla::plugins::child::_pushpopupsenabledstate,
-    mozilla::plugins::child::_poppopupsenabledstate,
-    mozilla::plugins::child::_enumerate,
-    nullptr,  // pluginthreadasynccall, not used
-    mozilla::plugins::child::_construct,
-    mozilla::plugins::child::_getvalueforurl,
-    mozilla::plugins::child::_setvalueforurl,
-    nullptr,  // NPN GetAuthenticationInfo, not supported
-    mozilla::plugins::child::_scheduletimer,
-    mozilla::plugins::child::_unscheduletimer,
-    mozilla::plugins::child::_popupcontextmenu,
-    mozilla::plugins::child::_convertpoint,
-    nullptr,  // handleevent, unimplemented
-    nullptr,  // unfocusinstance, unimplemented
-    mozilla::plugins::child::_urlredirectresponse,
-    mozilla::plugins::child::_initasyncsurface,
-    mozilla::plugins::child::_finalizeasyncsurface,
-    mozilla::plugins::child::_setcurrentasyncsurface,
-};
-
-PluginInstanceChild* InstCast(NPP aNPP) {
-  MOZ_ASSERT(!!(aNPP->ndata), "nil instance");
-  return static_cast<PluginInstanceChild*>(aNPP->ndata);
-}
-
-namespace mozilla::plugins::child {
-
-NPError _requestread(NPStream* aStream, NPByteRange* aRangeList) {
-  return NPERR_STREAM_NOT_SEEKABLE;
-}
-
-NPError _geturlnotify(NPP aNPP, const char* aRelativeURL, const char* aTarget,
-                      void* aNotifyData) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD(NPERR_INVALID_PARAM);
-
-  if (!aNPP)  // nullptr check for nspluginwrapper (bug 561690)
-    return NPERR_INVALID_INSTANCE_ERROR;
-
-  nsCString url = NullableString(aRelativeURL);
-  auto* sn = new StreamNotifyChild(url);
-
-  NPError err;
-  if (!InstCast(aNPP)->CallPStreamNotifyConstructor(
-          sn, url, NullableString(aTarget), false, nsCString(), false, &err)) {
-    return NPERR_GENERIC_ERROR;
-  }
-
-  if (NPERR_NO_ERROR == err) {
-    // If NPN_PostURLNotify fails, the parent will immediately send us
-    // a PStreamNotifyDestructor, which should not call NPP_URLNotify.
-    sn->SetValid(aNotifyData);
-  }
-
-  return err;
-}
-
-NPError _getvalue(NPP aNPP, NPNVariable aVariable, void* aValue) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD(NPERR_INVALID_PARAM);
-
-  switch (aVariable) {
-    // Copied from nsNPAPIPlugin.cpp
-    case NPNVToolkit:
-#if defined(MOZ_WIDGET_GTK)
-      *static_cast<NPNToolkitType*>(aValue) = NPNVGtk2;
-      return NPERR_NO_ERROR;
-#endif
-      return NPERR_GENERIC_ERROR;
-
-    case NPNVjavascriptEnabledBool:
-      *(NPBool*)aValue =
-          PluginModuleChild::GetChrome()->Settings().javascriptEnabled();
-      return NPERR_NO_ERROR;
-    case NPNVasdEnabledBool:
-      *(NPBool*)aValue =
-          PluginModuleChild::GetChrome()->Settings().asdEnabled();
-      return NPERR_NO_ERROR;
-    case NPNVisOfflineBool:
-      *(NPBool*)aValue = PluginModuleChild::GetChrome()->Settings().isOffline();
-      return NPERR_NO_ERROR;
-    case NPNVSupportsXEmbedBool:
-      // We don't support windowed xembed any more. But we still deliver
-      // events based on X/GTK, not Xt, so we continue to return true
-      // (and Flash requires that we return true).
-      *(NPBool*)aValue = true;
-      return NPERR_NO_ERROR;
-    case NPNVSupportsWindowless:
-      *(NPBool*)aValue = true;
-      return NPERR_NO_ERROR;
-#if defined(MOZ_WIDGET_GTK)
-    case NPNVxDisplay: {
-      if (!aNPP) {
-        return NPERR_INVALID_INSTANCE_ERROR;
-      }
-      return InstCast(aNPP)->NPN_GetValue(aVariable, aValue);
-    }
-    case NPNVxtAppContext:
-      return NPERR_GENERIC_ERROR;
-#endif
-    default: {
-      if (aNPP) {
-        return InstCast(aNPP)->NPN_GetValue(aVariable, aValue);
-      }
-
-      NS_WARNING("Null NPP!");
-      return NPERR_INVALID_INSTANCE_ERROR;
-    }
-  }
-
-  MOZ_ASSERT_UNREACHABLE("Shouldn't get here!");
-  return NPERR_GENERIC_ERROR;
-}
-
-NPError _setvalue(NPP aNPP, NPPVariable aVariable, void* aValue) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD(NPERR_INVALID_PARAM);
-  return InstCast(aNPP)->NPN_SetValue(aVariable, aValue);
-}
-
-NPError _geturl(NPP aNPP, const char* aRelativeURL, const char* aTarget) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD(NPERR_INVALID_PARAM);
-
-  NPError err;
-  InstCast(aNPP)->CallNPN_GetURL(NullableString(aRelativeURL),
-                                 NullableString(aTarget), &err);
-  return err;
-}
-
-NPError _posturlnotify(NPP aNPP, const char* aRelativeURL, const char* aTarget,
-                       uint32_t aLength, const char* aBuffer, NPBool aIsFile,
-                       void* aNotifyData) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD(NPERR_INVALID_PARAM);
-
-  if (!aBuffer) return NPERR_INVALID_PARAM;
-
-  if (aIsFile) {
-    PLUGIN_LOG_DEBUG(
-        ("NPN_PostURLNotify with file=true is no longer supported"));
-    return NPERR_GENERIC_ERROR;
-  }
-
-  nsCString url = NullableString(aRelativeURL);
-  auto* sn = new StreamNotifyChild(url);
-
-  NPError err;
-  if (!InstCast(aNPP)->CallPStreamNotifyConstructor(
-          sn, url, NullableString(aTarget), true, nsCString(aBuffer, aLength),
-          aIsFile, &err)) {
-    return NPERR_GENERIC_ERROR;
-  }
-
-  if (NPERR_NO_ERROR == err) {
-    // If NPN_PostURLNotify fails, the parent will immediately send us
-    // a PStreamNotifyDestructor, which should not call NPP_URLNotify.
-    sn->SetValid(aNotifyData);
-  }
-
-  return err;
-}
-
-NPError _posturl(NPP aNPP, const char* aRelativeURL, const char* aTarget,
-                 uint32_t aLength, const char* aBuffer, NPBool aIsFile) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD(NPERR_INVALID_PARAM);
-
-  if (aIsFile) {
-    PLUGIN_LOG_DEBUG(("NPN_PostURL with file=true is no longer supported"));
-    return NPERR_GENERIC_ERROR;
-  }
-  NPError err;
-  // FIXME what should happen when |aBuffer| is null?
-  InstCast(aNPP)->CallNPN_PostURL(
-      NullableString(aRelativeURL), NullableString(aTarget),
-      nsDependentCString(aBuffer, aLength), aIsFile, &err);
-  return err;
-}
-
-void _status(NPP aNPP, const char* aMessage) {
-  // NPN_Status is no longer supported.
-}
-
-void _memfree(void* aPtr) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  free(aPtr);
-}
-
-uint32_t _memflush(uint32_t aSize) { return 0; }
-
-void _reloadplugins(NPBool aReloadPages) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD_VOID();
-
-  // Send the reload message to all modules. Chrome will need to reload from
-  // disk and content will need to request a new list of plugin tags from
-  // chrome.
-  PluginModuleChild::GetChrome()->SendNPN_ReloadPlugins(!!aReloadPages);
-}
-
-void _invalidaterect(NPP aNPP, NPRect* aInvalidRect) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD_VOID();
-  // nullptr check for nspluginwrapper (bug 548434)
-  if (aNPP) {
-    InstCast(aNPP)->InvalidateRect(aInvalidRect);
-  }
-}
-
-void _invalidateregion(NPP aNPP, NPRegion aInvalidRegion) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD_VOID();
-  NS_WARNING("Not yet implemented!");
-}
-
-void _forceredraw(NPP aNPP) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD_VOID();
-
-  // We ignore calls to NPN_ForceRedraw. Such calls should
-  // never be necessary.
-}
-
-const char* _useragent(NPP aNPP) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD(nullptr);
-  return PluginModuleChild::GetChrome()->GetUserAgent();
-}
-
-void* _memalloc(uint32_t aSize) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  return moz_xmalloc(aSize);
-}
-
-// Deprecated entry points for the old Java plugin.
-void* /* OJI type: JRIEnv* */
-_getjavaenv(void) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  return 0;
-}
-
-void* /* OJI type: jref */
-_getjavapeer(NPP aNPP) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  return 0;
-}
-
-bool _invoke(NPP aNPP, NPObject* aNPObj, NPIdentifier aMethod,
-             const NPVariant* aArgs, uint32_t aArgCount, NPVariant* aResult) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD(false);
-
-  if (!aNPP || !aNPObj || !aNPObj->_class || !aNPObj->_class->invoke)
-    return false;
-
-  return aNPObj->_class->invoke(aNPObj, aMethod, aArgs, aArgCount, aResult);
-}
-
-bool _invokedefault(NPP aNPP, NPObject* aNPObj, const NPVariant* aArgs,
-                    uint32_t aArgCount, NPVariant* aResult) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD(false);
-
-  if (!aNPP || !aNPObj || !aNPObj->_class || !aNPObj->_class->invokeDefault)
-    return false;
-
-  return aNPObj->_class->invokeDefault(aNPObj, aArgs, aArgCount, aResult);
-}
-
-bool _evaluate(NPP aNPP, NPObject* aObject, NPString* aScript,
-               NPVariant* aResult) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD(false);
-
-  if (!(aNPP && aObject && aScript && aResult)) {
-    NS_ERROR("Bad arguments!");
-    return false;
-  }
-
-  PluginScriptableObjectChild* actor =
-      InstCast(aNPP)->GetActorForNPObject(aObject);
-  if (!actor) {
-    NS_ERROR("Failed to create actor?!");
-    return false;
-  }
-
-#ifdef XP_WIN
-  if (gDelayFlashFocusReplyUntilEval) {
-    ReplyMessage(0);
-    gDelayFlashFocusReplyUntilEval = false;
-  }
-#endif
-
-  return actor->Evaluate(aScript, aResult);
-}
-
-bool _getproperty(NPP aNPP, NPObject* aNPObj, NPIdentifier aPropertyName,
-                  NPVariant* aResult) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD(false);
-
-  if (!aNPP || !aNPObj || !aNPObj->_class || !aNPObj->_class->getProperty)
-    return false;
-
-  return aNPObj->_class->getProperty(aNPObj, aPropertyName, aResult);
-}
-
-bool _setproperty(NPP aNPP, NPObject* aNPObj, NPIdentifier aPropertyName,
-                  const NPVariant* aValue) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD(false);
-
-  if (!aNPP || !aNPObj || !aNPObj->_class || !aNPObj->_class->setProperty)
-    return false;
-
-  return aNPObj->_class->setProperty(aNPObj, aPropertyName, aValue);
-}
-
-bool _removeproperty(NPP aNPP, NPObject* aNPObj, NPIdentifier aPropertyName) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD(false);
-
-  if (!aNPP || !aNPObj || !aNPObj->_class || !aNPObj->_class->removeProperty)
-    return false;
-
-  return aNPObj->_class->removeProperty(aNPObj, aPropertyName);
-}
-
-bool _hasproperty(NPP aNPP, NPObject* aNPObj, NPIdentifier aPropertyName) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD(false);
-
-  if (!aNPP || !aNPObj || !aNPObj->_class || !aNPObj->_class->hasProperty)
-    return false;
-
-  return aNPObj->_class->hasProperty(aNPObj, aPropertyName);
-}
-
-bool _hasmethod(NPP aNPP, NPObject* aNPObj, NPIdentifier aMethodName) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD(false);
-
-  if (!aNPP || !aNPObj || !aNPObj->_class || !aNPObj->_class->hasMethod)
-    return false;
-
-  return aNPObj->_class->hasMethod(aNPObj, aMethodName);
-}
-
-bool _enumerate(NPP aNPP, NPObject* aNPObj, NPIdentifier** aIdentifiers,
-                uint32_t* aCount) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD(false);
-
-  if (!aNPP || !aNPObj || !aNPObj->_class) return false;
-
-  if (!NP_CLASS_STRUCT_VERSION_HAS_ENUM(aNPObj->_class) ||
-      !aNPObj->_class->enumerate) {
-    *aIdentifiers = 0;
-    *aCount = 0;
-    return true;
-  }
-
-  return aNPObj->_class->enumerate(aNPObj, aIdentifiers, aCount);
-}
-
-bool _construct(NPP aNPP, NPObject* aNPObj, const NPVariant* aArgs,
-                uint32_t aArgCount, NPVariant* aResult) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD(false);
-
-  if (!aNPP || !aNPObj || !aNPObj->_class ||
-      !NP_CLASS_STRUCT_VERSION_HAS_CTOR(aNPObj->_class) ||
-      !aNPObj->_class->construct) {
-    return false;
-  }
-
-  return aNPObj->_class->construct(aNPObj, aArgs, aArgCount, aResult);
-}
-
-void _releasevariantvalue(NPVariant* aVariant) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  // Only assert plugin thread here for consistency with in-process plugins.
-  AssertPluginThread();
-
-  if (NPVARIANT_IS_STRING(*aVariant)) {
-    NPString str = NPVARIANT_TO_STRING(*aVariant);
-    free(const_cast<NPUTF8*>(str.UTF8Characters));
-  } else if (NPVARIANT_IS_OBJECT(*aVariant)) {
-    NPObject* object = NPVARIANT_TO_OBJECT(*aVariant);
-    if (object) {
-      PluginModuleChild::NPN_ReleaseObject(object);
-    }
-  }
-  VOID_TO_NPVARIANT(*aVariant);
-}
-
-void _setexception(NPObject* aNPObj, const NPUTF8* aMessage) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD_VOID();
-
-  // Do nothing. We no longer support this API.
-}
-
-void _pushpopupsenabledstate(NPP aNPP, NPBool aEnabled) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD_VOID();
-
-  InstCast(aNPP)->CallNPN_PushPopupsEnabledState(aEnabled ? true : false);
-}
-
-void _poppopupsenabledstate(NPP aNPP) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD_VOID();
-
-  InstCast(aNPP)->CallNPN_PopPopupsEnabledState();
-}
-
-NPError _getvalueforurl(NPP npp, NPNURLVariable variable, const char* url,
-                        char** value, uint32_t* len) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  AssertPluginThread();
-
-  if (!url) return NPERR_INVALID_URL;
-
-  if (!npp || !value || !len) return NPERR_INVALID_PARAM;
-
-  if (variable == NPNURLVProxy) {
-    nsCString v;
-    NPError result;
-    InstCast(npp)->CallNPN_GetValueForURL(variable, nsCString(url), &v,
-                                          &result);
-    if (NPERR_NO_ERROR == result) {
-      *value = ToNewCString(v);
-      *len = v.Length();
-    }
-    return result;
-  }
-
-  return NPERR_INVALID_PARAM;
-}
-
-NPError _setvalueforurl(NPP npp, NPNURLVariable variable, const char* url,
-                        const char* value, uint32_t len) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  AssertPluginThread();
-
-  if (!value) return NPERR_INVALID_PARAM;
-
-  if (!url) return NPERR_INVALID_URL;
-
-  if (variable == NPNURLVProxy) {
-    NPError result;
-    InstCast(npp)->CallNPN_SetValueForURL(
-        variable, nsCString(url), nsDependentCString(value, len), &result);
-    return result;
-  }
-
-  return NPERR_INVALID_PARAM;
-}
-
-uint32_t _scheduletimer(NPP npp, uint32_t interval, NPBool repeat,
-                        void (*timerFunc)(NPP npp, uint32_t timerID)) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  AssertPluginThread();
-  return InstCast(npp)->ScheduleTimer(interval, repeat, timerFunc);
-}
-
-void _unscheduletimer(NPP npp, uint32_t timerID) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  AssertPluginThread();
-  InstCast(npp)->UnscheduleTimer(timerID);
-}
-
-#ifdef OS_MACOSX
-static void ProcessBrowserEvents(void* pluginModule) {
-  PluginModuleChild* pmc = static_cast<PluginModuleChild*>(pluginModule);
-
-  if (!pmc) return;
-
-  pmc->CallProcessSomeEvents();
-}
-#endif
-
-NPError _popupcontextmenu(NPP instance, NPMenu* menu) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  AssertPluginThread();
-
-#ifdef MOZ_WIDGET_COCOA
-  double pluginX, pluginY;
-  double screenX, screenY;
-
-  const NPCocoaEvent* currentEvent = InstCast(instance)->getCurrentEvent();
-  if (!currentEvent) {
-    return NPERR_GENERIC_ERROR;
-  }
-
-  // Ensure that the events has an x/y value.
-  if (currentEvent->type != NPCocoaEventMouseDown &&
-      currentEvent->type != NPCocoaEventMouseUp &&
-      currentEvent->type != NPCocoaEventMouseMoved &&
-      currentEvent->type != NPCocoaEventMouseEntered &&
-      currentEvent->type != NPCocoaEventMouseExited &&
-      currentEvent->type != NPCocoaEventMouseDragged) {
-    return NPERR_GENERIC_ERROR;
-  }
-
-  pluginX = currentEvent->data.mouse.pluginX;
-  pluginY = currentEvent->data.mouse.pluginY;
-
-  if ((pluginX < 0.0) || (pluginY < 0.0)) return NPERR_GENERIC_ERROR;
-
-  NPBool success =
-      _convertpoint(instance, pluginX, pluginY, NPCoordinateSpacePlugin,
-                    &screenX, &screenY, NPCoordinateSpaceScreen);
-
-  if (success) {
-    return mozilla::plugins::PluginUtilsOSX::ShowCocoaContextMenu(
-        menu, screenX, screenY, InstCast(instance)->Manager(),
-        ProcessBrowserEvents);
-  } else {
-    NS_WARNING("Convertpoint failed, could not created contextmenu.");
-    return NPERR_GENERIC_ERROR;
-  }
-
-#else
-  NS_WARNING("Not supported on this platform!");
-  return NPERR_GENERIC_ERROR;
-#endif
-}
-
-NPBool _convertpoint(NPP instance, double sourceX, double sourceY,
-                     NPCoordinateSpace sourceSpace, double* destX,
-                     double* destY, NPCoordinateSpace destSpace) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  if (!IsPluginThread()) {
-    NS_WARNING("Not running on the plugin's main thread!");
-    return false;
-  }
-
-  double rDestX = 0;
-  bool ignoreDestX = !destX;
-  double rDestY = 0;
-  bool ignoreDestY = !destY;
-  bool result = false;
-  InstCast(instance)->CallNPN_ConvertPoint(sourceX, ignoreDestX, sourceY,
-                                           ignoreDestY, sourceSpace, destSpace,
-                                           &rDestX, &rDestY, &result);
-  if (result) {
-    if (destX) *destX = rDestX;
-    if (destY) *destY = rDestY;
-  }
-
-  return result;
-}
-
-void _urlredirectresponse(NPP instance, void* notifyData, NPBool allow) {
-  InstCast(instance)->NPN_URLRedirectResponse(notifyData, allow);
-}
-
-NPError _initasyncsurface(NPP instance, NPSize* size, NPImageFormat format,
-                          void* initData, NPAsyncSurface* surface) {
-  return InstCast(instance)->NPN_InitAsyncSurface(size, format, initData,
-                                                  surface);
-}
-
-NPError _finalizeasyncsurface(NPP instance, NPAsyncSurface* surface) {
-  return InstCast(instance)->NPN_FinalizeAsyncSurface(surface);
-}
-
-void _setcurrentasyncsurface(NPP instance, NPAsyncSurface* surface,
-                             NPRect* changed) {
-  InstCast(instance)->NPN_SetCurrentAsyncSurface(surface, changed);
-}
-
-}  // namespace mozilla::plugins::child
-
-//-----------------------------------------------------------------------------
-
-mozilla::ipc::IPCResult PluginModuleChild::RecvSettingChanged(
-    const PluginSettings& aSettings) {
-  mCachedSettings = aSettings;
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginModuleChild::AnswerNP_GetEntryPoints(
-    NPError* _retval) {
-  PLUGIN_LOG_DEBUG_METHOD;
-  AssertPluginThread();
-  MOZ_ASSERT(mIsChrome);
-
-#if defined(OS_LINUX) || defined(OS_BSD) || defined(OS_SOLARIS)
-  return IPC_OK();
-#elif defined(OS_WIN) || defined(OS_MACOSX)
-  *_retval = mGetEntryPointsFunc(&mFunctions);
-  return IPC_OK();
-#else
-#  error Please implement me for your platform
-#endif
-}
-
-mozilla::ipc::IPCResult PluginModuleChild::AnswerNP_Initialize(
-    const PluginSettings& aSettings, NPError* rv) {
-  *rv = DoNP_Initialize(aSettings);
-  return IPC_OK();
-}
-
-NPError PluginModuleChild::DoNP_Initialize(const PluginSettings& aSettings) {
-  PLUGIN_LOG_DEBUG_METHOD;
-  AssertPluginThread();
-  MOZ_ASSERT(mIsChrome);
-
-  mCachedSettings = aSettings;
-
-#ifdef OS_WIN
-  SetEventHooks();
-#endif
-
-#ifdef MOZ_X11
-#  ifdef MOZ_WIDGET_GTK
-  if (!GdkIsX11Display()) {
-    // We don't support NPAPI plugins on Wayland.
-    return NPERR_GENERIC_ERROR;
-  }
-#  endif
-  // Send the parent our X socket to act as a proxy reference for our X
-  // resources.
-  int xSocketFd = ConnectionNumber(DefaultXDisplay());
-  SendBackUpXResources(FileDescriptor(xSocketFd));
-#endif
-
-  NPError result;
-#if defined(OS_LINUX) || defined(OS_BSD) || defined(OS_SOLARIS)
-  result = mInitializeFunc(&sBrowserFuncs, &mFunctions);
-#elif defined(OS_WIN) || defined(OS_MACOSX)
-  result = mInitializeFunc(&sBrowserFuncs);
-#else
-#  error Please implement me for your platform
-#endif
-
-  return result;
-}
-
-PPluginInstanceChild* PluginModuleChild::AllocPPluginInstanceChild(
-    const nsCString& aMimeType, const nsTArray<nsCString>& aNames,
-    const nsTArray<nsCString>& aValues) {
-  PLUGIN_LOG_DEBUG_METHOD;
-  AssertPluginThread();
-
-  // In e10s, gChromeInstance hands out quirks to instances, but never
-  // allocates an instance on its own. Make sure it gets the latest copy
-  // of quirks once we have them. Also note, with process-per-tab, we may
-  // have multiple PluginModuleChilds in the same plugin process, so only
-  // initialize this once in gChromeInstance, which is a singleton.
-  GetChrome()->InitQuirksModes(aMimeType);
-  mQuirks = GetChrome()->mQuirks;
-
-#ifdef XP_WIN
-  FunctionHook::HookFunctions(mQuirks);
-#endif
-
-  return new PluginInstanceChild(&mFunctions, aMimeType, aNames, aValues);
-}
-
-void PluginModuleChild::InitQuirksModes(const nsCString& aMimeType) {
-  if (mQuirks != QUIRKS_NOT_INITIALIZED) {
-    return;
-  }
-
-  mQuirks = GetQuirksFromMimeTypeAndFilename(aMimeType, mPluginFilename);
-}
-
-mozilla::ipc::IPCResult PluginModuleChild::AnswerModuleSupportsAsyncRender(
-    bool* aResult) {
-#if defined(XP_WIN)
-  *aResult = gChromeInstance->mAsyncRenderSupport;
-  return IPC_OK();
-#else
-  MOZ_ASSERT_UNREACHABLE("Shouldn't get here!");
-  return IPC_FAIL_NO_REASON(this);
-#endif
-}
-
-mozilla::ipc::IPCResult PluginModuleChild::RecvPPluginInstanceConstructor(
-    PPluginInstanceChild* aActor, const nsCString& aMimeType,
-    nsTArray<nsCString>&& aNames, nsTArray<nsCString>&& aValues) {
-  PLUGIN_LOG_DEBUG_METHOD;
-  AssertPluginThread();
-
-  NS_ASSERTION(aActor, "Null actor!");
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginModuleChild::AnswerSyncNPP_New(
-    PPluginInstanceChild* aActor, NPError* rv) {
-  PLUGIN_LOG_DEBUG_METHOD;
-  PluginInstanceChild* childInstance =
-      reinterpret_cast<PluginInstanceChild*>(aActor);
-  AssertPluginThread();
-  *rv = childInstance->DoNPP_New();
-  return IPC_OK();
-}
-
-bool PluginModuleChild::DeallocPPluginInstanceChild(
-    PPluginInstanceChild* aActor) {
-  PLUGIN_LOG_DEBUG_METHOD;
-  AssertPluginThread();
-
-  delete aActor;
-
-  return true;
-}
-
-NPObject* PluginModuleChild::NPN_CreateObject(NPP aNPP, NPClass* aClass) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  ENSURE_PLUGIN_THREAD(nullptr);
-
-  PluginInstanceChild* i = InstCast(aNPP);
-  if (i->mDeletingHash) {
-    NS_ERROR("Plugin used NPP after NPP_Destroy");
-    return nullptr;
-  }
-
-  NPObject* newObject;
-  if (aClass && aClass->allocate) {
-    newObject = aClass->allocate(aNPP, aClass);
-  } else {
-    newObject = reinterpret_cast<NPObject*>(child::_memalloc(sizeof(NPObject)));
-  }
-
-  if (newObject) {
-    newObject->_class = aClass;
-    newObject->referenceCount = 1;
-    NS_LOG_ADDREF(newObject, 1, "NPObject", sizeof(NPObject));
-  }
-
-  PluginScriptableObjectChild::RegisterObject(newObject, i);
-
-  return newObject;
-}
-
-NPObject* PluginModuleChild::NPN_RetainObject(NPObject* aNPObj) {
-  AssertPluginThread();
-
-  if (NS_WARN_IF(!aNPObj)) {
-    return nullptr;
-  }
-
-#ifdef NS_BUILD_REFCNT_LOGGING
-  int32_t refCnt =
-#endif
-      PR_ATOMIC_INCREMENT((int32_t*)&aNPObj->referenceCount);
-  NS_LOG_ADDREF(aNPObj, refCnt, "NPObject", sizeof(NPObject));
-
-  return aNPObj;
-}
-
-void PluginModuleChild::NPN_ReleaseObject(NPObject* aNPObj) {
-  AssertPluginThread();
-
-  PluginInstanceChild* instance =
-      PluginScriptableObjectChild::GetInstanceForNPObject(aNPObj);
-  if (!instance) {
-    // The PluginInstanceChild was destroyed
-    return;
-  }
-
-  DeletingObjectEntry* doe = nullptr;
-  if (instance->mDeletingHash) {
-    doe = instance->mDeletingHash->GetEntry(aNPObj);
-    if (!doe) {
-      NS_ERROR(
-          "An object for a destroyed instance isn't in the instance deletion "
-          "hash");
-      return;
-    }
-    if (doe->mDeleted) return;
-  }
-
-  int32_t refCnt = PR_ATOMIC_DECREMENT((int32_t*)&aNPObj->referenceCount);
-  NS_LOG_RELEASE(aNPObj, refCnt, "NPObject");
-
-  if (refCnt == 0) {
-    DeallocNPObject(aNPObj);
-    if (doe) doe->mDeleted = true;
-  }
-}
-
-void PluginModuleChild::DeallocNPObject(NPObject* aNPObj) {
-  if (aNPObj->_class && aNPObj->_class->deallocate) {
-    aNPObj->_class->deallocate(aNPObj);
-  } else {
-    child::_memfree(aNPObj);
-  }
-
-  PluginScriptableObjectChild* actor =
-      PluginScriptableObjectChild::GetActorForNPObject(aNPObj);
-  if (actor) actor->NPObjectDestroyed();
-
-  PluginScriptableObjectChild::UnregisterObject(aNPObj);
-}
-
-NPIdentifier PluginModuleChild::NPN_GetStringIdentifier(const NPUTF8* aName) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  AssertPluginThread();
-
-  if (!aName) return 0;
-
-  nsDependentCString name(aName);
-  PluginIdentifier ident(name);
-  PluginScriptableObjectChild::StackIdentifier stackID(ident);
-  stackID.MakePermanent();
-  return stackID.ToNPIdentifier();
-}
-
-void PluginModuleChild::NPN_GetStringIdentifiers(const NPUTF8** aNames,
-                                                 int32_t aNameCount,
-                                                 NPIdentifier* aIdentifiers) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  AssertPluginThread();
-
-  if (!(aNames && aNameCount > 0 && aIdentifiers)) {
-    MOZ_CRASH("Bad input! Headed for a crash!");
-  }
-
-  for (int32_t index = 0; index < aNameCount; ++index) {
-    if (!aNames[index]) {
-      aIdentifiers[index] = 0;
-      continue;
-    }
-    nsDependentCString name(aNames[index]);
-    PluginIdentifier ident(name);
-    PluginScriptableObjectChild::StackIdentifier stackID(ident);
-    stackID.MakePermanent();
-    aIdentifiers[index] = stackID.ToNPIdentifier();
-  }
-}
-
-bool PluginModuleChild::NPN_IdentifierIsString(NPIdentifier aIdentifier) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-
-  PluginScriptableObjectChild::StackIdentifier stack(aIdentifier);
-  return stack.IsString();
-}
-
-NPIdentifier PluginModuleChild::NPN_GetIntIdentifier(int32_t aIntId) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  AssertPluginThread();
-
-  PluginIdentifier ident(aIntId);
-  PluginScriptableObjectChild::StackIdentifier stackID(ident);
-  stackID.MakePermanent();
-  return stackID.ToNPIdentifier();
-}
-
-NPUTF8* PluginModuleChild::NPN_UTF8FromIdentifier(NPIdentifier aIdentifier) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-
-  PluginScriptableObjectChild::StackIdentifier stackID(aIdentifier);
-  if (stackID.IsString()) {
-    return ToNewCString(stackID.GetString());
-  }
-  return nullptr;
-}
-
-int32_t PluginModuleChild::NPN_IntFromIdentifier(NPIdentifier aIdentifier) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-
-  PluginScriptableObjectChild::StackIdentifier stackID(aIdentifier);
-  if (!stackID.IsString()) {
-    return stackID.GetInt();
-  }
-  return INT32_MIN;
-}
-
-#ifdef OS_WIN
-void PluginModuleChild::EnteredCall() { mIncallPumpingStack.AppendElement(); }
-
-void PluginModuleChild::ExitedCall() {
-  NS_ASSERTION(mIncallPumpingStack.Length(), "mismatched entered/exited");
-  const IncallFrame& f = mIncallPumpingStack.LastElement();
-  if (f._spinning)
-    MessageLoop::current()->SetNestableTasksAllowed(
-        f._savedNestableTasksAllowed);
-
-  // XXX Is RemoveLastElement intentionally called only after calling
-  // SetNestableTasksAllowed? Otherwise, PopLastElement could be used above.
-  mIncallPumpingStack.RemoveLastElement();
-}
-
-LRESULT CALLBACK PluginModuleChild::CallWindowProcHook(int nCode, WPARAM wParam,
-                                                       LPARAM lParam) {
-  // Trap and reply to anything we recognize as the source of a
-  // potential send message deadlock.
-  if (nCode >= 0 &&
-      (InSendMessageEx(nullptr) & (ISMEX_REPLIED | ISMEX_SEND)) == ISMEX_SEND) {
-    CWPSTRUCT* pCwp = reinterpret_cast<CWPSTRUCT*>(lParam);
-    if (pCwp->message == WM_KILLFOCUS) {
-      // Fix for flash fullscreen window loosing focus. On single
-      // core systems, sync killfocus events need to be handled
-      // after the flash fullscreen window procedure processes this
-      // message, otherwise fullscreen focus will not work correctly.
-      wchar_t szClass[26];
-      if (GetClassNameW(pCwp->hwnd, szClass,
-                        sizeof(szClass) / sizeof(char16_t)) &&
-          !wcscmp(szClass, kFlashFullscreenClass)) {
-        gDelayFlashFocusReplyUntilEval = true;
-      }
-    }
-  }
-
-  return CallNextHookEx(nullptr, nCode, wParam, lParam);
-}
-
-LRESULT CALLBACK PluginModuleChild::NestedInputEventHook(int nCode,
-                                                         WPARAM wParam,
-                                                         LPARAM lParam) {
-  PluginModuleChild* self = GetChrome();
-  uint32_t len = self->mIncallPumpingStack.Length();
-  if (nCode >= 0 && len && !self->mIncallPumpingStack[len - 1]._spinning) {
-    MessageLoop* loop = MessageLoop::current();
-    self->SendProcessNativeEventsInInterruptCall();
-    IncallFrame& f = self->mIncallPumpingStack[len - 1];
-    f._spinning = true;
-    f._savedNestableTasksAllowed = loop->NestableTasksAllowed();
-    loop->SetNestableTasksAllowed(true);
-    loop->set_os_modal_loop(true);
-  }
-
-  return CallNextHookEx(nullptr, nCode, wParam, lParam);
-}
-
-void PluginModuleChild::SetEventHooks() {
-  NS_ASSERTION(
-      !mNestedEventHook,
-      "mNestedEventHook already setup in call to SetNestedInputEventHook?");
-  NS_ASSERTION(
-      !mGlobalCallWndProcHook,
-      "mGlobalCallWndProcHook already setup in call to CallWindowProcHook?");
-
-  PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
-
-  // WH_MSGFILTER event hook for detecting modal loops in the child.
-  mNestedEventHook = SetWindowsHookEx(WH_MSGFILTER, NestedInputEventHook,
-                                      nullptr, GetCurrentThreadId());
-
-  // WH_CALLWNDPROC event hook for trapping sync messages sent from
-  // parent that can cause deadlocks.
-  mGlobalCallWndProcHook = SetWindowsHookEx(WH_CALLWNDPROC, CallWindowProcHook,
-                                            nullptr, GetCurrentThreadId());
-}
-
-void PluginModuleChild::ResetEventHooks() {
-  PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
-  if (mNestedEventHook) UnhookWindowsHookEx(mNestedEventHook);
-  mNestedEventHook = nullptr;
-  if (mGlobalCallWndProcHook) UnhookWindowsHookEx(mGlobalCallWndProcHook);
-  mGlobalCallWndProcHook = nullptr;
-}
-#endif
-
-mozilla::ipc::IPCResult
-PluginModuleChild::RecvProcessNativeEventsInInterruptCall() {
-  PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
-#if defined(OS_WIN)
-  ProcessNativeEventsInInterruptCall();
-  return IPC_OK();
-#else
-  MOZ_CRASH(
-      "PluginModuleChild::RecvProcessNativeEventsInInterruptCall not "
-      "implemented!");
-  return IPC_FAIL_NO_REASON(this);
-#endif
-}
-
-#ifdef MOZ_WIDGET_COCOA
-void PluginModuleChild::ProcessNativeEvents() { CallProcessSomeEvents(); }
-#endif
-
-NPError PluginModuleChild::PluginRequiresAudioDeviceChanges(
-    PluginInstanceChild* aInstance, NPBool aShouldRegister) {
-#ifdef XP_WIN
-  // Maintain a set of PluginInstanceChildren that we need to tell when the
-  // default audio device has changed.
-  NPError rv = NPERR_NO_ERROR;
-  if (aShouldRegister) {
-    if (mAudioNotificationSet.IsEmpty()) {
-      // We are registering the first plugin.  Notify the PluginModuleParent
-      // that it needs to start sending us audio device notifications.
-      if (!CallNPN_SetValue_NPPVpluginRequiresAudioDeviceChanges(
-              aShouldRegister, &rv)) {
-        return NPERR_GENERIC_ERROR;
-      }
-    }
-    if (rv == NPERR_NO_ERROR) {
-      mAudioNotificationSet.PutEntry(aInstance);
-    }
-  } else if (!mAudioNotificationSet.IsEmpty()) {
-    mAudioNotificationSet.RemoveEntry(aInstance);
-    if (mAudioNotificationSet.IsEmpty()) {
-      // We released the last plugin.  Unregister from the PluginModuleParent.
-      if (!CallNPN_SetValue_NPPVpluginRequiresAudioDeviceChanges(
-              aShouldRegister, &rv)) {
-        return NPERR_GENERIC_ERROR;
-      }
-    }
-  }
-  return rv;
-#else
-  MOZ_CRASH(
-      "PluginRequiresAudioDeviceChanges is not available on this platform.");
-#endif  // XP_WIN
-}
-
-mozilla::ipc::IPCResult
-PluginModuleChild::RecvNPP_SetValue_NPNVaudioDeviceChangeDetails(
-    const NPAudioDeviceChangeDetailsIPC& detailsIPC) {
-#if defined(XP_WIN)
-  NPAudioDeviceChangeDetails details;
-  details.flow = detailsIPC.flow;
-  details.role = detailsIPC.role;
-  details.defaultDevice = detailsIPC.defaultDevice.c_str();
-  for (auto iter = mAudioNotificationSet.ConstIter(); !iter.Done();
-       iter.Next()) {
-    PluginInstanceChild* pluginInst = iter.Get()->GetKey();
-    pluginInst->DefaultAudioDeviceChanged(details);
-  }
-  return IPC_OK();
-#else
-  MOZ_CRASH(
-      "NPP_SetValue_NPNVaudioDeviceChangeDetails is a Windows-only message");
-#endif
-}
-
-mozilla::ipc::IPCResult
-PluginModuleChild::RecvNPP_SetValue_NPNVaudioDeviceStateChanged(
-    const NPAudioDeviceStateChangedIPC& aDeviceStateIPC) {
-#if defined(XP_WIN)
-  NPAudioDeviceStateChanged stateChange;
-  stateChange.newState = aDeviceStateIPC.state;
-  stateChange.device = aDeviceStateIPC.device.c_str();
-  for (auto iter = mAudioNotificationSet.ConstIter(); !iter.Done();
-       iter.Next()) {
-    PluginInstanceChild* pluginInst = iter.Get()->GetKey();
-    pluginInst->AudioDeviceStateChanged(stateChange);
-  }
-  return IPC_OK();
-#else
-  MOZ_CRASH("NPP_SetValue_NPNVaudioDeviceRemoved is a Windows-only message");
-#endif
-}
diff --git a/dom/plugins/ipc/PluginModuleChild.h b/dom/plugins/ipc/PluginModuleChild.h
deleted file mode 100644
index f73cfdd6c3dad..0000000000000
--- a/dom/plugins/ipc/PluginModuleChild.h
+++ /dev/null
@@ -1,356 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef dom_plugins_PluginModuleChild_h
-#define dom_plugins_PluginModuleChild_h 1
-
-#include "mozilla/Attributes.h"
-
-#include <string>
-#include <vector>
-
-#include "base/basictypes.h"
-
-#include "prlink.h"
-
-#include "npapi.h"
-#include "npfunctions.h"
-
-#include "nsTHashtable.h"
-#include "nsHashKeys.h"
-
-#ifdef MOZ_WIDGET_COCOA
-#  include "PluginInterposeOSX.h"
-#endif
-
-#ifdef MOZ_WIDGET_COCOA
-#  include "PluginInterposeOSX.h"
-#endif
-
-#include "mozilla/plugins/PPluginModuleChild.h"
-#include "mozilla/plugins/PluginInstanceChild.h"
-#include "mozilla/plugins/PluginMessageUtils.h"
-#include "mozilla/plugins/PluginQuirks.h"
-
-#if defined(MOZ_WIDGET_GTK)
-#  include <glib.h>
-#endif
-
-namespace mozilla {
-
-class ChildProfilerController;
-
-namespace plugins {
-
-class PluginInstanceChild;
-
-class PluginModuleChild : public PPluginModuleChild {
-  friend class PPluginModuleChild;
-
- protected:
-  virtual mozilla::ipc::RacyInterruptPolicy MediateInterruptRace(
-      const MessageInfo& parent, const MessageInfo& child) override {
-    return MediateRace(parent, child);
-  }
-
-  virtual bool ShouldContinueFromReplyTimeout() override;
-
-  mozilla::ipc::IPCResult RecvSettingChanged(const PluginSettings& aSettings);
-
-  // Implement the PPluginModuleChild interface
-  mozilla::ipc::IPCResult RecvInitProfiler(
-      Endpoint<mozilla::PProfilerChild>&& aEndpoint);
-  mozilla::ipc::IPCResult RecvDisableFlashProtectedMode();
-  mozilla::ipc::IPCResult AnswerNP_GetEntryPoints(NPError* rv);
-  mozilla::ipc::IPCResult AnswerNP_Initialize(const PluginSettings& aSettings,
-                                              NPError* rv);
-  mozilla::ipc::IPCResult AnswerSyncNPP_New(PPluginInstanceChild* aActor,
-                                            NPError* rv);
-
-  mozilla::ipc::IPCResult RecvInitPluginModuleChild(
-      Endpoint<PPluginModuleChild>&& endpoint);
-
-  mozilla::ipc::IPCResult RecvInitPluginFunctionBroker(
-      Endpoint<PFunctionBrokerChild>&& endpoint);
-
-  PPluginInstanceChild* AllocPPluginInstanceChild(
-      const nsCString& aMimeType, const nsTArray<nsCString>& aNames,
-      const nsTArray<nsCString>& aValues);
-
-  bool DeallocPPluginInstanceChild(PPluginInstanceChild* aActor);
-
-  mozilla::ipc::IPCResult RecvPPluginInstanceConstructor(
-      PPluginInstanceChild* aActor, const nsCString& aMimeType,
-      nsTArray<nsCString>&& aNames, nsTArray<nsCString>&& aValues) override;
-  mozilla::ipc::IPCResult AnswerNP_Shutdown(NPError* rv);
-
-  mozilla::ipc::IPCResult AnswerOptionalFunctionsSupported(
-      bool* aURLRedirectNotify, bool* aClearSiteData, bool* aGetSitesWithData);
-
-  mozilla::ipc::IPCResult RecvNPP_ClearSiteData(const nsCString& aSite,
-                                                const uint64_t& aFlags,
-                                                const uint64_t& aMaxAge,
-                                                const uint64_t& aCallbackId);
-
-  mozilla::ipc::IPCResult RecvNPP_GetSitesWithData(const uint64_t& aCallbackId);
-
-  mozilla::ipc::IPCResult RecvSetAudioSessionData(const nsID& aId,
-                                                  const nsString& aDisplayName,
-                                                  const nsString& aIconPath);
-
-  mozilla::ipc::IPCResult RecvSetParentHangTimeout(const uint32_t& aSeconds);
-
-  mozilla::ipc::IPCResult AnswerInitCrashReporter(
-      mozilla::dom::NativeThreadId* aId);
-
-  virtual void ActorDestroy(ActorDestroyReason why) override;
-
-  mozilla::ipc::IPCResult RecvProcessNativeEventsInInterruptCall();
-
-  mozilla::ipc::IPCResult AnswerModuleSupportsAsyncRender(bool* aResult);
-
- public:
-  explicit PluginModuleChild(bool aIsChrome);
-  virtual ~PluginModuleChild();
-
-  void CommonInit();
-
-#if defined(OS_WIN) && defined(MOZ_SANDBOX)
-  // Path to the roaming Flash Player folder.  This is used to restore some
-  // behavior blocked by the sandbox.
-  static void SetFlashRoamingPath(const std::wstring& aRoamingPath);
-  static std::wstring GetFlashRoamingPath();
-#endif
-
-  // aPluginFilename is UTF8, not native-charset!
-  bool InitForChrome(const std::string& aPluginFilename,
-                     base::ProcessId aParentPid, MessageLoop* aIOLoop,
-                     UniquePtr<IPC::Channel> aChannel);
-
-  bool InitForContent(Endpoint<PPluginModuleChild>&& aEndpoint);
-
-  static bool CreateForContentProcess(Endpoint<PPluginModuleChild>&& aEndpoint);
-
-  void CleanUp();
-
-  NPError NP_Shutdown();
-
-  const char* GetUserAgent();
-
-  static const NPNetscapeFuncs sBrowserFuncs;
-
-  static PluginModuleChild* GetChrome();
-
-  /**
-   * The child implementation of NPN_CreateObject.
-   */
-  static NPObject* NPN_CreateObject(NPP aNPP, NPClass* aClass);
-  /**
-   * The child implementation of NPN_RetainObject.
-   */
-  static NPObject* NPN_RetainObject(NPObject* aNPObj);
-  /**
-   * The child implementation of NPN_ReleaseObject.
-   */
-  static void NPN_ReleaseObject(NPObject* aNPObj);
-
-  /**
-   * The child implementations of NPIdentifier-related functions.
-   */
-  static NPIdentifier NPN_GetStringIdentifier(const NPUTF8* aName);
-  static void NPN_GetStringIdentifiers(const NPUTF8** aNames,
-                                       int32_t aNameCount,
-                                       NPIdentifier* aIdentifiers);
-  static NPIdentifier NPN_GetIntIdentifier(int32_t aIntId);
-  static bool NPN_IdentifierIsString(NPIdentifier aIdentifier);
-  static NPUTF8* NPN_UTF8FromIdentifier(NPIdentifier aIdentifier);
-  static int32_t NPN_IntFromIdentifier(NPIdentifier aIdentifier);
-
-#ifdef MOZ_WIDGET_COCOA
-  void ProcessNativeEvents();
-
-  void PluginShowWindow(uint32_t window_id, bool modal, CGRect r) {
-    SendPluginShowWindow(window_id, modal, r.origin.x, r.origin.y, r.size.width,
-                         r.size.height);
-  }
-
-  void PluginHideWindow(uint32_t window_id) { SendPluginHideWindow(window_id); }
-
-  void SetCursor(NSCursorInfo& cursorInfo) { SendSetCursor(cursorInfo); }
-
-  void ShowCursor(bool show) { SendShowCursor(show); }
-
-  void PushCursor(NSCursorInfo& cursorInfo) { SendPushCursor(cursorInfo); }
-
-  void PopCursor() { SendPopCursor(); }
-
-  void SetCursor(NSCursorInfo& cursorInfo) { SendSetCursor(cursorInfo); }
-
-  void ShowCursor(bool show) { SendShowCursor(show); }
-
-  void PushCursor(NSCursorInfo& cursorInfo) { SendPushCursor(cursorInfo); }
-
-  void PopCursor() { SendPopCursor(); }
-
-  bool GetNativeCursorsSupported() {
-    return Settings().nativeCursorsSupported();
-  }
-#endif
-
-  int GetQuirks() { return mQuirks; }
-
-  const PluginSettings& Settings() const { return mCachedSettings; }
-
-  NPError PluginRequiresAudioDeviceChanges(PluginInstanceChild* aInstance,
-                                           NPBool aShouldRegister);
-  mozilla::ipc::IPCResult RecvNPP_SetValue_NPNVaudioDeviceChangeDetails(
-      const NPAudioDeviceChangeDetailsIPC& detailsIPC);
-  mozilla::ipc::IPCResult RecvNPP_SetValue_NPNVaudioDeviceStateChanged(
-      const NPAudioDeviceStateChangedIPC& aDeviceStateIPC);
-
- private:
-  NPError DoNP_Initialize(const PluginSettings& aSettings);
-  void AddQuirk(PluginQuirks quirk) {
-    if (mQuirks == QUIRKS_NOT_INITIALIZED) mQuirks = 0;
-    mQuirks |= quirk;
-  }
-  void InitQuirksModes(const nsCString& aMimeType);
-  bool InitGraphics();
-  void DeinitGraphics();
-
-#if defined(MOZ_WIDGET_GTK)
-  static gboolean DetectNestedEventLoop(gpointer data);
-  static gboolean ProcessBrowserEvents(gpointer data);
-
-  virtual void EnteredCxxStack() override;
-  virtual void ExitedCxxStack() override;
-#endif
-
-  PRLibrary* mLibrary;
-  nsCString mPluginFilename;  // UTF8
-  int mQuirks;
-
-  bool mIsChrome;
-  bool mHasShutdown;  // true if NP_Shutdown has run
-
-#ifdef MOZ_GECKO_PROFILER
-  RefPtr<ChildProfilerController> mProfilerController;
-#endif
-
-  // we get this from the plugin
-  NP_PLUGINSHUTDOWN mShutdownFunc;
-#if defined(OS_LINUX) || defined(OS_BSD) || defined(OS_SOLARIS)
-  NP_PLUGINUNIXINIT mInitializeFunc;
-#elif defined(OS_WIN) || defined(OS_MACOSX)
-  NP_PLUGININIT mInitializeFunc;
-  NP_GETENTRYPOINTS mGetEntryPointsFunc;
-#endif
-
-  NPPluginFuncs mFunctions;
-
-  PluginSettings mCachedSettings;
-
-#if defined(MOZ_WIDGET_GTK)
-  // If a plugin spins a nested glib event loop in response to a
-  // synchronous IPC message from the browser, the loop might break
-  // only after the browser responds to a request sent by the
-  // plugin.  This can happen if a plugin uses gtk's synchronous
-  // copy/paste, for example.  But because the browser is blocked on
-  // a condvar, it can't respond to the request.  This situation
-  // isn't technically a deadlock, but the symptoms are basically
-  // the same from the user's perspective.
-  //
-  // We take two steps to prevent this
-  //
-  //  (1) Detect nested event loops spun by the plugin.  This is
-  //      done by scheduling a glib timer event in the plugin
-  //      process whenever the browser might block on the plugin.
-  //      If the plugin indeed spins a nested loop, this timer event
-  //      will fire "soon" thereafter.
-  //
-  //  (2) When a nested loop is detected, deschedule the
-  //      nested-loop-detection timer and in its place, schedule
-  //      another timer that periodically calls back into the
-  //      browser and spins a mini event loop.  This mini event loop
-  //      processes a handful of pending native events.
-  //
-  // Because only timer (1) or (2) (or neither) may be active at any
-  // point in time, we use the same member variable
-  // |mNestedLoopTimerId| to refer to both.
-  //
-  // When the browser no longer might be blocked on a plugin's IPC
-  // response, we deschedule whichever of (1) or (2) is active.
-  guint mNestedLoopTimerId;
-#  ifdef DEBUG
-  // Depth of the stack of calls to g_main_context_dispatch before any
-  // nested loops are run.  This is 1 when IPC calls are dispatched from
-  // g_main_context_iteration, or 0 when dispatched directly from
-  // MessagePumpForUI.
-  int mTopLoopDepth;
-#  endif
-#endif
-
-#if defined(XP_WIN)
-  typedef nsTHashtable<nsPtrHashKey<PluginInstanceChild>> PluginInstanceSet;
-  // Set of plugins that have registered to be notified when the audio device
-  // changes.
-  PluginInstanceSet mAudioNotificationSet;
-#endif
-
- public:  // called by PluginInstanceChild
-  /**
-   * Dealloc an NPObject after last-release or when the associated instance
-   * is destroyed. This function will remove the object from mObjectMap.
-   */
-  static void DeallocNPObject(NPObject* o);
-
-  NPError NPP_Destroy(PluginInstanceChild* instance) {
-    return mFunctions.destroy(instance->GetNPP(), 0);
-  }
-
-#if defined(OS_MACOSX) && defined(MOZ_SANDBOX)
-  void EnableFlashSandbox(int aLevel, bool aShouldEnableLogging);
-#endif
-
- private:
-#if defined(OS_MACOSX) && defined(MOZ_SANDBOX)
-  int mFlashSandboxLevel;
-  bool mEnableFlashSandboxLogging;
-#endif
-
-#if defined(OS_WIN)
-  virtual void EnteredCall() override;
-  virtual void ExitedCall() override;
-
-  // Entered/ExitedCall notifications keep track of whether the plugin has
-  // entered a nested event loop within this interrupt call.
-  struct IncallFrame {
-    IncallFrame() : _spinning(false), _savedNestableTasksAllowed(false) {}
-
-    bool _spinning;
-    bool _savedNestableTasksAllowed;
-  };
-
-  AutoTArray<IncallFrame, 8> mIncallPumpingStack;
-
-  static LRESULT CALLBACK NestedInputEventHook(int code, WPARAM wParam,
-                                               LPARAM lParam);
-  static LRESULT CALLBACK CallWindowProcHook(int code, WPARAM wParam,
-                                             LPARAM lParam);
-  void SetEventHooks();
-  void ResetEventHooks();
-  HHOOK mNestedEventHook;
-  HHOOK mGlobalCallWndProcHook;
-
- public:
-  bool mAsyncRenderSupport;
-#endif
-};
-
-} /* namespace plugins */
-} /* namespace mozilla */
-
-#endif  // ifndef dom_plugins_PluginModuleChild_h
diff --git a/dom/plugins/ipc/PluginModuleParent.cpp b/dom/plugins/ipc/PluginModuleParent.cpp
deleted file mode 100644
index b4200a0724bb7..0000000000000
--- a/dom/plugins/ipc/PluginModuleParent.cpp
+++ /dev/null
@@ -1,2469 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "mozilla/plugins/PluginModuleParent.h"
-
-#include "base/process_util.h"
-#include "mozilla/Attributes.h"
-#include "mozilla/AutoRestore.h"
-#include "mozilla/BackgroundHangMonitor.h"
-#include "mozilla/dom/ContentParent.h"
-#include "mozilla/dom/ContentChild.h"
-#include "mozilla/dom/Document.h"
-#include "mozilla/ipc/CrashReporterClient.h"
-#include "mozilla/ipc/CrashReporterHost.h"
-#include "mozilla/dom/Element.h"
-#include "mozilla/ipc/Endpoint.h"
-#include "mozilla/ipc/GeckoChildProcessHost.h"
-#include "mozilla/ipc/MessageChannel.h"
-#include "mozilla/layers/ImageBridgeChild.h"
-#include "mozilla/plugins/BrowserStreamParent.h"
-#include "mozilla/plugins/PluginBridge.h"
-#include "mozilla/plugins/PluginInstanceParent.h"
-#include "mozilla/plugins/PPluginBackgroundDestroyerParent.h"
-#include "mozilla/plugins/PStreamNotifyParent.h"
-#include "mozilla/Preferences.h"
-#include "mozilla/ProcessHangMonitor.h"
-#include "mozilla/ProfilerLabels.h"
-#include "mozilla/Services.h"
-#include "mozilla/Telemetry.h"
-#include "mozilla/Unused.h"
-#include "mozilla/UniquePtr.h"
-#include "nsCRT.h"
-#include "nsIFile.h"
-#include "nsICrashService.h"
-#include "nsIObserverService.h"
-#include "nsNPAPIPlugin.h"
-#include "nsPluginInstanceOwner.h"
-#include "nsPrintfCString.h"
-#include "prsystem.h"
-#include "prclist.h"
-#include "PluginQuirks.h"
-#include "gfxPlatform.h"
-#include "nsPluginTags.h"
-#include "nsUnicharUtils.h"
-#include "mozilla/layers/TextureClientRecycleAllocator.h"
-
-#ifdef XP_WIN
-#  include "mozilla/plugins/PluginSurfaceParent.h"
-#  include "mozilla/widget/AudioSession.h"
-#  include "PluginHangUIParent.h"
-#  include "FunctionBrokerParent.h"
-#  include "PluginUtilsWin.h"
-#endif
-
-#ifdef MOZ_WIDGET_GTK
-#  include <glib.h>
-#elif XP_MACOSX
-#  include "PluginUtilsOSX.h"
-#endif
-
-#ifdef MOZ_GECKO_PROFILER
-#  include "ProfilerParent.h"
-#endif
-
-using base::KillProcess;
-
-using mozilla::PluginLibrary;
-using mozilla::ipc::GeckoChildProcessHost;
-using mozilla::ipc::MessageChannel;
-
-using namespace mozilla;
-using namespace mozilla::plugins;
-using namespace mozilla::plugins::parent;
-
-using namespace CrashReporter;
-
-static const char kContentTimeoutPref[] = "dom.ipc.plugins.contentTimeoutSecs";
-static const char kChildTimeoutPref[] = "dom.ipc.plugins.timeoutSecs";
-static const char kParentTimeoutPref[] = "dom.ipc.plugins.parentTimeoutSecs";
-static const char kLaunchTimeoutPref[] =
-    "dom.ipc.plugins.processLaunchTimeoutSecs";
-#ifdef XP_WIN
-static const char kHangUITimeoutPref[] = "dom.ipc.plugins.hangUITimeoutSecs";
-static const char kHangUIMinDisplayPref[] =
-    "dom.ipc.plugins.hangUIMinDisplaySecs";
-#  define CHILD_TIMEOUT_PREF kHangUITimeoutPref
-#else
-#  define CHILD_TIMEOUT_PREF kChildTimeoutPref
-#endif
-
-bool mozilla::plugins::SetupBridge(
-    uint32_t aPluginId, dom::ContentParent* aContentParent, nsresult* rv,
-    uint32_t* runID, ipc::Endpoint<PPluginModuleParent>* aEndpoint) {
-  AUTO_PROFILER_LABEL("plugins::SetupBridge", OTHER);
-  if (NS_WARN_IF(!rv) || NS_WARN_IF(!runID)) {
-    return false;
-  }
-
-  RefPtr<nsPluginHost> host = nsPluginHost::GetInst();
-  RefPtr<nsNPAPIPlugin> plugin;
-  *rv = host->GetPluginForContentProcess(aPluginId, getter_AddRefs(plugin));
-  if (NS_FAILED(*rv)) {
-    return true;
-  }
-  PluginModuleChromeParent* chromeParent =
-      static_cast<PluginModuleChromeParent*>(plugin->GetLibrary());
-  *rv = chromeParent->GetRunID(runID);
-  if (NS_FAILED(*rv)) {
-    return true;
-  }
-
-  ipc::Endpoint<PPluginModuleParent> parent;
-  ipc::Endpoint<PPluginModuleChild> child;
-
-  *rv = PPluginModule::CreateEndpoints(
-      aContentParent->OtherPid(), chromeParent->OtherPid(), &parent, &child);
-  if (NS_FAILED(*rv)) {
-    return true;
-  }
-
-  *aEndpoint = std::move(parent);
-
-  if (!chromeParent->SendInitPluginModuleChild(std::move(child))) {
-    *rv = NS_ERROR_BRIDGE_OPEN_CHILD;
-    return true;
-  }
-
-  return true;
-}
-
-#ifdef MOZ_CRASHREPORTER_INJECTOR
-
-/**
- * Use for executing CreateToolhelp32Snapshot off main thread
- */
-class mozilla::plugins::FinishInjectorInitTask
-    : public mozilla::CancelableRunnable {
- public:
-  FinishInjectorInitTask()
-      : CancelableRunnable("FinishInjectorInitTask"),
-        mMutex("FlashInjectorInitTask::mMutex"),
-        mParent(nullptr),
-        mMainThreadMsgLoop(MessageLoop::current()) {
-    MOZ_ASSERT(NS_IsMainThread());
-  }
-
-  void Init(PluginModuleChromeParent* aParent) {
-    MOZ_ASSERT(aParent);
-    mParent = aParent;
-  }
-
-  void PostToMainThread() {
-    RefPtr<Runnable> self = this;
-    mSnapshot.own(CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0));
-    {  // Scope for lock
-      mozilla::MutexAutoLock lock(mMutex);
-      if (mMainThreadMsgLoop) {
-        mMainThreadMsgLoop->PostTask(self.forget());
-      }
-    }
-  }
-
-  NS_IMETHOD Run() override {
-    mParent->DoInjection(mSnapshot);
-    // We don't need to hold this lock during DoInjection, but we do need
-    // to obtain it before returning from Run() to ensure that
-    // PostToMainThread has completed before we return.
-    mozilla::MutexAutoLock lock(mMutex);
-    return NS_OK;
-  }
-
-  nsresult Cancel() override {
-    mozilla::MutexAutoLock lock(mMutex);
-    mMainThreadMsgLoop = nullptr;
-    return NS_OK;
-  }
-
- private:
-  mozilla::Mutex mMutex;
-  nsAutoHandle mSnapshot;
-  PluginModuleChromeParent* mParent;
-  MessageLoop* mMainThreadMsgLoop;
-};
-
-#endif  // MOZ_CRASHREPORTER_INJECTOR
-
-namespace {
-
-/**
- * Objects of this class remain linked until an error occurs in the
- * plugin initialization sequence.
- */
-class PluginModuleMapping : public PRCList {
- public:
-  explicit PluginModuleMapping(uint32_t aPluginId)
-      : mPluginId(aPluginId),
-        mProcessIdValid(false),
-        mProcessId(0),
-        mModule(nullptr),
-        mChannelOpened(false) {
-    MOZ_COUNT_CTOR(PluginModuleMapping);
-    PR_INIT_CLIST(this);
-    PR_APPEND_LINK(this, &sModuleListHead);
-  }
-
-  ~PluginModuleMapping() {
-    PR_REMOVE_LINK(this);
-    MOZ_COUNT_DTOR(PluginModuleMapping);
-  }
-
-  bool IsChannelOpened() const { return mChannelOpened; }
-
-  void SetChannelOpened() { mChannelOpened = true; }
-
-  PluginModuleContentParent* GetModule() {
-    if (!mModule) {
-      mModule = new PluginModuleContentParent();
-    }
-    return mModule;
-  }
-
-  static PluginModuleMapping* AssociateWithProcessId(
-      uint32_t aPluginId, base::ProcessId aProcessId) {
-    PluginModuleMapping* mapping =
-        static_cast<PluginModuleMapping*>(PR_NEXT_LINK(&sModuleListHead));
-    while (mapping != &sModuleListHead) {
-      if (mapping->mPluginId == aPluginId) {
-        mapping->AssociateWithProcessId(aProcessId);
-        return mapping;
-      }
-      mapping = static_cast<PluginModuleMapping*>(PR_NEXT_LINK(mapping));
-    }
-    return nullptr;
-  }
-
-  static PluginModuleMapping* Resolve(base::ProcessId aProcessId) {
-    PluginModuleMapping* mapping = nullptr;
-
-    if (sIsLoadModuleOnStack) {
-      // Special case: If loading synchronously, we just need to access
-      // the tail entry of the list.
-      mapping =
-          static_cast<PluginModuleMapping*>(PR_LIST_TAIL(&sModuleListHead));
-      MOZ_ASSERT(mapping);
-      return mapping;
-    }
-
-    mapping = static_cast<PluginModuleMapping*>(PR_NEXT_LINK(&sModuleListHead));
-    while (mapping != &sModuleListHead) {
-      if (mapping->mProcessIdValid && mapping->mProcessId == aProcessId) {
-        return mapping;
-      }
-      mapping = static_cast<PluginModuleMapping*>(PR_NEXT_LINK(mapping));
-    }
-    return nullptr;
-  }
-
-  static PluginModuleMapping* FindModuleByPluginId(uint32_t aPluginId) {
-    PluginModuleMapping* mapping =
-        static_cast<PluginModuleMapping*>(PR_NEXT_LINK(&sModuleListHead));
-    while (mapping != &sModuleListHead) {
-      if (mapping->mPluginId == aPluginId) {
-        return mapping;
-      }
-      mapping = static_cast<PluginModuleMapping*>(PR_NEXT_LINK(mapping));
-    }
-    return nullptr;
-  }
-
-  class MOZ_RAII NotifyLoadingModule {
-   public:
-    explicit NotifyLoadingModule() {
-      PluginModuleMapping::sIsLoadModuleOnStack = true;
-    }
-
-    ~NotifyLoadingModule() {
-      PluginModuleMapping::sIsLoadModuleOnStack = false;
-    }
-
-   private:
-  };
-
- private:
-  void AssociateWithProcessId(base::ProcessId aProcessId) {
-    MOZ_ASSERT(!mProcessIdValid);
-    mProcessId = aProcessId;
-    mProcessIdValid = true;
-  }
-
-  uint32_t mPluginId;
-  bool mProcessIdValid;
-  base::ProcessId mProcessId;
-  PluginModuleContentParent* mModule;
-  bool mChannelOpened;
-
-  friend class NotifyLoadingModule;
-
-  static PRCList sModuleListHead;
-  static bool sIsLoadModuleOnStack;
-};
-
-PRCList PluginModuleMapping::sModuleListHead =
-    PR_INIT_STATIC_CLIST(&PluginModuleMapping::sModuleListHead);
-
-bool PluginModuleMapping::sIsLoadModuleOnStack = false;
-
-}  // namespace
-
-static PluginModuleChromeParent* PluginModuleChromeParentForId(
-    const uint32_t aPluginId) {
-  MOZ_ASSERT(XRE_IsParentProcess());
-
-  RefPtr<nsPluginHost> host = nsPluginHost::GetInst();
-  nsPluginTag* pluginTag = host->PluginWithId(aPluginId);
-  if (!pluginTag || !pluginTag->mPlugin) {
-    return nullptr;
-  }
-  RefPtr<nsNPAPIPlugin> plugin = pluginTag->mPlugin;
-
-  return static_cast<PluginModuleChromeParent*>(plugin->GetLibrary());
-}
-
-void mozilla::plugins::TakeFullMinidump(uint32_t aPluginId,
-                                        base::ProcessId aContentProcessId,
-                                        const nsAString& aBrowserDumpId,
-                                        nsString& aDumpId) {
-  PluginModuleChromeParent* chromeParent =
-      PluginModuleChromeParentForId(aPluginId);
-
-  if (chromeParent) {
-    chromeParent->TakeFullMinidump(aContentProcessId, aBrowserDumpId, aDumpId);
-  }
-}
-
-void mozilla::plugins::TerminatePlugin(uint32_t aPluginId,
-                                       base::ProcessId aContentProcessId,
-                                       const nsCString& aMonitorDescription,
-                                       const nsAString& aDumpId) {
-  PluginModuleChromeParent* chromeParent =
-      PluginModuleChromeParentForId(aPluginId);
-
-  if (chromeParent) {
-    chromeParent->TerminateChildProcess(MessageLoop::current(),
-                                        aContentProcessId, aMonitorDescription,
-                                        aDumpId);
-  }
-}
-
-/* static */
-PluginLibrary* PluginModuleContentParent::LoadModule(uint32_t aPluginId,
-                                                     nsPluginTag* aPluginTag) {
-  PluginModuleMapping::NotifyLoadingModule loadingModule;
-  UniquePtr<PluginModuleMapping> mapping(new PluginModuleMapping(aPluginId));
-
-  MOZ_ASSERT(XRE_IsContentProcess());
-
-  /*
-   * We send a LoadPlugin message to the chrome process using an intr
-   * message. Before it sends its response, it sends a message to create
-   * PluginModuleParent instance. That message is handled by
-   * PluginModuleContentParent::Initialize, which saves the instance in
-   * its module mapping. We fetch it from there after LoadPlugin finishes.
-   */
-  dom::ContentChild* cp = dom::ContentChild::GetSingleton();
-  nsresult rv;
-  uint32_t runID;
-  Endpoint<PPluginModuleParent> endpoint;
-  if (!cp->SendLoadPlugin(aPluginId, &rv, &runID, &endpoint) || NS_FAILED(rv)) {
-    return nullptr;
-  }
-  Initialize(std::move(endpoint));
-
-  PluginModuleContentParent* parent = mapping->GetModule();
-  MOZ_ASSERT(parent);
-
-  if (!mapping->IsChannelOpened()) {
-    // mapping is linked into PluginModuleMapping::sModuleListHead and is
-    // needed later, so since this function is returning successfully we
-    // forget it here.
-    Unused << mapping.release();
-  }
-
-  parent->mPluginId = aPluginId;
-  parent->mRunID = runID;
-
-  return parent;
-}
-
-/* static */
-void PluginModuleContentParent::Initialize(
-    Endpoint<PPluginModuleParent>&& aEndpoint) {
-  UniquePtr<PluginModuleMapping> moduleMapping(
-      PluginModuleMapping::Resolve(aEndpoint.OtherPid()));
-  MOZ_ASSERT(moduleMapping);
-  PluginModuleContentParent* parent = moduleMapping->GetModule();
-  MOZ_ASSERT(parent);
-
-  DebugOnly<bool> ok = aEndpoint.Bind(parent);
-  MOZ_ASSERT(ok);
-
-  moduleMapping->SetChannelOpened();
-
-  if (XRE_UseNativeEventProcessing()) {
-    // If we're processing native events in our message pump, request Windows
-    // message deferral behavior on our channel. This applies to the top level
-    // and all sub plugin protocols since they all share the same channel.
-    parent->GetIPCChannel()->SetChannelFlags(
-        MessageChannel::REQUIRE_DEFERRED_MESSAGE_PROTECTION);
-  }
-
-  TimeoutChanged(kContentTimeoutPref, parent);
-
-  // moduleMapping is linked into PluginModuleMapping::sModuleListHead and is
-  // needed later, so since this function is returning successfully we
-  // forget it here.
-  Unused << moduleMapping.release();
-}
-
-// static
-PluginLibrary* PluginModuleChromeParent::LoadModule(const char* aFilePath,
-                                                    uint32_t aPluginId,
-                                                    nsPluginTag* aPluginTag) {
-  PLUGIN_LOG_DEBUG_FUNCTION;
-
-  UniquePtr<PluginModuleChromeParent> parent(new PluginModuleChromeParent(
-      aFilePath, aPluginId, aPluginTag->mSandboxLevel));
-  UniquePtr<LaunchCompleteTask> onLaunchedRunnable(
-      new LaunchedTask(parent.get()));
-  bool launched = parent->mSubprocess->Launch(
-      std::move(onLaunchedRunnable), aPluginTag->mSandboxLevel,
-      aPluginTag->mIsSandboxLoggingEnabled);
-  if (!launched) {
-    // We never reached open
-    parent->mShutdown = true;
-    return nullptr;
-  }
-  parent->mIsFlashPlugin = aPluginTag->mIsFlashPlugin;
-  uint32_t blocklistState;
-  nsresult rv = aPluginTag->GetBlocklistState(&blocklistState);
-  parent->mIsBlocklisted = NS_FAILED(rv) || blocklistState != 0;
-  int32_t launchTimeoutSecs = Preferences::GetInt(kLaunchTimeoutPref, 0);
-  if (!parent->mSubprocess->WaitUntilConnected(launchTimeoutSecs * 1000)) {
-    parent->mShutdown = true;
-    return nullptr;
-  }
-
-#if defined(XP_WIN)
-  Endpoint<PFunctionBrokerParent> brokerParentEnd;
-  Endpoint<PFunctionBrokerChild> brokerChildEnd;
-  rv = PFunctionBroker::CreateEndpoints(base::GetCurrentProcId(),
-                                        parent->OtherPid(), &brokerParentEnd,
-                                        &brokerChildEnd);
-  if (NS_FAILED(rv)) {
-    parent->mShutdown = true;
-    return nullptr;
-  }
-
-  parent->mBrokerParent =
-      FunctionBrokerParent::Create(std::move(brokerParentEnd));
-  if (parent->mBrokerParent) {
-    Unused << parent->SendInitPluginFunctionBroker(std::move(brokerChildEnd));
-  }
-#endif
-  return parent.release();
-}
-
-static const char* gCallbackPrefs[] = {
-    kChildTimeoutPref,
-    kParentTimeoutPref,
-#ifdef XP_WIN
-    kHangUITimeoutPref,
-    kHangUIMinDisplayPref,
-#endif
-    nullptr,
-};
-
-void PluginModuleChromeParent::OnProcessLaunched(const bool aSucceeded) {
-  if (!aSucceeded) {
-    mShutdown = true;
-    OnInitFailure();
-    return;
-  }
-  // We may have already been initialized by another call that was waiting
-  // for process connect. If so, this function doesn't need to run.
-  if (mShutdown) {
-    return;
-  }
-
-  Open(mSubprocess->TakeChannel(),
-       base::GetProcId(mSubprocess->GetChildProcessHandle()));
-
-  // Request Windows message deferral behavior on our channel. This
-  // applies to the top level and all sub plugin protocols since they
-  // all share the same channel.
-  GetIPCChannel()->SetChannelFlags(
-      MessageChannel::REQUIRE_DEFERRED_MESSAGE_PROTECTION);
-
-  TimeoutChanged(CHILD_TIMEOUT_PREF, this);
-
-  Preferences::RegisterCallbacks(TimeoutChanged, gCallbackPrefs,
-                                 static_cast<PluginModuleParent*>(this));
-
-  RegisterSettingsCallbacks();
-
-  // If this fails, we're having IPC troubles, and we're doomed anyways.
-  if (!InitCrashReporter()) {
-    mShutdown = true;
-    Close();
-    OnInitFailure();
-    return;
-  }
-
-#if defined(XP_WIN) && defined(_X86_)
-  // Protected mode only applies to Windows and only to x86.
-  if (!mIsBlocklisted && mIsFlashPlugin &&
-      (Preferences::GetBool("dom.ipc.plugins.flash.disable-protected-mode",
-                            false) ||
-       mSandboxLevel >= 2)) {
-    Unused << SendDisableFlashProtectedMode();
-  }
-#endif
-
-#ifdef MOZ_GECKO_PROFILER
-  Unused << SendInitProfiler(ProfilerParent::CreateForProcess(OtherPid()));
-#endif
-}
-
-bool PluginModuleChromeParent::InitCrashReporter() {
-  NativeThreadId threadId;
-  if (!CallInitCrashReporter(&threadId)) {
-    return false;
-  }
-
-  {
-    mozilla::MutexAutoLock lock(mCrashReporterMutex);
-    mCrashReporter =
-        MakeUnique<ipc::CrashReporterHost>(GeckoProcessType_Plugin, threadId);
-  }
-
-  return true;
-}
-
-PluginModuleParent::PluginModuleParent(bool aIsChrome)
-    : mQuirks(QUIRKS_NOT_INITIALIZED),
-      mIsChrome(aIsChrome),
-      mShutdown(false),
-      mHadLocalInstance(false),
-      mClearSiteDataSupported(false),
-      mGetSitesWithDataSupported(false),
-      mNPNIface(nullptr),
-      mNPPIface(nullptr),
-      mPlugin(nullptr),
-      mTaskFactory(this),
-      mSandboxLevel(0),
-      mIsFlashPlugin(false),
-      mRunID(0),
-      mCrashReporterMutex("PluginModuleChromeParent::mCrashReporterMutex") {}
-
-PluginModuleParent::~PluginModuleParent() {
-  if (!OkToCleanup()) {
-    MOZ_CRASH("unsafe destruction");
-  }
-
-  if (!mShutdown) {
-    NS_WARNING("Plugin host deleted the module without shutting down.");
-    NPError err;
-    NP_Shutdown(&err);
-  }
-}
-
-PluginModuleContentParent::PluginModuleContentParent()
-    : PluginModuleParent(false), mPluginId(0) {
-  Preferences::RegisterCallback(TimeoutChanged, kContentTimeoutPref,
-                                static_cast<PluginModuleParent*>(this));
-}
-
-PluginModuleContentParent::~PluginModuleContentParent() {
-  Preferences::UnregisterCallback(TimeoutChanged, kContentTimeoutPref,
-                                  static_cast<PluginModuleParent*>(this));
-}
-
-PluginModuleChromeParent::PluginModuleChromeParent(const char* aFilePath,
-                                                   uint32_t aPluginId,
-                                                   int32_t aSandboxLevel)
-    : PluginModuleParent(true),
-      mSubprocess(new PluginProcessParent(aFilePath)),
-      mPluginId(aPluginId),
-      mChromeTaskFactory(this),
-      mHangAnnotationFlags(0)
-#ifdef XP_WIN
-      ,
-      mPluginCpuUsageOnHang(),
-      mHangUIParent(nullptr),
-      mHangUIEnabled(true),
-      mIsTimerReset(true),
-      mBrokerParent(nullptr)
-#endif
-#ifdef MOZ_CRASHREPORTER_INJECTOR
-      ,
-      mFlashProcess1(0),
-      mFlashProcess2(0),
-      mFinishInitTask(nullptr)
-#endif
-      ,
-      mIsBlocklisted(false),
-      mIsCleaningFromTimeout(false) {
-  NS_ASSERTION(mSubprocess, "Out of memory!");
-  mSandboxLevel = aSandboxLevel;
-  mRunID = GeckoChildProcessHost::GetUniqueID();
-
-  mozilla::BackgroundHangMonitor::RegisterAnnotator(*this);
-}
-
-PluginModuleChromeParent::~PluginModuleChromeParent() {
-  if (!OkToCleanup()) {
-    MOZ_CRASH("unsafe destruction");
-  }
-
-#ifdef XP_WIN
-  // If we registered for audio notifications, stop.
-  mozilla::plugins::PluginUtilsWin::RegisterForAudioDeviceChanges(this, false);
-#endif
-
-  if (!mShutdown) {
-    NS_WARNING("Plugin host deleted the module without shutting down.");
-    NPError err;
-    NP_Shutdown(&err);
-  }
-
-  NS_ASSERTION(mShutdown, "NP_Shutdown didn't");
-
-  if (mSubprocess) {
-    mSubprocess->Destroy();
-    mSubprocess = nullptr;
-  }
-
-#ifdef MOZ_CRASHREPORTER_INJECTOR
-  if (mFlashProcess1) UnregisterInjectorCallback(mFlashProcess1);
-  if (mFlashProcess2) UnregisterInjectorCallback(mFlashProcess2);
-  if (mFinishInitTask) {
-    // mFinishInitTask will be deleted by the main thread message_loop
-    mFinishInitTask->Cancel();
-  }
-#endif
-
-  UnregisterSettingsCallbacks();
-
-  Preferences::UnregisterCallbacks(TimeoutChanged, gCallbackPrefs,
-                                   static_cast<PluginModuleParent*>(this));
-
-#ifdef XP_WIN
-  if (mHangUIParent) {
-    delete mHangUIParent;
-    mHangUIParent = nullptr;
-  }
-#endif
-
-  mozilla::BackgroundHangMonitor::UnregisterAnnotator(*this);
-}
-
-void PluginModuleChromeParent::AddCrashAnnotations() {
-  // mCrashReporterMutex is already held by the caller
-  mCrashReporterMutex.AssertCurrentThreadOwns();
-
-  typedef nsDependentCString cstring;
-
-  // Get the plugin filename, try to get just the file leafname
-  const std::string& pluginFile = mSubprocess->GetPluginFilePath();
-  size_t filePos = pluginFile.rfind(FILE_PATH_SEPARATOR);
-  if (filePos == std::string::npos)
-    filePos = 0;
-  else
-    filePos++;
-  mCrashReporter->AddAnnotation(CrashReporter::Annotation::PluginFilename,
-                                cstring(pluginFile.substr(filePos).c_str()));
-  mCrashReporter->AddAnnotation(CrashReporter::Annotation::PluginName,
-                                mPluginName);
-  mCrashReporter->AddAnnotation(CrashReporter::Annotation::PluginVersion,
-                                mPluginVersion);
-
-  if (mCrashReporter) {
-#ifdef XP_WIN
-    if (mPluginCpuUsageOnHang.Length() > 0) {
-      nsCString cpuUsageStr;
-      cpuUsageStr.AppendFloat(std::ceil(mPluginCpuUsageOnHang[0] * 100) / 100);
-      mCrashReporter->AddAnnotation(CrashReporter::Annotation::PluginCpuUsage,
-                                    cpuUsageStr);
-
-#  ifdef MOZ_CRASHREPORTER_INJECTOR
-      for (uint32_t i = 1; i < mPluginCpuUsageOnHang.Length(); ++i) {
-        nsCString tempStr;
-        tempStr.AppendFloat(std::ceil(mPluginCpuUsageOnHang[i] * 100) / 100);
-        // HACK: There can only be at most two flash processes hence
-        // the hardcoded annotations
-        CrashReporter::Annotation annotation =
-            (i == 1) ? CrashReporter::Annotation::CpuUsageFlashProcess1
-                     : CrashReporter::Annotation::CpuUsageFlashProcess2;
-        mCrashReporter->AddAnnotation(annotation, tempStr);
-      }
-#  endif
-    }
-#endif
-  }
-}
-
-void PluginModuleParent::SetChildTimeout(const int32_t aChildTimeout) {
-  int32_t timeoutMs =
-      (aChildTimeout > 0) ? (1000 * aChildTimeout) : MessageChannel::kNoTimeout;
-  SetReplyTimeoutMs(timeoutMs);
-}
-
-void PluginModuleParent::TimeoutChanged(const char* aPref, void* aModule) {
-  auto module = static_cast<PluginModuleParent*>(aModule);
-
-  NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
-#ifndef XP_WIN
-  if (!strcmp(aPref, kChildTimeoutPref)) {
-    MOZ_ASSERT(module->IsChrome());
-    // The timeout value used by the parent for children
-    int32_t timeoutSecs = Preferences::GetInt(kChildTimeoutPref, 0);
-    module->SetChildTimeout(timeoutSecs);
-#else
-  if (!strcmp(aPref, kChildTimeoutPref) ||
-      !strcmp(aPref, kHangUIMinDisplayPref) ||
-      !strcmp(aPref, kHangUITimeoutPref)) {
-    MOZ_ASSERT(module->IsChrome());
-    static_cast<PluginModuleChromeParent*>(module)->EvaluateHangUIState(true);
-#endif  // XP_WIN
-  } else if (!strcmp(aPref, kParentTimeoutPref)) {
-    // The timeout value used by the child for its parent
-    MOZ_ASSERT(module->IsChrome());
-    int32_t timeoutSecs = Preferences::GetInt(kParentTimeoutPref, 0);
-    Unused << static_cast<PluginModuleChromeParent*>(module)
-                  ->SendSetParentHangTimeout(timeoutSecs);
-  } else if (!strcmp(aPref, kContentTimeoutPref)) {
-    MOZ_ASSERT(!module->IsChrome());
-    int32_t timeoutSecs = Preferences::GetInt(kContentTimeoutPref, 0);
-    module->SetChildTimeout(timeoutSecs);
-  }
-}
-
-void PluginModuleChromeParent::CleanupFromTimeout(const bool aFromHangUI) {
-  if (mShutdown) {
-    return;
-  }
-
-  if (!OkToCleanup()) {
-    // there's still plugin code on the C++ stack, try again
-    MessageLoop::current()->PostDelayedTask(
-        mChromeTaskFactory.NewRunnableMethod(
-            &PluginModuleChromeParent::CleanupFromTimeout, aFromHangUI),
-        10);
-    return;
-  }
-
-  // Avoid recursively calling this method.  MessageChannel::Close() can
-  // cause this task to be re-launched.
-  if (mIsCleaningFromTimeout) {
-    return;
-  }
-
-  AutoRestore<bool> resetCleaningFlag(mIsCleaningFromTimeout);
-  mIsCleaningFromTimeout = true;
-
-  /* If the plugin container was terminated by the Plugin Hang UI,
-     then either the I/O thread detects a channel error, or the
-     main thread must set the error (whomever gets there first).
-     OTOH, if we terminate and return false from
-     ShouldContinueFromReplyTimeout, then the channel state has
-     already been set to ChannelTimeout and we should call the
-     regular Close function. */
-  if (aFromHangUI) {
-    GetIPCChannel()->CloseWithError();
-  } else {
-    Close();
-  }
-}
-
-#ifdef XP_WIN
-namespace {
-
-uint64_t FileTimeToUTC(const FILETIME& ftime) {
-  ULARGE_INTEGER li;
-  li.LowPart = ftime.dwLowDateTime;
-  li.HighPart = ftime.dwHighDateTime;
-  return li.QuadPart;
-}
-
-struct CpuUsageSamples {
-  uint64_t sampleTimes[2];
-  uint64_t cpuTimes[2];
-};
-
-bool GetProcessCpuUsage(const nsTArray<base::ProcessHandle>& processHandles,
-                        nsTArray<float>& cpuUsage) {
-  nsTArray<CpuUsageSamples> samples(processHandles.Length());
-  FILETIME creationTime, exitTime, kernelTime, userTime, currentTime;
-  BOOL res;
-
-  for (uint32_t i = 0; i < processHandles.Length(); ++i) {
-    ::GetSystemTimeAsFileTime(&currentTime);
-    res = ::GetProcessTimes(processHandles[i], &creationTime, &exitTime,
-                            &kernelTime, &userTime);
-    if (!res) {
-      NS_WARNING("failed to get process times");
-      return false;
-    }
-
-    CpuUsageSamples s;
-    s.sampleTimes[0] = FileTimeToUTC(currentTime);
-    s.cpuTimes[0] = FileTimeToUTC(kernelTime) + FileTimeToUTC(userTime);
-    samples.AppendElement(s);
-  }
-
-  // we already hung for a while, a little bit longer won't matter
-  ::Sleep(50);
-
-  const int32_t numberOfProcessors = PR_GetNumberOfProcessors();
-
-  for (uint32_t i = 0; i < processHandles.Length(); ++i) {
-    ::GetSystemTimeAsFileTime(&currentTime);
-    res = ::GetProcessTimes(processHandles[i], &creationTime, &exitTime,
-                            &kernelTime, &userTime);
-    if (!res) {
-      NS_WARNING("failed to get process times");
-      return false;
-    }
-
-    samples[i].sampleTimes[1] = FileTimeToUTC(currentTime);
-    samples[i].cpuTimes[1] =
-        FileTimeToUTC(kernelTime) + FileTimeToUTC(userTime);
-
-    const uint64_t deltaSampleTime =
-        samples[i].sampleTimes[1] - samples[i].sampleTimes[0];
-    const uint64_t deltaCpuTime =
-        samples[i].cpuTimes[1] - samples[i].cpuTimes[0];
-    const float usage =
-        100.f * (float(deltaCpuTime) / deltaSampleTime) / numberOfProcessors;
-    cpuUsage.AppendElement(usage);
-  }
-
-  return true;
-}
-
-}  // namespace
-
-#endif  // #ifdef XP_WIN
-
-/**
- * This function converts the topmost routing id on the call stack (as recorded
- * by the MessageChannel) into a pointer to a IProtocol object.
- */
-mozilla::ipc::IProtocol* PluginModuleChromeParent::GetInvokingProtocol() {
-  int32_t routingId = GetIPCChannel()->GetTopmostMessageRoutingId();
-  // Nothing being routed. No protocol. Just return nullptr.
-  if (routingId == MSG_ROUTING_NONE) {
-    return nullptr;
-  }
-  // If routingId is MSG_ROUTING_CONTROL then we're dealing with control
-  // messages that were initiated by the topmost managing protocol, ie. this.
-  if (routingId == MSG_ROUTING_CONTROL) {
-    return this;
-  }
-  // Otherwise we can look up the protocol object by the routing id.
-  mozilla::ipc::IProtocol* protocol = Lookup(routingId);
-  return protocol;
-}
-
-/**
- * This function examines the IProtocol object parameter and converts it into
- * the PluginInstanceParent object that is associated with that protocol, if
- * any. Since PluginInstanceParent manages subprotocols, this function needs
- * to determine whether |aProtocol| is a subprotocol, and if so it needs to
- * obtain the protocol's manager.
- *
- * This function needs to be updated if the subprotocols are modified in
- * PPluginInstance.ipdl.
- */
-PluginInstanceParent* PluginModuleChromeParent::GetManagingInstance(
-    mozilla::ipc::IProtocol* aProtocol) {
-  MOZ_ASSERT(aProtocol);
-  mozilla::ipc::IProtocol* listener = aProtocol;
-  switch (listener->GetProtocolId()) {
-    case PPluginInstanceMsgStart:
-      // In this case, aProtocol is the instance itself. Just cast it.
-      return static_cast<PluginInstanceParent*>(aProtocol);
-    case PPluginBackgroundDestroyerMsgStart: {
-      PPluginBackgroundDestroyerParent* actor =
-          static_cast<PPluginBackgroundDestroyerParent*>(aProtocol);
-      return static_cast<PluginInstanceParent*>(actor->Manager());
-    }
-    case PPluginScriptableObjectMsgStart: {
-      PPluginScriptableObjectParent* actor =
-          static_cast<PPluginScriptableObjectParent*>(aProtocol);
-      return static_cast<PluginInstanceParent*>(actor->Manager());
-    }
-    case PBrowserStreamMsgStart: {
-      PBrowserStreamParent* actor =
-          static_cast<PBrowserStreamParent*>(aProtocol);
-      return static_cast<PluginInstanceParent*>(actor->Manager());
-    }
-    case PStreamNotifyMsgStart: {
-      PStreamNotifyParent* actor = static_cast<PStreamNotifyParent*>(aProtocol);
-      return static_cast<PluginInstanceParent*>(actor->Manager());
-    }
-#ifdef XP_WIN
-    case PPluginSurfaceMsgStart: {
-      PPluginSurfaceParent* actor =
-          static_cast<PPluginSurfaceParent*>(aProtocol);
-      return static_cast<PluginInstanceParent*>(actor->Manager());
-    }
-#endif
-    default:
-      return nullptr;
-  }
-}
-
-void PluginModuleChromeParent::EnteredCxxStack() {
-  mHangAnnotationFlags |= kInPluginCall;
-}
-
-void PluginModuleChromeParent::ExitedCxxStack() {
-  mHangAnnotationFlags = 0;
-#ifdef XP_WIN
-  FinishHangUI();
-#endif
-}
-
-/**
- * This function is always called by the BackgroundHangMonitor thread.
- */
-void PluginModuleChromeParent::AnnotateHang(
-    mozilla::BackgroundHangAnnotations& aAnnotations) {
-  uint32_t flags = mHangAnnotationFlags;
-  if (flags) {
-    /* We don't actually annotate anything specifically for kInPluginCall;
-       we use it to determine whether to annotate other things. It will
-       be pretty obvious from the hang stack that we're in a plugin
-       call when the hang occurred. */
-    if (flags & kHangUIShown) {
-      aAnnotations.AddAnnotation(u"HangUIShown"_ns, true);
-    }
-    if (flags & kHangUIContinued) {
-      aAnnotations.AddAnnotation(u"HangUIContinued"_ns, true);
-    }
-    if (flags & kHangUIDontShow) {
-      aAnnotations.AddAnnotation(u"HangUIDontShow"_ns, true);
-    }
-    aAnnotations.AddAnnotation(u"pluginName"_ns, mPluginName);
-    aAnnotations.AddAnnotation(u"pluginVersion"_ns, mPluginVersion);
-  }
-}
-
-static bool CreatePluginMinidump(base::ProcessId processId,
-                                 ThreadId childThread, nsIFile* parentMinidump,
-                                 const nsACString& name) {
-  mozilla::ipc::ScopedProcessHandle handle;
-  if (processId == 0 ||
-      !base::OpenPrivilegedProcessHandle(processId, &handle.rwget())) {
-    return false;
-  }
-  return CreateAdditionalChildMinidump(handle, 0, parentMinidump, name);
-}
-
-bool PluginModuleChromeParent::ShouldContinueFromReplyTimeout() {
-  if (mIsFlashPlugin) {
-    MessageLoop::current()->PostTask(mTaskFactory.NewRunnableMethod(
-        &PluginModuleChromeParent::NotifyFlashHang));
-  }
-
-#ifdef XP_WIN
-  if (LaunchHangUI()) {
-    return true;
-  }
-  // If LaunchHangUI returned false then we should proceed with the
-  // original plugin hang behaviour and kill the plugin container.
-  FinishHangUI();
-#endif  // XP_WIN
-
-  TerminateChildProcess(MessageLoop::current(), mozilla::ipc::kInvalidProcessId,
-                        "ModalHangUI"_ns, u""_ns);
-  GetIPCChannel()->CloseWithTimeout();
-  return false;
-}
-
-bool PluginModuleContentParent::ShouldContinueFromReplyTimeout() {
-  RefPtr<ProcessHangMonitor> monitor = ProcessHangMonitor::Get();
-  if (!monitor) {
-    return true;
-  }
-  monitor->NotifyPluginHang(mPluginId);
-  return true;
-}
-
-void PluginModuleContentParent::OnExitedSyncSend() {
-  ProcessHangMonitor::ClearHang();
-}
-
-void PluginModuleChromeParent::TakeFullMinidump(base::ProcessId aContentPid,
-                                                const nsAString& aBrowserDumpId,
-                                                nsString& aDumpId) {
-  mozilla::MutexAutoLock lock(mCrashReporterMutex);
-
-  if (!mCrashReporter) {
-    return;
-  }
-
-  bool reportsReady = false;
-
-  // Check to see if we already have a browser dump id - with e10s plugin
-  // hangs we take this earlier (see ProcessHangMonitor) from a background
-  // thread. We do this before we message the main thread about the hang
-  // since the posted message will trash our browser stack state.
-  nsCOMPtr<nsIFile> browserDumpFile;
-  if (CrashReporter::GetMinidumpForID(aBrowserDumpId,
-                                      getter_AddRefs(browserDumpFile))) {
-    // We have a single browser report, generate a new plugin process parent
-    // report and pair it up with the browser report handed in.
-    reportsReady = mCrashReporter->GenerateMinidumpAndPair(
-        this, browserDumpFile, "browser"_ns);
-
-    if (!reportsReady) {
-      browserDumpFile = nullptr;
-      CrashReporter::DeleteMinidumpFilesForID(aBrowserDumpId);
-    }
-  }
-
-  // Generate crash report including plugin and browser process minidumps.
-  // The plugin process is the parent report with additional dumps including
-  // the browser process, content process when running under e10s, and
-  // various flash subprocesses if we're the flash module.
-  if (!reportsReady) {
-    reportsReady = mCrashReporter->GenerateMinidumpAndPair(
-        this,
-        nullptr,  // Pair with a dump of this process and thread.
-        "browser"_ns);
-  }
-
-  if (reportsReady) {
-    aDumpId = mCrashReporter->MinidumpID();
-    PLUGIN_LOG_DEBUG(("generated paired browser/plugin minidumps: %s)",
-                      NS_ConvertUTF16toUTF8(aDumpId).get()));
-    nsAutoCString additionalDumps("browser");
-    nsCOMPtr<nsIFile> pluginDumpFile;
-    if (GetMinidumpForID(aDumpId, getter_AddRefs(pluginDumpFile))) {
-#ifdef MOZ_CRASHREPORTER_INJECTOR
-      // If we have handles to the flash sandbox processes on Windows,
-      // include those minidumps as well.
-      if (CreatePluginMinidump(mFlashProcess1, 0, pluginDumpFile,
-                               "flash1"_ns)) {
-        additionalDumps.AppendLiteral(",flash1");
-      }
-      if (CreatePluginMinidump(mFlashProcess2, 0, pluginDumpFile,
-                               "flash2"_ns)) {
-        additionalDumps.AppendLiteral(",flash2");
-      }
-#endif  // MOZ_CRASHREPORTER_INJECTOR
-      if (aContentPid != mozilla::ipc::kInvalidProcessId) {
-        // Include the content process minidump
-        if (CreatePluginMinidump(aContentPid, 0, pluginDumpFile,
-                                 "content"_ns)) {
-          additionalDumps.AppendLiteral(",content");
-        }
-      }
-    }
-    mCrashReporter->AddAnnotation(Annotation::additional_minidumps,
-                                  additionalDumps);
-  } else {
-    NS_WARNING("failed to capture paired minidumps from hang");
-  }
-}
-
-void PluginModuleChromeParent::TerminateChildProcess(
-    MessageLoop* aMsgLoop, base::ProcessId aContentPid,
-    const nsCString& aMonitorDescription, const nsAString& aDumpId) {
-  // Start by taking a full minidump if necessary, this is done early
-  // because it also needs to lock the mCrashReporterMutex and Mutex doesn't
-  // support recursive locking.
-  nsAutoString dumpId;
-  if (aDumpId.IsEmpty()) {
-    TakeFullMinidump(aContentPid, u""_ns, dumpId);
-  }
-
-  mozilla::MutexAutoLock lock(mCrashReporterMutex);
-  if (!mCrashReporter) {
-    // If mCrashReporter is null then the hang has ended, the plugin module
-    // is shutting down. There's nothing to do here.
-    return;
-  }
-  mCrashReporter->AddAnnotation(Annotation::PluginHang, true);
-  mCrashReporter->AddAnnotation(Annotation::HangMonitorDescription,
-                                aMonitorDescription);
-#ifdef XP_WIN
-  if (mHangUIParent) {
-    unsigned int hangUIDuration = mHangUIParent->LastShowDurationMs();
-    if (hangUIDuration) {
-      mCrashReporter->AddAnnotation(Annotation::PluginHangUIDuration,
-                                    hangUIDuration);
-    }
-  }
-#endif  // XP_WIN
-
-  mozilla::ipc::ScopedProcessHandle geckoChildProcess;
-  bool childOpened =
-      base::OpenProcessHandle(OtherPid(), &geckoChildProcess.rwget());
-
-#ifdef XP_WIN
-  // collect cpu usage for plugin processes
-
-  nsTArray<base::ProcessHandle> processHandles;
-
-  if (childOpened) {
-    processHandles.AppendElement(geckoChildProcess);
-  }
-
-#  ifdef MOZ_CRASHREPORTER_INJECTOR
-  mozilla::ipc::ScopedProcessHandle flashBrokerProcess;
-  if (mFlashProcess1 &&
-      base::OpenProcessHandle(mFlashProcess1, &flashBrokerProcess.rwget())) {
-    processHandles.AppendElement(flashBrokerProcess);
-  }
-  mozilla::ipc::ScopedProcessHandle flashSandboxProcess;
-  if (mFlashProcess2 &&
-      base::OpenProcessHandle(mFlashProcess2, &flashSandboxProcess.rwget())) {
-    processHandles.AppendElement(flashSandboxProcess);
-  }
-#  endif
-
-  if (!GetProcessCpuUsage(processHandles, mPluginCpuUsageOnHang)) {
-    mPluginCpuUsageOnHang.Clear();
-  }
-#endif
-
-  // this must run before the error notification from the channel,
-  // or not at all
-  bool isFromHangUI = aMsgLoop != MessageLoop::current();
-  aMsgLoop->PostTask(mChromeTaskFactory.NewRunnableMethod(
-      &PluginModuleChromeParent::CleanupFromTimeout, isFromHangUI));
-
-  if (!childOpened || !KillProcess(geckoChildProcess, 1, false)) {
-    NS_WARNING("failed to kill subprocess!");
-  }
-}
-
-bool PluginModuleParent::GetPluginDetails() {
-  RefPtr<nsPluginHost> host = nsPluginHost::GetInst();
-  if (!host) {
-    return false;
-  }
-  nsPluginTag* pluginTag = host->TagForPlugin(mPlugin);
-  if (!pluginTag) {
-    return false;
-  }
-  mPluginName = pluginTag->Name();
-  mPluginVersion = pluginTag->Version();
-  mPluginFilename = pluginTag->FileName();
-  mIsFlashPlugin = pluginTag->mIsFlashPlugin;
-  mSandboxLevel = pluginTag->mSandboxLevel;
-  return true;
-}
-
-void PluginModuleParent::InitQuirksModes(const nsCString& aMimeType) {
-  if (mQuirks != QUIRKS_NOT_INITIALIZED) {
-    return;
-  }
-
-  mQuirks = GetQuirksFromMimeTypeAndFilename(aMimeType, mPluginFilename);
-}
-
-#ifdef XP_WIN
-void PluginModuleChromeParent::EvaluateHangUIState(const bool aReset) {
-  int32_t minDispSecs = Preferences::GetInt(kHangUIMinDisplayPref, 10);
-  int32_t autoStopSecs = Preferences::GetInt(kChildTimeoutPref, 0);
-  int32_t timeoutSecs = 0;
-  if (autoStopSecs > 0 && autoStopSecs < minDispSecs) {
-    /* If we're going to automatically terminate the plugin within a
-       time frame shorter than minDispSecs, there's no point in
-       showing the hang UI; it would just flash briefly on the screen. */
-    mHangUIEnabled = false;
-  } else {
-    timeoutSecs = Preferences::GetInt(kHangUITimeoutPref, 0);
-    mHangUIEnabled = timeoutSecs > 0;
-  }
-  if (mHangUIEnabled) {
-    if (aReset) {
-      mIsTimerReset = true;
-      SetChildTimeout(timeoutSecs);
-      return;
-    } else if (mIsTimerReset) {
-      /* The Hang UI is being shown, so now we're setting the
-         timeout to kChildTimeoutPref while we wait for a user
-         response. ShouldContinueFromReplyTimeout will fire
-         after (reply timeout / 2) seconds, which is not what
-         we want. Doubling the timeout value here so that we get
-         the right result. */
-      autoStopSecs *= 2;
-    }
-  }
-  mIsTimerReset = false;
-  SetChildTimeout(autoStopSecs);
-}
-
-bool PluginModuleChromeParent::LaunchHangUI() {
-  if (!mHangUIEnabled) {
-    return false;
-  }
-  if (mHangUIParent) {
-    if (mHangUIParent->IsShowing()) {
-      // We've already shown the UI but the timeout has expired again.
-      return false;
-    }
-    if (mHangUIParent->DontShowAgain()) {
-      mHangAnnotationFlags |= kHangUIDontShow;
-      bool wasLastHangStopped = mHangUIParent->WasLastHangStopped();
-      if (!wasLastHangStopped) {
-        mHangAnnotationFlags |= kHangUIContinued;
-      }
-      return !wasLastHangStopped;
-    }
-    delete mHangUIParent;
-    mHangUIParent = nullptr;
-  }
-  mHangUIParent =
-      new PluginHangUIParent(this, Preferences::GetInt(kHangUITimeoutPref, 0),
-                             Preferences::GetInt(kChildTimeoutPref, 0));
-  bool retval = mHangUIParent->Init(NS_ConvertUTF8toUTF16(mPluginName));
-  if (retval) {
-    mHangAnnotationFlags |= kHangUIShown;
-    /* Once the UI is shown we switch the timeout over to use
-       kChildTimeoutPref, allowing us to terminate a hung plugin
-       after kChildTimeoutPref seconds if the user doesn't respond to
-       the hang UI. */
-    EvaluateHangUIState(false);
-  }
-  return retval;
-}
-
-void PluginModuleChromeParent::FinishHangUI() {
-  if (mHangUIEnabled && mHangUIParent) {
-    bool needsCancel = mHangUIParent->IsShowing();
-    // If we're still showing, send a Cancel notification
-    if (needsCancel) {
-      mHangUIParent->Cancel();
-    }
-    /* If we cancelled the UI or if the user issued a response,
-       we need to reset the child process timeout. */
-    if (needsCancel || (!mIsTimerReset && mHangUIParent->WasShown())) {
-      /* We changed the timeout to kChildTimeoutPref when the plugin hang
-         UI was displayed. Now that we're finishing the UI, we need to
-         switch it back to kHangUITimeoutPref. */
-      EvaluateHangUIState(true);
-    }
-  }
-}
-
-void PluginModuleChromeParent::OnHangUIContinue() {
-  mHangAnnotationFlags |= kHangUIContinued;
-}
-#endif  // XP_WIN
-
-#ifdef MOZ_CRASHREPORTER_INJECTOR
-static void RemoveMinidump(nsIFile* minidump) {
-  if (!minidump) return;
-
-  minidump->Remove(false);
-  nsCOMPtr<nsIFile> extraFile;
-  if (GetExtraFileForMinidump(minidump, getter_AddRefs(extraFile))) {
-    extraFile->Remove(true);
-  }
-}
-#endif  // MOZ_CRASHREPORTER_INJECTOR
-
-void PluginModuleChromeParent::ProcessFirstMinidump() {
-  mozilla::MutexAutoLock lock(mCrashReporterMutex);
-
-  if (!mCrashReporter) {
-    HandleOrphanedMinidump();
-    return;
-  }
-
-  AddCrashAnnotations();
-
-  if (mCrashReporter->HasMinidump()) {
-    // A minidump may be set in TerminateChildProcess, which means the
-    // process hang monitor has already collected a 3-way browser, plugin,
-    // content crash report. If so, update the existing report with our
-    // annotations and finalize it. If not, fall through for standard
-    // plugin crash report handling.
-    mCrashReporter->FinalizeCrashReport();
-    return;
-  }
-
-  AnnotationTable annotations;
-  uint32_t sequence = UINT32_MAX;
-  nsAutoCString flashProcessType;
-  RefPtr<nsIFile> dumpFile =
-      mCrashReporter->TakeCrashedChildMinidump(OtherPid(), &sequence);
-
-#ifdef MOZ_CRASHREPORTER_INJECTOR
-  nsCOMPtr<nsIFile> childDumpFile;
-  uint32_t childSequence;
-
-  if (mFlashProcess1 &&
-      TakeMinidumpForChild(mFlashProcess1, getter_AddRefs(childDumpFile),
-                           annotations, &childSequence)) {
-    if (childSequence < sequence &&
-        mCrashReporter->AdoptMinidump(childDumpFile, annotations)) {
-      RemoveMinidump(dumpFile);
-      dumpFile = childDumpFile;
-      sequence = childSequence;
-      flashProcessType.AssignLiteral("Broker");
-    } else {
-      RemoveMinidump(childDumpFile);
-    }
-  }
-  if (mFlashProcess2 &&
-      TakeMinidumpForChild(mFlashProcess2, getter_AddRefs(childDumpFile),
-                           annotations, &childSequence)) {
-    if (childSequence < sequence &&
-        mCrashReporter->AdoptMinidump(childDumpFile, annotations)) {
-      RemoveMinidump(dumpFile);
-      dumpFile = childDumpFile;
-      sequence = childSequence;
-      flashProcessType.AssignLiteral("Sandbox");
-    } else {
-      RemoveMinidump(childDumpFile);
-    }
-  }
-#endif
-
-  if (!dumpFile) {
-    NS_WARNING(
-        "[PluginModuleParent::ActorDestroy] abnormal shutdown without "
-        "minidump!");
-    return;
-  }
-
-  PLUGIN_LOG_DEBUG(("got child minidump: %s",
-                    NS_ConvertUTF16toUTF8(mCrashReporter->MinidumpID()).get()));
-
-  if (!flashProcessType.IsEmpty()) {
-    mCrashReporter->AddAnnotation(Annotation::FlashProcessDump,
-                                  flashProcessType);
-  }
-  mCrashReporter->FinalizeCrashReport();
-}
-
-void PluginModuleChromeParent::HandleOrphanedMinidump() {
-  if (CrashReporter::FinalizeOrphanedMinidump(
-          OtherPid(), GeckoProcessType_Plugin, &mOrphanedDumpId)) {
-    ipc::CrashReporterHost::RecordCrash(GeckoProcessType_Plugin,
-                                        nsICrashService::CRASH_TYPE_CRASH,
-                                        mOrphanedDumpId);
-  } else {
-    NS_WARNING(nsPrintfCString("plugin process pid = %d crashed without "
-                               "leaving a minidump behind",
-                               OtherPid())
-                   .get());
-  }
-}
-
-void PluginModuleParent::ActorDestroy(ActorDestroyReason why) {
-  switch (why) {
-    case AbnormalShutdown: {
-      mShutdown = true;
-      // Defer the PluginCrashed method so that we don't re-enter
-      // and potentially modify the actor child list while enumerating it.
-      if (mPlugin)
-        MessageLoop::current()->PostTask(mTaskFactory.NewRunnableMethod(
-            &PluginModuleParent::NotifyPluginCrashed));
-      break;
-    }
-    case NormalShutdown:
-      mShutdown = true;
-      break;
-
-    default:
-      MOZ_CRASH("Unexpected shutdown reason for toplevel actor.");
-  }
-}
-
-nsresult PluginModuleParent::GetRunID(uint32_t* aRunID) {
-  if (NS_WARN_IF(!aRunID)) {
-    return NS_ERROR_INVALID_POINTER;
-  }
-  *aRunID = mRunID;
-  return NS_OK;
-}
-
-void PluginModuleChromeParent::ActorDestroy(ActorDestroyReason why) {
-  if (why == AbnormalShutdown) {
-    ProcessFirstMinidump();
-    Telemetry::Accumulate(Telemetry::SUBPROCESS_ABNORMAL_ABORT, "plugin"_ns, 1);
-  }
-
-  // We can't broadcast settings changes anymore.
-  UnregisterSettingsCallbacks();
-
-#if defined(XP_WIN)
-  if (mBrokerParent) {
-    FunctionBrokerParent::Destroy(mBrokerParent);
-    mBrokerParent = nullptr;
-  }
-#endif
-
-  PluginModuleParent::ActorDestroy(why);
-}
-
-void PluginModuleParent::NotifyFlashHang() {
-  nsCOMPtr<nsIObserverService> obs = services::GetObserverService();
-  if (obs) {
-    obs->NotifyObservers(nullptr, "flash-plugin-hang", nullptr);
-  }
-}
-
-void PluginModuleParent::NotifyPluginCrashed() {
-  if (!OkToCleanup()) {
-    // there's still plugin code on the C++ stack.  try again
-    MessageLoop::current()->PostDelayedTask(
-        mTaskFactory.NewRunnableMethod(
-            &PluginModuleParent::NotifyPluginCrashed),
-        10);
-    return;
-  }
-
-  if (!mPlugin) {
-    return;
-  }
-
-  nsString dumpID;
-  nsCString additionalMinidumps;
-
-  if (mCrashReporter && mCrashReporter->HasMinidump()) {
-    dumpID = mCrashReporter->MinidumpID();
-    additionalMinidumps = mCrashReporter->AdditionalMinidumps();
-  } else {
-    dumpID = mOrphanedDumpId;
-  }
-
-  mPlugin->PluginCrashed(dumpID, additionalMinidumps);
-}
-
-PPluginInstanceParent* PluginModuleParent::AllocPPluginInstanceParent(
-    const nsCString& aMimeType, const nsTArray<nsCString>& aNames,
-    const nsTArray<nsCString>& aValues) {
-  NS_ERROR("Not reachable!");
-  return nullptr;
-}
-
-bool PluginModuleParent::DeallocPPluginInstanceParent(
-    PPluginInstanceParent* aActor) {
-  PLUGIN_LOG_DEBUG_METHOD;
-  delete aActor;
-  return true;
-}
-
-void PluginModuleParent::SetPluginFuncs(NPPluginFuncs* aFuncs) {
-  MOZ_ASSERT(aFuncs);
-
-  aFuncs->version = (NP_VERSION_MAJOR << 8) | NP_VERSION_MINOR;
-  aFuncs->javaClass = nullptr;
-
-  // Gecko should always call these functions through a PluginLibrary object.
-  aFuncs->newp = nullptr;
-  aFuncs->clearsitedata = nullptr;
-  aFuncs->getsiteswithdata = nullptr;
-
-  aFuncs->destroy = NPP_Destroy;
-  aFuncs->setwindow = NPP_SetWindow;
-  aFuncs->newstream = NPP_NewStream;
-  aFuncs->destroystream = NPP_DestroyStream;
-  aFuncs->writeready = NPP_WriteReady;
-  aFuncs->write = NPP_Write;
-  aFuncs->print = NPP_Print;
-  aFuncs->event = NPP_HandleEvent;
-  aFuncs->urlnotify = NPP_URLNotify;
-  aFuncs->getvalue = NPP_GetValue;
-  aFuncs->setvalue = NPP_SetValue;
-  aFuncs->gotfocus = nullptr;
-  aFuncs->lostfocus = nullptr;
-  aFuncs->urlredirectnotify = nullptr;
-
-  // Provide 'NPP_URLRedirectNotify', 'NPP_ClearSiteData', and
-  // 'NPP_GetSitesWithData' functionality if it is supported by the plugin.
-  bool urlRedirectSupported = false;
-  Unused << CallOptionalFunctionsSupported(&urlRedirectSupported,
-                                           &mClearSiteDataSupported,
-                                           &mGetSitesWithDataSupported);
-  if (urlRedirectSupported) {
-    aFuncs->urlredirectnotify = NPP_URLRedirectNotify;
-  }
-}
-
-NPError PluginModuleParent::NPP_Destroy(NPP instance, NPSavedData** saved) {
-  // FIXME/cjones:
-  //  (1) send a "destroy" message to the child
-  //  (2) the child shuts down its instance
-  //  (3) remove both parent and child IDs from map
-  //  (4) free parent
-
-  PLUGIN_LOG_DEBUG_FUNCTION;
-  PluginInstanceParent* pip = PluginInstanceParent::Cast(instance);
-  if (!pip) return NPERR_NO_ERROR;
-
-  NPError retval = pip->Destroy();
-  instance->pdata = nullptr;
-
-  Unused << PluginInstanceParent::Send__delete__(pip);
-  return retval;
-}
-
-NPError PluginModuleParent::NPP_NewStream(NPP instance, NPMIMEType type,
-                                          NPStream* stream, NPBool seekable,
-                                          uint16_t* stype) {
-  AUTO_PROFILER_LABEL("PluginModuleParent::NPP_NewStream", OTHER);
-
-  PluginInstanceParent* pip = PluginInstanceParent::Cast(instance);
-  return pip ? pip->NPP_NewStream(type, stream, seekable, stype)
-             : NPERR_GENERIC_ERROR;
-}
-
-NPError PluginModuleParent::NPP_SetWindow(NPP instance, NPWindow* window) {
-  PluginInstanceParent* pip = PluginInstanceParent::Cast(instance);
-  return pip ? pip->NPP_SetWindow(window) : NPERR_GENERIC_ERROR;
-}
-
-NPError PluginModuleParent::NPP_DestroyStream(NPP instance, NPStream* stream,
-                                              NPReason reason) {
-  PluginInstanceParent* pip = PluginInstanceParent::Cast(instance);
-  return pip ? pip->NPP_DestroyStream(stream, reason) : NPERR_GENERIC_ERROR;
-}
-
-int32_t PluginModuleParent::NPP_WriteReady(NPP instance, NPStream* stream) {
-  BrowserStreamParent* s = StreamCast(instance, stream);
-  return s ? s->WriteReady() : -1;
-}
-
-int32_t PluginModuleParent::NPP_Write(NPP instance, NPStream* stream,
-                                      int32_t offset, int32_t len,
-                                      void* buffer) {
-  BrowserStreamParent* s = StreamCast(instance, stream);
-  if (!s) return -1;
-
-  return s->Write(offset, len, buffer);
-}
-
-void PluginModuleParent::NPP_Print(NPP instance, NPPrint* platformPrint) {
-  PluginInstanceParent* pip = PluginInstanceParent::Cast(instance);
-  return pip ? pip->NPP_Print(platformPrint) : (void)0;
-}
-
-int16_t PluginModuleParent::NPP_HandleEvent(NPP instance, void* event) {
-  PluginInstanceParent* pip = PluginInstanceParent::Cast(instance);
-  return pip ? pip->NPP_HandleEvent(event) : NPERR_GENERIC_ERROR;
-}
-
-void PluginModuleParent::NPP_URLNotify(NPP instance, const char* url,
-                                       NPReason reason, void* notifyData) {
-  PluginInstanceParent* pip = PluginInstanceParent::Cast(instance);
-  return pip ? pip->NPP_URLNotify(url, reason, notifyData) : (void)0;
-}
-
-NPError PluginModuleParent::NPP_GetValue(NPP instance, NPPVariable variable,
-                                         void* ret_value) {
-  PluginInstanceParent* pip = PluginInstanceParent::Cast(instance);
-  return pip ? pip->NPP_GetValue(variable, ret_value) : NPERR_GENERIC_ERROR;
-}
-
-NPError PluginModuleParent::NPP_SetValue(NPP instance, NPNVariable variable,
-                                         void* value) {
-  PluginInstanceParent* pip = PluginInstanceParent::Cast(instance);
-  return pip ? pip->NPP_SetValue(variable, value) : NPERR_GENERIC_ERROR;
-}
-
-mozilla::ipc::IPCResult PluginModuleChromeParent::
-    AnswerNPN_SetValue_NPPVpluginRequiresAudioDeviceChanges(
-        const bool& shouldRegister, NPError* result) {
-#ifdef XP_WIN
-  *result = NPERR_NO_ERROR;
-  nsresult err =
-      mozilla::plugins::PluginUtilsWin::RegisterForAudioDeviceChanges(
-          this, shouldRegister);
-  if (err != NS_OK) {
-    *result = NPERR_GENERIC_ERROR;
-  }
-  return IPC_OK();
-#else
-  MOZ_CRASH(
-      "NPPVpluginRequiresAudioDeviceChanges is not valid on this platform.");
-#endif
-}
-
-mozilla::ipc::IPCResult PluginModuleParent::RecvBackUpXResources(
-    const FileDescriptor& aXSocketFd) {
-#ifndef MOZ_X11
-  MOZ_CRASH("This message only makes sense on X11 platforms");
-#else
-  MOZ_ASSERT(0 > mPluginXSocketFdDup.get(), "Already backed up X resources??");
-  if (aXSocketFd.IsValid()) {
-    auto rawFD = aXSocketFd.ClonePlatformHandle();
-    mPluginXSocketFdDup.reset(rawFD.release());
-  }
-#endif
-  return IPC_OK();
-}
-
-void PluginModuleParent::NPP_URLRedirectNotify(NPP instance, const char* url,
-                                               int32_t status,
-                                               void* notifyData) {
-  PluginInstanceParent* pip = PluginInstanceParent::Cast(instance);
-  return pip ? pip->NPP_URLRedirectNotify(url, status, notifyData) : (void)0;
-}
-
-BrowserStreamParent* PluginModuleParent::StreamCast(NPP instance, NPStream* s) {
-  PluginInstanceParent* pip = PluginInstanceParent::Cast(instance);
-  if (!pip) {
-    return nullptr;
-  }
-
-  BrowserStreamParent* sp =
-      static_cast<BrowserStreamParent*>(static_cast<AStream*>(s->pdata));
-  if (sp && (sp->mNPP != pip || s != sp->mStream)) {
-    MOZ_CRASH("Corrupted plugin stream data.");
-  }
-  return sp;
-}
-
-bool PluginModuleParent::HasRequiredFunctions() { return true; }
-
-nsresult PluginModuleParent::AsyncSetWindow(NPP instance, NPWindow* window) {
-  PluginInstanceParent* pip = PluginInstanceParent::Cast(instance);
-  return pip ? pip->AsyncSetWindow(window) : NS_ERROR_FAILURE;
-}
-
-nsresult PluginModuleParent::GetImageContainer(
-    NPP instance, mozilla::layers::ImageContainer** aContainer) {
-  PluginInstanceParent* pip = PluginInstanceParent::Cast(instance);
-  return pip ? pip->GetImageContainer(aContainer) : NS_ERROR_FAILURE;
-}
-
-nsresult PluginModuleParent::GetImageSize(NPP instance, nsIntSize* aSize) {
-  PluginInstanceParent* pip = PluginInstanceParent::Cast(instance);
-  return pip ? pip->GetImageSize(aSize) : NS_ERROR_FAILURE;
-}
-
-void PluginModuleParent::DidComposite(NPP aInstance) {
-  PluginInstanceParent* pip = PluginInstanceParent::Cast(aInstance);
-  return pip ? pip->DidComposite() : (void)0;
-}
-
-nsresult PluginModuleParent::SetBackgroundUnknown(NPP instance) {
-  PluginInstanceParent* pip = PluginInstanceParent::Cast(instance);
-  return pip ? pip->SetBackgroundUnknown() : NS_ERROR_FAILURE;
-}
-
-nsresult PluginModuleParent::BeginUpdateBackground(NPP instance,
-                                                   const nsIntRect& aRect,
-                                                   DrawTarget** aDrawTarget) {
-  PluginInstanceParent* pip = PluginInstanceParent::Cast(instance);
-  return pip ? pip->BeginUpdateBackground(aRect, aDrawTarget)
-             : NS_ERROR_FAILURE;
-}
-
-nsresult PluginModuleParent::EndUpdateBackground(NPP instance,
-                                                 const nsIntRect& aRect) {
-  PluginInstanceParent* pip = PluginInstanceParent::Cast(instance);
-  return pip ? pip->EndUpdateBackground(aRect) : NS_ERROR_FAILURE;
-}
-
-#if defined(XP_WIN)
-nsresult PluginModuleParent::GetScrollCaptureContainer(
-    NPP aInstance, mozilla::layers::ImageContainer** aContainer) {
-  PluginInstanceParent* pip = PluginInstanceParent::Cast(aInstance);
-  return pip ? pip->GetScrollCaptureContainer(aContainer) : NS_ERROR_FAILURE;
-}
-#endif
-
-void PluginModuleParent::OnInitFailure() {
-  if (GetIPCChannel()->CanSend()) {
-    Close();
-  }
-
-  mShutdown = true;
-}
-
-class PluginOfflineObserver final : public nsIObserver {
- public:
-  NS_DECL_ISUPPORTS
-  NS_DECL_NSIOBSERVER
-
-  explicit PluginOfflineObserver(PluginModuleChromeParent* pmp) : mPmp(pmp) {}
-
- private:
-  ~PluginOfflineObserver() = default;
-  PluginModuleChromeParent* mPmp;
-};
-
-NS_IMPL_ISUPPORTS(PluginOfflineObserver, nsIObserver)
-
-NS_IMETHODIMP
-PluginOfflineObserver::Observe(nsISupports* aSubject, const char* aTopic,
-                               const char16_t* aData) {
-  MOZ_ASSERT(!strcmp(aTopic, "ipc:network:set-offline"));
-  mPmp->CachedSettingChanged();
-  return NS_OK;
-}
-
-void PluginModuleChromeParent::RegisterSettingsCallbacks() {
-  Preferences::RegisterCallback(CachedSettingChanged, "javascript.enabled",
-                                this);
-  Preferences::RegisterCallback(CachedSettingChanged,
-                                "dom.ipc.plugins.nativeCursorSupport", this);
-
-  nsCOMPtr<nsIObserverService> observerService =
-      mozilla::services::GetObserverService();
-  if (observerService) {
-    mPluginOfflineObserver = new PluginOfflineObserver(this);
-    observerService->AddObserver(mPluginOfflineObserver,
-                                 "ipc:network:set-offline", false);
-  }
-}
-
-void PluginModuleChromeParent::UnregisterSettingsCallbacks() {
-  Preferences::UnregisterCallback(CachedSettingChanged, "javascript.enabled",
-                                  this);
-  Preferences::UnregisterCallback(CachedSettingChanged,
-                                  "dom.ipc.plugins.nativeCursorSupport", this);
-
-  nsCOMPtr<nsIObserverService> observerService =
-      mozilla::services::GetObserverService();
-  if (observerService) {
-    observerService->RemoveObserver(mPluginOfflineObserver,
-                                    "ipc:network:set-offline");
-    mPluginOfflineObserver = nullptr;
-  }
-}
-
-bool PluginModuleParent::GetSetting(NPNVariable aVariable) {
-  NPBool boolVal = false;
-  mozilla::plugins::parent::_getvalue(nullptr, aVariable, &boolVal);
-  return boolVal;
-}
-
-void PluginModuleParent::GetSettings(PluginSettings* aSettings) {
-  aSettings->javascriptEnabled() = GetSetting(NPNVjavascriptEnabledBool);
-  aSettings->asdEnabled() = GetSetting(NPNVasdEnabledBool);
-  aSettings->isOffline() = GetSetting(NPNVisOfflineBool);
-  aSettings->supportsXembed() = GetSetting(NPNVSupportsXEmbedBool);
-  aSettings->supportsWindowless() = GetSetting(NPNVSupportsWindowless);
-  aSettings->userAgent() = NullableString(mNPNIface->uagent(nullptr));
-
-#if defined(XP_MACOSX)
-  aSettings->nativeCursorsSupported() =
-      Preferences::GetBool("dom.ipc.plugins.nativeCursorSupport", false);
-#else
-  // Need to initialize this to satisfy IPDL.
-  aSettings->nativeCursorsSupported() = false;
-#endif
-}
-
-void PluginModuleChromeParent::CachedSettingChanged() {
-  PluginSettings settings;
-  GetSettings(&settings);
-  Unused << SendSettingChanged(settings);
-}
-
-/* static */
-void PluginModuleChromeParent::CachedSettingChanged(const char* aPref,
-                                                    void* aModule) {
-  auto module = static_cast<PluginModuleChromeParent*>(aModule);
-  module->CachedSettingChanged();
-}
-
-#if defined(XP_UNIX) && !defined(XP_MACOSX)
-nsresult PluginModuleParent::NP_Initialize(NPNetscapeFuncs* bFuncs,
-                                           NPPluginFuncs* pFuncs,
-                                           NPError* error) {
-  PLUGIN_LOG_DEBUG_METHOD;
-
-  mNPNIface = bFuncs;
-  mNPPIface = pFuncs;
-
-  if (mShutdown) {
-    *error = NPERR_GENERIC_ERROR;
-    return NS_ERROR_FAILURE;
-  }
-
-  *error = NPERR_NO_ERROR;
-  SetPluginFuncs(pFuncs);
-
-  return NS_OK;
-}
-
-nsresult PluginModuleChromeParent::NP_Initialize(NPNetscapeFuncs* bFuncs,
-                                                 NPPluginFuncs* pFuncs,
-                                                 NPError* error) {
-  PLUGIN_LOG_DEBUG_METHOD;
-
-  if (mShutdown) {
-    *error = NPERR_GENERIC_ERROR;
-    return NS_ERROR_FAILURE;
-  }
-
-  *error = NPERR_NO_ERROR;
-
-  mNPNIface = bFuncs;
-  mNPPIface = pFuncs;
-
-  PluginSettings settings;
-  GetSettings(&settings);
-
-  if (!CallNP_Initialize(settings, error)) {
-    Close();
-    return NS_ERROR_FAILURE;
-  } else if (*error != NPERR_NO_ERROR) {
-    Close();
-    return NS_ERROR_FAILURE;
-  }
-
-  if (*error != NPERR_NO_ERROR) {
-    OnInitFailure();
-    return NS_OK;
-  }
-
-  SetPluginFuncs(mNPPIface);
-
-  return NS_OK;
-}
-
-#else
-
-nsresult PluginModuleParent::NP_Initialize(NPNetscapeFuncs* bFuncs,
-                                           NPError* error) {
-  PLUGIN_LOG_DEBUG_METHOD;
-
-  mNPNIface = bFuncs;
-
-  if (mShutdown) {
-    *error = NPERR_GENERIC_ERROR;
-    return NS_ERROR_FAILURE;
-  }
-
-  *error = NPERR_NO_ERROR;
-  return NS_OK;
-}
-
-#  if defined(XP_WIN) || defined(XP_MACOSX)
-
-nsresult PluginModuleContentParent::NP_Initialize(NPNetscapeFuncs* bFuncs,
-                                                  NPError* error) {
-  PLUGIN_LOG_DEBUG_METHOD;
-  return PluginModuleParent::NP_Initialize(bFuncs, error);
-}
-
-#  endif
-
-nsresult PluginModuleChromeParent::NP_Initialize(NPNetscapeFuncs* bFuncs,
-                                                 NPError* error) {
-  nsresult rv = PluginModuleParent::NP_Initialize(bFuncs, error);
-  if (NS_FAILED(rv)) return rv;
-
-  PluginSettings settings;
-  GetSettings(&settings);
-
-  if (!CallNP_Initialize(settings, error)) {
-    Close();
-    return NS_ERROR_FAILURE;
-  }
-
-  bool ok = true;
-  if (*error == NPERR_NO_ERROR) {
-    // Initialization steps for (e10s && !asyncInit) || !e10s
-#  if defined XP_WIN
-    // Send the info needed to join the browser process's audio session to
-    // the plugin process.
-    nsID id;
-    nsString sessionName;
-    nsString iconPath;
-
-    if (NS_SUCCEEDED(
-            mozilla::widget::GetAudioSessionData(id, sessionName, iconPath))) {
-      Unused << SendSetAudioSessionData(id, sessionName, iconPath);
-    }
-#  endif
-
-#  ifdef MOZ_CRASHREPORTER_INJECTOR
-    InitializeInjector();
-#  endif
-  }
-
-  if (!ok) {
-    return NS_ERROR_FAILURE;
-  }
-
-  if (*error != NPERR_NO_ERROR) {
-    OnInitFailure();
-    return NS_OK;
-  }
-
-  return NS_OK;
-}
-
-#endif
-
-nsresult PluginModuleParent::NP_Shutdown(NPError* error) {
-  PLUGIN_LOG_DEBUG_METHOD;
-
-  if (mShutdown) {
-    *error = NPERR_GENERIC_ERROR;
-    return NS_ERROR_FAILURE;
-  }
-
-  if (!DoShutdown(error)) {
-    return NS_ERROR_FAILURE;
-  }
-
-  return NS_OK;
-}
-
-bool PluginModuleParent::DoShutdown(NPError* error) {
-  bool ok = true;
-  if (IsChrome() && mHadLocalInstance) {
-    // We synchronously call NP_Shutdown if the chrome process was using
-    // plugins itself. That way we can service any requests the plugin
-    // makes. If we're in e10s, though, the content processes will have
-    // already shut down and there's no one to talk to. So we shut down
-    // asynchronously in PluginModuleChild::ActorDestroy.
-    ok = CallNP_Shutdown(error);
-  }
-
-  // if NP_Shutdown() is nested within another interrupt call, this will
-  // break things.  but lord help us if we're doing that anyway; the
-  // plugin dso will have been unloaded on the other side by the
-  // CallNP_Shutdown() message
-  Close();
-
-  // mShutdown should either be initialized to false, or be transitiong from
-  // false to true. It is never ok to go from true to false. Using OR for
-  // the following assignment to ensure this.
-  mShutdown |= ok;
-  if (!ok) {
-    *error = NPERR_GENERIC_ERROR;
-  }
-  return ok;
-}
-
-nsresult PluginModuleParent::NP_GetMIMEDescription(const char** mimeDesc) {
-  PLUGIN_LOG_DEBUG_METHOD;
-
-  *mimeDesc = "application/x-foobar";
-  return NS_OK;
-}
-
-nsresult PluginModuleParent::NP_GetValue(void* future, NPPVariable aVariable,
-                                         void* aValue, NPError* error) {
-  MOZ_LOG(GetPluginLog(), LogLevel::Warning,
-          ("%s Not implemented, requested variable %i", __FUNCTION__,
-           (int)aVariable));
-
-  // TODO: implement this correctly
-  *error = NPERR_GENERIC_ERROR;
-  return NS_OK;
-}
-
-#if defined(XP_WIN) || defined(XP_MACOSX)
-nsresult PluginModuleParent::NP_GetEntryPoints(NPPluginFuncs* pFuncs,
-                                               NPError* error) {
-  NS_ASSERTION(pFuncs, "Null pointer!");
-
-  *error = NPERR_NO_ERROR;
-  SetPluginFuncs(pFuncs);
-
-  return NS_OK;
-}
-
-nsresult PluginModuleChromeParent::NP_GetEntryPoints(NPPluginFuncs* pFuncs,
-                                                     NPError* error) {
-#  if !defined(XP_MACOSX)
-  if (!mSubprocess->IsConnected()) {
-    mNPPIface = pFuncs;
-    *error = NPERR_NO_ERROR;
-    return NS_OK;
-  }
-#  endif
-
-  // We need to have the plugin process update its function table here by
-  // actually calling NP_GetEntryPoints. The parent's function table will
-  // reflect nullptr entries in the child's table once SetPluginFuncs is
-  // called.
-
-  if (!CallNP_GetEntryPoints(error)) {
-    return NS_ERROR_FAILURE;
-  } else if (*error != NPERR_NO_ERROR) {
-    return NS_OK;
-  }
-
-  return PluginModuleParent::NP_GetEntryPoints(pFuncs, error);
-}
-
-#endif
-
-nsresult PluginModuleParent::NPP_New(NPMIMEType pluginType, NPP instance,
-                                     int16_t argc, char* argn[], char* argv[],
-                                     NPSavedData* saved, NPError* error) {
-  PLUGIN_LOG_DEBUG_METHOD;
-
-  if (mShutdown) {
-    *error = NPERR_GENERIC_ERROR;
-    return NS_ERROR_FAILURE;
-  }
-
-  // create the instance on the other side
-  nsTArray<nsCString> names;
-  nsTArray<nsCString> values;
-
-  for (int i = 0; i < argc; ++i) {
-    names.AppendElement(NullableString(argn[i]));
-    values.AppendElement(NullableString(argv[i]));
-  }
-
-  return NPP_NewInternal(pluginType, instance, names, values, saved, error);
-}
-
-class nsCaseInsensitiveUTF8StringArrayComparator {
- public:
-  template <class A, class B>
-  bool Equals(const A& a, const B& b) const {
-    return a.Equals(b.get(), nsCaseInsensitiveUTF8StringComparator);
-  }
-};
-
-#if defined(XP_WIN) || defined(MOZ_WIDGET_GTK)
-static void ForceWindowless(nsTArray<nsCString>& names,
-                            nsTArray<nsCString>& values) {
-  nsCaseInsensitiveUTF8StringArrayComparator comparator;
-  constexpr auto wmodeAttributeName = "wmode"_ns;
-  constexpr auto opaqueAttributeValue = "opaque"_ns;
-  auto wmodeAttributeIndex = names.IndexOf(wmodeAttributeName, 0, comparator);
-  if (wmodeAttributeIndex != names.NoIndex) {
-    if (!values[wmodeAttributeIndex].EqualsLiteral("transparent")) {
-      values[wmodeAttributeIndex].Assign(opaqueAttributeValue);
-    }
-  } else {
-    names.AppendElement(wmodeAttributeName);
-    values.AppendElement(opaqueAttributeValue);
-  }
-}
-#endif  // windows or linux
-#if defined(XP_WIN)
-static void ForceDirect(nsTArray<nsCString>& names,
-                        nsTArray<nsCString>& values) {
-  nsCaseInsensitiveUTF8StringArrayComparator comparator;
-  constexpr auto wmodeAttributeName = "wmode"_ns;
-  constexpr auto directAttributeValue = "direct"_ns;
-  auto wmodeAttributeIndex = names.IndexOf(wmodeAttributeName, 0, comparator);
-  if (wmodeAttributeIndex != names.NoIndex) {
-    if ((!values[wmodeAttributeIndex].EqualsLiteral("transparent")) &&
-        (!values[wmodeAttributeIndex].EqualsLiteral("opaque"))) {
-      values[wmodeAttributeIndex].Assign(directAttributeValue);
-    }
-  } else {
-    names.AppendElement(wmodeAttributeName);
-    values.AppendElement(directAttributeValue);
-  }
-}
-#endif  // windows
-
-nsresult PluginModuleParent::NPP_NewInternal(
-    NPMIMEType pluginType, NPP instance, nsTArray<nsCString>& names,
-    nsTArray<nsCString>& values, NPSavedData* saved, NPError* error) {
-  MOZ_ASSERT(names.Length() == values.Length());
-  if (mPluginName.IsEmpty()) {
-    GetPluginDetails();
-    InitQuirksModes(nsDependentCString(pluginType));
-  }
-
-  nsCaseInsensitiveUTF8StringArrayComparator comparator;
-  constexpr auto srcAttributeName = "src"_ns;
-  auto srcAttributeIndex = names.IndexOf(srcAttributeName, 0, comparator);
-  nsAutoCString srcAttribute;
-  if (srcAttributeIndex != names.NoIndex) {
-    srcAttribute = values[srcAttributeIndex];
-  }
-
-  nsDependentCString strPluginType(pluginType);
-  PluginInstanceParent* parentInstance =
-      new PluginInstanceParent(this, instance, strPluginType, mNPNIface);
-
-  if (mIsFlashPlugin) {
-    parentInstance->InitMetadata(strPluginType, srcAttribute);
-#ifdef XP_WIN
-    bool supportsAsyncRender =
-        Preferences::GetBool("dom.ipc.plugins.asyncdrawing.enabled", false);
-    bool supportsForceDirect =
-        Preferences::GetBool("dom.ipc.plugins.forcedirect.enabled", false);
-    if (supportsAsyncRender) {
-      // Prefs indicates we want async plugin rendering, make sure
-      // the flash module has support.
-      if (!CallModuleSupportsAsyncRender(&supportsAsyncRender)) {
-        *error = NPERR_GENERIC_ERROR;
-        return NS_ERROR_FAILURE;
-      }
-    }
-#  ifdef _WIN64
-    // For 64-bit builds force windowless if the flash library doesn't support
-    // async rendering regardless of sandbox level.
-    if (!supportsAsyncRender) {
-#  else
-    // For 32-bit builds force windowless if the flash library doesn't support
-    // async rendering and the sandbox level is 2 or greater.
-    if (!supportsAsyncRender && mSandboxLevel >= 2) {
-#  endif
-      ForceWindowless(names, values);
-    }
-#elif defined(MOZ_WIDGET_GTK)
-    // We no longer support windowed mode on Linux.
-    ForceWindowless(names, values);
-#endif
-#ifdef XP_WIN
-    // For all builds that use async rendering force use of the accelerated
-    // direct path for flash objects that have wmode=window or no wmode
-    // specified.
-    if (supportsAsyncRender && supportsForceDirect &&
-        PluginInstanceParent::SupportsPluginDirectDXGISurfaceDrawing()) {
-      ForceDirect(names, values);
-    }
-#endif
-  }
-
-  instance->pdata = parentInstance;
-
-  // Any IPC messages for the PluginInstance actor should be dispatched to the
-  // DocGroup for the plugin's document.
-  RefPtr<nsPluginInstanceOwner> owner = parentInstance->GetOwner();
-  RefPtr<dom::Element> elt;
-  owner->GetDOMElement(getter_AddRefs(elt));
-  if (elt) {
-    RefPtr<dom::Document> doc = elt->OwnerDoc();
-    nsCOMPtr<nsISerialEventTarget> eventTarget =
-        doc->EventTargetFor(TaskCategory::Other);
-    SetEventTargetForActor(parentInstance, eventTarget);
-  }
-
-  if (!SendPPluginInstanceConstructor(
-          parentInstance, nsDependentCString(pluginType), names, values)) {
-    // |parentInstance| is automatically deleted.
-    instance->pdata = nullptr;
-    *error = NPERR_GENERIC_ERROR;
-    return NS_ERROR_FAILURE;
-  }
-
-  if (!CallSyncNPP_New(parentInstance, error)) {
-    // if IPC is down, we'll get an immediate "failed" return, but
-    // without *error being set.  So make sure that the error
-    // condition is signaled to nsNPAPIPluginInstance
-    if (NPERR_NO_ERROR == *error) {
-      *error = NPERR_GENERIC_ERROR;
-    }
-    return NS_ERROR_FAILURE;
-  }
-
-  if (*error != NPERR_NO_ERROR) {
-    NPP_Destroy(instance, 0);
-    return NS_ERROR_FAILURE;
-  }
-
-  Telemetry::ScalarAdd(Telemetry::ScalarID::BROWSER_USAGE_PLUGIN_INSTANTIATED,
-                       1);
-
-  UpdatePluginTimeout();
-
-  return NS_OK;
-}
-
-void PluginModuleChromeParent::UpdatePluginTimeout() {
-  TimeoutChanged(kParentTimeoutPref, this);
-}
-
-nsresult PluginModuleParent::NPP_ClearSiteData(
-    const char* site, uint64_t flags, uint64_t maxAge,
-    nsCOMPtr<nsIClearSiteDataCallback> callback) {
-  if (!mClearSiteDataSupported) return NS_ERROR_NOT_AVAILABLE;
-
-  static uint64_t callbackId = 0;
-  callbackId++;
-  mClearSiteDataCallbacks[callbackId] = callback;
-
-  if (!SendNPP_ClearSiteData(NullableString(site), flags, maxAge, callbackId)) {
-    return NS_ERROR_FAILURE;
-  }
-  return NS_OK;
-}
-
-nsresult PluginModuleParent::NPP_GetSitesWithData(
-    nsCOMPtr<nsIGetSitesWithDataCallback> callback) {
-  if (!mGetSitesWithDataSupported) return NS_ERROR_NOT_AVAILABLE;
-
-  static uint64_t callbackId = 0;
-  callbackId++;
-  mSitesWithDataCallbacks[callbackId] = callback;
-
-  if (!SendNPP_GetSitesWithData(callbackId)) return NS_ERROR_FAILURE;
-
-  return NS_OK;
-}
-
-#if defined(XP_MACOSX)
-nsresult PluginModuleParent::IsRemoteDrawingCoreAnimation(NPP instance,
-                                                          bool* aDrawing) {
-  PluginInstanceParent* pip = PluginInstanceParent::Cast(instance);
-  return pip ? pip->IsRemoteDrawingCoreAnimation(aDrawing) : NS_ERROR_FAILURE;
-}
-#endif
-#if defined(XP_MACOSX) || defined(XP_WIN)
-nsresult PluginModuleParent::ContentsScaleFactorChanged(
-    NPP instance, double aContentsScaleFactor) {
-  PluginInstanceParent* pip = PluginInstanceParent::Cast(instance);
-  return pip ? pip->ContentsScaleFactorChanged(aContentsScaleFactor)
-             : NS_ERROR_FAILURE;
-}
-#endif  // #if defined(XP_MACOSX)
-
-#if defined(XP_MACOSX)
-mozilla::ipc::IPCResult PluginModuleParent::AnswerProcessSomeEvents() {
-  mozilla::plugins::PluginUtilsOSX::InvokeNativeEventLoop();
-  return IPC_OK();
-}
-
-#elif !defined(MOZ_WIDGET_GTK)
-mozilla::ipc::IPCResult PluginModuleParent::AnswerProcessSomeEvents() {
-  MOZ_CRASH("unreached");
-}
-
-#else
-static const int kMaxChancesToProcessEvents = 20;
-
-mozilla::ipc::IPCResult PluginModuleParent::AnswerProcessSomeEvents() {
-  PLUGIN_LOG_DEBUG(("Spinning mini nested loop ..."));
-
-  int i = 0;
-  for (; i < kMaxChancesToProcessEvents; ++i)
-    if (!g_main_context_iteration(nullptr, FALSE)) break;
-
-  PLUGIN_LOG_DEBUG(("... quitting mini nested loop; processed %i tasks", i));
-
-  return IPC_OK();
-}
-#endif
-
-mozilla::ipc::IPCResult
-PluginModuleParent::RecvProcessNativeEventsInInterruptCall() {
-  PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
-#if defined(OS_WIN)
-  ProcessNativeEventsInInterruptCall();
-  return IPC_OK();
-#else
-  MOZ_ASSERT_UNREACHABLE(
-      "PluginModuleParent::RecvProcessNativeEventsInInterruptCall not "
-      "implemented!");
-  return IPC_FAIL_NO_REASON(this);
-#endif
-}
-
-void PluginModuleParent::ProcessRemoteNativeEventsInInterruptCall() {
-#if defined(OS_WIN)
-  Unused << SendProcessNativeEventsInInterruptCall();
-  return;
-#endif
-  MOZ_ASSERT_UNREACHABLE(
-      "PluginModuleParent::ProcessRemoteNativeEventsInInterruptCall not "
-      "implemented!");
-}
-
-mozilla::ipc::IPCResult PluginModuleParent::RecvPluginShowWindow(
-    const uint32_t& aWindowId, const bool& aModal, const int32_t& aX,
-    const int32_t& aY, const double& aWidth, const double& aHeight) {
-  MOZ_ASSERT_UNREACHABLE(
-      "PluginInstanceParent::RecvPluginShowWindow not implemented!");
-  return IPC_FAIL_NO_REASON(this);
-}
-
-mozilla::ipc::IPCResult PluginModuleParent::RecvPluginHideWindow(
-    const uint32_t& aWindowId) {
-  MOZ_ASSERT_UNREACHABLE(
-      "PluginInstanceParent::RecvPluginHideWindow not implemented!");
-  return IPC_FAIL_NO_REASON(this);
-}
-
-mozilla::ipc::IPCResult PluginModuleParent::RecvNPN_SetException(
-    const nsCString& aMessage) {
-  PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
-
-  // This function ignores its first argument.
-  mozilla::plugins::parent::_setexception(nullptr, NullableStringGet(aMessage));
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginModuleParent::RecvNPN_ReloadPlugins(
-    const bool& aReloadPages) {
-  PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
-
-  mozilla::plugins::parent::_reloadplugins(aReloadPages);
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult
-PluginModuleChromeParent::RecvNotifyContentModuleDestroyed() {
-  RefPtr<nsPluginHost> host = nsPluginHost::GetInst();
-  if (host) {
-    host->NotifyContentModuleDestroyed(mPluginId);
-  }
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginModuleParent::RecvReturnClearSiteData(
-    const NPError& aRv, const uint64_t& aCallbackId) {
-  if (mClearSiteDataCallbacks.find(aCallbackId) ==
-      mClearSiteDataCallbacks.end()) {
-    return IPC_OK();
-  }
-  if (!!mClearSiteDataCallbacks[aCallbackId]) {
-    nsresult rv;
-    switch (aRv) {
-      case NPERR_NO_ERROR:
-        rv = NS_OK;
-        break;
-      case NPERR_TIME_RANGE_NOT_SUPPORTED:
-        rv = NS_ERROR_PLUGIN_TIME_RANGE_NOT_SUPPORTED;
-        break;
-      case NPERR_MALFORMED_SITE:
-        rv = NS_ERROR_INVALID_ARG;
-        break;
-      default:
-        rv = NS_ERROR_FAILURE;
-    }
-    mClearSiteDataCallbacks[aCallbackId]->Callback(rv);
-  }
-  mClearSiteDataCallbacks.erase(aCallbackId);
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginModuleParent::RecvReturnSitesWithData(
-    nsTArray<nsCString>&& aSites, const uint64_t& aCallbackId) {
-  if (mSitesWithDataCallbacks.find(aCallbackId) ==
-      mSitesWithDataCallbacks.end()) {
-    return IPC_OK();
-  }
-
-  if (!!mSitesWithDataCallbacks[aCallbackId]) {
-    mSitesWithDataCallbacks[aCallbackId]->SitesWithData(aSites);
-  }
-  mSitesWithDataCallbacks.erase(aCallbackId);
-  return IPC_OK();
-}
-
-layers::TextureClientRecycleAllocator*
-PluginModuleParent::EnsureTextureAllocatorForDirectBitmap() {
-  if (!mTextureAllocatorForDirectBitmap) {
-    mTextureAllocatorForDirectBitmap =
-        new layers::TextureClientRecycleAllocator(
-            layers::ImageBridgeChild::GetSingleton().get());
-  }
-  return mTextureAllocatorForDirectBitmap;
-}
-
-layers::TextureClientRecycleAllocator*
-PluginModuleParent::EnsureTextureAllocatorForDXGISurface() {
-  if (!mTextureAllocatorForDXGISurface) {
-    mTextureAllocatorForDXGISurface = new layers::TextureClientRecycleAllocator(
-        layers::ImageBridgeChild::GetSingleton().get());
-  }
-  return mTextureAllocatorForDXGISurface;
-}
-
-mozilla::ipc::IPCResult
-PluginModuleParent::AnswerNPN_SetValue_NPPVpluginRequiresAudioDeviceChanges(
-    const bool& shouldRegister, NPError* result) {
-  MOZ_CRASH(
-      "SetValue_NPPVpluginRequiresAudioDeviceChanges is only valid "
-      "with PluginModuleChromeParent");
-}
-
-#ifdef MOZ_CRASHREPORTER_INJECTOR
-
-// We only add the crash reporter to subprocess which have the filename
-// FlashPlayerPlugin*
-#  define FLASH_PROCESS_PREFIX u"FLASHPLAYERPLUGIN"
-
-static DWORD GetFlashChildOfPID(DWORD pid, HANDLE snapshot) {
-  PROCESSENTRY32 entry = {sizeof(entry)};
-  for (BOOL ok = Process32First(snapshot, &entry); ok;
-       ok = Process32Next(snapshot, &entry)) {
-    if (entry.th32ParentProcessID == pid) {
-      nsString name(entry.szExeFile);
-      ToUpperCase(name);
-      if (StringBeginsWith(name, nsLiteralString(FLASH_PROCESS_PREFIX))) {
-        return entry.th32ProcessID;
-      }
-    }
-  }
-  return 0;
-}
-
-// We only look for child processes of the Flash plugin, NPSWF*
-#  define FLASH_PLUGIN_PREFIX "NPSWF"
-
-void PluginModuleChromeParent::InitializeInjector() {
-  if (!Preferences::GetBool(
-          "dom.ipc.plugins.flash.subprocess.crashreporter.enabled", false))
-    return;
-
-  nsCString path(Process()->GetPluginFilePath().c_str());
-  ToUpperCase(path);
-  int32_t lastSlash = path.RFindCharInSet("\\/");
-  if (kNotFound == lastSlash) return;
-
-  if (!StringBeginsWith(Substring(path, lastSlash + 1),
-                        nsLiteralCString(FLASH_PLUGIN_PREFIX)))
-    return;
-
-  mFinishInitTask = mChromeTaskFactory.NewTask<FinishInjectorInitTask>();
-  mFinishInitTask->Init(this);
-  if (!::QueueUserWorkItem(&PluginModuleChromeParent::GetToolhelpSnapshot,
-                           mFinishInitTask, WT_EXECUTEDEFAULT)) {
-    mFinishInitTask = nullptr;
-    return;
-  }
-}
-
-void PluginModuleChromeParent::DoInjection(const nsAutoHandle& aSnapshot) {
-  DWORD pluginProcessPID = GetProcessId(Process()->GetChildProcessHandle());
-  mFlashProcess1 = GetFlashChildOfPID(pluginProcessPID, aSnapshot);
-  if (mFlashProcess1) {
-    InjectCrashReporterIntoProcess(mFlashProcess1, this);
-
-    mFlashProcess2 = GetFlashChildOfPID(mFlashProcess1, aSnapshot);
-    if (mFlashProcess2) {
-      InjectCrashReporterIntoProcess(mFlashProcess2, this);
-    }
-  }
-  mFinishInitTask = nullptr;
-}
-
-DWORD WINAPI PluginModuleChromeParent::GetToolhelpSnapshot(LPVOID aContext) {
-  FinishInjectorInitTask* task = static_cast<FinishInjectorInitTask*>(aContext);
-  MOZ_ASSERT(task);
-  task->PostToMainThread();
-  return 0;
-}
-
-void PluginModuleChromeParent::OnCrash(DWORD processID) {
-  if (!mShutdown) {
-    GetIPCChannel()->CloseWithError();
-    mozilla::ipc::ScopedProcessHandle geckoPluginChild;
-    if (base::OpenProcessHandle(OtherPid(), &geckoPluginChild.rwget())) {
-      if (!base::KillProcess(geckoPluginChild, base::PROCESS_END_KILLED_BY_USER,
-                             false)) {
-        NS_ERROR("May have failed to kill child process.");
-      }
-    } else {
-      NS_ERROR("Failed to open child process when attempting kill.");
-    }
-  }
-}
-
-#endif  // MOZ_CRASHREPORTER_INJECTOR
diff --git a/dom/plugins/ipc/PluginModuleParent.h b/dom/plugins/ipc/PluginModuleParent.h
deleted file mode 100644
index 25a904f543943..0000000000000
--- a/dom/plugins/ipc/PluginModuleParent.h
+++ /dev/null
@@ -1,532 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_plugins_PluginModuleParent_h
-#define mozilla_plugins_PluginModuleParent_h
-
-#include "base/process.h"
-#include "mozilla/FileUtils.h"
-#include "mozilla/HangAnnotations.h"
-#include "mozilla/PluginLibrary.h"
-#include "mozilla/plugins/PluginProcessParent.h"
-#include "mozilla/plugins/PPluginModuleParent.h"
-#include "mozilla/plugins/PluginMessageUtils.h"
-#include "mozilla/plugins/PluginTypes.h"
-#include "mozilla/ipc/TaskFactory.h"
-#include "mozilla/TimeStamp.h"
-#include "mozilla/Unused.h"
-#include "npapi.h"
-#include "npfunctions.h"
-#include "nsExceptionHandler.h"
-#include "nsHashKeys.h"
-#include "nsIObserver.h"
-#ifdef XP_WIN
-#  include "nsWindowsHelpers.h"
-#endif
-
-class nsPluginTag;
-
-namespace mozilla {
-
-namespace ipc {
-class CrashReporterHost;
-}  // namespace ipc
-namespace layers {
-class TextureClientRecycleAllocator;
-}  // namespace layers
-
-namespace plugins {
-//-----------------------------------------------------------------------------
-
-class BrowserStreamParent;
-class PluginInstanceParent;
-
-#ifdef XP_WIN
-class PluginHangUIParent;
-class FunctionBrokerParent;
-#endif
-#ifdef MOZ_CRASHREPORTER_INJECTOR
-class FinishInjectorInitTask;
-#endif
-
-/**
- * PluginModuleParent
- *
- * This class implements the NPP API from the perspective of the rest
- * of Gecko, forwarding NPP calls along to the child process that is
- * actually running the plugin.
- *
- * This class /also/ implements a version of the NPN API, because the
- * child process needs to make these calls back into Gecko proper.
- * This class is responsible for "actually" making those function calls.
- *
- * If a plugin is running, there will always be one PluginModuleParent for it in
- * the chrome process. In addition, any content process using the plugin will
- * have its own PluginModuleParent. The subclasses PluginModuleChromeParent and
- * PluginModuleContentParent implement functionality that is specific to one
- * case or the other.
- */
-class PluginModuleParent : public PPluginModuleParent,
-                           public PluginLibrary
-#ifdef MOZ_CRASHREPORTER_INJECTOR
-    ,
-                           public CrashReporter::InjectorCrashCallback
-#endif
-{
-  friend class PPluginModuleParent;
-
- protected:
-  typedef mozilla::PluginLibrary PluginLibrary;
-
-  PPluginInstanceParent* AllocPPluginInstanceParent(
-      const nsCString& aMimeType, const nsTArray<nsCString>& aNames,
-      const nsTArray<nsCString>& aValues);
-
-  bool DeallocPPluginInstanceParent(PPluginInstanceParent* aActor);
-
- public:
-  explicit PluginModuleParent(bool aIsChrome);
-  virtual ~PluginModuleParent();
-
-  bool IsChrome() const { return mIsChrome; }
-
-  virtual void SetPlugin(nsNPAPIPlugin* plugin) override { mPlugin = plugin; }
-
-  virtual void ActorDestroy(ActorDestroyReason why) override;
-
-  const NPNetscapeFuncs* GetNetscapeFuncs() { return mNPNIface; }
-
-  bool OkToCleanup() const { return !IsOnCxxStack(); }
-
-  void ProcessRemoteNativeEventsInInterruptCall() override;
-
-  virtual nsresult GetRunID(uint32_t* aRunID) override;
-  virtual void SetHasLocalInstance() override { mHadLocalInstance = true; }
-
-  int GetQuirks() { return mQuirks; }
-
- protected:
-  virtual mozilla::ipc::RacyInterruptPolicy MediateInterruptRace(
-      const MessageInfo& parent, const MessageInfo& child) override {
-    return MediateRace(parent, child);
-  }
-
-  mozilla::ipc::IPCResult RecvBackUpXResources(
-      const FileDescriptor& aXSocketFd);
-
-  mozilla::ipc::IPCResult AnswerProcessSomeEvents();
-
-  mozilla::ipc::IPCResult RecvProcessNativeEventsInInterruptCall();
-
-  mozilla::ipc::IPCResult RecvPluginShowWindow(
-      const uint32_t& aWindowId, const bool& aModal, const int32_t& aX,
-      const int32_t& aY, const double& aWidth, const double& aHeight);
-
-  mozilla::ipc::IPCResult RecvPluginHideWindow(const uint32_t& aWindowId);
-
-  mozilla::ipc::IPCResult RecvNPN_SetException(const nsCString& aMessage);
-
-  mozilla::ipc::IPCResult RecvNPN_ReloadPlugins(const bool& aReloadPages);
-
-  static BrowserStreamParent* StreamCast(NPP instance, NPStream* s);
-
-  virtual mozilla::ipc::IPCResult
-  AnswerNPN_SetValue_NPPVpluginRequiresAudioDeviceChanges(
-      const bool& shouldRegister, NPError* result);
-
- protected:
-  void SetChildTimeout(const int32_t aChildTimeout);
-  static void TimeoutChanged(const char* aPref, void* aModule);
-
-  virtual void UpdatePluginTimeout() {}
-
-  virtual mozilla::ipc::IPCResult RecvNotifyContentModuleDestroyed() {
-    return IPC_OK();
-  }
-
-  mozilla::ipc::IPCResult RecvReturnClearSiteData(const NPError& aRv,
-                                                  const uint64_t& aCallbackId);
-
-  mozilla::ipc::IPCResult RecvReturnSitesWithData(nsTArray<nsCString>&& aSites,
-                                                  const uint64_t& aCallbackId);
-
-  void SetPluginFuncs(NPPluginFuncs* aFuncs);
-
-  nsresult NPP_NewInternal(NPMIMEType pluginType, NPP instance,
-                           nsTArray<nsCString>& names,
-                           nsTArray<nsCString>& values, NPSavedData* saved,
-                           NPError* error);
-
-  // NPP-like API that Gecko calls are trampolined into.  These
-  // messages then get forwarded along to the plugin instance,
-  // and then eventually the child process.
-
-  static NPError NPP_Destroy(NPP instance, NPSavedData** save);
-
-  static NPError NPP_SetWindow(NPP instance, NPWindow* window);
-  static NPError NPP_NewStream(NPP instance, NPMIMEType type, NPStream* stream,
-                               NPBool seekable, uint16_t* stype);
-  static NPError NPP_DestroyStream(NPP instance, NPStream* stream,
-                                   NPReason reason);
-  static int32_t NPP_WriteReady(NPP instance, NPStream* stream);
-  static int32_t NPP_Write(NPP instance, NPStream* stream, int32_t offset,
-                           int32_t len, void* buffer);
-  static void NPP_Print(NPP instance, NPPrint* platformPrint);
-  static int16_t NPP_HandleEvent(NPP instance, void* event);
-  static void NPP_URLNotify(NPP instance, const char* url, NPReason reason,
-                            void* notifyData);
-  static NPError NPP_GetValue(NPP instance, NPPVariable variable,
-                              void* ret_value);
-  static NPError NPP_SetValue(NPP instance, NPNVariable variable, void* value);
-  static void NPP_URLRedirectNotify(NPP instance, const char* url,
-                                    int32_t status, void* notifyData);
-
-  virtual bool HasRequiredFunctions() override;
-  virtual nsresult AsyncSetWindow(NPP aInstance, NPWindow* aWindow) override;
-  virtual nsresult GetImageContainer(
-      NPP aInstance, mozilla::layers::ImageContainer** aContainer) override;
-  virtual nsresult GetImageSize(NPP aInstance, nsIntSize* aSize) override;
-  virtual void DidComposite(NPP aInstance) override;
-  virtual bool IsOOP() override { return true; }
-  virtual nsresult SetBackgroundUnknown(NPP instance) override;
-  virtual nsresult BeginUpdateBackground(NPP instance, const nsIntRect& aRect,
-                                         DrawTarget** aDrawTarget) override;
-  virtual nsresult EndUpdateBackground(NPP instance,
-                                       const nsIntRect& aRect) override;
-
-#if defined(XP_WIN)
-  virtual nsresult GetScrollCaptureContainer(
-      NPP aInstance, mozilla::layers::ImageContainer** aContainer) override;
-#endif
-
-#if defined(XP_UNIX) && !defined(XP_MACOSX)
-  virtual nsresult NP_Initialize(NPNetscapeFuncs* bFuncs, NPPluginFuncs* pFuncs,
-                                 NPError* error) override;
-#else
-  virtual nsresult NP_Initialize(NPNetscapeFuncs* bFuncs,
-                                 NPError* error) override;
-#endif
-  virtual nsresult NP_Shutdown(NPError* error) override;
-
-  virtual nsresult NP_GetMIMEDescription(const char** mimeDesc) override;
-  virtual nsresult NP_GetValue(void* future, NPPVariable aVariable,
-                               void* aValue, NPError* error) override;
-#if defined(XP_WIN) || defined(XP_MACOSX)
-  virtual nsresult NP_GetEntryPoints(NPPluginFuncs* pFuncs,
-                                     NPError* error) override;
-#endif
-  virtual nsresult NPP_New(NPMIMEType pluginType, NPP instance, int16_t argc,
-                           char* argn[], char* argv[], NPSavedData* saved,
-                           NPError* error) override;
-  virtual nsresult NPP_ClearSiteData(
-      const char* site, uint64_t flags, uint64_t maxAge,
-      nsCOMPtr<nsIClearSiteDataCallback> callback) override;
-  virtual nsresult NPP_GetSitesWithData(
-      nsCOMPtr<nsIGetSitesWithDataCallback> callback) override;
-
- private:
-  std::map<uint64_t, nsCOMPtr<nsIClearSiteDataCallback>>
-      mClearSiteDataCallbacks;
-  std::map<uint64_t, nsCOMPtr<nsIGetSitesWithDataCallback>>
-      mSitesWithDataCallbacks;
-
-  nsCString mPluginFilename;
-  int mQuirks;
-  void InitQuirksModes(const nsCString& aMimeType);
-
- public:
-#if defined(XP_MACOSX)
-  virtual nsresult IsRemoteDrawingCoreAnimation(NPP instance,
-                                                bool* aDrawing) override;
-#endif
-#if defined(XP_MACOSX) || defined(XP_WIN)
-  virtual nsresult ContentsScaleFactorChanged(
-      NPP instance, double aContentsScaleFactor) override;
-#endif
-
-  layers::TextureClientRecycleAllocator*
-  EnsureTextureAllocatorForDirectBitmap();
-  layers::TextureClientRecycleAllocator* EnsureTextureAllocatorForDXGISurface();
-
- protected:
-  void NotifyFlashHang();
-  void NotifyPluginCrashed();
-  void OnInitFailure();
-  bool DoShutdown(NPError* error);
-
-  bool GetSetting(NPNVariable aVariable);
-  void GetSettings(PluginSettings* aSettings);
-
-  bool mIsChrome;
-  bool mShutdown;
-  bool mHadLocalInstance;
-  bool mClearSiteDataSupported;
-  bool mGetSitesWithDataSupported;
-  NPNetscapeFuncs* mNPNIface;
-  NPPluginFuncs* mNPPIface;
-  nsNPAPIPlugin* mPlugin;
-  ipc::TaskFactory<PluginModuleParent> mTaskFactory;
-  nsString mHangID;
-  nsCString mPluginName;
-  nsCString mPluginVersion;
-  int32_t mSandboxLevel;
-  bool mIsFlashPlugin;
-
-#ifdef MOZ_X11
-  // Dup of plugin's X socket, used to scope its resources to this
-  // object instead of the plugin process's lifetime
-  ScopedClose mPluginXSocketFdDup;
-#endif
-
-  bool GetPluginDetails();
-
-  uint32_t mRunID;
-
-  RefPtr<layers::TextureClientRecycleAllocator>
-      mTextureAllocatorForDirectBitmap;
-  RefPtr<layers::TextureClientRecycleAllocator> mTextureAllocatorForDXGISurface;
-
-  /**
-   * This mutex protects the crash reporter when the Plugin Hang UI event
-   * handler is executing off main thread. It is intended to protect both
-   * the mCrashReporter variable in addition to the CrashReporterHost object
-   * that mCrashReporter refers to.
-   */
-  mozilla::Mutex mCrashReporterMutex;
-  UniquePtr<ipc::CrashReporterHost> mCrashReporter;
-  nsString mOrphanedDumpId;
-};
-
-class PluginModuleContentParent : public PluginModuleParent {
- public:
-  explicit PluginModuleContentParent();
-
-  static PluginLibrary* LoadModule(uint32_t aPluginId, nsPluginTag* aPluginTag);
-
-  virtual ~PluginModuleContentParent();
-
-#if defined(XP_WIN) || defined(XP_MACOSX)
-  nsresult NP_Initialize(NPNetscapeFuncs* bFuncs, NPError* error) override;
-#endif
-
- private:
-  static void Initialize(Endpoint<PPluginModuleParent>&& aEndpoint);
-
-  virtual bool ShouldContinueFromReplyTimeout() override;
-  virtual void OnExitedSyncSend() override;
-
-#ifdef MOZ_CRASHREPORTER_INJECTOR
-  void OnCrash(DWORD processID) override {}
-#endif
-
-  static PluginModuleContentParent* sSavedModuleParent;
-
-  uint32_t mPluginId;
-};
-
-class PluginModuleChromeParent : public PluginModuleParent,
-                                 public mozilla::BackgroundHangAnnotator {
-  friend class mozilla::ipc::CrashReporterHost;
-
- public:
-  /**
-   * LoadModule
-   *
-   * This may or may not launch a plugin child process,
-   * and may or may not be very expensive.
-   */
-  static PluginLibrary* LoadModule(const char* aFilePath, uint32_t aPluginId,
-                                   nsPluginTag* aPluginTag);
-
-  virtual ~PluginModuleChromeParent();
-
-  /*
-   * Takes a full multi-process dump including the plugin process and the
-   * content process. If aBrowserDumpId is not empty then the browser dump
-   * associated with it will be paired to the resulting minidump.
-   * Takes ownership of the file associated with aBrowserDumpId.
-   *
-   * @param aContentPid PID of the e10s content process from which a hang was
-   *   reported. May be kInvalidProcessId if not applicable.
-   * @param aBrowserDumpId (optional) previously taken browser dump id. If
-   *   provided TakeFullMinidump will use this dump file instead of
-   *   generating a new one. If not provided a browser dump will be taken at
-   *   the time of this call.
-   * @param aDumpId Returns the ID of the newly generated crash dump. Left
-   *   untouched upon failure.
-   */
-  void TakeFullMinidump(base::ProcessId aContentPid,
-                        const nsAString& aBrowserDumpId, nsString& aDumpId);
-
-  /*
-   * Terminates the plugin process associated with this plugin module. Also
-   * generates appropriate crash reports unless an existing one is provided.
-   * Takes ownership of the file associated with aDumpId on success.
-   *
-   * @param aMsgLoop the main message pump associated with the module
-   *   protocol.
-   * @param aContentPid PID of the e10s content process from which a hang was
-   *   reported. May be kInvalidProcessId if not applicable.
-   * @param aMonitorDescription a string describing the hang monitor that
-   *   is making this call. This string is added to the crash reporter
-   *   annotations for the plugin process.
-   * @param aDumpId (optional) previously taken dump id. If provided
-   *   TerminateChildProcess will use this dump file instead of generating a
-   *   multi-process crash report. If not provided a multi-process dump will
-   *   be taken at the time of this call.
-   */
-  void TerminateChildProcess(MessageLoop* aMsgLoop, base::ProcessId aContentPid,
-                             const nsCString& aMonitorDescription,
-                             const nsAString& aDumpId);
-
-#ifdef XP_WIN
-  /**
-   * Called by Plugin Hang UI to notify that the user has clicked continue.
-   * Used for chrome hang annotations.
-   */
-  void OnHangUIContinue();
-
-  void EvaluateHangUIState(const bool aReset);
-#endif  // XP_WIN
-
-  void CachedSettingChanged();
-
- private:
-  virtual void EnteredCxxStack() override;
-
-  void ExitedCxxStack() override;
-
-  mozilla::ipc::IProtocol* GetInvokingProtocol();
-  PluginInstanceParent* GetManagingInstance(mozilla::ipc::IProtocol* aProtocol);
-
-  virtual void AnnotateHang(
-      mozilla::BackgroundHangAnnotations& aAnnotations) override;
-
-  virtual bool ShouldContinueFromReplyTimeout() override;
-
-  void ProcessFirstMinidump();
-  void HandleOrphanedMinidump();
-  void AddCrashAnnotations();
-
-  PluginProcessParent* Process() const { return mSubprocess; }
-  base::ProcessHandle ChildProcessHandle() {
-    return mSubprocess->GetChildProcessHandle();
-  }
-
-#if defined(XP_UNIX) && !defined(XP_MACOSX)
-  virtual nsresult NP_Initialize(NPNetscapeFuncs* bFuncs, NPPluginFuncs* pFuncs,
-                                 NPError* error) override;
-#else
-  virtual nsresult NP_Initialize(NPNetscapeFuncs* bFuncs,
-                                 NPError* error) override;
-#endif
-
-#if defined(XP_WIN) || defined(XP_MACOSX)
-  virtual nsresult NP_GetEntryPoints(NPPluginFuncs* pFuncs,
-                                     NPError* error) override;
-#endif
-
-  virtual void ActorDestroy(ActorDestroyReason why) override;
-
-  // aFilePath is UTF8, not native!
-  explicit PluginModuleChromeParent(const char* aFilePath, uint32_t aPluginId,
-                                    int32_t aSandboxLevel);
-
-  void CleanupFromTimeout(const bool aByHangUI);
-
-  virtual void UpdatePluginTimeout() override;
-
-  void RegisterSettingsCallbacks();
-  void UnregisterSettingsCallbacks();
-
-  bool InitCrashReporter();
-
-  mozilla::ipc::IPCResult RecvNotifyContentModuleDestroyed() override;
-
-  static void CachedSettingChanged(const char* aPref, void* aModule);
-
-  mozilla::ipc::IPCResult
-  AnswerNPN_SetValue_NPPVpluginRequiresAudioDeviceChanges(
-      const bool& shouldRegister, NPError* result) override;
-
-  PluginProcessParent* mSubprocess;
-  uint32_t mPluginId;
-
-  ipc::TaskFactory<PluginModuleChromeParent> mChromeTaskFactory;
-
-  enum HangAnnotationFlags {
-    kInPluginCall = (1u << 0),
-    kHangUIShown = (1u << 1),
-    kHangUIContinued = (1u << 2),
-    kHangUIDontShow = (1u << 3)
-  };
-  Atomic<uint32_t> mHangAnnotationFlags;
-#ifdef XP_WIN
-  nsTArray<float> mPluginCpuUsageOnHang;
-  PluginHangUIParent* mHangUIParent;
-  bool mHangUIEnabled;
-  bool mIsTimerReset;
-
-  /**
-   * Launches the Plugin Hang UI.
-   *
-   * @return true if plugin-hang-ui.exe has been successfully launched.
-   *         false if the Plugin Hang UI is disabled, already showing,
-   *               or the launch failed.
-   */
-  bool LaunchHangUI();
-
-  /**
-   * Finishes the Plugin Hang UI and cancels if it is being shown to the user.
-   */
-  void FinishHangUI();
-
-  FunctionBrokerParent* mBrokerParent;
-#endif
-
-#ifdef MOZ_CRASHREPORTER_INJECTOR
-  friend class mozilla::plugins::FinishInjectorInitTask;
-
-  void InitializeInjector();
-  void DoInjection(const nsAutoHandle& aSnapshot);
-  static DWORD WINAPI GetToolhelpSnapshot(LPVOID aContext);
-
-  void OnCrash(DWORD processID) override;
-
-  DWORD mFlashProcess1;
-  DWORD mFlashProcess2;
-  RefPtr<mozilla::plugins::FinishInjectorInitTask> mFinishInitTask;
-#endif
-
-  void OnProcessLaunched(const bool aSucceeded);
-
-  class LaunchedTask : public LaunchCompleteTask {
-   public:
-    explicit LaunchedTask(PluginModuleChromeParent* aModule)
-        : mModule(aModule) {
-      MOZ_ASSERT(aModule);
-    }
-
-    NS_IMETHOD Run() override {
-      mModule->OnProcessLaunched(mLaunchSucceeded);
-      return NS_OK;
-    }
-
-   private:
-    PluginModuleChromeParent* mModule;
-  };
-
-  friend class LaunchedTask;
-
-  nsCOMPtr<nsIObserver> mPluginOfflineObserver;
-  bool mIsBlocklisted;
-  bool mIsCleaningFromTimeout;
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // mozilla_plugins_PluginModuleParent_h
diff --git a/dom/plugins/ipc/PluginProcessChild.cpp b/dom/plugins/ipc/PluginProcessChild.cpp
deleted file mode 100644
index c411914449cc9..0000000000000
--- a/dom/plugins/ipc/PluginProcessChild.cpp
+++ /dev/null
@@ -1,186 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "mozilla/plugins/PluginProcessChild.h"
-
-#include "ClearOnShutdown.h"
-#include "base/command_line.h"
-#include "base/message_loop.h"  // for MessageLoop
-#include "base/string_util.h"
-#include "mozilla/AbstractThread.h"
-#include "mozilla/TaskController.h"
-#include "mozilla/ipc/IOThreadChild.h"
-#include "nsDebugImpl.h"
-#include "nsThreadManager.h"
-#include "prlink.h"
-
-#if defined(XP_MACOSX) && defined(MOZ_SANDBOX)
-#  include "mozilla/SandboxSettings.h"
-#endif
-
-#ifdef XP_WIN
-#  if defined(MOZ_SANDBOX)
-#    include "mozilla/sandboxTarget.h"
-#    include "ProcessUtils.h"
-#    include "nsDirectoryService.h"
-#  endif
-#endif
-
-using mozilla::ipc::IOThreadChild;
-
-#ifdef OS_WIN
-#  include <algorithm>
-#endif
-
-namespace mozilla::plugins {
-
-#if defined(XP_WIN) && defined(MOZ_SANDBOX)
-static void SetSandboxTempPath(const std::wstring& aFullTmpPath) {
-  // Save the TMP environment variable so that is is picked up by GetTempPath().
-  // Note that we specifically write to the TMP variable, as that is the first
-  // variable that is checked by GetTempPath() to determine its output.
-  Unused << NS_WARN_IF(!SetEnvironmentVariableW(L"TMP", aFullTmpPath.c_str()));
-
-  // We also set TEMP in case there is naughty third-party code that is
-  // referencing the environment variable directly.
-  Unused << NS_WARN_IF(!SetEnvironmentVariableW(L"TEMP", aFullTmpPath.c_str()));
-}
-#endif
-
-bool PluginProcessChild::Init(int aArgc, char* aArgv[]) {
-  nsDebugImpl::SetMultiprocessMode("NPAPI");
-
-#if defined(XP_MACOSX)
-  // Remove the trigger for "dyld interposing" that we added in
-  // GeckoChildProcessHost::PerformAsyncLaunch(), in the host
-  // process just before we were launched.  Dyld interposing will still
-  // happen in our process (the plugin child process).  But we don't want
-  // it to happen in any processes that the plugin might launch from our
-  // process.
-  nsCString interpose(PR_GetEnv("DYLD_INSERT_LIBRARIES"));
-  if (!interpose.IsEmpty()) {
-    // If we added the path to libplugin_child_interpose.dylib to an
-    // existing DYLD_INSERT_LIBRARIES, we appended it to the end, after a
-    // ":" path seperator.
-    int32_t lastSeparatorPos = interpose.RFind(":");
-    int32_t lastTriggerPos = interpose.RFind("libplugin_child_interpose.dylib");
-    bool needsReset = false;
-    if (lastTriggerPos != -1) {
-      if (lastSeparatorPos == -1) {
-        interpose.Truncate();
-        needsReset = true;
-      } else if (lastTriggerPos > lastSeparatorPos) {
-        interpose.SetLength(lastSeparatorPos);
-        needsReset = true;
-      }
-    }
-    if (needsReset) {
-      nsCString setInterpose("DYLD_INSERT_LIBRARIES=");
-      if (!interpose.IsEmpty()) {
-        setInterpose.Append(interpose);
-      }
-      // Values passed to PR_SetEnv() must be seperately allocated.
-      char* setInterposePtr = strdup(setInterpose.get());
-      PR_SetEnv(setInterposePtr);
-    }
-  }
-#endif
-
-  // Certain plugins, such as flash, steal the unhandled exception filter
-  // thus we never get crash reports when they fault. This call fixes it.
-  message_loop()->set_exception_restoration(true);
-
-  std::string pluginFilename;
-
-#if defined(OS_POSIX)
-  // NB: need to be very careful in ensuring that the first arg
-  // (after the binary name) here is indeed the plugin module path.
-  // Keep in sync with dom/plugins/PluginModuleParent.
-  std::vector<std::string> values = CommandLine::ForCurrentProcess()->argv();
-  MOZ_ASSERT(values.size() >= 2, "not enough args");
-
-  pluginFilename = UnmungePluginDsoPath(values[1]);
-
-#  if defined(XP_MACOSX) && defined(MOZ_SANDBOX)
-  int level;
-  if (values.size() >= 4 && values[2] == "-flashSandboxLevel" &&
-      (level = std::stoi(values[3], nullptr)) > 0) {
-    level = ClampFlashSandboxLevel(level);
-    MOZ_ASSERT(level > 0);
-
-    bool enableLogging = false;
-    if (values.size() >= 5 && values[4] == "-flashSandboxLogging") {
-      enableLogging = true;
-    }
-
-    mPlugin.EnableFlashSandbox(level, enableLogging);
-  }
-#  endif
-
-#elif defined(OS_WIN)
-  std::vector<std::wstring> values =
-      CommandLine::ForCurrentProcess()->GetLooseValues();
-  MOZ_ASSERT(values.size() >= 1, "not enough loose args");
-
-  // parameters are:
-  // values[0] is path to plugin DLL
-  // values[1] is path to folder that should be used for temp files
-  // values[2] is path to the Flash Player roaming folder
-  //   (this is always that Flash folder, regardless of what plugin is being
-  //   run)
-  pluginFilename = WideToUTF8(values[0]);
-
-  // We don't initialize XPCOM but we need the thread manager and the
-  // logging framework for the FunctionBroker.
-  NS_SetMainThread();
-  mozilla::TimeStamp::Startup();
-  NS_LogInit();
-  mozilla::LogModule::Init(aArgc, aArgv);
-  nsThreadManager::get().Init();
-
-#  if defined(MOZ_SANDBOX)
-  MOZ_ASSERT(values.size() >= 3,
-             "not enough loose args for sandboxed plugin process");
-
-  // The sandbox closes off the default location temp file location so we set
-  // a new one here (regardless of whether or not we are sandboxing).
-  SetSandboxTempPath(values[1]);
-  PluginModuleChild::SetFlashRoamingPath(values[2]);
-
-  // This is probably the earliest we would want to start the sandbox.
-  // As we attempt to tighten the sandbox, we may need to consider moving this
-  // to later in the plugin initialization.
-  mozilla::SandboxTarget::Instance()->StartSandbox();
-#  endif
-#else
-#  error Sorry
-#endif
-
-  return mPlugin.InitForChrome(pluginFilename, ParentPid(),
-                               IOThreadChild::message_loop(),
-                               IOThreadChild::TakeChannel());
-}
-
-void PluginProcessChild::CleanUp() {
-#if defined(OS_WIN)
-  MOZ_ASSERT(NS_IsMainThread());
-
-  // Shutdown components we started in Init.  Note that KillClearOnShutdown
-  // is an event that is regularly part of XPCOM shutdown.  We do not
-  // call XPCOM's shutdown but we need this event to be sent to avoid
-  // leaking objects labeled as ClearOnShutdown.
-  nsThreadManager::get().Shutdown();
-  NS_LogTerm();
-#endif
-
-  mozilla::KillClearOnShutdown(ShutdownPhase::XPCOMShutdownFinal);
-
-  AbstractThread::ShutdownMainThread();
-
-  mozilla::TaskController::Shutdown();
-}
-
-}  // namespace mozilla::plugins
diff --git a/dom/plugins/ipc/PluginProcessChild.h b/dom/plugins/ipc/PluginProcessChild.h
deleted file mode 100644
index 36c8077ce87aa..0000000000000
--- a/dom/plugins/ipc/PluginProcessChild.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef dom_plugins_PluginProcessChild_h
-#define dom_plugins_PluginProcessChild_h 1
-
-#include "mozilla/ipc/ProcessChild.h"
-#include "mozilla/plugins/PluginModuleChild.h"
-
-#if defined(XP_WIN)
-#  include "mozilla/mscom/ProcessRuntime.h"
-#endif
-
-namespace mozilla {
-namespace plugins {
-//-----------------------------------------------------------------------------
-
-class PluginProcessChild : public mozilla::ipc::ProcessChild {
- protected:
-  typedef mozilla::ipc::ProcessChild ProcessChild;
-
- public:
-  explicit PluginProcessChild(ProcessId aParentPid)
-      : ProcessChild(aParentPid), mPlugin(true) {}
-
-  virtual ~PluginProcessChild() = default;
-
-  virtual bool Init(int aArgc, char* aArgv[]) override;
-  virtual void CleanUp() override;
-
- protected:
-  static PluginProcessChild* current() {
-    return static_cast<PluginProcessChild*>(ProcessChild::current());
-  }
-
- private:
-#if defined(XP_WIN)
-  /* Drag-and-drop depends on the host initializing COM.
-   * This object initializes and configures COM. */
-  mozilla::mscom::ProcessRuntime mCOMRuntime;
-#endif
-  PluginModuleChild mPlugin;
-
-  DISALLOW_EVIL_CONSTRUCTORS(PluginProcessChild);
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // ifndef dom_plugins_PluginProcessChild_h
diff --git a/dom/plugins/ipc/PluginProcessParent.cpp b/dom/plugins/ipc/PluginProcessParent.cpp
deleted file mode 100644
index 8a960ebc966f0..0000000000000
--- a/dom/plugins/ipc/PluginProcessParent.cpp
+++ /dev/null
@@ -1,191 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "mozilla/plugins/PluginProcessParent.h"
-
-#include "base/string_util.h"
-#include "base/process_util.h"
-
-#include "nsAppDirectoryServiceDefs.h"
-#include "nsDirectoryServiceDefs.h"
-#include "nsIFile.h"
-#include "nsIProperties.h"
-#include "nsServiceManagerUtils.h"
-
-#include "mozilla/ipc/BrowserProcessSubThread.h"
-#include "mozilla/plugins/PluginMessageUtils.h"
-#include "mozilla/Telemetry.h"
-#include "nsThreadUtils.h"
-
-using std::string;
-using std::vector;
-
-using mozilla::ipc::BrowserProcessSubThread;
-using mozilla::ipc::GeckoChildProcessHost;
-using mozilla::plugins::LaunchCompleteTask;
-using mozilla::plugins::PluginProcessParent;
-
-#ifdef XP_WIN
-PluginProcessParent::PidSet* PluginProcessParent::sPidSet = nullptr;
-#endif
-
-PluginProcessParent::PluginProcessParent(const std::string& aPluginFilePath)
-    : GeckoChildProcessHost(GeckoProcessType_Plugin),
-      mPluginFilePath(aPluginFilePath),
-      mTaskFactory(this),
-      mMainMsgLoop(MessageLoop::current())
-#ifdef XP_WIN
-      ,
-      mChildPid(0)
-#endif
-{
-}
-
-PluginProcessParent::~PluginProcessParent() {
-#ifdef XP_WIN
-  if (sPidSet && mChildPid) {
-    sPidSet->RemoveEntry(mChildPid);
-    if (sPidSet->IsEmpty()) {
-      delete sPidSet;
-      sPidSet = nullptr;
-    }
-  }
-#endif
-}
-
-bool PluginProcessParent::Launch(
-    mozilla::UniquePtr<LaunchCompleteTask> aLaunchCompleteTask,
-    int32_t aSandboxLevel, bool aIsSandboxLoggingEnabled) {
-#if (defined(XP_WIN) || defined(XP_MACOSX)) && defined(MOZ_SANDBOX)
-  // At present, the Mac Flash plugin sandbox does not support different
-  // levels and is enabled via a boolean pref or environment variable.
-  // On Mac, when |aSandboxLevel| is positive, we enable the sandbox.
-#  if defined(XP_WIN)
-  mSandboxLevel = aSandboxLevel;
-
-  // The sandbox process sometimes needs read access to the plugin file.
-  if (aSandboxLevel >= 3) {
-    std::wstring pluginFile(
-        NS_ConvertUTF8toUTF16(mPluginFilePath.c_str()).get());
-    mAllowedFilesRead.push_back(pluginFile);
-  }
-#  endif  // XP_WIN
-#else
-  if (aSandboxLevel != 0) {
-    MOZ_ASSERT(false,
-               "Can't enable an NPAPI process sandbox for platform/build.");
-  }
-#endif
-
-  mLaunchCompleteTask = std::move(aLaunchCompleteTask);
-
-  vector<string> args;
-  args.push_back(MungePluginDsoPath(mPluginFilePath));
-
-#if defined(XP_MACOSX) && defined(MOZ_SANDBOX)
-  if (aSandboxLevel > 0) {
-    args.push_back("-flashSandboxLevel");
-    args.push_back(std::to_string(aSandboxLevel));
-    if (aIsSandboxLoggingEnabled) {
-      args.push_back("-flashSandboxLogging");
-    }
-  }
-#elif defined(XP_WIN) && defined(MOZ_SANDBOX)
-  nsresult rv;
-  nsCOMPtr<nsIProperties> dirSvc =
-      do_GetService(NS_DIRECTORY_SERVICE_CONTRACTID, &rv);
-  if (NS_FAILED(rv)) {
-    MOZ_ASSERT(false, "Failed to get directory service.");
-    return false;
-  }
-
-  nsCOMPtr<nsIFile> dir;
-  rv = dirSvc->Get(NS_APP_PLUGIN_PROCESS_TEMP_DIR, NS_GET_IID(nsIFile),
-                   getter_AddRefs(dir));
-  if (NS_FAILED(rv)) {
-    NS_WARNING("Failed to get plugin process temp directory.");
-    return false;
-  }
-
-  nsAutoString tempDir;
-  MOZ_ALWAYS_SUCCEEDS(dir->GetPath(tempDir));
-  args.push_back(NS_ConvertUTF16toUTF8(tempDir).get());
-
-  rv =
-      dirSvc->Get(NS_WIN_APPDATA_DIR, NS_GET_IID(nsIFile), getter_AddRefs(dir));
-  if (NS_FAILED(rv)) {
-    NS_WARNING("Failed to get appdata directory.");
-    return false;
-  }
-
-  nsAutoString appdataDir;
-  MOZ_ALWAYS_SUCCEEDS(dir->GetPath(appdataDir));
-  appdataDir.Append(L"\\Adobe\\");
-  args.push_back(NS_ConvertUTF16toUTF8(appdataDir).get());
-#endif
-
-  bool result = AsyncLaunch(args);
-  if (!result) {
-    mLaunchCompleteTask = nullptr;
-  }
-  return result;
-}
-
-/**
- * This function exists so that we may provide an additional level of
- * indirection between the task being posted to main event loop (a
- * RunnableMethod) and the launch complete task itself. This is needed
- * for cases when both WaitUntilConnected or OnChannel* race to invoke the
- * task.
- */
-void PluginProcessParent::RunLaunchCompleteTask() {
-  if (mLaunchCompleteTask) {
-    mLaunchCompleteTask->Run();
-    mLaunchCompleteTask = nullptr;
-  }
-}
-
-bool PluginProcessParent::WaitUntilConnected(int32_t aTimeoutMs) {
-  bool result = GeckoChildProcessHost::WaitUntilConnected(aTimeoutMs);
-  if (mLaunchCompleteTask) {
-    if (result) {
-      mLaunchCompleteTask->SetLaunchSucceeded();
-    }
-    RunLaunchCompleteTask();
-  }
-  return result;
-}
-
-void PluginProcessParent::OnChannelConnected(int32_t peer_pid) {
-#ifdef XP_WIN
-  mChildPid = static_cast<uint32_t>(peer_pid);
-  if (!sPidSet) {
-    sPidSet = new PluginProcessParent::PidSet();
-  }
-  sPidSet->PutEntry(mChildPid);
-#endif
-
-  GeckoChildProcessHost::OnChannelConnected(peer_pid);
-}
-
-void PluginProcessParent::OnChannelError() {
-  GeckoChildProcessHost::OnChannelError();
-}
-
-bool PluginProcessParent::IsConnected() {
-  mozilla::MonitorAutoLock lock(mMonitor);
-  return mProcessState == PROCESS_CONNECTED;
-}
-
-bool PluginProcessParent::IsPluginProcessId(base::ProcessId procId) {
-#ifdef XP_WIN
-  MOZ_ASSERT(XRE_IsParentProcess());
-  return sPidSet && sPidSet->Contains(static_cast<uint32_t>(procId));
-#else
-  NS_ERROR("IsPluginProcessId not available on this platform.");
-  return false;
-#endif
-}
diff --git a/dom/plugins/ipc/PluginProcessParent.h b/dom/plugins/ipc/PluginProcessParent.h
deleted file mode 100644
index b2810865a584f..0000000000000
--- a/dom/plugins/ipc/PluginProcessParent.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef dom_plugins_PluginProcessParent_h
-#define dom_plugins_PluginProcessParent_h 1
-
-#include "mozilla/Attributes.h"
-#include "base/basictypes.h"
-
-#include "base/file_path.h"
-#include "base/task.h"
-#include "base/thread.h"
-#include "chrome/common/child_process_host.h"
-
-#include "mozilla/ipc/GeckoChildProcessHost.h"
-#include "mozilla/ipc/TaskFactory.h"
-#include "mozilla/UniquePtr.h"
-#include "nsCOMPtr.h"
-#include "nsTHashtable.h"
-#include "nsHashKeys.h"
-
-namespace mozilla {
-namespace plugins {
-
-class LaunchCompleteTask : public Runnable {
- public:
-  LaunchCompleteTask()
-      : Runnable("plugins::LaunchCompleteTask"), mLaunchSucceeded(false) {}
-
-  void SetLaunchSucceeded() { mLaunchSucceeded = true; }
-
- protected:
-  bool mLaunchSucceeded;
-};
-
-class PluginProcessParent final : public mozilla::ipc::GeckoChildProcessHost {
- public:
-  explicit PluginProcessParent(const std::string& aPluginFilePath);
-
-  /**
-   * Launch the plugin process. If the process fails to launch,
-   * this method will return false.
-   *
-   * @param aLaunchCompleteTask Task that is executed on the main
-   * thread once the asynchonous launch has completed.
-   * @param aSandboxLevel Determines the strength of the sandbox.
-   * <= 0 means no sandbox.
-   * @param aIsSandboxLoggingEnabled Indicates if sandbox violation
-   * logging should be enabled for the plugin process.
-   */
-  bool Launch(UniquePtr<LaunchCompleteTask> aLaunchCompleteTask =
-                  UniquePtr<LaunchCompleteTask>(),
-              int32_t aSandboxLevel = 0, bool aIsSandboxLoggingEnabled = false);
-
-  virtual bool CanShutdown() override { return true; }
-
-  const std::string& GetPluginFilePath() { return mPluginFilePath; }
-
-  using mozilla::ipc::GeckoChildProcessHost::GetChannel;
-
-  virtual bool WaitUntilConnected(int32_t aTimeoutMs = 0) override;
-
-  virtual void OnChannelConnected(int32_t peer_pid) override;
-  virtual void OnChannelError() override;
-
-  bool IsConnected();
-
-  static bool IsPluginProcessId(base::ProcessId procId);
-
- private:
-  ~PluginProcessParent();
-
-  void RunLaunchCompleteTask();
-
-  std::string mPluginFilePath;
-  ipc::TaskFactory<PluginProcessParent> mTaskFactory;
-  UniquePtr<LaunchCompleteTask> mLaunchCompleteTask;
-  MessageLoop* mMainMsgLoop;
-#ifdef XP_WIN
-  typedef nsTHashtable<nsUint32HashKey> PidSet;
-  // Set of PIDs for all plugin child processes or NULL if empty.
-  static PidSet* sPidSet;
-  uint32_t mChildPid;
-#endif
-
-  DISALLOW_EVIL_CONSTRUCTORS(PluginProcessParent);
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // ifndef dom_plugins_PluginProcessParent_h
diff --git a/dom/plugins/ipc/PluginQuirks.cpp b/dom/plugins/ipc/PluginQuirks.cpp
deleted file mode 100644
index 2e83cbc37b4aa..0000000000000
--- a/dom/plugins/ipc/PluginQuirks.cpp
+++ /dev/null
@@ -1,54 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "PluginQuirks.h"
-
-#include "nsPluginHost.h"
-
-namespace mozilla::plugins {
-
-int GetQuirksFromMimeTypeAndFilename(const nsCString& aMimeType,
-                                     const nsCString& aPluginFilename) {
-  int quirks = 0;
-
-  nsPluginHost::SpecialType specialType =
-      nsPluginHost::GetSpecialType(aMimeType);
-
-  if (specialType == nsPluginHost::eSpecialType_Flash) {
-    quirks |= QUIRK_FLASH_RETURN_EMPTY_DOCUMENT_ORIGIN;
-#ifdef OS_WIN
-    quirks |= QUIRK_WINLESS_TRACKPOPUP_HOOK;
-    quirks |= QUIRK_FLASH_THROTTLE_WMUSER_EVENTS;
-    quirks |= QUIRK_FLASH_HOOK_SETLONGPTR;
-    quirks |= QUIRK_FLASH_HOOK_GETWINDOWINFO;
-    quirks |= QUIRK_FLASH_FIXUP_MOUSE_CAPTURE;
-    quirks |= QUIRK_WINLESS_HOOK_IME;
-#  if defined(_M_X64) || defined(__x86_64__)
-    quirks |= QUIRK_FLASH_HOOK_GETKEYSTATE;
-    quirks |= QUIRK_FLASH_HOOK_PRINTDLGW;
-    quirks |= QUIRK_FLASH_HOOK_SSL;
-    quirks |= QUIRK_FLASH_HOOK_CREATEMUTEXW;
-#  endif
-#endif
-  }
-
-#ifdef XP_MACOSX
-  // Whitelist Flash to support offline renderer.
-  if (specialType == nsPluginHost::eSpecialType_Flash) {
-    quirks |= QUIRK_ALLOW_OFFLINE_RENDERER;
-  }
-#endif
-
-#ifdef OS_WIN
-  if (specialType == nsPluginHost::eSpecialType_Test) {
-    quirks |= QUIRK_WINLESS_HOOK_IME;
-  }
-#endif
-
-  return quirks;
-}
-
-}  // namespace mozilla::plugins
diff --git a/dom/plugins/ipc/PluginQuirks.h b/dom/plugins/ipc/PluginQuirks.h
deleted file mode 100644
index 852ebb6b7a45f..0000000000000
--- a/dom/plugins/ipc/PluginQuirks.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=4 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef dom_plugins_PluginQuirks_h
-#define dom_plugins_PluginQuirks_h
-
-#include "nsString.h"
-
-namespace mozilla {
-namespace plugins {
-
-// Quirks mode support for various plugin mime types
-enum PluginQuirks {
-  QUIRKS_NOT_INITIALIZED = 0,
-  // Win32: Hook TrackPopupMenu api so that we can swap out parent
-  // hwnds. The api will fail with parents not associated with our
-  // child ui thread. See WinlessHandleEvent for details.
-  QUIRK_WINLESS_TRACKPOPUP_HOOK = 1 << 1,
-  // Win32: Throttle flash WM_USER+1 heart beat messages to prevent
-  // flooding chromium's dispatch loop, which can cause ipc traffic
-  // processing lag.
-  QUIRK_FLASH_THROTTLE_WMUSER_EVENTS = 1 << 2,
-  // Win32: Catch resets on our subclass by hooking SetWindowLong.
-  QUIRK_FLASH_HOOK_SETLONGPTR = 1 << 3,
-  // X11: Work around a bug in Flash up to 10.1 d51 at least, where
-  // expose event top left coordinates within the plugin-rect and
-  // not at the drawable origin are misinterpreted.
-  QUIRK_FLASH_EXPOSE_COORD_TRANSLATION = 1 << 4,
-  // Win32: Catch get window info calls on the browser and tweak the
-  // results so mouse input works when flash is displaying it's settings
-  // window.
-  QUIRK_FLASH_HOOK_GETWINDOWINFO = 1 << 5,
-  // Win: Addresses a flash bug with mouse capture and full screen
-  // windows.
-  QUIRK_FLASH_FIXUP_MOUSE_CAPTURE = 1 << 6,
-  // Mac: Allow the plugin to use offline renderer mode.
-  // Use this only if the plugin is certified the support the offline renderer.
-  QUIRK_ALLOW_OFFLINE_RENDERER = 1 << 9,
-  // Work around a Flash bug where it fails to check the error code of a
-  // NPN_GetValue(NPNVdocumentOrigin) call before trying to dereference
-  // its char* output.
-  QUIRK_FLASH_RETURN_EMPTY_DOCUMENT_ORIGIN = 1 << 10,
-  // Win: Hook IMM32 API to handle IME event on windowless plugin
-  QUIRK_WINLESS_HOOK_IME = 1 << 12,
-  // Win: Hook GetKeyState to get keyboard state on sandbox process
-  QUIRK_FLASH_HOOK_GETKEYSTATE = 1 << 13,
-  // Win: Hook PrintDlgW to show print settings dialog on sandbox process
-  QUIRK_FLASH_HOOK_PRINTDLGW = 1 << 14,
-  // Win: Broker Win32 SSL operations
-  QUIRK_FLASH_HOOK_SSL = 1 << 15,
-  // Win: Hook CreateMutexW for brokering when using the camera
-  QUIRK_FLASH_HOOK_CREATEMUTEXW = 1 << 16,
-};
-
-int GetQuirksFromMimeTypeAndFilename(const nsCString& aMimeType,
-                                     const nsCString& aPluginFilename);
-
-} /* namespace plugins */
-} /* namespace mozilla */
-
-#endif  // ifndef dom_plugins_PluginQuirks_h
diff --git a/dom/plugins/ipc/PluginScriptableObjectChild.cpp b/dom/plugins/ipc/PluginScriptableObjectChild.cpp
deleted file mode 100644
index 9567c050e07e7..0000000000000
--- a/dom/plugins/ipc/PluginScriptableObjectChild.cpp
+++ /dev/null
@@ -1,1198 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=2 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "PluginScriptableObjectChild.h"
-#include "PluginScriptableObjectUtils.h"
-#include "mozilla/plugins/PluginTypes.h"
-
-using namespace mozilla::plugins;
-
-/**
- * NPIdentifiers in the plugin process use a tagged representation. The low bit
- * stores the tag. If it's zero, the identifier is a string, and the value is a
- * pointer to a StoredIdentifier. If the tag bit is 1, then the rest of the
- * NPIdentifier value is the integer itself. Like the JSAPI, we require that all
- * integers stored in NPIdentifier be non-negative.
- *
- * String identifiers are stored in the sIdentifiers hashtable to ensure
- * uniqueness. The lifetime of these identifiers is only as long as the incoming
- * IPC call from the chrome process. If the plugin wants to retain an
- * identifier, it needs to call NPN_GetStringIdentifier, which causes the
- * mPermanent flag to be set on the identifier. When this flag is set, the
- * identifier is saved until the plugin process exits.
- *
- * The StackIdentifier RAII class is used to manage ownership of
- * identifiers. Any identifier obtained from this class should not be used
- * outside its scope, except when the MakePermanent() method has been called on
- * it.
- *
- * The lifetime of an NPIdentifier in the plugin process is totally divorced
- * from the lifetime of an NPIdentifier in the chrome process (where an
- * NPIdentifier is stored as a jsid). The JS GC in the chrome process is able to
- * trace through the entire heap, unlike in the plugin process, so there is no
- * reason to retain identifiers there.
- */
-
-PluginScriptableObjectChild::IdentifierTable
-    PluginScriptableObjectChild::sIdentifiers;
-
-/* static */ PluginScriptableObjectChild::StoredIdentifier*
-PluginScriptableObjectChild::HashIdentifier(const nsCString& aIdentifier) {
-  return sIdentifiers.GetOrInsertNew(aIdentifier, aIdentifier);
-}
-
-/* static */
-void PluginScriptableObjectChild::UnhashIdentifier(StoredIdentifier* aStored) {
-  MOZ_ASSERT(sIdentifiers.Contains(aStored->mIdentifier));
-  sIdentifiers.Remove(aStored->mIdentifier);
-}
-
-/* static */
-void PluginScriptableObjectChild::ClearIdentifiers() { sIdentifiers.Clear(); }
-
-PluginScriptableObjectChild::StackIdentifier::StackIdentifier(
-    const PluginIdentifier& aIdentifier)
-    : mIdentifier(aIdentifier), mStored(nullptr) {
-  if (aIdentifier.type() == PluginIdentifier::TnsCString) {
-    mStored = PluginScriptableObjectChild::HashIdentifier(
-        mIdentifier.get_nsCString());
-  }
-}
-
-PluginScriptableObjectChild::StackIdentifier::StackIdentifier(
-    NPIdentifier aIdentifier)
-    : mStored(nullptr) {
-  uintptr_t bits = reinterpret_cast<uintptr_t>(aIdentifier);
-  if (bits & 1) {
-    int32_t num = int32_t(bits >> 1);
-    mIdentifier = PluginIdentifier(num);
-  } else {
-    mStored = static_cast<StoredIdentifier*>(aIdentifier);
-    mIdentifier = mStored->mIdentifier;
-  }
-}
-
-PluginScriptableObjectChild::StackIdentifier::~StackIdentifier() {
-  if (!mStored) {
-    return;
-  }
-
-  // Each StackIdentifier owns one reference to its StoredIdentifier. In
-  // addition, the sIdentifiers table owns a reference. If mPermanent is false
-  // and sIdentifiers has the last reference, then we want to remove the
-  // StoredIdentifier from the table (and destroy it).
-  StoredIdentifier* stored = mStored;
-  mStored = nullptr;
-  if (stored->mRefCnt == 1 && !stored->mPermanent) {
-    PluginScriptableObjectChild::UnhashIdentifier(stored);
-  }
-}
-
-NPIdentifier PluginScriptableObjectChild::StackIdentifier::ToNPIdentifier()
-    const {
-  if (mStored) {
-    MOZ_ASSERT(mIdentifier.type() == PluginIdentifier::TnsCString);
-    MOZ_ASSERT((reinterpret_cast<uintptr_t>(mStored.get()) & 1) == 0);
-    return mStored;
-  }
-
-  int32_t num = mIdentifier.get_int32_t();
-  // The JS engine imposes this condition on int32s in jsids, so we assume it.
-  MOZ_ASSERT(num >= 0);
-  return reinterpret_cast<NPIdentifier>((num << 1) | 1);
-}
-
-static PluginIdentifier FromNPIdentifier(NPIdentifier aIdentifier) {
-  PluginScriptableObjectChild::StackIdentifier stack(aIdentifier);
-  return stack.GetIdentifier();
-}
-
-// static
-NPObject* PluginScriptableObjectChild::ScriptableAllocate(NPP aInstance,
-                                                          NPClass* aClass) {
-  AssertPluginThread();
-
-  if (aClass != GetClass()) {
-    MOZ_CRASH("Huh?! Wrong class!");
-  }
-
-  return new ChildNPObject();
-}
-
-// static
-void PluginScriptableObjectChild::ScriptableInvalidate(NPObject* aObject) {
-  AssertPluginThread();
-
-  if (aObject->_class != GetClass()) {
-    MOZ_CRASH("Don't know what kind of object this is!");
-  }
-
-  ChildNPObject* object = reinterpret_cast<ChildNPObject*>(aObject);
-  if (object->invalidated) {
-    // This can happen more than once, and is just fine.
-    return;
-  }
-
-  object->invalidated = true;
-}
-
-// static
-void PluginScriptableObjectChild::ScriptableDeallocate(NPObject* aObject) {
-  AssertPluginThread();
-
-  if (aObject->_class != GetClass()) {
-    MOZ_CRASH("Don't know what kind of object this is!");
-  }
-
-  ChildNPObject* object = reinterpret_cast<ChildNPObject*>(aObject);
-  PluginScriptableObjectChild* actor = object->parent;
-  if (actor) {
-    NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
-    actor->DropNPObject();
-  }
-
-  delete object;
-}
-
-// static
-bool PluginScriptableObjectChild::ScriptableHasMethod(NPObject* aObject,
-                                                      NPIdentifier aName) {
-  AssertPluginThread();
-
-  if (aObject->_class != GetClass()) {
-    MOZ_CRASH("Don't know what kind of object this is!");
-  }
-
-  ChildNPObject* object = reinterpret_cast<ChildNPObject*>(aObject);
-  if (object->invalidated) {
-    NS_WARNING("Calling method on an invalidated object!");
-    return false;
-  }
-
-  ProtectedActor<PluginScriptableObjectChild> actor(object->parent);
-  NS_ASSERTION(actor, "This shouldn't ever be null!");
-  NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
-
-  bool result;
-  actor->CallHasMethod(FromNPIdentifier(aName), &result);
-
-  return result;
-}
-
-// static
-bool PluginScriptableObjectChild::ScriptableInvoke(NPObject* aObject,
-                                                   NPIdentifier aName,
-                                                   const NPVariant* aArgs,
-                                                   uint32_t aArgCount,
-                                                   NPVariant* aResult) {
-  AssertPluginThread();
-
-  if (aObject->_class != GetClass()) {
-    MOZ_CRASH("Don't know what kind of object this is!");
-  }
-
-  ChildNPObject* object = reinterpret_cast<ChildNPObject*>(aObject);
-  if (object->invalidated) {
-    NS_WARNING("Calling method on an invalidated object!");
-    return false;
-  }
-
-  ProtectedActor<PluginScriptableObjectChild> actor(object->parent);
-  NS_ASSERTION(actor, "This shouldn't ever be null!");
-  NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
-
-  ProtectedVariantArray args(aArgs, aArgCount, actor->GetInstance());
-  if (!args.IsOk()) {
-    NS_ERROR("Failed to convert arguments!");
-    return false;
-  }
-
-  Variant remoteResult;
-  bool success;
-  actor->CallInvoke(FromNPIdentifier(aName), args, &remoteResult, &success);
-
-  if (!success) {
-    return false;
-  }
-
-  ConvertToVariant(remoteResult, *aResult);
-  return true;
-}
-
-// static
-bool PluginScriptableObjectChild::ScriptableInvokeDefault(
-    NPObject* aObject, const NPVariant* aArgs, uint32_t aArgCount,
-    NPVariant* aResult) {
-  AssertPluginThread();
-
-  if (aObject->_class != GetClass()) {
-    MOZ_CRASH("Don't know what kind of object this is!");
-  }
-
-  ChildNPObject* object = reinterpret_cast<ChildNPObject*>(aObject);
-  if (object->invalidated) {
-    NS_WARNING("Calling method on an invalidated object!");
-    return false;
-  }
-
-  ProtectedActor<PluginScriptableObjectChild> actor(object->parent);
-  NS_ASSERTION(actor, "This shouldn't ever be null!");
-  NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
-
-  ProtectedVariantArray args(aArgs, aArgCount, actor->GetInstance());
-  if (!args.IsOk()) {
-    NS_ERROR("Failed to convert arguments!");
-    return false;
-  }
-
-  Variant remoteResult;
-  bool success;
-  actor->CallInvokeDefault(args, &remoteResult, &success);
-
-  if (!success) {
-    return false;
-  }
-
-  ConvertToVariant(remoteResult, *aResult);
-  return true;
-}
-
-// static
-bool PluginScriptableObjectChild::ScriptableHasProperty(NPObject* aObject,
-                                                        NPIdentifier aName) {
-  AssertPluginThread();
-
-  if (aObject->_class != GetClass()) {
-    MOZ_CRASH("Don't know what kind of object this is!");
-  }
-
-  ChildNPObject* object = reinterpret_cast<ChildNPObject*>(aObject);
-  if (object->invalidated) {
-    NS_WARNING("Calling method on an invalidated object!");
-    return false;
-  }
-
-  ProtectedActor<PluginScriptableObjectChild> actor(object->parent);
-  NS_ASSERTION(actor, "This shouldn't ever be null!");
-  NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
-
-  bool result;
-  actor->CallHasProperty(FromNPIdentifier(aName), &result);
-
-  return result;
-}
-
-// static
-bool PluginScriptableObjectChild::ScriptableGetProperty(NPObject* aObject,
-                                                        NPIdentifier aName,
-                                                        NPVariant* aResult) {
-  AssertPluginThread();
-
-  if (aObject->_class != GetClass()) {
-    MOZ_CRASH("Don't know what kind of object this is!");
-  }
-
-  ChildNPObject* object = reinterpret_cast<ChildNPObject*>(aObject);
-  if (object->invalidated) {
-    NS_WARNING("Calling method on an invalidated object!");
-    return false;
-  }
-
-  ProtectedActor<PluginScriptableObjectChild> actor(object->parent);
-  NS_ASSERTION(actor, "This shouldn't ever be null!");
-  NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
-
-  PluginInstanceChild::AutoStackHelper guard(actor->mInstance);
-
-  Variant result;
-  bool success;
-  actor->CallGetParentProperty(FromNPIdentifier(aName), &result, &success);
-
-  if (!success) {
-    return false;
-  }
-
-  ConvertToVariant(result, *aResult);
-  return true;
-}
-
-// static
-bool PluginScriptableObjectChild::ScriptableSetProperty(
-    NPObject* aObject, NPIdentifier aName, const NPVariant* aValue) {
-  AssertPluginThread();
-
-  if (aObject->_class != GetClass()) {
-    MOZ_CRASH("Don't know what kind of object this is!");
-  }
-
-  ChildNPObject* object = reinterpret_cast<ChildNPObject*>(aObject);
-  if (object->invalidated) {
-    NS_WARNING("Calling method on an invalidated object!");
-    return false;
-  }
-
-  ProtectedActor<PluginScriptableObjectChild> actor(object->parent);
-  NS_ASSERTION(actor, "This shouldn't ever be null!");
-  NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
-
-  ProtectedVariant value(*aValue, actor->GetInstance());
-  if (!value.IsOk()) {
-    NS_WARNING("Failed to convert variant!");
-    return false;
-  }
-
-  bool success;
-  actor->CallSetProperty(FromNPIdentifier(aName), value, &success);
-
-  return success;
-}
-
-// static
-bool PluginScriptableObjectChild::ScriptableRemoveProperty(NPObject* aObject,
-                                                           NPIdentifier aName) {
-  AssertPluginThread();
-
-  if (aObject->_class != GetClass()) {
-    MOZ_CRASH("Don't know what kind of object this is!");
-  }
-
-  ChildNPObject* object = reinterpret_cast<ChildNPObject*>(aObject);
-  if (object->invalidated) {
-    NS_WARNING("Calling method on an invalidated object!");
-    return false;
-  }
-
-  ProtectedActor<PluginScriptableObjectChild> actor(object->parent);
-  NS_ASSERTION(actor, "This shouldn't ever be null!");
-  NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
-
-  bool success;
-  actor->CallRemoveProperty(FromNPIdentifier(aName), &success);
-
-  return success;
-}
-
-// static
-bool PluginScriptableObjectChild::ScriptableEnumerate(
-    NPObject* aObject, NPIdentifier** aIdentifiers, uint32_t* aCount) {
-  AssertPluginThread();
-
-  if (aObject->_class != GetClass()) {
-    MOZ_CRASH("Don't know what kind of object this is!");
-  }
-
-  ChildNPObject* object = reinterpret_cast<ChildNPObject*>(aObject);
-  if (object->invalidated) {
-    NS_WARNING("Calling method on an invalidated object!");
-    return false;
-  }
-
-  ProtectedActor<PluginScriptableObjectChild> actor(object->parent);
-  NS_ASSERTION(actor, "This shouldn't ever be null!");
-  NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
-
-  AutoTArray<PluginIdentifier, 10> identifiers;
-  bool success;
-  actor->CallEnumerate(&identifiers, &success);
-
-  if (!success) {
-    return false;
-  }
-
-  *aCount = identifiers.Length();
-  if (!*aCount) {
-    *aIdentifiers = nullptr;
-    return true;
-  }
-
-  *aIdentifiers =
-      reinterpret_cast<NPIdentifier*>(PluginModuleChild::sBrowserFuncs.memalloc(
-          *aCount * sizeof(NPIdentifier)));
-  if (!*aIdentifiers) {
-    NS_ERROR("Out of memory!");
-    return false;
-  }
-
-  for (uint32_t index = 0; index < *aCount; index++) {
-    StackIdentifier id(identifiers[index]);
-    // Make the id permanent in case the plugin retains it.
-    id.MakePermanent();
-    (*aIdentifiers)[index] = id.ToNPIdentifier();
-  }
-  return true;
-}
-
-// static
-bool PluginScriptableObjectChild::ScriptableConstruct(NPObject* aObject,
-                                                      const NPVariant* aArgs,
-                                                      uint32_t aArgCount,
-                                                      NPVariant* aResult) {
-  AssertPluginThread();
-
-  if (aObject->_class != GetClass()) {
-    MOZ_CRASH("Don't know what kind of object this is!");
-  }
-
-  ChildNPObject* object = reinterpret_cast<ChildNPObject*>(aObject);
-  if (object->invalidated) {
-    NS_WARNING("Calling method on an invalidated object!");
-    return false;
-  }
-
-  ProtectedActor<PluginScriptableObjectChild> actor(object->parent);
-  NS_ASSERTION(actor, "This shouldn't ever be null!");
-  NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
-
-  ProtectedVariantArray args(aArgs, aArgCount, actor->GetInstance());
-  if (!args.IsOk()) {
-    NS_ERROR("Failed to convert arguments!");
-    return false;
-  }
-
-  Variant remoteResult;
-  bool success;
-  actor->CallConstruct(args, &remoteResult, &success);
-
-  if (!success) {
-    return false;
-  }
-
-  ConvertToVariant(remoteResult, *aResult);
-  return true;
-}
-
-const NPClass PluginScriptableObjectChild::sNPClass = {
-    NP_CLASS_STRUCT_VERSION,
-    PluginScriptableObjectChild::ScriptableAllocate,
-    PluginScriptableObjectChild::ScriptableDeallocate,
-    PluginScriptableObjectChild::ScriptableInvalidate,
-    PluginScriptableObjectChild::ScriptableHasMethod,
-    PluginScriptableObjectChild::ScriptableInvoke,
-    PluginScriptableObjectChild::ScriptableInvokeDefault,
-    PluginScriptableObjectChild::ScriptableHasProperty,
-    PluginScriptableObjectChild::ScriptableGetProperty,
-    PluginScriptableObjectChild::ScriptableSetProperty,
-    PluginScriptableObjectChild::ScriptableRemoveProperty,
-    PluginScriptableObjectChild::ScriptableEnumerate,
-    PluginScriptableObjectChild::ScriptableConstruct};
-
-PluginScriptableObjectChild::PluginScriptableObjectChild(
-    ScriptableObjectType aType)
-    : mInstance(nullptr),
-      mObject(nullptr),
-      mInvalidated(false),
-      mProtectCount(0),
-      mType(aType) {
-  AssertPluginThread();
-}
-
-PluginScriptableObjectChild::~PluginScriptableObjectChild() {
-  AssertPluginThread();
-
-  if (mObject) {
-    UnregisterActor(mObject);
-
-    if (mObject->_class == GetClass()) {
-      NS_ASSERTION(mType == Proxy, "Wrong type!");
-      static_cast<ChildNPObject*>(mObject)->parent = nullptr;
-    } else {
-      NS_ASSERTION(mType == LocalObject, "Wrong type!");
-      PluginModuleChild::sBrowserFuncs.releaseobject(mObject);
-    }
-  }
-}
-
-bool PluginScriptableObjectChild::InitializeProxy() {
-  AssertPluginThread();
-  NS_ASSERTION(mType == Proxy, "Bad type!");
-  NS_ASSERTION(!mObject, "Calling Initialize more than once!");
-  NS_ASSERTION(!mInvalidated, "Already invalidated?!");
-
-  mInstance = static_cast<PluginInstanceChild*>(Manager());
-  NS_ASSERTION(mInstance, "Null manager?!");
-
-  NPObject* object = CreateProxyObject();
-  if (!object) {
-    NS_ERROR("Failed to create object!");
-    return false;
-  }
-
-  if (!RegisterActor(object)) {
-    NS_ERROR("RegisterActor failed");
-    return false;
-  }
-
-  mObject = object;
-  return true;
-}
-
-void PluginScriptableObjectChild::InitializeLocal(NPObject* aObject) {
-  AssertPluginThread();
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-  NS_ASSERTION(!mObject, "Calling Initialize more than once!");
-  NS_ASSERTION(!mInvalidated, "Already invalidated?!");
-
-  mInstance = static_cast<PluginInstanceChild*>(Manager());
-  NS_ASSERTION(mInstance, "Null manager?!");
-
-  PluginModuleChild::sBrowserFuncs.retainobject(aObject);
-
-  NS_ASSERTION(!mProtectCount, "Should be zero!");
-  mProtectCount++;
-
-  if (!RegisterActor(aObject)) {
-    NS_ERROR("RegisterActor failed");
-  }
-
-  mObject = aObject;
-}
-
-NPObject* PluginScriptableObjectChild::CreateProxyObject() {
-  NS_ASSERTION(mInstance, "Must have an instance!");
-  NS_ASSERTION(mType == Proxy, "Shouldn't call this for non-proxy object!");
-
-  NPClass* proxyClass = const_cast<NPClass*>(GetClass());
-  NPObject* npobject = PluginModuleChild::sBrowserFuncs.createobject(
-      mInstance->GetNPP(), proxyClass);
-  NS_ASSERTION(npobject, "Failed to create object?!");
-  NS_ASSERTION(npobject->_class == GetClass(), "Wrong kind of object!");
-  NS_ASSERTION(npobject->referenceCount == 1, "Some kind of live object!");
-
-  ChildNPObject* object = static_cast<ChildNPObject*>(npobject);
-  NS_ASSERTION(!object->invalidated, "Bad object!");
-  NS_ASSERTION(!object->parent, "Bad object!");
-
-  // We don't want to have the actor own this object but rather let the object
-  // own this actor. Set the reference count to 0 here so that when the object
-  // dies we will send the destructor message to the child.
-  object->referenceCount = 0;
-  NS_LOG_RELEASE(object, 0, "NPObject");
-
-  object->parent = const_cast<PluginScriptableObjectChild*>(this);
-  return object;
-}
-
-bool PluginScriptableObjectChild::ResurrectProxyObject() {
-  NS_ASSERTION(mInstance, "Must have an instance already!");
-  NS_ASSERTION(!mObject, "Should not have an object already!");
-  NS_ASSERTION(mType == Proxy, "Shouldn't call this for non-proxy object!");
-
-  if (!InitializeProxy()) {
-    NS_ERROR("Initialize failed!");
-    return false;
-  }
-
-  SendProtect();
-  return true;
-}
-
-NPObject* PluginScriptableObjectChild::GetObject(bool aCanResurrect) {
-  if (!mObject && aCanResurrect && !ResurrectProxyObject()) {
-    NS_ERROR("Null object!");
-    return nullptr;
-  }
-  return mObject;
-}
-
-void PluginScriptableObjectChild::Protect() {
-  NS_ASSERTION(mObject, "No object!");
-  NS_ASSERTION(mProtectCount >= 0, "Negative retain count?!");
-
-  if (mType == LocalObject) {
-    ++mProtectCount;
-  }
-}
-
-void PluginScriptableObjectChild::Unprotect() {
-  NS_ASSERTION(mObject, "Bad state!");
-  NS_ASSERTION(mProtectCount >= 0, "Negative retain count?!");
-
-  if (mType == LocalObject) {
-    if (--mProtectCount == 0) {
-      PluginScriptableObjectChild::Send__delete__(this);
-    }
-  }
-}
-
-void PluginScriptableObjectChild::DropNPObject() {
-  NS_ASSERTION(mObject, "Invalidated object!");
-  NS_ASSERTION(mObject->_class == GetClass(), "Wrong type of object!");
-  NS_ASSERTION(mType == Proxy, "Shouldn't call this for non-proxy object!");
-
-  // We think we're about to be deleted, but we could be racing with the other
-  // process.
-  UnregisterActor(mObject);
-  mObject = nullptr;
-
-  SendUnprotect();
-}
-
-void PluginScriptableObjectChild::NPObjectDestroyed() {
-  NS_ASSERTION(LocalObject == mType,
-               "ScriptableDeallocate should have handled this for proxies");
-  mInvalidated = true;
-  mObject = nullptr;
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectChild::AnswerInvalidate() {
-  AssertPluginThread();
-  PluginInstanceChild::AutoStackHelper guard(mInstance);
-
-  if (mInvalidated) {
-    return IPC_OK();
-  }
-
-  mInvalidated = true;
-
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  if (mObject->_class && mObject->_class->invalidate) {
-    mObject->_class->invalidate(mObject);
-  }
-
-  Unprotect();
-
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectChild::AnswerHasMethod(
-    const PluginIdentifier& aId, bool* aHasMethod) {
-  AssertPluginThread();
-  PluginInstanceChild::AutoStackHelper guard(mInstance);
-
-  if (mInvalidated) {
-    NS_WARNING("Calling AnswerHasMethod with an invalidated object!");
-    *aHasMethod = false;
-    return IPC_OK();
-  }
-
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  if (!(mObject->_class && mObject->_class->hasMethod)) {
-    *aHasMethod = false;
-    return IPC_OK();
-  }
-
-  StackIdentifier id(aId);
-  *aHasMethod = mObject->_class->hasMethod(mObject, id.ToNPIdentifier());
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectChild::AnswerInvoke(
-    const PluginIdentifier& aId, nsTArray<Variant>&& aArgs, Variant* aResult,
-    bool* aSuccess) {
-  AssertPluginThread();
-  PluginInstanceChild::AutoStackHelper guard(mInstance);
-
-  if (mInvalidated) {
-    NS_WARNING("Calling AnswerInvoke with an invalidated object!");
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  if (!(mObject->_class && mObject->_class->invoke)) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  AutoTArray<NPVariant, 10> convertedArgs;
-  uint32_t argCount = aArgs.Length();
-
-  if (!convertedArgs.SetLength(argCount, mozilla::fallible)) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  for (uint32_t index = 0; index < argCount; index++) {
-    ConvertToVariant(aArgs[index], convertedArgs[index]);
-  }
-
-  NPVariant result;
-  VOID_TO_NPVARIANT(result);
-  StackIdentifier id(aId);
-  bool success =
-      mObject->_class->invoke(mObject, id.ToNPIdentifier(),
-                              convertedArgs.Elements(), argCount, &result);
-
-  for (uint32_t index = 0; index < argCount; index++) {
-    PluginModuleChild::sBrowserFuncs.releasevariantvalue(&convertedArgs[index]);
-  }
-
-  if (!success) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  Variant convertedResult;
-  success =
-      ConvertToRemoteVariant(result, convertedResult, GetInstance(), false);
-
-  DeferNPVariantLastRelease(&PluginModuleChild::sBrowserFuncs, &result);
-
-  if (!success) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  *aSuccess = true;
-  *aResult = convertedResult;
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectChild::AnswerInvokeDefault(
-    nsTArray<Variant>&& aArgs, Variant* aResult, bool* aSuccess) {
-  AssertPluginThread();
-  PluginInstanceChild::AutoStackHelper guard(mInstance);
-
-  if (mInvalidated) {
-    NS_WARNING("Calling AnswerInvokeDefault with an invalidated object!");
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  if (!(mObject->_class && mObject->_class->invokeDefault)) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  AutoTArray<NPVariant, 10> convertedArgs;
-  uint32_t argCount = aArgs.Length();
-
-  if (!convertedArgs.SetLength(argCount, mozilla::fallible)) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  for (uint32_t index = 0; index < argCount; index++) {
-    ConvertToVariant(aArgs[index], convertedArgs[index]);
-  }
-
-  NPVariant result;
-  VOID_TO_NPVARIANT(result);
-  bool success = mObject->_class->invokeDefault(
-      mObject, convertedArgs.Elements(), argCount, &result);
-
-  for (uint32_t index = 0; index < argCount; index++) {
-    PluginModuleChild::sBrowserFuncs.releasevariantvalue(&convertedArgs[index]);
-  }
-
-  if (!success) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  Variant convertedResult;
-  success =
-      ConvertToRemoteVariant(result, convertedResult, GetInstance(), false);
-
-  DeferNPVariantLastRelease(&PluginModuleChild::sBrowserFuncs, &result);
-
-  if (!success) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  *aResult = convertedResult;
-  *aSuccess = true;
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectChild::AnswerHasProperty(
-    const PluginIdentifier& aId, bool* aHasProperty) {
-  AssertPluginThread();
-  PluginInstanceChild::AutoStackHelper guard(mInstance);
-
-  if (mInvalidated) {
-    NS_WARNING("Calling AnswerHasProperty with an invalidated object!");
-    *aHasProperty = false;
-    return IPC_OK();
-  }
-
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  if (!(mObject->_class && mObject->_class->hasProperty)) {
-    *aHasProperty = false;
-    return IPC_OK();
-  }
-
-  StackIdentifier id(aId);
-  *aHasProperty = mObject->_class->hasProperty(mObject, id.ToNPIdentifier());
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectChild::AnswerGetChildProperty(
-    const PluginIdentifier& aId, bool* aHasProperty, bool* aHasMethod,
-    Variant* aResult, bool* aSuccess) {
-  AssertPluginThread();
-  PluginInstanceChild::AutoStackHelper guard(mInstance);
-
-  *aHasProperty = *aHasMethod = *aSuccess = false;
-  *aResult = void_t();
-
-  if (mInvalidated) {
-    NS_WARNING("Calling AnswerGetProperty with an invalidated object!");
-    return IPC_OK();
-  }
-
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  if (!(mObject->_class && mObject->_class->hasProperty &&
-        mObject->_class->hasMethod && mObject->_class->getProperty)) {
-    return IPC_OK();
-  }
-
-  StackIdentifier stackID(aId);
-  NPIdentifier id = stackID.ToNPIdentifier();
-
-  *aHasProperty = mObject->_class->hasProperty(mObject, id);
-  *aHasMethod = mObject->_class->hasMethod(mObject, id);
-
-  if (*aHasProperty) {
-    NPVariant result;
-    VOID_TO_NPVARIANT(result);
-
-    if (!mObject->_class->getProperty(mObject, id, &result)) {
-      return IPC_OK();
-    }
-
-    Variant converted;
-    if ((*aSuccess =
-             ConvertToRemoteVariant(result, converted, GetInstance(), false))) {
-      DeferNPVariantLastRelease(&PluginModuleChild::sBrowserFuncs, &result);
-      *aResult = converted;
-    }
-  }
-
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectChild::AnswerSetProperty(
-    const PluginIdentifier& aId, const Variant& aValue, bool* aSuccess) {
-  AssertPluginThread();
-  PluginInstanceChild::AutoStackHelper guard(mInstance);
-
-  if (mInvalidated) {
-    NS_WARNING("Calling AnswerSetProperty with an invalidated object!");
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  if (!(mObject->_class && mObject->_class->hasProperty &&
-        mObject->_class->setProperty)) {
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  StackIdentifier stackID(aId);
-  NPIdentifier id = stackID.ToNPIdentifier();
-
-  if (!mObject->_class->hasProperty(mObject, id)) {
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  NPVariant converted;
-  ConvertToVariant(aValue, converted);
-
-  if ((*aSuccess = mObject->_class->setProperty(mObject, id, &converted))) {
-    PluginModuleChild::sBrowserFuncs.releasevariantvalue(&converted);
-  }
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectChild::AnswerRemoveProperty(
-    const PluginIdentifier& aId, bool* aSuccess) {
-  AssertPluginThread();
-  PluginInstanceChild::AutoStackHelper guard(mInstance);
-
-  if (mInvalidated) {
-    NS_WARNING("Calling AnswerRemoveProperty with an invalidated object!");
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  if (!(mObject->_class && mObject->_class->hasProperty &&
-        mObject->_class->removeProperty)) {
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  StackIdentifier stackID(aId);
-  NPIdentifier id = stackID.ToNPIdentifier();
-  *aSuccess = mObject->_class->hasProperty(mObject, id)
-                  ? mObject->_class->removeProperty(mObject, id)
-                  : true;
-
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectChild::AnswerEnumerate(
-    nsTArray<PluginIdentifier>* aProperties, bool* aSuccess) {
-  AssertPluginThread();
-  PluginInstanceChild::AutoStackHelper guard(mInstance);
-
-  if (mInvalidated) {
-    NS_WARNING("Calling AnswerEnumerate with an invalidated object!");
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  if (!(mObject->_class && mObject->_class->enumerate)) {
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  NPIdentifier* ids;
-  uint32_t idCount;
-  if (!mObject->_class->enumerate(mObject, &ids, &idCount)) {
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  aProperties->SetCapacity(idCount);
-
-  for (uint32_t index = 0; index < idCount; index++) {
-    aProperties->AppendElement(FromNPIdentifier(ids[index]));
-  }
-
-  PluginModuleChild::sBrowserFuncs.memfree(ids);
-  *aSuccess = true;
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectChild::AnswerConstruct(
-    nsTArray<Variant>&& aArgs, Variant* aResult, bool* aSuccess) {
-  AssertPluginThread();
-  PluginInstanceChild::AutoStackHelper guard(mInstance);
-
-  if (mInvalidated) {
-    NS_WARNING("Calling AnswerConstruct with an invalidated object!");
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  if (!(mObject->_class && mObject->_class->construct)) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  AutoTArray<NPVariant, 10> convertedArgs;
-  uint32_t argCount = aArgs.Length();
-
-  if (!convertedArgs.SetLength(argCount, mozilla::fallible)) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  for (uint32_t index = 0; index < argCount; index++) {
-    ConvertToVariant(aArgs[index], convertedArgs[index]);
-  }
-
-  NPVariant result;
-  VOID_TO_NPVARIANT(result);
-  bool success = mObject->_class->construct(mObject, convertedArgs.Elements(),
-                                            argCount, &result);
-
-  for (uint32_t index = 0; index < argCount; index++) {
-    PluginModuleChild::sBrowserFuncs.releasevariantvalue(&convertedArgs[index]);
-  }
-
-  if (!success) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  Variant convertedResult;
-  success =
-      ConvertToRemoteVariant(result, convertedResult, GetInstance(), false);
-
-  DeferNPVariantLastRelease(&PluginModuleChild::sBrowserFuncs, &result);
-
-  if (!success) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  *aResult = convertedResult;
-  *aSuccess = true;
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectChild::RecvProtect() {
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  Protect();
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectChild::RecvUnprotect() {
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  Unprotect();
-  return IPC_OK();
-}
-
-bool PluginScriptableObjectChild::Evaluate(NPString* aScript,
-                                           NPVariant* aResult) {
-  PluginInstanceChild::AutoStackHelper guard(mInstance);
-
-  nsDependentCString script("");
-  if (aScript->UTF8Characters && aScript->UTF8Length) {
-    script.Rebind(aScript->UTF8Characters, aScript->UTF8Length);
-  }
-
-  bool success;
-  Variant result;
-  CallNPN_Evaluate(script, &result, &success);
-
-  if (!success) {
-    return false;
-  }
-
-  ConvertToVariant(result, *aResult);
-  return true;
-}
-
-nsTHashtable<PluginScriptableObjectChild::NPObjectData>*
-    PluginScriptableObjectChild::sObjectMap;
-
-bool PluginScriptableObjectChild::RegisterActor(NPObject* aObject) {
-  AssertPluginThread();
-  MOZ_ASSERT(aObject, "Null pointer!");
-
-  NPObjectData* d = sObjectMap->GetEntry(aObject);
-  if (!d) {
-    NS_ERROR("NPObject not in object table");
-    return false;
-  }
-
-  d->actor = this;
-  return true;
-}
-
-void PluginScriptableObjectChild::UnregisterActor(NPObject* aObject) {
-  AssertPluginThread();
-  MOZ_ASSERT(aObject, "Null pointer!");
-
-  NPObjectData* d = sObjectMap->GetEntry(aObject);
-  MOZ_ASSERT(d, "NPObject not in object table");
-  if (d) {
-    d->actor = nullptr;
-  }
-}
-
-/* static */
-PluginScriptableObjectChild* PluginScriptableObjectChild::GetActorForNPObject(
-    NPObject* aObject) {
-  AssertPluginThread();
-  MOZ_ASSERT(aObject, "Null pointer!");
-
-  NPObjectData* d = sObjectMap->GetEntry(aObject);
-  if (!d) {
-    NS_ERROR("Plugin using object not created with NPN_CreateObject?");
-    return nullptr;
-  }
-
-  return d->actor;
-}
-
-/* static */
-void PluginScriptableObjectChild::RegisterObject(
-    NPObject* aObject, PluginInstanceChild* aInstance) {
-  AssertPluginThread();
-
-  if (!sObjectMap) {
-    sObjectMap = new nsTHashtable<PluginScriptableObjectChild::NPObjectData>();
-  }
-
-  NPObjectData* d = sObjectMap->PutEntry(aObject);
-  MOZ_ASSERT(!d->instance, "New NPObject already mapped?");
-  d->instance = aInstance;
-}
-
-/* static */
-void PluginScriptableObjectChild::UnregisterObject(NPObject* aObject) {
-  AssertPluginThread();
-
-  sObjectMap->RemoveEntry(aObject);
-
-  if (!sObjectMap->Count()) {
-    delete sObjectMap;
-    sObjectMap = nullptr;
-  }
-}
-
-/* static */
-PluginInstanceChild* PluginScriptableObjectChild::GetInstanceForNPObject(
-    NPObject* aObject) {
-  AssertPluginThread();
-  if (!sObjectMap) {
-    // All PluginInstanceChilds have been destroyed
-    return nullptr;
-  }
-
-  NPObjectData* d = sObjectMap->GetEntry(aObject);
-  if (!d) {
-    return nullptr;
-  }
-  return d->instance;
-}
-
-/* static */
-void PluginScriptableObjectChild::NotifyOfInstanceShutdown(
-    PluginInstanceChild* aInstance) {
-  AssertPluginThread();
-  if (!sObjectMap) {
-    return;
-  }
-
-  for (auto iter = sObjectMap->Iter(); !iter.Done(); iter.Next()) {
-    NPObjectData* d = iter.Get();
-    if (d->instance == aInstance) {
-      NPObject* o = d->GetKey();
-      aInstance->mDeletingHash->PutEntry(o);
-    }
-  }
-}
diff --git a/dom/plugins/ipc/PluginScriptableObjectChild.h b/dom/plugins/ipc/PluginScriptableObjectChild.h
deleted file mode 100644
index 793d4c7549d06..0000000000000
--- a/dom/plugins/ipc/PluginScriptableObjectChild.h
+++ /dev/null
@@ -1,275 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=2 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef dom_plugins_PluginScriptableObjectChild_h
-#define dom_plugins_PluginScriptableObjectChild_h 1
-
-#include "mozilla/plugins/PPluginScriptableObjectChild.h"
-#include "mozilla/plugins/PluginMessageUtils.h"
-#include "mozilla/plugins/PluginTypes.h"
-
-#include "npruntime.h"
-#include "nsTHashMap.h"
-
-namespace mozilla {
-namespace plugins {
-
-class PluginInstanceChild;
-class PluginScriptableObjectChild;
-
-struct ChildNPObject : NPObject {
-  ChildNPObject() : NPObject(), parent(nullptr), invalidated(false) {
-    MOZ_COUNT_CTOR(ChildNPObject);
-  }
-
-  MOZ_COUNTED_DTOR(ChildNPObject)
-
-  // |parent| is always valid as long as the actor is alive. Once the actor is
-  // destroyed this will be set to null.
-  PluginScriptableObjectChild* parent;
-  bool invalidated;
-};
-
-class PluginScriptableObjectChild : public PPluginScriptableObjectChild {
-  friend class PluginInstanceChild;
-
- public:
-  explicit PluginScriptableObjectChild(ScriptableObjectType aType);
-  virtual ~PluginScriptableObjectChild();
-
-  bool InitializeProxy();
-
-  void InitializeLocal(NPObject* aObject);
-
-  mozilla::ipc::IPCResult AnswerInvalidate();
-
-  mozilla::ipc::IPCResult AnswerHasMethod(const PluginIdentifier& aId,
-                                          bool* aHasMethod);
-
-  mozilla::ipc::IPCResult AnswerInvoke(const PluginIdentifier& aId,
-                                       nsTArray<Variant>&& aArgs,
-                                       Variant* aResult, bool* aSuccess);
-
-  mozilla::ipc::IPCResult AnswerInvokeDefault(nsTArray<Variant>&& aArgs,
-                                              Variant* aResult, bool* aSuccess);
-
-  mozilla::ipc::IPCResult AnswerHasProperty(const PluginIdentifier& aId,
-                                            bool* aHasProperty);
-
-  mozilla::ipc::IPCResult AnswerGetChildProperty(const PluginIdentifier& aId,
-                                                 bool* aHasProperty,
-                                                 bool* aHasMethod,
-                                                 Variant* aResult,
-                                                 bool* aSuccess);
-
-  mozilla::ipc::IPCResult AnswerSetProperty(const PluginIdentifier& aId,
-                                            const Variant& aValue,
-                                            bool* aSuccess);
-
-  mozilla::ipc::IPCResult AnswerRemoveProperty(const PluginIdentifier& aId,
-                                               bool* aSuccess);
-
-  mozilla::ipc::IPCResult AnswerEnumerate(
-      nsTArray<PluginIdentifier>* aProperties, bool* aSuccess);
-
-  mozilla::ipc::IPCResult AnswerConstruct(nsTArray<Variant>&& aArgs,
-                                          Variant* aResult, bool* aSuccess);
-
-  mozilla::ipc::IPCResult RecvProtect();
-
-  mozilla::ipc::IPCResult RecvUnprotect();
-
-  NPObject* GetObject(bool aCanResurrect);
-
-  static const NPClass* GetClass() { return &sNPClass; }
-
-  PluginInstanceChild* GetInstance() const { return mInstance; }
-
-  // Protect only affects LocalObject actors. It is called by the
-  // ProtectedVariant/Actor helper classes before the actor is used as an
-  // argument to an IPC call and when the parent process resurrects a
-  // proxy object to the NPObject associated with this actor.
-  void Protect();
-
-  // Unprotect only affects LocalObject actors. It is called by the
-  // ProtectedVariant/Actor helper classes after the actor is used as an
-  // argument to an IPC call and when the parent process is no longer using
-  // this actor.
-  void Unprotect();
-
-  // DropNPObject is only used for Proxy actors and is called when the child
-  // process is no longer using the NPObject associated with this actor. The
-  // parent process may subsequently use this actor again in which case a new
-  // NPObject will be created and associated with this actor (see
-  // ResurrectProxyObject).
-  void DropNPObject();
-
-  /**
-   * After NPP_Destroy, all NPObjects associated with an instance are
-   * destroyed. We are informed of this destruction. This should only be called
-   * on Local actors.
-   */
-  void NPObjectDestroyed();
-
-  bool Evaluate(NPString* aScript, NPVariant* aResult);
-
-  ScriptableObjectType Type() const { return mType; }
-
- private:
-  struct StoredIdentifier {
-    nsCString mIdentifier;
-    nsAutoRefCnt mRefCnt;
-    bool mPermanent;
-
-    nsrefcnt AddRef() {
-      ++mRefCnt;
-      return mRefCnt;
-    }
-
-    nsrefcnt Release() {
-      --mRefCnt;
-      if (mRefCnt == 0) {
-        delete this;
-        return 0;
-      }
-      return mRefCnt;
-    }
-
-    explicit StoredIdentifier(const nsCString& aIdentifier)
-        : mIdentifier(aIdentifier), mRefCnt(), mPermanent(false) {
-      MOZ_COUNT_CTOR(StoredIdentifier);
-    }
-
-    MOZ_COUNTED_DTOR(StoredIdentifier)
-  };
-
- public:
-  class MOZ_STACK_CLASS StackIdentifier {
-   public:
-    explicit StackIdentifier(const PluginIdentifier& aIdentifier);
-    explicit StackIdentifier(NPIdentifier aIdentifier);
-    ~StackIdentifier();
-
-    void MakePermanent() {
-      if (mStored) {
-        mStored->mPermanent = true;
-      }
-    }
-    NPIdentifier ToNPIdentifier() const;
-
-    bool IsString() const {
-      return mIdentifier.type() == PluginIdentifier::TnsCString;
-    }
-    const nsCString& GetString() const { return mIdentifier.get_nsCString(); }
-
-    int32_t GetInt() const { return mIdentifier.get_int32_t(); }
-
-    PluginIdentifier GetIdentifier() const { return mIdentifier; }
-
-   private:
-    DISALLOW_COPY_AND_ASSIGN(StackIdentifier);
-
-    PluginIdentifier mIdentifier;
-    RefPtr<StoredIdentifier> mStored;
-  };
-
-  static void ClearIdentifiers();
-
-  bool RegisterActor(NPObject* aObject);
-  void UnregisterActor(NPObject* aObject);
-
-  static PluginScriptableObjectChild* GetActorForNPObject(NPObject* aObject);
-
-  static void RegisterObject(NPObject* aObject, PluginInstanceChild* aInstance);
-  static void UnregisterObject(NPObject* aObject);
-
-  static PluginInstanceChild* GetInstanceForNPObject(NPObject* aObject);
-
-  /**
-   * Fill PluginInstanceChild.mDeletingHash with all the remaining NPObjects
-   * associated with that instance.
-   */
-  static void NotifyOfInstanceShutdown(PluginInstanceChild* aInstance);
-
- private:
-  static NPObject* ScriptableAllocate(NPP aInstance, NPClass* aClass);
-
-  static void ScriptableInvalidate(NPObject* aObject);
-
-  static void ScriptableDeallocate(NPObject* aObject);
-
-  static bool ScriptableHasMethod(NPObject* aObject, NPIdentifier aName);
-
-  static bool ScriptableInvoke(NPObject* aObject, NPIdentifier aName,
-                               const NPVariant* aArgs, uint32_t aArgCount,
-                               NPVariant* aResult);
-
-  static bool ScriptableInvokeDefault(NPObject* aObject, const NPVariant* aArgs,
-                                      uint32_t aArgCount, NPVariant* aResult);
-
-  static bool ScriptableHasProperty(NPObject* aObject, NPIdentifier aName);
-
-  static bool ScriptableGetProperty(NPObject* aObject, NPIdentifier aName,
-                                    NPVariant* aResult);
-
-  static bool ScriptableSetProperty(NPObject* aObject, NPIdentifier aName,
-                                    const NPVariant* aValue);
-
-  static bool ScriptableRemoveProperty(NPObject* aObject, NPIdentifier aName);
-
-  static bool ScriptableEnumerate(NPObject* aObject,
-                                  NPIdentifier** aIdentifiers,
-                                  uint32_t* aCount);
-
-  static bool ScriptableConstruct(NPObject* aObject, const NPVariant* aArgs,
-                                  uint32_t aArgCount, NPVariant* aResult);
-
-  NPObject* CreateProxyObject();
-
-  // ResurrectProxyObject is only used with Proxy actors. It is called when the
-  // parent process uses an actor whose NPObject was deleted by the child
-  // process.
-  bool ResurrectProxyObject();
-
- private:
-  PluginInstanceChild* mInstance;
-  NPObject* mObject;
-  bool mInvalidated;
-  int mProtectCount;
-
-  ScriptableObjectType mType;
-
-  static const NPClass sNPClass;
-
-  static StoredIdentifier* HashIdentifier(const nsCString& aIdentifier);
-  static void UnhashIdentifier(StoredIdentifier* aIdentifier);
-
-  typedef nsTHashMap<nsCString, RefPtr<StoredIdentifier>> IdentifierTable;
-  static IdentifierTable sIdentifiers;
-
-  struct NPObjectData : public nsPtrHashKey<NPObject> {
-    explicit NPObjectData(const NPObject* key)
-        : nsPtrHashKey<NPObject>(key), instance(nullptr), actor(nullptr) {}
-
-    // never nullptr
-    PluginInstanceChild* instance;
-
-    // sometimes nullptr (no actor associated with an NPObject)
-    PluginScriptableObjectChild* actor;
-  };
-
-  /**
-   * mObjectMap contains all the currently active NPObjects (from
-   * NPN_CreateObject until the final release/dealloc, whether or not an actor
-   * is currently associated with the object.
-   */
-  static nsTHashtable<NPObjectData>* sObjectMap;
-};
-
-} /* namespace plugins */
-} /* namespace mozilla */
-
-#endif /* dom_plugins_PluginScriptableObjectChild_h */
diff --git a/dom/plugins/ipc/PluginScriptableObjectParent.cpp b/dom/plugins/ipc/PluginScriptableObjectParent.cpp
deleted file mode 100644
index d12474c999e50..0000000000000
--- a/dom/plugins/ipc/PluginScriptableObjectParent.cpp
+++ /dev/null
@@ -1,1289 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=2 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "PluginScriptableObjectParent.h"
-
-#include "jsapi.h"
-#include "mozilla/DebugOnly.h"
-#include "mozilla/dom/ScriptSettings.h"
-#include "mozilla/plugins/PluginTypes.h"
-#include "mozilla/Unused.h"
-#include "nsNPAPIPlugin.h"
-#include "PluginScriptableObjectUtils.h"
-
-using namespace mozilla;
-using namespace mozilla::plugins;
-using namespace mozilla::plugins::parent;
-
-/**
- * NPIdentifiers in the chrome process are stored as jsids. The difficulty is in
- * ensuring that string identifiers are rooted without pinning them all. We
- * assume that all NPIdentifiers passed into nsJSNPRuntime will not be used
- * outside the scope of the NPAPI call (i.e., they won't be stored in the
- * heap). Rooting is done using the StackIdentifier class, which roots the
- * identifier via RootedId.
- *
- * This system does not allow jsids to be moved, as would be needed for
- * generational or compacting GC. When Firefox implements a moving GC for
- * strings, we will need to ensure that no movement happens while NPAPI code is
- * on the stack: although StackIdentifier roots all identifiers used, the GC has
- * no way to know that a jsid cast to an NPIdentifier needs to be fixed up if it
- * is moved.
- */
-
-class MOZ_STACK_CLASS StackIdentifier {
- public:
-  explicit StackIdentifier(const PluginIdentifier& aIdentifier,
-                           bool aAtomizeAndPin = false);
-
-  bool Failed() const { return mFailed; }
-  NPIdentifier ToNPIdentifier() const { return mIdentifier; }
-
- private:
-  bool mFailed;
-  NPIdentifier mIdentifier;
-  AutoSafeJSContext mCx;
-  JS::RootedId mId;
-};
-
-StackIdentifier::StackIdentifier(const PluginIdentifier& aIdentifier,
-                                 bool aAtomizeAndPin)
-    : mFailed(false), mId(mCx) {
-  if (aIdentifier.type() == PluginIdentifier::TnsCString) {
-    // We don't call _getstringidentifier because we may not want to intern the
-    // string.
-    NS_ConvertUTF8toUTF16 utf16name(aIdentifier.get_nsCString());
-    JS::RootedString str(
-        mCx, JS_NewUCStringCopyN(mCx, utf16name.get(), utf16name.Length()));
-    if (!str) {
-      NS_ERROR("Id can't be allocated");
-      mFailed = true;
-      return;
-    }
-    if (aAtomizeAndPin) {
-      str = JS_AtomizeAndPinJSString(mCx, str);
-      if (!str) {
-        NS_ERROR("Id can't be allocated");
-        mFailed = true;
-        return;
-      }
-    }
-    if (!JS_StringToId(mCx, str, &mId)) {
-      NS_ERROR("Id can't be allocated");
-      mFailed = true;
-      return;
-    }
-    mIdentifier = JSIdToNPIdentifier(mId);
-    return;
-  }
-
-  mIdentifier =
-      mozilla::plugins::parent::_getintidentifier(aIdentifier.get_int32_t());
-}
-
-static bool FromNPIdentifier(NPIdentifier aIdentifier,
-                             PluginIdentifier* aResult) {
-  if (mozilla::plugins::parent::_identifierisstring(aIdentifier)) {
-    nsCString string;
-    NPUTF8* chars = mozilla::plugins::parent::_utf8fromidentifier(aIdentifier);
-    if (!chars) {
-      return false;
-    }
-    string.Adopt(chars);
-    *aResult = PluginIdentifier(string);
-    return true;
-  } else {
-    int32_t intval = mozilla::plugins::parent::_intfromidentifier(aIdentifier);
-    *aResult = PluginIdentifier(intval);
-    return true;
-  }
-}
-
-namespace {
-
-inline void ReleaseVariant(NPVariant& aVariant,
-                           PluginInstanceParent* aInstance) {
-  const NPNetscapeFuncs* npn = GetNetscapeFuncs(aInstance);
-  if (npn) {
-    npn->releasevariantvalue(&aVariant);
-  }
-}
-
-}  // namespace
-
-// static
-NPObject* PluginScriptableObjectParent::ScriptableAllocate(NPP aInstance,
-                                                           NPClass* aClass) {
-  if (aClass != GetClass()) {
-    NS_ERROR("Huh?! Wrong class!");
-    return nullptr;
-  }
-
-  return new ParentNPObject();
-}
-
-// static
-void PluginScriptableObjectParent::ScriptableInvalidate(NPObject* aObject) {
-  if (aObject->_class != GetClass()) {
-    NS_ERROR("Don't know what kind of object this is!");
-    return;
-  }
-
-  ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
-  if (object->invalidated) {
-    // This can happen more than once, and is just fine.
-    return;
-  }
-
-  object->invalidated = true;
-
-  // |object->parent| may be null already if the instance has gone away.
-  if (object->parent && !object->parent->CallInvalidate()) {
-    NS_ERROR("Failed to send message!");
-  }
-}
-
-// static
-void PluginScriptableObjectParent::ScriptableDeallocate(NPObject* aObject) {
-  if (aObject->_class != GetClass()) {
-    NS_ERROR("Don't know what kind of object this is!");
-    return;
-  }
-
-  ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
-
-  if (object->asyncWrapperCount > 0) {
-    // In this case we should just drop the refcount to the asyncWrapperCount
-    // instead of deallocating because there are still some async wrappers
-    // out there that are referencing this object.
-    object->referenceCount = object->asyncWrapperCount;
-    return;
-  }
-
-  PluginScriptableObjectParent* actor = object->parent;
-  if (actor) {
-    NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
-    actor->DropNPObject();
-  }
-
-  delete object;
-}
-
-// static
-bool PluginScriptableObjectParent::ScriptableHasMethod(NPObject* aObject,
-                                                       NPIdentifier aName) {
-  if (aObject->_class != GetClass()) {
-    NS_ERROR("Don't know what kind of object this is!");
-    return false;
-  }
-
-  ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
-  if (object->invalidated) {
-    NS_WARNING("Calling method on an invalidated object!");
-    return false;
-  }
-
-  ProtectedActor<PluginScriptableObjectParent> actor(object->parent);
-  if (!actor) {
-    return false;
-  }
-
-  PluginIdentifier identifier;
-  if (!FromNPIdentifier(aName, &identifier)) {
-    return false;
-  }
-
-  NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
-
-  bool result;
-  if (!actor->CallHasMethod(identifier, &result)) {
-    NS_WARNING("Failed to send message!");
-    return false;
-  }
-
-  return result;
-}
-
-// static
-bool PluginScriptableObjectParent::ScriptableInvoke(NPObject* aObject,
-                                                    NPIdentifier aName,
-                                                    const NPVariant* aArgs,
-                                                    uint32_t aArgCount,
-                                                    NPVariant* aResult) {
-  if (aObject->_class != GetClass()) {
-    NS_ERROR("Don't know what kind of object this is!");
-    return false;
-  }
-
-  ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
-  if (object->invalidated) {
-    NS_WARNING("Calling method on an invalidated object!");
-    return false;
-  }
-
-  ProtectedActor<PluginScriptableObjectParent> actor(object->parent);
-  if (!actor) {
-    return false;
-  }
-
-  PluginIdentifier identifier;
-  if (!FromNPIdentifier(aName, &identifier)) {
-    return false;
-  }
-
-  NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
-
-  ProtectedVariantArray args(aArgs, aArgCount, actor->GetInstance());
-  if (!args.IsOk()) {
-    NS_ERROR("Failed to convert arguments!");
-    return false;
-  }
-
-  Variant remoteResult;
-  bool success;
-  if (!actor->CallInvoke(identifier, args, &remoteResult, &success)) {
-    NS_WARNING("Failed to send message!");
-    return false;
-  }
-
-  if (!success) {
-    return false;
-  }
-
-  if (!ConvertToVariant(remoteResult, *aResult, actor->GetInstance())) {
-    NS_WARNING("Failed to convert result!");
-    return false;
-  }
-  return true;
-}
-
-// static
-bool PluginScriptableObjectParent::ScriptableInvokeDefault(
-    NPObject* aObject, const NPVariant* aArgs, uint32_t aArgCount,
-    NPVariant* aResult) {
-  if (aObject->_class != GetClass()) {
-    NS_ERROR("Don't know what kind of object this is!");
-    return false;
-  }
-
-  ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
-  if (object->invalidated) {
-    NS_WARNING("Calling method on an invalidated object!");
-    return false;
-  }
-
-  ProtectedActor<PluginScriptableObjectParent> actor(object->parent);
-  if (!actor) {
-    return false;
-  }
-
-  NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
-
-  ProtectedVariantArray args(aArgs, aArgCount, actor->GetInstance());
-  if (!args.IsOk()) {
-    NS_ERROR("Failed to convert arguments!");
-    return false;
-  }
-
-  Variant remoteResult;
-  bool success;
-  if (!actor->CallInvokeDefault(args, &remoteResult, &success)) {
-    NS_WARNING("Failed to send message!");
-    return false;
-  }
-
-  if (!success) {
-    return false;
-  }
-
-  if (!ConvertToVariant(remoteResult, *aResult, actor->GetInstance())) {
-    NS_WARNING("Failed to convert result!");
-    return false;
-  }
-  return true;
-}
-
-// static
-bool PluginScriptableObjectParent::ScriptableHasProperty(NPObject* aObject,
-                                                         NPIdentifier aName) {
-  if (aObject->_class != GetClass()) {
-    NS_ERROR("Don't know what kind of object this is!");
-    return false;
-  }
-
-  ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
-  if (object->invalidated) {
-    NS_WARNING("Calling method on an invalidated object!");
-    return false;
-  }
-
-  ProtectedActor<PluginScriptableObjectParent> actor(object->parent);
-  if (!actor) {
-    return false;
-  }
-
-  PluginIdentifier identifier;
-  if (!FromNPIdentifier(aName, &identifier)) {
-    return false;
-  }
-
-  NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
-
-  bool result;
-  if (!actor->CallHasProperty(identifier, &result)) {
-    NS_WARNING("Failed to send message!");
-    return false;
-  }
-
-  return result;
-}
-
-// static
-bool PluginScriptableObjectParent::ScriptableGetProperty(NPObject* aObject,
-                                                         NPIdentifier aName,
-                                                         NPVariant* aResult) {
-  // See GetPropertyHelper below.
-  MOZ_ASSERT_UNREACHABLE("Shouldn't ever call this directly!");
-  return false;
-}
-
-// static
-bool PluginScriptableObjectParent::ScriptableSetProperty(
-    NPObject* aObject, NPIdentifier aName, const NPVariant* aValue) {
-  if (aObject->_class != GetClass()) {
-    NS_ERROR("Don't know what kind of object this is!");
-    return false;
-  }
-
-  ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
-  if (object->invalidated) {
-    NS_WARNING("Calling method on an invalidated object!");
-    return false;
-  }
-
-  ProtectedActor<PluginScriptableObjectParent> actor(object->parent);
-  if (!actor) {
-    return false;
-  }
-
-  PluginIdentifier identifier;
-  if (!FromNPIdentifier(aName, &identifier)) {
-    return false;
-  }
-
-  NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
-
-  ProtectedVariant value(*aValue, actor->GetInstance());
-  if (!value.IsOk()) {
-    NS_WARNING("Failed to convert variant!");
-    return false;
-  }
-
-  bool success;
-  if (!actor->CallSetProperty(identifier, value, &success)) {
-    NS_WARNING("Failed to send message!");
-    return false;
-  }
-
-  return success;
-}
-
-// static
-bool PluginScriptableObjectParent::ScriptableRemoveProperty(
-    NPObject* aObject, NPIdentifier aName) {
-  if (aObject->_class != GetClass()) {
-    NS_ERROR("Don't know what kind of object this is!");
-    return false;
-  }
-
-  ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
-  if (object->invalidated) {
-    NS_WARNING("Calling method on an invalidated object!");
-    return false;
-  }
-
-  ProtectedActor<PluginScriptableObjectParent> actor(object->parent);
-  if (!actor) {
-    return false;
-  }
-
-  PluginIdentifier identifier;
-  if (!FromNPIdentifier(aName, &identifier)) {
-    return false;
-  }
-
-  NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
-
-  bool success;
-  if (!actor->CallRemoveProperty(identifier, &success)) {
-    NS_WARNING("Failed to send message!");
-    return false;
-  }
-
-  return success;
-}
-
-// static
-bool PluginScriptableObjectParent::ScriptableEnumerate(
-    NPObject* aObject, NPIdentifier** aIdentifiers, uint32_t* aCount) {
-  if (aObject->_class != GetClass()) {
-    NS_ERROR("Don't know what kind of object this is!");
-    return false;
-  }
-
-  ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
-  if (object->invalidated) {
-    NS_WARNING("Calling method on an invalidated object!");
-    return false;
-  }
-
-  ProtectedActor<PluginScriptableObjectParent> actor(object->parent);
-  if (!actor) {
-    return false;
-  }
-
-  NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
-
-  const NPNetscapeFuncs* npn = GetNetscapeFuncs(aObject);
-  if (!npn) {
-    NS_ERROR("No netscape funcs!");
-    return false;
-  }
-
-  AutoTArray<PluginIdentifier, 10> identifiers;
-  bool success;
-  if (!actor->CallEnumerate(&identifiers, &success)) {
-    NS_WARNING("Failed to send message!");
-    return false;
-  }
-
-  if (!success) {
-    return false;
-  }
-
-  *aCount = identifiers.Length();
-  if (!*aCount) {
-    *aIdentifiers = nullptr;
-    return true;
-  }
-
-  *aIdentifiers = (NPIdentifier*)npn->memalloc(*aCount * sizeof(NPIdentifier));
-  if (!*aIdentifiers) {
-    NS_ERROR("Out of memory!");
-    return false;
-  }
-
-  for (uint32_t index = 0; index < *aCount; index++) {
-    // We pin the ID to avoid a GC hazard here. This could probably be fixed
-    // if the interface with nsJSNPRuntime were smarter.
-    StackIdentifier stackID(identifiers[index], true /* aAtomizeAndPin */);
-    if (stackID.Failed()) {
-      return false;
-    }
-    (*aIdentifiers)[index] = stackID.ToNPIdentifier();
-  }
-  return true;
-}
-
-// static
-bool PluginScriptableObjectParent::ScriptableConstruct(NPObject* aObject,
-                                                       const NPVariant* aArgs,
-                                                       uint32_t aArgCount,
-                                                       NPVariant* aResult) {
-  if (aObject->_class != GetClass()) {
-    NS_ERROR("Don't know what kind of object this is!");
-    return false;
-  }
-
-  ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
-  if (object->invalidated) {
-    NS_WARNING("Calling method on an invalidated object!");
-    return false;
-  }
-
-  ProtectedActor<PluginScriptableObjectParent> actor(object->parent);
-  if (!actor) {
-    return false;
-  }
-
-  NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
-
-  ProtectedVariantArray args(aArgs, aArgCount, actor->GetInstance());
-  if (!args.IsOk()) {
-    NS_ERROR("Failed to convert arguments!");
-    return false;
-  }
-
-  Variant remoteResult;
-  bool success;
-  if (!actor->CallConstruct(args, &remoteResult, &success)) {
-    NS_WARNING("Failed to send message!");
-    return false;
-  }
-
-  if (!success) {
-    return false;
-  }
-
-  if (!ConvertToVariant(remoteResult, *aResult, actor->GetInstance())) {
-    NS_WARNING("Failed to convert result!");
-    return false;
-  }
-  return true;
-}
-
-const NPClass PluginScriptableObjectParent::sNPClass = {
-    NP_CLASS_STRUCT_VERSION,
-    PluginScriptableObjectParent::ScriptableAllocate,
-    PluginScriptableObjectParent::ScriptableDeallocate,
-    PluginScriptableObjectParent::ScriptableInvalidate,
-    PluginScriptableObjectParent::ScriptableHasMethod,
-    PluginScriptableObjectParent::ScriptableInvoke,
-    PluginScriptableObjectParent::ScriptableInvokeDefault,
-    PluginScriptableObjectParent::ScriptableHasProperty,
-    PluginScriptableObjectParent::ScriptableGetProperty,
-    PluginScriptableObjectParent::ScriptableSetProperty,
-    PluginScriptableObjectParent::ScriptableRemoveProperty,
-    PluginScriptableObjectParent::ScriptableEnumerate,
-    PluginScriptableObjectParent::ScriptableConstruct};
-
-PluginScriptableObjectParent::PluginScriptableObjectParent(
-    ScriptableObjectType aType)
-    : mInstance(nullptr), mObject(nullptr), mProtectCount(0), mType(aType) {}
-
-PluginScriptableObjectParent::~PluginScriptableObjectParent() {
-  if (mObject) {
-    if (mObject->_class == GetClass()) {
-      NS_ASSERTION(mType == Proxy, "Wrong type!");
-      static_cast<ParentNPObject*>(mObject)->parent = nullptr;
-    } else {
-      NS_ASSERTION(mType == LocalObject, "Wrong type!");
-      GetInstance()->GetNPNIface()->releaseobject(mObject);
-    }
-  }
-}
-
-void PluginScriptableObjectParent::InitializeProxy() {
-  NS_ASSERTION(mType == Proxy, "Bad type!");
-  NS_ASSERTION(!mObject, "Calling Initialize more than once!");
-
-  mInstance = static_cast<PluginInstanceParent*>(Manager());
-  NS_ASSERTION(mInstance, "Null manager?!");
-
-  NPObject* object = CreateProxyObject();
-  NS_ASSERTION(object, "Failed to create object!");
-
-  if (!mInstance->RegisterNPObjectForActor(object, this)) {
-    NS_ERROR("Out of memory?");
-  }
-
-  mObject = object;
-}
-
-void PluginScriptableObjectParent::InitializeLocal(NPObject* aObject) {
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-  NS_ASSERTION(!(mInstance && mObject), "Calling Initialize more than once!");
-
-  mInstance = static_cast<PluginInstanceParent*>(Manager());
-  NS_ASSERTION(mInstance, "Null manager?!");
-
-  mInstance->GetNPNIface()->retainobject(aObject);
-
-  NS_ASSERTION(!mProtectCount, "Should be zero!");
-  mProtectCount++;
-
-  if (!mInstance->RegisterNPObjectForActor(aObject, this)) {
-    NS_ERROR("Out of memory?");
-  }
-
-  mObject = aObject;
-}
-
-NPObject* PluginScriptableObjectParent::CreateProxyObject() {
-  NS_ASSERTION(mInstance, "Must have an instance!");
-  NS_ASSERTION(mType == Proxy, "Shouldn't call this for non-proxy object!");
-
-  const NPNetscapeFuncs* npn = GetNetscapeFuncs(mInstance);
-
-  NPObject* npobject =
-      npn->createobject(mInstance->GetNPP(), const_cast<NPClass*>(GetClass()));
-  NS_ASSERTION(npobject, "Failed to create object?!");
-  NS_ASSERTION(npobject->_class == GetClass(), "Wrong kind of object!");
-  NS_ASSERTION(npobject->referenceCount == 1, "Some kind of live object!");
-
-  ParentNPObject* object = static_cast<ParentNPObject*>(npobject);
-  NS_ASSERTION(!object->invalidated, "Bad object!");
-  NS_ASSERTION(!object->parent, "Bad object!");
-
-  // We don't want to have the actor own this object but rather let the object
-  // own this actor. Set the reference count to 0 here so that when the object
-  // dies we will send the destructor message to the child.
-  object->referenceCount = 0;
-  NS_LOG_RELEASE(object, 0, "BrowserNPObject");
-
-  object->parent = const_cast<PluginScriptableObjectParent*>(this);
-  return object;
-}
-
-bool PluginScriptableObjectParent::ResurrectProxyObject() {
-  NS_ASSERTION(mInstance, "Must have an instance already!");
-  NS_ASSERTION(!mObject, "Should not have an object already!");
-  NS_ASSERTION(mType == Proxy, "Shouldn't call this for non-proxy object!");
-
-  InitializeProxy();
-  NS_ASSERTION(mObject, "Initialize failed!");
-
-  if (!SendProtect()) {
-    NS_WARNING("Failed to send message!");
-    return false;
-  }
-
-  return true;
-}
-
-NPObject* PluginScriptableObjectParent::GetObject(bool aCanResurrect) {
-  if (!mObject && aCanResurrect && !ResurrectProxyObject()) {
-    NS_ERROR("Null object!");
-    return nullptr;
-  }
-  return mObject;
-}
-
-void PluginScriptableObjectParent::Protect() {
-  NS_ASSERTION(mObject, "No object!");
-  NS_ASSERTION(mProtectCount >= 0, "Negative protect count?!");
-
-  if (mType == LocalObject) {
-    ++mProtectCount;
-  }
-}
-
-void PluginScriptableObjectParent::Unprotect() {
-  NS_ASSERTION(mObject, "No object!");
-  NS_ASSERTION(mProtectCount >= 0, "Negative protect count?!");
-
-  if (mType == LocalObject) {
-    if (--mProtectCount == 0) {
-      Unused << PluginScriptableObjectParent::Send__delete__(this);
-    }
-  }
-}
-
-void PluginScriptableObjectParent::DropNPObject() {
-  NS_ASSERTION(mObject, "Invalidated object!");
-  NS_ASSERTION(mObject->_class == GetClass(), "Wrong type of object!");
-  NS_ASSERTION(mType == Proxy, "Shouldn't call this for non-proxy object!");
-
-  // We think we're about to be deleted, but we could be racing with the other
-  // process.
-  PluginInstanceParent* instance = GetInstance();
-  NS_ASSERTION(instance, "Must have an instance!");
-
-  instance->UnregisterNPObject(mObject);
-  mObject = nullptr;
-
-  Unused << SendUnprotect();
-}
-
-void PluginScriptableObjectParent::ActorDestroy(ActorDestroyReason aWhy) {
-  // Implement me! Bug 1005163
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectParent::AnswerHasMethod(
-    const PluginIdentifier& aId, bool* aHasMethod) {
-  if (!mObject) {
-    NS_WARNING("Calling AnswerHasMethod with an invalidated object!");
-    *aHasMethod = false;
-    return IPC_OK();
-  }
-
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  PluginInstanceParent* instance = GetInstance();
-  if (!instance) {
-    NS_ERROR("No instance?!");
-    *aHasMethod = false;
-    return IPC_OK();
-  }
-
-  const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
-  if (!npn) {
-    NS_ERROR("No netscape funcs?!");
-    *aHasMethod = false;
-    return IPC_OK();
-  }
-
-  StackIdentifier stackID(aId);
-  if (stackID.Failed()) {
-    *aHasMethod = false;
-    return IPC_OK();
-  }
-  *aHasMethod =
-      npn->hasmethod(instance->GetNPP(), mObject, stackID.ToNPIdentifier());
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectParent::AnswerInvoke(
-    const PluginIdentifier& aId, nsTArray<Variant>&& aArgs, Variant* aResult,
-    bool* aSuccess) {
-  if (!mObject) {
-    NS_WARNING("Calling AnswerInvoke with an invalidated object!");
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  PluginInstanceParent* instance = GetInstance();
-  if (!instance) {
-    NS_ERROR("No instance?!");
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
-  if (!npn) {
-    NS_ERROR("No netscape funcs?!");
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  StackIdentifier stackID(aId);
-  if (stackID.Failed()) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  AutoTArray<NPVariant, 10> convertedArgs;
-  uint32_t argCount = aArgs.Length();
-
-  if (!convertedArgs.SetLength(argCount, fallible)) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  for (uint32_t index = 0; index < argCount; index++) {
-    if (!ConvertToVariant(aArgs[index], convertedArgs[index], instance)) {
-      // Don't leak things we've already converted!
-      while (index-- > 0) {
-        ReleaseVariant(convertedArgs[index], instance);
-      }
-      *aResult = void_t();
-      *aSuccess = false;
-      return IPC_OK();
-    }
-  }
-
-  NPVariant result;
-  bool success =
-      npn->invoke(instance->GetNPP(), mObject, stackID.ToNPIdentifier(),
-                  convertedArgs.Elements(), argCount, &result);
-
-  for (uint32_t index = 0; index < argCount; index++) {
-    ReleaseVariant(convertedArgs[index], instance);
-  }
-
-  if (!success) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  Variant convertedResult;
-  success = ConvertToRemoteVariant(result, convertedResult, GetInstance());
-
-  DeferNPVariantLastRelease(npn, &result);
-
-  if (!success) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  *aResult = convertedResult;
-  *aSuccess = true;
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectParent::AnswerInvokeDefault(
-    nsTArray<Variant>&& aArgs, Variant* aResult, bool* aSuccess) {
-  if (!mObject) {
-    NS_WARNING("Calling AnswerInvoke with an invalidated object!");
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  PluginInstanceParent* instance = GetInstance();
-  if (!instance) {
-    NS_ERROR("No instance?!");
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
-  if (!npn) {
-    NS_ERROR("No netscape funcs?!");
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  AutoTArray<NPVariant, 10> convertedArgs;
-  uint32_t argCount = aArgs.Length();
-
-  if (!convertedArgs.SetLength(argCount, fallible)) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  for (uint32_t index = 0; index < argCount; index++) {
-    if (!ConvertToVariant(aArgs[index], convertedArgs[index], instance)) {
-      // Don't leak things we've already converted!
-      while (index-- > 0) {
-        ReleaseVariant(convertedArgs[index], instance);
-      }
-      *aResult = void_t();
-      *aSuccess = false;
-      return IPC_OK();
-    }
-  }
-
-  NPVariant result;
-  bool success = npn->invokeDefault(
-      instance->GetNPP(), mObject, convertedArgs.Elements(), argCount, &result);
-
-  for (uint32_t index = 0; index < argCount; index++) {
-    ReleaseVariant(convertedArgs[index], instance);
-  }
-
-  if (!success) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  Variant convertedResult;
-  success = ConvertToRemoteVariant(result, convertedResult, GetInstance());
-
-  DeferNPVariantLastRelease(npn, &result);
-
-  if (!success) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  *aResult = convertedResult;
-  *aSuccess = true;
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectParent::AnswerHasProperty(
-    const PluginIdentifier& aId, bool* aHasProperty) {
-  if (!mObject) {
-    NS_WARNING("Calling AnswerHasProperty with an invalidated object!");
-    *aHasProperty = false;
-    return IPC_OK();
-  }
-
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  PluginInstanceParent* instance = GetInstance();
-  if (!instance) {
-    NS_ERROR("No instance?!");
-    *aHasProperty = false;
-    return IPC_OK();
-  }
-
-  const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
-  if (!npn) {
-    NS_ERROR("No netscape funcs?!");
-    *aHasProperty = false;
-    return IPC_OK();
-  }
-
-  StackIdentifier stackID(aId);
-  if (stackID.Failed()) {
-    *aHasProperty = false;
-    return IPC_OK();
-  }
-
-  *aHasProperty =
-      npn->hasproperty(instance->GetNPP(), mObject, stackID.ToNPIdentifier());
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectParent::AnswerGetParentProperty(
-    const PluginIdentifier& aId, Variant* aResult, bool* aSuccess) {
-  if (!mObject) {
-    NS_WARNING("Calling AnswerGetProperty with an invalidated object!");
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  PluginInstanceParent* instance = GetInstance();
-  if (!instance) {
-    NS_ERROR("No instance?!");
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
-  if (!npn) {
-    NS_ERROR("No netscape funcs?!");
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  StackIdentifier stackID(aId);
-  if (stackID.Failed()) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  NPVariant result;
-  if (!npn->getproperty(instance->GetNPP(), mObject, stackID.ToNPIdentifier(),
-                        &result)) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  Variant converted;
-  if ((*aSuccess = ConvertToRemoteVariant(result, converted, instance))) {
-    DeferNPVariantLastRelease(npn, &result);
-    *aResult = converted;
-  } else {
-    *aResult = void_t();
-  }
-
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectParent::AnswerSetProperty(
-    const PluginIdentifier& aId, const Variant& aValue, bool* aSuccess) {
-  if (!mObject) {
-    NS_WARNING("Calling AnswerSetProperty with an invalidated object!");
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  PluginInstanceParent* instance = GetInstance();
-  if (!instance) {
-    NS_ERROR("No instance?!");
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
-  if (!npn) {
-    NS_ERROR("No netscape funcs?!");
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  NPVariant converted;
-  if (!ConvertToVariant(aValue, converted, instance)) {
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  StackIdentifier stackID(aId);
-  if (stackID.Failed()) {
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  if ((*aSuccess = npn->setproperty(instance->GetNPP(), mObject,
-                                    stackID.ToNPIdentifier(), &converted))) {
-    ReleaseVariant(converted, instance);
-  }
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectParent::AnswerRemoveProperty(
-    const PluginIdentifier& aId, bool* aSuccess) {
-  if (!mObject) {
-    NS_WARNING("Calling AnswerRemoveProperty with an invalidated object!");
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  PluginInstanceParent* instance = GetInstance();
-  if (!instance) {
-    NS_ERROR("No instance?!");
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
-  if (!npn) {
-    NS_ERROR("No netscape funcs?!");
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  StackIdentifier stackID(aId);
-  if (stackID.Failed()) {
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  *aSuccess = npn->removeproperty(instance->GetNPP(), mObject,
-                                  stackID.ToNPIdentifier());
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectParent::AnswerEnumerate(
-    nsTArray<PluginIdentifier>* aProperties, bool* aSuccess) {
-  if (!mObject) {
-    NS_WARNING("Calling AnswerEnumerate with an invalidated object!");
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  PluginInstanceParent* instance = GetInstance();
-  if (!instance) {
-    NS_ERROR("No instance?!");
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
-  if (!npn) {
-    NS_WARNING("No netscape funcs?!");
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  NPIdentifier* ids;
-  uint32_t idCount;
-  if (!npn->enumerate(instance->GetNPP(), mObject, &ids, &idCount)) {
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  aProperties->SetCapacity(idCount);
-
-  for (uint32_t index = 0; index < idCount; index++) {
-    PluginIdentifier id;
-    if (!FromNPIdentifier(ids[index], &id)) {
-      return IPC_FAIL_NO_REASON(this);
-    }
-    aProperties->AppendElement(id);
-  }
-
-  npn->memfree(ids);
-  *aSuccess = true;
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectParent::AnswerConstruct(
-    nsTArray<Variant>&& aArgs, Variant* aResult, bool* aSuccess) {
-  if (!mObject) {
-    NS_WARNING("Calling AnswerConstruct with an invalidated object!");
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  PluginInstanceParent* instance = GetInstance();
-  if (!instance) {
-    NS_ERROR("No instance?!");
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
-  if (!npn) {
-    NS_ERROR("No netscape funcs?!");
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  AutoTArray<NPVariant, 10> convertedArgs;
-  uint32_t argCount = aArgs.Length();
-
-  if (!convertedArgs.SetLength(argCount, fallible)) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  for (uint32_t index = 0; index < argCount; index++) {
-    if (!ConvertToVariant(aArgs[index], convertedArgs[index], instance)) {
-      // Don't leak things we've already converted!
-      while (index-- > 0) {
-        ReleaseVariant(convertedArgs[index], instance);
-      }
-      *aResult = void_t();
-      *aSuccess = false;
-      return IPC_OK();
-    }
-  }
-
-  NPVariant result;
-  bool success = npn->construct(instance->GetNPP(), mObject,
-                                convertedArgs.Elements(), argCount, &result);
-
-  for (uint32_t index = 0; index < argCount; index++) {
-    ReleaseVariant(convertedArgs[index], instance);
-  }
-
-  if (!success) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  Variant convertedResult;
-  success = ConvertToRemoteVariant(result, convertedResult, instance);
-
-  DeferNPVariantLastRelease(npn, &result);
-
-  if (!success) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  *aSuccess = true;
-  *aResult = convertedResult;
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectParent::RecvProtect() {
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  Protect();
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectParent::RecvUnprotect() {
-  NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
-  NS_ASSERTION(mType == LocalObject, "Bad type!");
-
-  Unprotect();
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginScriptableObjectParent::AnswerNPN_Evaluate(
-    const nsCString& aScript, Variant* aResult, bool* aSuccess) {
-  PluginInstanceParent* instance = GetInstance();
-  if (!instance) {
-    NS_ERROR("No instance?!");
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  const NPNetscapeFuncs* npn = GetNetscapeFuncs(instance);
-  if (!npn) {
-    NS_ERROR("No netscape funcs?!");
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  NPString script = {aScript.get(), aScript.Length()};
-
-  NPVariant result;
-  bool success = npn->evaluate(instance->GetNPP(), mObject, &script, &result);
-  if (!success) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  Variant convertedResult;
-  success = ConvertToRemoteVariant(result, convertedResult, instance);
-
-  DeferNPVariantLastRelease(npn, &result);
-
-  if (!success) {
-    *aResult = void_t();
-    *aSuccess = false;
-    return IPC_OK();
-  }
-
-  *aSuccess = true;
-  *aResult = convertedResult;
-  return IPC_OK();
-}
-
-bool PluginScriptableObjectParent::GetPropertyHelper(NPIdentifier aName,
-                                                     bool* aHasProperty,
-                                                     bool* aHasMethod,
-                                                     NPVariant* aResult) {
-  NS_ASSERTION(Type() == Proxy, "Bad type!");
-
-  ParentNPObject* object = static_cast<ParentNPObject*>(mObject);
-  if (object->invalidated) {
-    NS_WARNING("Calling method on an invalidated object!");
-    return false;
-  }
-
-  PluginIdentifier identifier;
-  if (!FromNPIdentifier(aName, &identifier)) {
-    return false;
-  }
-
-  bool hasProperty, hasMethod, success;
-  Variant result;
-  if (!CallGetChildProperty(identifier, &hasProperty, &hasMethod, &result,
-                            &success)) {
-    return false;
-  }
-
-  if (!success) {
-    return false;
-  }
-
-  if (!ConvertToVariant(result, *aResult, GetInstance())) {
-    NS_WARNING("Failed to convert result!");
-    return false;
-  }
-
-  *aHasProperty = hasProperty;
-  *aHasMethod = hasMethod;
-  return true;
-}
diff --git a/dom/plugins/ipc/PluginScriptableObjectParent.h b/dom/plugins/ipc/PluginScriptableObjectParent.h
deleted file mode 100644
index cf8bc5f04f3cd..0000000000000
--- a/dom/plugins/ipc/PluginScriptableObjectParent.h
+++ /dev/null
@@ -1,169 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=2 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef dom_plugins_PluginScriptableObjectParent_h
-#define dom_plugins_PluginScriptableObjectParent_h 1
-
-#include "mozilla/plugins/PPluginScriptableObjectParent.h"
-#include "mozilla/plugins/PluginMessageUtils.h"
-
-#include "npfunctions.h"
-#include "npruntime.h"
-
-namespace mozilla {
-namespace plugins {
-
-class PluginInstanceParent;
-class PluginScriptableObjectParent;
-
-struct ParentNPObject : NPObject {
-  ParentNPObject()
-      : NPObject(), parent(nullptr), invalidated(false), asyncWrapperCount(0) {}
-
-  // |parent| is always valid as long as the actor is alive. Once the actor is
-  // destroyed this will be set to null.
-  PluginScriptableObjectParent* parent;
-  bool invalidated;
-  int32_t asyncWrapperCount;
-};
-
-class PluginScriptableObjectParent : public PPluginScriptableObjectParent {
-  friend class PluginInstanceParent;
-
- public:
-  explicit PluginScriptableObjectParent(ScriptableObjectType aType);
-  virtual ~PluginScriptableObjectParent();
-
-  void InitializeProxy();
-
-  void InitializeLocal(NPObject* aObject);
-
-  virtual void ActorDestroy(ActorDestroyReason aWhy) override;
-
-  mozilla::ipc::IPCResult AnswerHasMethod(const PluginIdentifier& aId,
-                                          bool* aHasMethod);
-
-  mozilla::ipc::IPCResult AnswerInvoke(const PluginIdentifier& aId,
-                                       nsTArray<Variant>&& aArgs,
-                                       Variant* aResult, bool* aSuccess);
-
-  mozilla::ipc::IPCResult AnswerInvokeDefault(nsTArray<Variant>&& aArgs,
-                                              Variant* aResult, bool* aSuccess);
-
-  mozilla::ipc::IPCResult AnswerHasProperty(const PluginIdentifier& aId,
-                                            bool* aHasProperty);
-
-  mozilla::ipc::IPCResult AnswerGetParentProperty(const PluginIdentifier& aId,
-                                                  Variant* aResult,
-                                                  bool* aSuccess);
-
-  mozilla::ipc::IPCResult AnswerSetProperty(const PluginIdentifier& aId,
-                                            const Variant& aValue,
-                                            bool* aSuccess);
-
-  mozilla::ipc::IPCResult AnswerRemoveProperty(const PluginIdentifier& aId,
-                                               bool* aSuccess);
-
-  mozilla::ipc::IPCResult AnswerEnumerate(
-      nsTArray<PluginIdentifier>* aProperties, bool* aSuccess);
-
-  mozilla::ipc::IPCResult AnswerConstruct(nsTArray<Variant>&& aArgs,
-                                          Variant* aResult, bool* aSuccess);
-
-  mozilla::ipc::IPCResult AnswerNPN_Evaluate(const nsCString& aScript,
-                                             Variant* aResult, bool* aSuccess);
-
-  mozilla::ipc::IPCResult RecvProtect();
-
-  mozilla::ipc::IPCResult RecvUnprotect();
-
-  static const NPClass* GetClass() { return &sNPClass; }
-
-  PluginInstanceParent* GetInstance() const { return mInstance; }
-
-  NPObject* GetObject(bool aCanResurrect);
-
-  // Protect only affects LocalObject actors. It is called by the
-  // ProtectedVariant/Actor helper classes before the actor is used as an
-  // argument to an IPC call and when the child process resurrects a
-  // proxy object to the NPObject associated with this actor.
-  void Protect();
-
-  // Unprotect only affects LocalObject actors. It is called by the
-  // ProtectedVariant/Actor helper classes after the actor is used as an
-  // argument to an IPC call and when the child process is no longer using this
-  // actor.
-  void Unprotect();
-
-  // DropNPObject is only used for Proxy actors and is called when the parent
-  // process is no longer using the NPObject associated with this actor. The
-  // child process may subsequently use this actor again in which case a new
-  // NPObject will be created and associated with this actor (see
-  // ResurrectProxyObject).
-  void DropNPObject();
-
-  ScriptableObjectType Type() const { return mType; }
-
-  bool GetPropertyHelper(NPIdentifier aName, bool* aHasProperty,
-                         bool* aHasMethod, NPVariant* aResult);
-
- private:
-  static NPObject* ScriptableAllocate(NPP aInstance, NPClass* aClass);
-
-  static void ScriptableInvalidate(NPObject* aObject);
-
-  static void ScriptableDeallocate(NPObject* aObject);
-
-  static bool ScriptableHasMethod(NPObject* aObject, NPIdentifier aName);
-
-  static bool ScriptableInvoke(NPObject* aObject, NPIdentifier aName,
-                               const NPVariant* aArgs, uint32_t aArgCount,
-                               NPVariant* aResult);
-
-  static bool ScriptableInvokeDefault(NPObject* aObject, const NPVariant* aArgs,
-                                      uint32_t aArgCount, NPVariant* aResult);
-
-  static bool ScriptableHasProperty(NPObject* aObject, NPIdentifier aName);
-
-  static bool ScriptableGetProperty(NPObject* aObject, NPIdentifier aName,
-                                    NPVariant* aResult);
-
-  static bool ScriptableSetProperty(NPObject* aObject, NPIdentifier aName,
-                                    const NPVariant* aValue);
-
-  static bool ScriptableRemoveProperty(NPObject* aObject, NPIdentifier aName);
-
-  static bool ScriptableEnumerate(NPObject* aObject,
-                                  NPIdentifier** aIdentifiers,
-                                  uint32_t* aCount);
-
-  static bool ScriptableConstruct(NPObject* aObject, const NPVariant* aArgs,
-                                  uint32_t aArgCount, NPVariant* aResult);
-
-  NPObject* CreateProxyObject();
-
-  // ResurrectProxyObject is only used with Proxy actors. It is called when the
-  // child process uses an actor whose NPObject was deleted by the parent
-  // process.
-  bool ResurrectProxyObject();
-
- private:
-  PluginInstanceParent* mInstance;
-
-  // This may be a ParentNPObject or some other kind depending on who created
-  // it. Have to check its class to find out.
-  NPObject* mObject;
-  int mProtectCount;
-
-  ScriptableObjectType mType;
-
-  static const NPClass sNPClass;
-};
-
-} /* namespace plugins */
-} /* namespace mozilla */
-
-#endif /* dom_plugins_PluginScriptableObjectParent_h */
diff --git a/dom/plugins/ipc/PluginScriptableObjectUtils-inl.h b/dom/plugins/ipc/PluginScriptableObjectUtils-inl.h
deleted file mode 100644
index b211e1687fa63..0000000000000
--- a/dom/plugins/ipc/PluginScriptableObjectUtils-inl.h
+++ /dev/null
@@ -1,154 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=2 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "PluginScriptableObjectUtils.h"
-
-namespace {
-
-template <class InstanceType>
-class VariantTraits;
-
-template <>
-class VariantTraits<mozilla::plugins::PluginInstanceParent> {
- public:
-  typedef mozilla::plugins::PluginScriptableObjectParent ScriptableObjectType;
-};
-
-template <>
-class VariantTraits<mozilla::plugins::PluginInstanceChild> {
- public:
-  typedef mozilla::plugins::PluginScriptableObjectChild ScriptableObjectType;
-};
-
-} /* anonymous namespace */
-
-inline bool mozilla::plugins::ConvertToVariant(
-    const Variant& aRemoteVariant, NPVariant& aVariant,
-    PluginInstanceParent* aInstance) {
-  switch (aRemoteVariant.type()) {
-    case Variant::Tvoid_t: {
-      VOID_TO_NPVARIANT(aVariant);
-      break;
-    }
-
-    case Variant::Tnull_t: {
-      NULL_TO_NPVARIANT(aVariant);
-      break;
-    }
-
-    case Variant::Tbool: {
-      BOOLEAN_TO_NPVARIANT(aRemoteVariant.get_bool(), aVariant);
-      break;
-    }
-
-    case Variant::Tint: {
-      INT32_TO_NPVARIANT(aRemoteVariant.get_int(), aVariant);
-      break;
-    }
-
-    case Variant::Tdouble: {
-      DOUBLE_TO_NPVARIANT(aRemoteVariant.get_double(), aVariant);
-      break;
-    }
-
-    case Variant::TnsCString: {
-      const nsCString& string = aRemoteVariant.get_nsCString();
-      const size_t length = string.Length();
-      NPUTF8* buffer =
-          static_cast<NPUTF8*>(::malloc(sizeof(NPUTF8) * (length + 1)));
-      if (!buffer) {
-        NS_ERROR("Out of memory!");
-        return false;
-      }
-
-      std::copy(string.get(), string.get() + length, buffer);
-      buffer[length] = '\0';
-      STRINGN_TO_NPVARIANT(buffer, length, aVariant);
-      break;
-    }
-
-    case Variant::TPPluginScriptableObjectParent: {
-      NS_ASSERTION(aInstance, "Must have an instance!");
-      NPObject* object = NPObjectFromVariant(aRemoteVariant);
-      if (!object) {
-        NS_ERROR("Er, this shouldn't fail!");
-        return false;
-      }
-
-      const NPNetscapeFuncs* npn = GetNetscapeFuncs(aInstance);
-      if (!npn) {
-        NS_ERROR("Null netscape funcs!");
-        return false;
-      }
-
-      npn->retainobject(object);
-      OBJECT_TO_NPVARIANT(object, aVariant);
-      break;
-    }
-
-    case Variant::TPPluginScriptableObjectChild: {
-      NS_ASSERTION(!aInstance, "No instance should be given!");
-      NS_ASSERTION(XRE_GetProcessType() == GeckoProcessType_Plugin,
-                   "Should be running on child only!");
-
-      NPObject* object = NPObjectFromVariant(aRemoteVariant);
-      NS_ASSERTION(object, "Null object?!");
-
-      PluginModuleChild::sBrowserFuncs.retainobject(object);
-      OBJECT_TO_NPVARIANT(object, aVariant);
-      break;
-    }
-
-    default:
-      MOZ_ASSERT_UNREACHABLE("Shouldn't get here!");
-      return false;
-  }
-
-  return true;
-}
-
-template <class InstanceType>
-bool mozilla::plugins::ConvertToRemoteVariant(const NPVariant& aVariant,
-                                              Variant& aRemoteVariant,
-                                              InstanceType* aInstance,
-                                              bool aProtectActors) {
-  if (NPVARIANT_IS_VOID(aVariant)) {
-    aRemoteVariant = mozilla::void_t();
-  } else if (NPVARIANT_IS_NULL(aVariant)) {
-    aRemoteVariant = mozilla::null_t();
-  } else if (NPVARIANT_IS_BOOLEAN(aVariant)) {
-    aRemoteVariant = NPVARIANT_TO_BOOLEAN(aVariant);
-  } else if (NPVARIANT_IS_INT32(aVariant)) {
-    aRemoteVariant = NPVARIANT_TO_INT32(aVariant);
-  } else if (NPVARIANT_IS_DOUBLE(aVariant)) {
-    aRemoteVariant = NPVARIANT_TO_DOUBLE(aVariant);
-  } else if (NPVARIANT_IS_STRING(aVariant)) {
-    NPString str = NPVARIANT_TO_STRING(aVariant);
-    nsCString string(str.UTF8Characters, str.UTF8Length);
-    aRemoteVariant = string;
-  } else if (NPVARIANT_IS_OBJECT(aVariant)) {
-    NPObject* object = NPVARIANT_TO_OBJECT(aVariant);
-
-    typename VariantTraits<InstanceType>::ScriptableObjectType* actor =
-        aInstance->GetActorForNPObject(object);
-
-    if (!actor) {
-      NS_ERROR("Null actor!");
-      return false;
-    }
-
-    if (aProtectActors) {
-      actor->Protect();
-    }
-
-    aRemoteVariant = actor;
-  } else {
-    MOZ_ASSERT_UNREACHABLE("Shouldn't get here!");
-    return false;
-  }
-
-  return true;
-}
diff --git a/dom/plugins/ipc/PluginScriptableObjectUtils.h b/dom/plugins/ipc/PluginScriptableObjectUtils.h
deleted file mode 100644
index e620e017e931e..0000000000000
--- a/dom/plugins/ipc/PluginScriptableObjectUtils.h
+++ /dev/null
@@ -1,253 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
- * vim: sw=2 ts=2 et :
- * This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef dom_plugins_PluginScriptableObjectUtils_h
-#define dom_plugins_PluginScriptableObjectUtils_h
-
-#include "PluginModuleParent.h"
-#include "PluginModuleChild.h"
-#include "PluginInstanceParent.h"
-#include "PluginInstanceChild.h"
-#include "PluginScriptableObjectParent.h"
-#include "PluginScriptableObjectChild.h"
-
-#include "npapi.h"
-#include "npfunctions.h"
-#include "npruntime.h"
-
-#include "nsDebug.h"
-
-namespace mozilla {
-namespace plugins {
-
-inline PluginInstanceParent* GetInstance(NPObject* aObject) {
-  NS_ASSERTION(aObject->_class == PluginScriptableObjectParent::GetClass(),
-               "Bad class!");
-
-  ParentNPObject* object = reinterpret_cast<ParentNPObject*>(aObject);
-  if (object->invalidated) {
-    NS_WARNING("Calling method on an invalidated object!");
-    return nullptr;
-  }
-  if (!object->parent) {
-    return nullptr;
-  }
-  return object->parent->GetInstance();
-}
-
-inline NPObject* NPObjectFromVariant(const Variant& aRemoteVariant) {
-  switch (aRemoteVariant.type()) {
-    case Variant::TPPluginScriptableObjectParent: {
-      PluginScriptableObjectParent* actor =
-          const_cast<PluginScriptableObjectParent*>(
-              reinterpret_cast<const PluginScriptableObjectParent*>(
-                  aRemoteVariant.get_PPluginScriptableObjectParent()));
-      return actor->GetObject(true);
-    }
-
-    case Variant::TPPluginScriptableObjectChild: {
-      PluginScriptableObjectChild* actor =
-          const_cast<PluginScriptableObjectChild*>(
-              reinterpret_cast<const PluginScriptableObjectChild*>(
-                  aRemoteVariant.get_PPluginScriptableObjectChild()));
-      return actor->GetObject(true);
-    }
-
-    default:
-      MOZ_ASSERT_UNREACHABLE("Shouldn't get here!");
-      return nullptr;
-  }
-}
-
-inline NPObject* NPObjectFromVariant(const NPVariant& aVariant) {
-  NS_ASSERTION(NPVARIANT_IS_OBJECT(aVariant), "Wrong variant type!");
-  return NPVARIANT_TO_OBJECT(aVariant);
-}
-
-inline const NPNetscapeFuncs* GetNetscapeFuncs(
-    PluginInstanceParent* aInstance) {
-  PluginModuleParent* module = aInstance->Module();
-  if (!module) {
-    NS_WARNING("Null module?!");
-    return nullptr;
-  }
-  return module->GetNetscapeFuncs();
-}
-
-inline const NPNetscapeFuncs* GetNetscapeFuncs(NPObject* aObject) {
-  NS_ASSERTION(aObject->_class == PluginScriptableObjectParent::GetClass(),
-               "Bad class!");
-
-  PluginInstanceParent* instance = GetInstance(aObject);
-  if (!instance) {
-    return nullptr;
-  }
-
-  return GetNetscapeFuncs(instance);
-}
-
-inline void ReleaseRemoteVariant(Variant& aVariant) {
-  switch (aVariant.type()) {
-    case Variant::TPPluginScriptableObjectParent: {
-      PluginScriptableObjectParent* actor =
-          const_cast<PluginScriptableObjectParent*>(
-              reinterpret_cast<const PluginScriptableObjectParent*>(
-                  aVariant.get_PPluginScriptableObjectParent()));
-      actor->Unprotect();
-      break;
-    }
-
-    case Variant::TPPluginScriptableObjectChild: {
-      NS_ASSERTION(XRE_GetProcessType() == GeckoProcessType_Plugin,
-                   "Should only be running in the child!");
-      PluginScriptableObjectChild* actor =
-          const_cast<PluginScriptableObjectChild*>(
-              reinterpret_cast<const PluginScriptableObjectChild*>(
-                  aVariant.get_PPluginScriptableObjectChild()));
-      actor->Unprotect();
-      break;
-    }
-
-    default:
-      break;  // Intentional fall-through for other variant types.
-  }
-
-  aVariant = mozilla::void_t();
-}
-
-bool ConvertToVariant(const Variant& aRemoteVariant, NPVariant& aVariant,
-                      PluginInstanceParent* aInstance = nullptr);
-
-template <class InstanceType>
-bool ConvertToRemoteVariant(const NPVariant& aVariant, Variant& aRemoteVariant,
-                            InstanceType* aInstance,
-                            bool aProtectActors = false);
-
-class ProtectedVariant {
- public:
-  ProtectedVariant(const NPVariant& aVariant, PluginInstanceParent* aInstance) {
-    mOk = ConvertToRemoteVariant(aVariant, mVariant, aInstance, true);
-  }
-
-  ProtectedVariant(const NPVariant& aVariant, PluginInstanceChild* aInstance) {
-    mOk = ConvertToRemoteVariant(aVariant, mVariant, aInstance, true);
-  }
-
-  ~ProtectedVariant() { ReleaseRemoteVariant(mVariant); }
-
-  bool IsOk() { return mOk; }
-
-  operator const Variant&() { return mVariant; }
-
- private:
-  Variant mVariant;
-  bool mOk;
-};
-
-class ProtectedVariantArray {
- public:
-  ProtectedVariantArray(const NPVariant* aArgs, uint32_t aCount,
-                        PluginInstanceParent* aInstance)
-      : mUsingShadowArray(false) {
-    for (uint32_t index = 0; index < aCount; index++) {
-      Variant* remoteVariant = mArray.AppendElement();
-      if (!(remoteVariant &&
-            ConvertToRemoteVariant(aArgs[index], *remoteVariant, aInstance,
-                                   true))) {
-        mOk = false;
-        return;
-      }
-    }
-    mOk = true;
-  }
-
-  ProtectedVariantArray(const NPVariant* aArgs, uint32_t aCount,
-                        PluginInstanceChild* aInstance)
-      : mUsingShadowArray(false) {
-    for (uint32_t index = 0; index < aCount; index++) {
-      Variant* remoteVariant = mArray.AppendElement();
-      if (!(remoteVariant &&
-            ConvertToRemoteVariant(aArgs[index], *remoteVariant, aInstance,
-                                   true))) {
-        mOk = false;
-        return;
-      }
-    }
-    mOk = true;
-  }
-
-  ~ProtectedVariantArray() {
-    nsTArray<Variant>& vars = EnsureAndGetShadowArray();
-    uint32_t count = vars.Length();
-    for (uint32_t index = 0; index < count; index++) {
-      ReleaseRemoteVariant(vars[index]);
-    }
-  }
-
-  operator const nsTArray<Variant>&() { return EnsureAndGetShadowArray(); }
-
-  bool IsOk() { return mOk; }
-
- private:
-  nsTArray<Variant>& EnsureAndGetShadowArray() {
-    if (!mUsingShadowArray) {
-      mShadowArray.SwapElements(mArray);
-      mUsingShadowArray = true;
-    }
-    return mShadowArray;
-  }
-
-  // We convert the variants fallibly, but pass them to Call*()
-  // methods as an infallible array
-  nsTArray<Variant> mArray;
-  nsTArray<Variant> mShadowArray;
-  bool mOk;
-  bool mUsingShadowArray;
-};
-
-template <class ActorType>
-struct ProtectedActorTraits {
-  static bool Nullable();
-};
-
-template <class ActorType, class Traits = ProtectedActorTraits<ActorType> >
-class ProtectedActor {
- public:
-  explicit ProtectedActor(ActorType* aActor) : mActor(aActor) {
-    if (!Traits::Nullable()) {
-      NS_ASSERTION(mActor, "This should never be null!");
-    }
-  }
-
-  ~ProtectedActor() {
-    if (Traits::Nullable() && !mActor) return;
-    mActor->Unprotect();
-  }
-
-  ActorType* operator->() { return mActor; }
-
-  explicit operator bool() { return !!mActor; }
-
- private:
-  ActorType* mActor;
-};
-
-template <>
-struct ProtectedActorTraits<PluginScriptableObjectParent> {
-  static bool Nullable() { return true; }
-};
-
-template <>
-struct ProtectedActorTraits<PluginScriptableObjectChild> {
-  static bool Nullable() { return false; }
-};
-
-} /* namespace plugins */
-} /* namespace mozilla */
-
-#include "PluginScriptableObjectUtils-inl.h"
-
-#endif /* dom_plugins_PluginScriptableObjectUtils_h */
diff --git a/dom/plugins/ipc/PluginTypes.ipdlh b/dom/plugins/ipc/PluginTypes.ipdlh
deleted file mode 100644
index 0c674c365396c..0000000000000
--- a/dom/plugins/ipc/PluginTypes.ipdlh
+++ /dev/null
@@ -1,48 +0,0 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-include URIParams;
-
-namespace mozilla {
-namespace plugins {
-
-struct PluginTag
-{
-  uint32_t id;
-  nsCString name;
-  nsCString description;
-  nsCString[] mimeTypes;
-  nsCString[] mimeDescriptions;
-  nsCString[] extensions;
-  bool isFlashPlugin;
-  bool supportsAsyncRender; // flash specific
-  nsCString filename;
-  nsCString version;
-  int64_t lastModifiedTime;
-  int32_t sandboxLevel;
-  uint16_t blocklistState;
-};
-
-struct FakePluginTag
-{
-  uint32_t id;
-  URIParams handlerURI;
-  nsCString name;
-  nsCString description;
-  nsCString[] mimeTypes;
-  nsCString[] mimeDescriptions;
-  nsCString[] extensions;
-  nsCString niceName;
-  nsString sandboxScript;
-};
-
-union PluginIdentifier
-{
-  nsCString;
-  int32_t;
-};
-
-} // namespace plugins
-} // namespace mozilla
diff --git a/dom/plugins/ipc/PluginUtilsOSX.h b/dom/plugins/ipc/PluginUtilsOSX.h
deleted file mode 100644
index bf03c90c78ea8..0000000000000
--- a/dom/plugins/ipc/PluginUtilsOSX.h
+++ /dev/null
@@ -1,94 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-// vim:set ts=2 sts=2 sw=2 et cin:
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef dom_plugins_PluginUtilsOSX_h
-#define dom_plugins_PluginUtilsOSX_h 1
-
-#include "npapi.h"
-#include "mozilla/gfx/QuartzSupport.h"
-#include "nsRect.h"
-
-namespace mozilla {
-namespace plugins {
-namespace PluginUtilsOSX {
-
-// Need to call back into the browser's message loop to process event.
-typedef void (*RemoteProcessEvents)(void*);
-
-NPError ShowCocoaContextMenu(void* aMenu, int aX, int aY, void* pluginModule,
-                             RemoteProcessEvents remoteEvent);
-
-void InvokeNativeEventLoop();
-
-// Need to call back and send a cocoa draw event to the plugin.
-typedef void (*DrawPluginFunc)(CGContextRef, void*, nsIntRect aUpdateRect);
-
-void* GetCGLayer(DrawPluginFunc aFunc, void* aPluginInstance,
-                 double aContentsScaleFactor);
-void ReleaseCGLayer(void* cgLayer);
-void Repaint(void* cgLayer, nsIntRect aRect);
-
-bool SetProcessName(const char* aProcessName);
-
-/*
- * Provides a wrapper around nsCARenderer to manage double buffering
- * without having to unbind nsCARenderer on every surface swaps.
- *
- * The double buffer renderer begins with no initialize surfaces.
- * The buffers can be initialized and cleared individually.
- * Swapping still occurs regardless if the buffers are initialized.
- */
-class nsDoubleBufferCARenderer {
- public:
-  nsDoubleBufferCARenderer() : mCALayer(nullptr), mContentsScaleFactor(1.0) {}
-  // Returns width in "display pixels".  A "display pixel" is the smallest
-  // fully addressable part of a display.  But in HiDPI modes each "display
-  // pixel" corresponds to more than one device pixel.  Multiply display pixels
-  // by mContentsScaleFactor to get device pixels.
-  size_t GetFrontSurfaceWidth();
-  // Returns height in "display pixels".  Multiply by
-  // mContentsScaleFactor to get device pixels.
-  size_t GetFrontSurfaceHeight();
-  double GetFrontSurfaceContentsScaleFactor();
-  // Returns width in "display pixels".  Multiply by
-  // mContentsScaleFactor to get device pixels.
-  size_t GetBackSurfaceWidth();
-  // Returns height in "display pixels".  Multiply by
-  // mContentsScaleFactor to get device pixels.
-  size_t GetBackSurfaceHeight();
-  double GetBackSurfaceContentsScaleFactor();
-  IOSurfaceID GetFrontSurfaceID();
-
-  bool HasBackSurface();
-  bool HasFrontSurface();
-  bool HasCALayer();
-
-  void SetCALayer(void* aCALayer);
-  // aWidth and aHeight are in "display pixels".  Multiply by
-  // aContentsScaleFactor to get device pixels.
-  bool InitFrontSurface(size_t aWidth, size_t aHeight,
-                        double aContentsScaleFactor,
-                        AllowOfflineRendererEnum aAllowOfflineRenderer);
-  void Render();
-  void SwapSurfaces();
-  void ClearFrontSurface();
-  void ClearBackSurface();
-
-  double GetContentsScaleFactor() { return mContentsScaleFactor; }
-
- private:
-  void* mCALayer;
-  RefPtr<nsCARenderer> mCARenderer;
-  RefPtr<MacIOSurface> mFrontSurface;
-  RefPtr<MacIOSurface> mBackSurface;
-  double mContentsScaleFactor;
-};
-
-}  // namespace PluginUtilsOSX
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // dom_plugins_PluginUtilsOSX_h
diff --git a/dom/plugins/ipc/PluginUtilsOSX.mm b/dom/plugins/ipc/PluginUtilsOSX.mm
deleted file mode 100644
index 246e5caf6821e..0000000000000
--- a/dom/plugins/ipc/PluginUtilsOSX.mm
+++ /dev/null
@@ -1,429 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-// vim:set ts=2 sts=2 sw=2 et cin:
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include <dlfcn.h>
-#import <AppKit/AppKit.h>
-#import <QuartzCore/QuartzCore.h>
-#include "PluginUtilsOSX.h"
-
-// Remove definitions for try/catch interfering with ObjCException macros.
-#include "nsObjCExceptions.h"
-#include "nsCocoaUtils.h"
-
-#include "nsDebug.h"
-
-#include "mozilla/Sprintf.h"
-
-@interface CALayer (ContentsScale)
-- (double)contentsScale;
-- (void)setContentsScale:(double)scale;
-@end
-
-using namespace mozilla::plugins::PluginUtilsOSX;
-
-@interface CGBridgeLayer : CALayer {
-  DrawPluginFunc mDrawFunc;
-  void* mPluginInstance;
-  nsIntRect mUpdateRect;
-}
-- (void)setDrawFunc:(DrawPluginFunc)aFunc pluginInstance:(void*)aPluginInstance;
-- (void)updateRect:(nsIntRect)aRect;
-
-@end
-
-// CGBitmapContextSetData() is an undocumented function present (with
-// the same signature) since at least OS X 10.5.  As the name suggests,
-// it's used to replace the "data" in a bitmap context that was
-// originally specified in a call to CGBitmapContextCreate() or
-// CGBitmapContextCreateWithData().
-typedef void (*CGBitmapContextSetDataFunc)(CGContextRef c, size_t x, size_t y, size_t width,
-                                           size_t height, void* data, size_t bitsPerComponent,
-                                           size_t bitsPerPixel, size_t bytesPerRow);
-CGBitmapContextSetDataFunc CGBitmapContextSetDataPtr = NULL;
-
-@implementation CGBridgeLayer
-- (void)updateRect:(nsIntRect)aRect {
-  mUpdateRect.UnionRect(mUpdateRect, aRect);
-}
-
-- (void)setDrawFunc:(DrawPluginFunc)aFunc pluginInstance:(void*)aPluginInstance {
-  mDrawFunc = aFunc;
-  mPluginInstance = aPluginInstance;
-}
-
-- (void)drawInContext:(CGContextRef)aCGContext {
-  ::CGContextSaveGState(aCGContext);
-  ::CGContextTranslateCTM(aCGContext, 0, self.bounds.size.height);
-  ::CGContextScaleCTM(aCGContext, (CGFloat)1, (CGFloat)-1);
-
-  mUpdateRect = nsIntRect::Truncate(0, 0, self.bounds.size.width, self.bounds.size.height);
-
-  mDrawFunc(aCGContext, mPluginInstance, mUpdateRect);
-
-  ::CGContextRestoreGState(aCGContext);
-
-  mUpdateRect.SetEmpty();
-}
-
-@end
-
-void* mozilla::plugins::PluginUtilsOSX::GetCGLayer(DrawPluginFunc aFunc, void* aPluginInstance,
-                                                   double aContentsScaleFactor) {
-  CGBridgeLayer* bridgeLayer = [[CGBridgeLayer alloc] init];
-
-  // We need to make bridgeLayer behave properly when its superlayer changes
-  // size (in nsCARenderer::SetBounds()).
-  bridgeLayer.autoresizingMask = kCALayerWidthSizable | kCALayerHeightSizable;
-  bridgeLayer.needsDisplayOnBoundsChange = YES;
-  NSNull* nullValue = [NSNull null];
-  NSDictionary* actions = [NSDictionary
-      dictionaryWithObjectsAndKeys:nullValue, @"bounds", nullValue, @"contents", nullValue,
-                                   @"contentsRect", nullValue, @"position", nil];
-  [bridgeLayer setStyle:[NSDictionary dictionaryWithObject:actions forKey:@"actions"]];
-
-  // For reasons that aren't clear (perhaps one or more OS bugs), we can only
-  // use full HiDPI resolution here if the tree is built with the 10.7 SDK or
-  // up.  If we build with the 10.6 SDK, changing the contentsScale property
-  // of bridgeLayer (even to the same value) causes it to stop working (go
-  // blank).  This doesn't happen with objects that are members of the CALayer
-  // class (as opposed to one of its subclasses).
-#if defined(MAC_OS_X_VERSION_10_7) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_7
-  if ([bridgeLayer respondsToSelector:@selector(setContentsScale:)]) {
-    bridgeLayer.contentsScale = aContentsScaleFactor;
-  }
-#endif
-
-  [bridgeLayer setDrawFunc:aFunc pluginInstance:aPluginInstance];
-  return bridgeLayer;
-}
-
-void mozilla::plugins::PluginUtilsOSX::ReleaseCGLayer(void* cgLayer) {
-  CGBridgeLayer* bridgeLayer = (CGBridgeLayer*)cgLayer;
-  [bridgeLayer release];
-}
-
-void mozilla::plugins::PluginUtilsOSX::Repaint(void* caLayer, nsIntRect aRect) {
-  CGBridgeLayer* bridgeLayer = (CGBridgeLayer*)caLayer;
-  [CATransaction begin];
-  [bridgeLayer updateRect:aRect];
-  [bridgeLayer setNeedsDisplay];
-  [bridgeLayer displayIfNeeded];
-  [CATransaction commit];
-}
-
-@interface EventProcessor : NSObject {
-  RemoteProcessEvents aRemoteEvents;
-  void* aPluginModule;
-}
-- (void)setRemoteEvents:(RemoteProcessEvents)remoteEvents pluginModule:(void*)pluginModule;
-- (void)onTick;
-@end
-
-@implementation EventProcessor
-- (void)onTick {
-  aRemoteEvents(aPluginModule);
-}
-
-- (void)setRemoteEvents:(RemoteProcessEvents)remoteEvents pluginModule:(void*)pluginModule {
-  aRemoteEvents = remoteEvents;
-  aPluginModule = pluginModule;
-}
-@end
-
-#define EVENT_PROCESS_DELAY 0.05  // 50 ms
-
-NPError mozilla::plugins::PluginUtilsOSX::ShowCocoaContextMenu(void* aMenu, int aX, int aY,
-                                                               void* pluginModule,
-                                                               RemoteProcessEvents remoteEvent) {
-  NS_OBJC_BEGIN_TRY_IGNORE_BLOCK;
-
-  // Set the native cursor to the OS default (an arrow) before displaying the
-  // context menu.  Otherwise (if the plugin has changed the cursor) it may
-  // stay as the plugin has set it -- which means it may be invisible.  We
-  // need to do this because we display the context menu without making the
-  // plugin process the foreground process.  If we did, the cursor would
-  // change to an arrow cursor automatically -- as it does in Chrome.
-  [[NSCursor arrowCursor] set];
-
-  EventProcessor* eventProcessor = nullptr;
-  NSTimer* eventTimer = nullptr;
-  if (pluginModule) {
-    // Create a timer to process browser events while waiting
-    // on the menu. This prevents the browser from hanging
-    // during the lifetime of the menu.
-    eventProcessor = [[EventProcessor alloc] init];
-    [eventProcessor setRemoteEvents:remoteEvent pluginModule:pluginModule];
-    eventTimer = [NSTimer timerWithTimeInterval:EVENT_PROCESS_DELAY
-                                         target:eventProcessor
-                                       selector:@selector(onTick)
-                                       userInfo:nil
-                                        repeats:TRUE];
-    // Use NSEventTrackingRunLoopMode otherwise the timer will
-    // not fire during the right click menu.
-    [[NSRunLoop currentRunLoop] addTimer:eventTimer forMode:NSEventTrackingRunLoopMode];
-  }
-
-  NSMenu* nsmenu = reinterpret_cast<NSMenu*>(aMenu);
-  NSPoint screen_point = ::NSMakePoint(aX, aY);
-
-  [nsmenu popUpMenuPositioningItem:nil atLocation:screen_point inView:nil];
-
-  if (pluginModule) {
-    [eventTimer invalidate];
-    [eventProcessor release];
-  }
-
-  return NPERR_NO_ERROR;
-
-  NS_OBJC_END_TRY_BLOCK_RETURN(NPERR_GENERIC_ERROR);
-}
-
-void mozilla::plugins::PluginUtilsOSX::InvokeNativeEventLoop() {
-  NS_OBJC_BEGIN_TRY_IGNORE_BLOCK;
-  ::CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0.0, true);
-  NS_OBJC_END_TRY_IGNORE_BLOCK;
-}
-
-#define UNDOCUMENTED_SESSION_CONSTANT ((int)-2)
-namespace mozilla {
-namespace plugins {
-namespace PluginUtilsOSX {
-static void* sApplicationASN = NULL;
-static void* sApplicationInfoItem = NULL;
-}  // namespace PluginUtilsOSX
-}  // namespace plugins
-}  // namespace mozilla
-
-bool mozilla::plugins::PluginUtilsOSX::SetProcessName(const char* aProcessName) {
-  NS_OBJC_BEGIN_TRY_IGNORE_BLOCK;
-  nsAutoreleasePool localPool;
-
-  if (!aProcessName || strcmp(aProcessName, "") == 0) {
-    return false;
-  }
-
-  NSString* currentName =
-      [[[NSBundle mainBundle] localizedInfoDictionary] objectForKey:(NSString*)kCFBundleNameKey];
-
-  char formattedName[1024];
-  SprintfLiteral(formattedName, "%s %s", [currentName UTF8String], aProcessName);
-
-  aProcessName = formattedName;
-
-  // This function is based on Chrome/Webkit's and relies on potentially dangerous SPI.
-  typedef CFTypeRef (*LSGetASNType)();
-  typedef OSStatus (*LSSetInformationItemType)(int, CFTypeRef, CFStringRef, CFStringRef,
-                                               CFDictionaryRef*);
-
-  CFBundleRef launchServices = ::CFBundleGetBundleWithIdentifier(CFSTR("com.apple.LaunchServices"));
-  if (!launchServices) {
-    NS_WARNING("Failed to set process name: Could not open LaunchServices bundle");
-    return false;
-  }
-
-  if (!sApplicationASN) {
-    sApplicationASN =
-        ::CFBundleGetFunctionPointerForName(launchServices, CFSTR("_LSGetCurrentApplicationASN"));
-    if (!sApplicationASN) {
-      NS_WARNING("Failed to set process name: Could not get function pointer "
-                 "for LaunchServices");
-      return false;
-    }
-  }
-
-  LSGetASNType getASNFunc = reinterpret_cast<LSGetASNType>(sApplicationASN);
-
-  if (!sApplicationInfoItem) {
-    sApplicationInfoItem = ::CFBundleGetFunctionPointerForName(
-        launchServices, CFSTR("_LSSetApplicationInformationItem"));
-  }
-
-  LSSetInformationItemType setInformationItemFunc =
-      reinterpret_cast<LSSetInformationItemType>(sApplicationInfoItem);
-
-  void* displayNameKeyAddr =
-      ::CFBundleGetDataPointerForName(launchServices, CFSTR("_kLSDisplayNameKey"));
-
-  CFStringRef displayNameKey = nil;
-  if (displayNameKeyAddr) {
-    displayNameKey = reinterpret_cast<CFStringRef>(*(CFStringRef*)displayNameKeyAddr);
-  }
-
-  // Rename will fail without this
-  ProcessSerialNumber psn;
-  if (::GetCurrentProcess(&psn) != noErr) {
-    return false;
-  }
-
-  CFTypeRef currentAsn = getASNFunc ? getASNFunc() : nullptr;
-
-  if (!getASNFunc || !setInformationItemFunc || !displayNameKey || !currentAsn) {
-    NS_WARNING("Failed to set process name: Accessing launchServices failed");
-    return false;
-  }
-
-  CFStringRef processName = ::CFStringCreateWithCString(nil, aProcessName, kCFStringEncodingASCII);
-  if (!processName) {
-    NS_WARNING("Failed to set process name: Could not create CFStringRef");
-    return false;
-  }
-
-  OSErr err =
-      setInformationItemFunc(UNDOCUMENTED_SESSION_CONSTANT, currentAsn, displayNameKey, processName,
-                             nil);  // Optional out param
-  ::CFRelease(processName);
-  if (err != noErr) {
-    NS_WARNING("Failed to set process name: LSSetInformationItemType err");
-    return false;
-  }
-
-  return true;
-  NS_OBJC_END_TRY_BLOCK_RETURN(false);
-}
-
-namespace mozilla {
-namespace plugins {
-namespace PluginUtilsOSX {
-
-size_t nsDoubleBufferCARenderer::GetFrontSurfaceWidth() {
-  if (!HasFrontSurface()) {
-    return 0;
-  }
-
-  return mFrontSurface->GetWidth();
-}
-
-size_t nsDoubleBufferCARenderer::GetFrontSurfaceHeight() {
-  if (!HasFrontSurface()) {
-    return 0;
-  }
-
-  return mFrontSurface->GetHeight();
-}
-
-double nsDoubleBufferCARenderer::GetFrontSurfaceContentsScaleFactor() {
-  if (!HasFrontSurface()) {
-    return 1.0;
-  }
-
-  return mFrontSurface->GetContentsScaleFactor();
-}
-
-size_t nsDoubleBufferCARenderer::GetBackSurfaceWidth() {
-  if (!HasBackSurface()) {
-    return 0;
-  }
-
-  return mBackSurface->GetWidth();
-}
-
-size_t nsDoubleBufferCARenderer::GetBackSurfaceHeight() {
-  if (!HasBackSurface()) {
-    return 0;
-  }
-
-  return mBackSurface->GetHeight();
-}
-
-double nsDoubleBufferCARenderer::GetBackSurfaceContentsScaleFactor() {
-  if (!HasBackSurface()) {
-    return 1.0;
-  }
-
-  return mBackSurface->GetContentsScaleFactor();
-}
-
-IOSurfaceID nsDoubleBufferCARenderer::GetFrontSurfaceID() {
-  if (!HasFrontSurface()) {
-    return 0;
-  }
-
-  return mFrontSurface->GetIOSurfaceID();
-}
-
-bool nsDoubleBufferCARenderer::HasBackSurface() { return !!mBackSurface; }
-
-bool nsDoubleBufferCARenderer::HasFrontSurface() { return !!mFrontSurface; }
-
-bool nsDoubleBufferCARenderer::HasCALayer() { return !!mCALayer; }
-
-void nsDoubleBufferCARenderer::SetCALayer(void* aCALayer) { mCALayer = aCALayer; }
-
-bool nsDoubleBufferCARenderer::InitFrontSurface(size_t aWidth, size_t aHeight,
-                                                double aContentsScaleFactor,
-                                                AllowOfflineRendererEnum aAllowOfflineRenderer) {
-  if (!mCALayer) {
-    return false;
-  }
-
-  mContentsScaleFactor = aContentsScaleFactor;
-  mFrontSurface = MacIOSurface::CreateIOSurface(aWidth, aHeight, mContentsScaleFactor);
-  if (!mFrontSurface) {
-    mCARenderer = nullptr;
-    return false;
-  }
-
-  if (!mCARenderer) {
-    mCARenderer = new nsCARenderer();
-    if (!mCARenderer) {
-      mFrontSurface = nullptr;
-      return false;
-    }
-
-    mCARenderer->AttachIOSurface(mFrontSurface);
-
-    nsresult result =
-        mCARenderer->SetupRenderer(mCALayer, mFrontSurface->GetWidth(), mFrontSurface->GetHeight(),
-                                   mContentsScaleFactor, aAllowOfflineRenderer);
-
-    if (result != NS_OK) {
-      mCARenderer = nullptr;
-      mFrontSurface = nullptr;
-      return false;
-    }
-  } else {
-    mCARenderer->AttachIOSurface(mFrontSurface);
-  }
-
-  return true;
-}
-
-void nsDoubleBufferCARenderer::Render() {
-  if (!HasFrontSurface() || !mCARenderer) {
-    return;
-  }
-
-  mCARenderer->Render(GetFrontSurfaceWidth(), GetFrontSurfaceHeight(), mContentsScaleFactor,
-                      nullptr);
-}
-
-void nsDoubleBufferCARenderer::SwapSurfaces() {
-  RefPtr<MacIOSurface> prevFrontSurface = mFrontSurface;
-  mFrontSurface = mBackSurface;
-  mBackSurface = prevFrontSurface;
-
-  if (mFrontSurface) {
-    mCARenderer->AttachIOSurface(mFrontSurface);
-  }
-}
-
-void nsDoubleBufferCARenderer::ClearFrontSurface() {
-  mFrontSurface = nullptr;
-  if (!mFrontSurface && !mBackSurface) {
-    mCARenderer = nullptr;
-  }
-}
-
-void nsDoubleBufferCARenderer::ClearBackSurface() {
-  mBackSurface = nullptr;
-  if (!mFrontSurface && !mBackSurface) {
-    mCARenderer = nullptr;
-  }
-}
-
-}  // namespace PluginUtilsOSX
-}  // namespace plugins
-}  // namespace mozilla
diff --git a/dom/plugins/ipc/PluginUtilsWin.cpp b/dom/plugins/ipc/PluginUtilsWin.cpp
deleted file mode 100644
index c913321d745ff..0000000000000
--- a/dom/plugins/ipc/PluginUtilsWin.cpp
+++ /dev/null
@@ -1,272 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-/* PluginUtilsWin.cpp - top-level Windows plugin management code */
-
-#include <mmdeviceapi.h>
-#include "PluginUtilsWin.h"
-#include "PluginModuleParent.h"
-#include "mozilla/StaticMutex.h"
-
-namespace mozilla {
-namespace plugins {
-namespace PluginUtilsWin {
-
-class AudioNotification;
-typedef nsTHashtable<nsPtrHashKey<PluginModuleParent>> PluginModuleSet;
-StaticMutex sMutex;
-
-class AudioDeviceMessageRunnable : public Runnable {
- public:
-  explicit AudioDeviceMessageRunnable(
-      AudioNotification* aAudioNotification,
-      NPAudioDeviceChangeDetailsIPC aChangeDetails);
-
-  explicit AudioDeviceMessageRunnable(
-      AudioNotification* aAudioNotification,
-      NPAudioDeviceStateChangedIPC aDeviceState);
-
-  NS_IMETHOD Run() override;
-
- protected:
-  // The potential payloads for the message.  Type determined by mMessageType.
-  NPAudioDeviceChangeDetailsIPC mChangeDetails;
-  NPAudioDeviceStateChangedIPC mDeviceState;
-  enum { DEFAULT_DEVICE_CHANGED, DEVICE_STATE_CHANGED } mMessageType;
-
-  AudioNotification* mAudioNotification;
-};
-
-class AudioNotification final : public IMMNotificationClient {
- public:
-  AudioNotification() : mIsRegistered(false), mRefCt(1) {
-    HRESULT hr =
-        CoCreateInstance(__uuidof(MMDeviceEnumerator), NULL,
-                         CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&mDeviceEnum));
-    if (FAILED(hr)) {
-      mDeviceEnum = nullptr;
-      return;
-    }
-
-    hr = mDeviceEnum->RegisterEndpointNotificationCallback(this);
-    if (FAILED(hr)) {
-      mDeviceEnum->Release();
-      mDeviceEnum = nullptr;
-      return;
-    }
-
-    mIsRegistered = true;
-  }
-
-  // IMMNotificationClient Implementation
-  HRESULT STDMETHODCALLTYPE OnDefaultDeviceChanged(EDataFlow flow, ERole role,
-                                                   LPCWSTR device_id) override {
-    NPAudioDeviceChangeDetailsIPC changeDetails;
-    changeDetails.flow = (int32_t)flow;
-    changeDetails.role = (int32_t)role;
-    changeDetails.defaultDevice = device_id ? std::wstring(device_id) : L"";
-
-    // Make sure that plugin is notified on the main thread.
-    RefPtr<AudioDeviceMessageRunnable> runnable =
-        new AudioDeviceMessageRunnable(this, changeDetails);
-    NS_DispatchToMainThread(runnable);
-    return S_OK;
-  }
-
-  HRESULT STDMETHODCALLTYPE OnDeviceAdded(LPCWSTR device_id) override {
-    return S_OK;
-  };
-
-  HRESULT STDMETHODCALLTYPE OnDeviceRemoved(LPCWSTR device_id) override {
-    return S_OK;
-  }
-
-  HRESULT STDMETHODCALLTYPE OnDeviceStateChanged(LPCWSTR device_id,
-                                                 DWORD new_state) override {
-    NPAudioDeviceStateChangedIPC deviceStateIPC;
-    deviceStateIPC.device = device_id ? std::wstring(device_id) : L"";
-    deviceStateIPC.state = (uint32_t)new_state;
-
-    // Make sure that plugin is notified on the main thread.
-    RefPtr<AudioDeviceMessageRunnable> runnable =
-        new AudioDeviceMessageRunnable(this, deviceStateIPC);
-    NS_DispatchToMainThread(runnable);
-    return S_OK;
-  }
-
-  HRESULT STDMETHODCALLTYPE
-  OnPropertyValueChanged(LPCWSTR device_id, const PROPERTYKEY key) override {
-    return S_OK;
-  }
-
-  // IUnknown Implementation
-  ULONG STDMETHODCALLTYPE AddRef() override {
-    return InterlockedIncrement(&mRefCt);
-  }
-
-  ULONG STDMETHODCALLTYPE Release() override {
-    ULONG ulRef = InterlockedDecrement(&mRefCt);
-    if (0 == ulRef) {
-      delete this;
-    }
-    return ulRef;
-  }
-
-  HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid,
-                                           VOID** ppvInterface) override {
-    if (__uuidof(IUnknown) == riid) {
-      AddRef();
-      *ppvInterface = (IUnknown*)this;
-    } else if (__uuidof(IMMNotificationClient) == riid) {
-      AddRef();
-      *ppvInterface = (IMMNotificationClient*)this;
-    } else {
-      *ppvInterface = NULL;
-      return E_NOINTERFACE;
-    }
-    return S_OK;
-  }
-
-  /*
-   * A Valid instance must be Unregistered before Releasing it.
-   */
-  void Unregister() {
-    if (mDeviceEnum) {
-      mDeviceEnum->UnregisterEndpointNotificationCallback(this);
-    }
-    mIsRegistered = false;
-  }
-
-  /*
-   * True whenever the notification server is set to report events to this
-   * object.
-   */
-  bool IsRegistered() { return mIsRegistered; }
-
-  void AddModule(PluginModuleParent* aModule) {
-    StaticMutexAutoLock lock(sMutex);
-    mAudioNotificationSet.PutEntry(aModule);
-  }
-
-  void RemoveModule(PluginModuleParent* aModule) {
-    StaticMutexAutoLock lock(sMutex);
-    mAudioNotificationSet.RemoveEntry(aModule);
-  }
-
-  /*
-   * Are any modules registered for audio notifications?
-   */
-  bool HasModules() { return !mAudioNotificationSet.IsEmpty(); }
-
-  const PluginModuleSet* GetModuleSet() const { return &mAudioNotificationSet; }
-
- private:
-  bool mIsRegistered;  // only used to make sure that Unregister is called
-                       // before destroying a Valid instance.
-  LONG mRefCt;
-  IMMDeviceEnumerator* mDeviceEnum;
-
-  // Set of plugin modules that have registered to be notified when the audio
-  // device changes.
-  PluginModuleSet mAudioNotificationSet;
-
-  ~AudioNotification() {
-    MOZ_ASSERT(!mIsRegistered,
-               "Destroying AudioNotification without first calling Unregister");
-    if (mDeviceEnum) {
-      mDeviceEnum->Release();
-    }
-  }
-};  // class AudioNotification
-
-// callback that gets notified of audio device events, or NULL
-AudioNotification* sAudioNotification = nullptr;
-
-nsresult RegisterForAudioDeviceChanges(PluginModuleParent* aModuleParent,
-                                       bool aShouldRegister) {
-  // Hold the AudioNotification singleton iff there are PluginModuleParents
-  // that are subscribed to it.
-  if (aShouldRegister) {
-    if (!sAudioNotification) {
-      // We are registering the first module.  Create the singleton.
-      sAudioNotification = new AudioNotification();
-      if (!sAudioNotification->IsRegistered()) {
-        PLUGIN_LOG_DEBUG(
-            ("Registered for plugin audio device notification failed."));
-        sAudioNotification->Release();
-        sAudioNotification = nullptr;
-        return NS_ERROR_FAILURE;
-      }
-      PLUGIN_LOG_DEBUG(("Registered for plugin audio device notification."));
-    }
-    sAudioNotification->AddModule(aModuleParent);
-  } else if (!aShouldRegister && sAudioNotification) {
-    sAudioNotification->RemoveModule(aModuleParent);
-    if (!sAudioNotification->HasModules()) {
-      // We have removed the last module from the notification mechanism
-      // so we can destroy the singleton.
-      PLUGIN_LOG_DEBUG(("Unregistering for plugin audio device notification."));
-      sAudioNotification->Unregister();
-      sAudioNotification->Release();
-      sAudioNotification = nullptr;
-    }
-  }
-  return NS_OK;
-}
-
-AudioDeviceMessageRunnable::AudioDeviceMessageRunnable(
-    AudioNotification* aAudioNotification,
-    NPAudioDeviceChangeDetailsIPC aChangeDetails)
-    : Runnable("AudioDeviceMessageRunnableCD"),
-      mChangeDetails(aChangeDetails),
-      mMessageType(DEFAULT_DEVICE_CHANGED),
-      mAudioNotification(aAudioNotification) {
-  // We increment the AudioNotification ref-count here -- the runnable will
-  // decrement it when it is done with us.
-  mAudioNotification->AddRef();
-}
-
-AudioDeviceMessageRunnable::AudioDeviceMessageRunnable(
-    AudioNotification* aAudioNotification,
-    NPAudioDeviceStateChangedIPC aDeviceState)
-    : Runnable("AudioDeviceMessageRunnableSC"),
-      mDeviceState(aDeviceState),
-      mMessageType(DEVICE_STATE_CHANGED),
-      mAudioNotification(aAudioNotification) {
-  // We increment the AudioNotification ref-count here -- the runnable will
-  // decrement it when it is done with us.
-  mAudioNotification->AddRef();
-}
-
-NS_IMETHODIMP
-AudioDeviceMessageRunnable::Run() {
-  StaticMutexAutoLock lock(sMutex);
-  PLUGIN_LOG_DEBUG(("Notifying %d plugins of audio device change.",
-                    mAudioNotification->GetModuleSet()->Count()));
-
-  bool success = true;
-  for (auto iter = mAudioNotification->GetModuleSet()->ConstIter();
-       !iter.Done(); iter.Next()) {
-    PluginModuleParent* pluginModule = iter.Get()->GetKey();
-    switch (mMessageType) {
-      case DEFAULT_DEVICE_CHANGED:
-        success &= pluginModule->SendNPP_SetValue_NPNVaudioDeviceChangeDetails(
-            mChangeDetails);
-        break;
-      case DEVICE_STATE_CHANGED:
-        success &= pluginModule->SendNPP_SetValue_NPNVaudioDeviceStateChanged(
-            mDeviceState);
-        break;
-      default:
-        MOZ_ASSERT_UNREACHABLE("bad AudioDeviceMessageRunnable state");
-    }
-  }
-  mAudioNotification->Release();
-  return success ? NS_OK : NS_ERROR_FAILURE;
-}
-
-}  // namespace PluginUtilsWin
-}  // namespace plugins
-}  // namespace mozilla
diff --git a/dom/plugins/ipc/PluginUtilsWin.h b/dom/plugins/ipc/PluginUtilsWin.h
deleted file mode 100644
index f3afa79d2c169..0000000000000
--- a/dom/plugins/ipc/PluginUtilsWin.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-// vim:set ts=2 sts=2 sw=2 et cin:
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef dom_plugins_PluginUtilsWin_h
-#define dom_plugins_PluginUtilsWin_h 1
-
-#include "npapi.h"
-#include "nscore.h"
-
-namespace mozilla {
-namespace plugins {
-
-class PluginModuleParent;
-
-namespace PluginUtilsWin {
-
-nsresult RegisterForAudioDeviceChanges(PluginModuleParent* aModuleParent,
-                                       bool aShouldRegister);
-
-}  // namespace PluginUtilsWin
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // dom_plugins_PluginUtilsWin_h
diff --git a/dom/plugins/ipc/StreamNotifyChild.h b/dom/plugins/ipc/StreamNotifyChild.h
deleted file mode 100644
index a08f37e723b81..0000000000000
--- a/dom/plugins/ipc/StreamNotifyChild.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
-/* vim: set sw=2 ts=2 et : */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_plugins_StreamNotifyChild_h
-#define mozilla_plugins_StreamNotifyChild_h
-
-#include "mozilla/plugins/PStreamNotifyChild.h"
-
-namespace mozilla {
-namespace plugins {
-
-class BrowserStreamChild;
-
-class StreamNotifyChild : public PStreamNotifyChild {
-  friend class PluginInstanceChild;
-  friend class BrowserStreamChild;
-  friend class PStreamNotifyChild;
-
- public:
-  explicit StreamNotifyChild(const nsCString& aURL)
-      : mURL(aURL), mClosure(nullptr), mBrowserStream(nullptr) {}
-
-  virtual void ActorDestroy(ActorDestroyReason why) override;
-
-  void SetValid(void* aClosure) { mClosure = aClosure; }
-
-  void NPP_URLNotify(NPReason reason);
-
- private:
-  mozilla::ipc::IPCResult Recv__delete__(const NPReason& reason);
-
-  mozilla::ipc::IPCResult RecvRedirectNotify(const nsCString& url,
-                                             const int32_t& status);
-
-  /**
-   * If a stream is created for this this URLNotify, we associate the objects
-   * so that the NPP_URLNotify call is not fired before the stream data is
-   * completely delivered. The BrowserStreamChild takes responsibility for
-   * calling NPP_URLNotify and deleting this object.
-   */
-  void SetAssociatedStream(BrowserStreamChild* bs);
-
-  nsCString mURL;
-  void* mClosure;
-
-  /**
-   * If mBrowserStream is true, it is responsible for deleting this C++ object
-   * and DeallocPStreamNotify is not, so that the delayed delivery of
-   * NPP_URLNotify is possible.
-   */
-  BrowserStreamChild* mBrowserStream;
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif
diff --git a/dom/plugins/ipc/StreamNotifyParent.h b/dom/plugins/ipc/StreamNotifyParent.h
deleted file mode 100644
index 6020f702ac68c..0000000000000
--- a/dom/plugins/ipc/StreamNotifyParent.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
-/* vim: set sw=2 ts=2 et : */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_plugins_StreamNotifyParent_h
-#define mozilla_plugins_StreamNotifyParent_h
-
-#include "mozilla/plugins/PStreamNotifyParent.h"
-
-namespace mozilla {
-namespace plugins {
-
-class StreamNotifyParent : public PStreamNotifyParent {
-  friend class PluginInstanceParent;
-  friend class PStreamNotifyParent;
-
-  StreamNotifyParent() : mDestructionFlag(nullptr) {}
-  ~StreamNotifyParent() {
-    if (mDestructionFlag) *mDestructionFlag = true;
-  }
-
- public:
-  // If we are destroyed within the call to NPN_GetURLNotify, notify the caller
-  // so that we aren't destroyed again. see bug 536437.
-  void SetDestructionFlag(bool* flag) { mDestructionFlag = flag; }
-  void ClearDestructionFlag() { mDestructionFlag = nullptr; }
-
-  virtual void ActorDestroy(ActorDestroyReason aWhy) override;
-
- private:
-  mozilla::ipc::IPCResult RecvRedirectNotifyResponse(const bool& allow);
-
-  bool* mDestructionFlag;
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif
diff --git a/dom/plugins/ipc/hangui/HangUIDlg.h b/dom/plugins/ipc/hangui/HangUIDlg.h
deleted file mode 100644
index 79cdfc74b4f23..0000000000000
--- a/dom/plugins/ipc/hangui/HangUIDlg.h
+++ /dev/null
@@ -1,17 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_plugins_HangUIDlg_h
-#define mozilla_plugins_HangUIDlg_h
-
-#define IDD_HANGUIDLG 102
-#define IDC_MSG 1000
-#define IDC_CONTINUE 1001
-#define IDC_STOP 1002
-#define IDC_NOFUTURE 1003
-#define IDC_DLGICON 1004
-
-#endif  // mozilla_plugins_HangUIDlg_h
diff --git a/dom/plugins/ipc/hangui/HangUIDlg.rc b/dom/plugins/ipc/hangui/HangUIDlg.rc
deleted file mode 100644
index 62e98ca249245..0000000000000
--- a/dom/plugins/ipc/hangui/HangUIDlg.rc
+++ /dev/null
@@ -1,26 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "HangUIDlg.h"
-#include <windows.h>
-
-LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
-
-/////////////////////////////////////////////////////////////////////////////
-//
-// Dialog
-//
-
-IDD_HANGUIDLG DIALOGEX 0, 0, 400, 75
-STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | DS_CENTER | WS_POPUP | WS_CAPTION | WS_SYSMENU
-CAPTION "Dialog"
-FONT 8, "MS Shell Dlg", 400, 0, 0x1
-BEGIN
-    DEFPUSHBUTTON   "Continue",IDC_CONTINUE,283,51,50,18
-    PUSHBUTTON      "Stop",IDC_STOP,341,51,50,18
-    CONTROL         "Check1",IDC_NOFUTURE,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,37,32,354,10
-    LTEXT           "Static",IDC_MSG,37,7,353,24
-    ICON            "",IDC_DLGICON,7,7,20,20
-END
-
diff --git a/dom/plugins/ipc/hangui/MiniShmBase.h b/dom/plugins/ipc/hangui/MiniShmBase.h
deleted file mode 100644
index 9782330b1298f..0000000000000
--- a/dom/plugins/ipc/hangui/MiniShmBase.h
+++ /dev/null
@@ -1,280 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_plugins_MiniShmBase_h
-#define mozilla_plugins_MiniShmBase_h
-
-#include "base/basictypes.h"
-
-#include "nsDebug.h"
-
-#include <windows.h>
-
-namespace mozilla {
-namespace plugins {
-
-/**
- * This class is used to provide RAII semantics for mapped views.
- * @see ScopedHandle
- */
-class ScopedMappedFileView {
- public:
-  explicit ScopedMappedFileView(LPVOID aView) : mView(aView) {}
-
-  ~ScopedMappedFileView() { Close(); }
-
-  void Close() {
-    if (mView) {
-      ::UnmapViewOfFile(mView);
-      mView = nullptr;
-    }
-  }
-
-  void Set(LPVOID aView) {
-    Close();
-    mView = aView;
-  }
-
-  LPVOID
-  Get() const { return mView; }
-
-  LPVOID
-  Take() {
-    LPVOID result = mView;
-    mView = nullptr;
-    return result;
-  }
-
-  operator LPVOID() { return mView; }
-
-  bool IsValid() const { return (mView); }
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(ScopedMappedFileView);
-
-  LPVOID mView;
-};
-
-class MiniShmBase;
-
-class MiniShmObserver {
- public:
-  /**
-   * This function is called whenever there is a new shared memory request.
-   * @param aMiniShmObj MiniShmBase object that may be used to read and
-   *                    write from shared memory.
-   */
-  virtual void OnMiniShmEvent(MiniShmBase* aMiniShmObj) = 0;
-  /**
-   * This function is called once when a MiniShmParent and a MiniShmChild
-   * object have successfully negotiated a connection.
-   *
-   * @param aMiniShmObj MiniShmBase object that may be used to read and
-   *                    write from shared memory.
-   */
-  virtual void OnMiniShmConnect(MiniShmBase* aMiniShmObj) {}
-};
-
-/**
- * Base class for MiniShm connections. This class defines the common
- * interfaces and code between parent and child.
- */
-class MiniShmBase {
- public:
-  /**
-   * Obtains a writable pointer into shared memory of type T.
-   * typename T must be plain-old-data and contain an unsigned integral
-   * member T::identifier that uniquely identifies T with respect to
-   * other types used by the protocol being implemented.
-   *
-   * @param aPtr Pointer to receive the shared memory address.
-   *             This value is set if and only if the function
-   *             succeeded.
-   * @return NS_OK if and only if aPtr was successfully obtained.
-   *         NS_ERROR_ILLEGAL_VALUE if type T is not valid for MiniShm.
-   *         NS_ERROR_NOT_INITIALIZED if there is no valid MiniShm connection.
-   *         NS_ERROR_NOT_AVAILABLE if the memory is not safe to write.
-   */
-  template <typename T>
-  nsresult GetWritePtr(T*& aPtr) {
-    if (!mWriteHeader || !mGuard) {
-      return NS_ERROR_NOT_INITIALIZED;
-    }
-    if (sizeof(T) > mPayloadMaxLen ||
-        (int)T::identifier <= (int)RESERVED_CODE_LAST) {
-      return NS_ERROR_ILLEGAL_VALUE;
-    }
-    if (::WaitForSingleObject(mGuard, mTimeout) != WAIT_OBJECT_0) {
-      return NS_ERROR_NOT_AVAILABLE;
-    }
-    mWriteHeader->mId = T::identifier;
-    mWriteHeader->mPayloadLen = sizeof(T);
-    aPtr = reinterpret_cast<T*>(mWriteHeader + 1);
-    return NS_OK;
-  }
-
-  /**
-   * Obtains a readable pointer into shared memory of type T.
-   * typename T must be plain-old-data and contain an unsigned integral
-   * member T::identifier that uniquely identifies T with respect to
-   * other types used by the protocol being implemented.
-   *
-   * @param aPtr Pointer to receive the shared memory address.
-   *             This value is set if and only if the function
-   *             succeeded.
-   * @return NS_OK if and only if aPtr was successfully obtained.
-   *         NS_ERROR_ILLEGAL_VALUE if type T is not valid for MiniShm or if
-   *                                type T does not match the type of the data
-   *                                stored in shared memory.
-   *         NS_ERROR_NOT_INITIALIZED if there is no valid MiniShm connection.
-   */
-  template <typename T>
-  nsresult GetReadPtr(const T*& aPtr) {
-    if (!mReadHeader) {
-      return NS_ERROR_NOT_INITIALIZED;
-    }
-    if (mReadHeader->mId != T::identifier ||
-        sizeof(T) != mReadHeader->mPayloadLen) {
-      return NS_ERROR_ILLEGAL_VALUE;
-    }
-    aPtr = reinterpret_cast<const T*>(mReadHeader + 1);
-    return NS_OK;
-  }
-
-  /**
-   * Fires the peer's event causing its request handler to execute.
-   *
-   * @return Should return NS_OK if the send was successful.
-   */
-  virtual nsresult Send() = 0;
-
- protected:
-  /**
-   * MiniShm reserves some identifier codes for its own use. Any
-   * identifiers used by MiniShm protocol implementations must be
-   * greater than RESERVED_CODE_LAST.
-   */
-  enum ReservedCodes {
-    RESERVED_CODE_INIT = 0,
-    RESERVED_CODE_INIT_COMPLETE = 1,
-    RESERVED_CODE_LAST = RESERVED_CODE_INIT_COMPLETE
-  };
-
-  struct MiniShmHeader {
-    unsigned int mId;
-    unsigned int mPayloadLen;
-  };
-
-  struct MiniShmInit {
-    enum identifier_t { identifier = RESERVED_CODE_INIT };
-    HANDLE mParentEvent;
-    HANDLE mParentGuard;
-    HANDLE mChildEvent;
-    HANDLE mChildGuard;
-  };
-
-  struct MiniShmInitComplete {
-    enum identifier_t { identifier = RESERVED_CODE_INIT_COMPLETE };
-    bool mSucceeded;
-  };
-
-  MiniShmBase()
-      : mObserver(nullptr),
-        mWriteHeader(nullptr),
-        mReadHeader(nullptr),
-        mPayloadMaxLen(0),
-        mGuard(nullptr),
-        mTimeout(INFINITE) {}
-  virtual ~MiniShmBase() {}
-
-  virtual void OnEvent() {
-    if (mObserver) {
-      mObserver->OnMiniShmEvent(this);
-    }
-  }
-
-  virtual void OnConnect() {
-    if (mObserver) {
-      mObserver->OnMiniShmConnect(this);
-    }
-  }
-
-  nsresult SetView(LPVOID aView, const unsigned int aSize, bool aIsChild) {
-    if (!aView || aSize <= 2 * sizeof(MiniShmHeader)) {
-      return NS_ERROR_ILLEGAL_VALUE;
-    }
-    // Divide the region into halves for parent and child
-    if (aIsChild) {
-      mReadHeader = static_cast<MiniShmHeader*>(aView);
-      mWriteHeader = reinterpret_cast<MiniShmHeader*>(
-          static_cast<char*>(aView) + aSize / 2U);
-    } else {
-      mWriteHeader = static_cast<MiniShmHeader*>(aView);
-      mReadHeader = reinterpret_cast<MiniShmHeader*>(static_cast<char*>(aView) +
-                                                     aSize / 2U);
-    }
-    mPayloadMaxLen = aSize / 2U - sizeof(MiniShmHeader);
-    return NS_OK;
-  }
-
-  nsresult SetGuard(HANDLE aGuard, DWORD aTimeout) {
-    if (!aGuard || !aTimeout) {
-      return NS_ERROR_ILLEGAL_VALUE;
-    }
-    mGuard = aGuard;
-    mTimeout = aTimeout;
-    return NS_OK;
-  }
-
-  inline void SetObserver(MiniShmObserver* aObserver) { mObserver = aObserver; }
-
-  /**
-   * Obtains a writable pointer into shared memory of type T. This version
-   * differs from GetWritePtr in that it allows typename T to be one of
-   * the private data structures declared in MiniShmBase.
-   *
-   * @param aPtr Pointer to receive the shared memory address.
-   *             This value is set if and only if the function
-   *             succeeded.
-   * @return NS_OK if and only if aPtr was successfully obtained.
-   *         NS_ERROR_ILLEGAL_VALUE if type T not an internal MiniShm struct.
-   *         NS_ERROR_NOT_INITIALIZED if there is no valid MiniShm connection.
-   */
-  template <typename T>
-  nsresult GetWritePtrInternal(T*& aPtr) {
-    if (!mWriteHeader) {
-      return NS_ERROR_NOT_INITIALIZED;
-    }
-    if (sizeof(T) > mPayloadMaxLen ||
-        (int)T::identifier > (int)RESERVED_CODE_LAST) {
-      return NS_ERROR_ILLEGAL_VALUE;
-    }
-    mWriteHeader->mId = T::identifier;
-    mWriteHeader->mPayloadLen = sizeof(T);
-    aPtr = reinterpret_cast<T*>(mWriteHeader + 1);
-    return NS_OK;
-  }
-
-  static VOID CALLBACK SOnEvent(PVOID aContext, BOOLEAN aIsTimer) {
-    MiniShmBase* object = static_cast<MiniShmBase*>(aContext);
-    object->OnEvent();
-  }
-
- private:
-  MiniShmObserver* mObserver;
-  MiniShmHeader* mWriteHeader;
-  MiniShmHeader* mReadHeader;
-  unsigned int mPayloadMaxLen;
-  HANDLE mGuard;
-  DWORD mTimeout;
-
-  DISALLOW_COPY_AND_ASSIGN(MiniShmBase);
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // mozilla_plugins_MiniShmBase_h
diff --git a/dom/plugins/ipc/hangui/MiniShmChild.cpp b/dom/plugins/ipc/hangui/MiniShmChild.cpp
deleted file mode 100644
index ec5a79714fb62..0000000000000
--- a/dom/plugins/ipc/hangui/MiniShmChild.cpp
+++ /dev/null
@@ -1,160 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "MiniShmChild.h"
-
-#include <limits>
-#include <sstream>
-
-namespace mozilla {
-namespace plugins {
-
-MiniShmChild::MiniShmChild()
-    : mParentEvent(nullptr),
-      mParentGuard(nullptr),
-      mChildEvent(nullptr),
-      mChildGuard(nullptr),
-      mFileMapping(nullptr),
-      mRegWait(nullptr),
-      mView(nullptr),
-      mTimeout(INFINITE) {}
-
-MiniShmChild::~MiniShmChild() {
-  if (mRegWait) {
-    ::UnregisterWaitEx(mRegWait, INVALID_HANDLE_VALUE);
-  }
-  if (mParentGuard) {
-    // Try to avoid shutting down while the parent's event handler is running.
-    ::WaitForSingleObject(mParentGuard, mTimeout);
-    ::CloseHandle(mParentGuard);
-  }
-  if (mParentEvent) {
-    ::CloseHandle(mParentEvent);
-  }
-  if (mChildEvent) {
-    ::CloseHandle(mChildEvent);
-  }
-  if (mChildGuard) {
-    ::CloseHandle(mChildGuard);
-  }
-  if (mView) {
-    ::UnmapViewOfFile(mView);
-  }
-  if (mFileMapping) {
-    ::CloseHandle(mFileMapping);
-  }
-}
-
-nsresult MiniShmChild::Init(MiniShmObserver* aObserver,
-                            const std::wstring& aCookie, const DWORD aTimeout) {
-  if (aCookie.empty() || !aTimeout) {
-    return NS_ERROR_ILLEGAL_VALUE;
-  }
-  if (mFileMapping) {
-    return NS_ERROR_ALREADY_INITIALIZED;
-  }
-  std::wistringstream iss(aCookie);
-  HANDLE mapHandle = nullptr;
-  iss >> mapHandle;
-  if (!iss) {
-    return NS_ERROR_ILLEGAL_VALUE;
-  }
-  ScopedMappedFileView view(
-      ::MapViewOfFile(mapHandle, FILE_MAP_WRITE, 0, 0, 0));
-  if (!view.IsValid()) {
-    return NS_ERROR_FAILURE;
-  }
-  MEMORY_BASIC_INFORMATION memInfo = {0};
-  SIZE_T querySize = ::VirtualQuery(view, &memInfo, sizeof(memInfo));
-  unsigned int mappingSize = 0;
-  if (querySize) {
-    if (memInfo.RegionSize <= std::numeric_limits<unsigned int>::max()) {
-      mappingSize = static_cast<unsigned int>(memInfo.RegionSize);
-    }
-  }
-  if (!querySize || !mappingSize) {
-    return NS_ERROR_FAILURE;
-  }
-  nsresult rv = SetView(view, mappingSize, true);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  const MiniShmInit* initStruct = nullptr;
-  rv = GetReadPtr(initStruct);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-  if (!initStruct->mParentEvent || !initStruct->mParentGuard ||
-      !initStruct->mChildEvent || !initStruct->mChildGuard) {
-    return NS_ERROR_FAILURE;
-  }
-  rv = SetGuard(initStruct->mParentGuard, aTimeout);
-  if (NS_FAILED(rv)) {
-    return rv;
-  }
-  if (!::RegisterWaitForSingleObject(&mRegWait, initStruct->mChildEvent,
-                                     &SOnEvent, this, INFINITE,
-                                     WT_EXECUTEDEFAULT)) {
-    return NS_ERROR_FAILURE;
-  }
-
-  MiniShmInitComplete* initCompleteStruct = nullptr;
-  rv = GetWritePtrInternal(initCompleteStruct);
-  if (NS_FAILED(rv)) {
-    ::UnregisterWaitEx(mRegWait, INVALID_HANDLE_VALUE);
-    mRegWait = nullptr;
-    return NS_ERROR_FAILURE;
-  }
-
-  initCompleteStruct->mSucceeded = true;
-
-  // We must set the member variables before we signal the event
-  mFileMapping = mapHandle;
-  mView = view.Take();
-  mParentEvent = initStruct->mParentEvent;
-  mParentGuard = initStruct->mParentGuard;
-  mChildEvent = initStruct->mChildEvent;
-  mChildGuard = initStruct->mChildGuard;
-  SetObserver(aObserver);
-  mTimeout = aTimeout;
-
-  rv = Send();
-  if (NS_FAILED(rv)) {
-    initCompleteStruct->mSucceeded = false;
-    mFileMapping = nullptr;
-    view.Set(mView);
-    mView = nullptr;
-    mParentEvent = nullptr;
-    mParentGuard = nullptr;
-    mChildEvent = nullptr;
-    mChildGuard = nullptr;
-    ::UnregisterWaitEx(mRegWait, INVALID_HANDLE_VALUE);
-    mRegWait = nullptr;
-    return rv;
-  }
-
-  OnConnect();
-  return NS_OK;
-}
-
-nsresult MiniShmChild::Send() {
-  if (!mParentEvent) {
-    return NS_ERROR_NOT_INITIALIZED;
-  }
-  if (!::SetEvent(mParentEvent)) {
-    return NS_ERROR_FAILURE;
-  }
-  return NS_OK;
-}
-
-void MiniShmChild::OnEvent() {
-  MiniShmBase::OnEvent();
-  ::SetEvent(mChildGuard);
-}
-
-}  // namespace plugins
-}  // namespace mozilla
diff --git a/dom/plugins/ipc/hangui/MiniShmChild.h b/dom/plugins/ipc/hangui/MiniShmChild.h
deleted file mode 100644
index ddaa3277b28cf..0000000000000
--- a/dom/plugins/ipc/hangui/MiniShmChild.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_plugins_MiniShmChild_h
-#define mozilla_plugins_MiniShmChild_h
-
-#include "MiniShmBase.h"
-
-#include <string>
-
-namespace mozilla {
-namespace plugins {
-
-/**
- * This class provides a lightweight shared memory interface for a child
- * process in Win32.
- * This code assumes that there is a parent-child relationship between
- * processes, as it inherits handles from the parent process.
- * Note that this class is *not* an IPDL actor.
- *
- * @see MiniShmParent
- */
-class MiniShmChild : public MiniShmBase {
- public:
-  MiniShmChild();
-  virtual ~MiniShmChild();
-
-  /**
-   * Initialize shared memory on the child side.
-   *
-   * @param aObserver A MiniShmObserver object to receive event notifications.
-   * @param aCookie Cookie obtained from MiniShmParent::GetCookie
-   * @param aTimeout Timeout in milliseconds.
-   * @return nsresult error code
-   */
-  nsresult Init(MiniShmObserver* aObserver, const std::wstring& aCookie,
-                const DWORD aTimeout);
-
-  virtual nsresult Send() override;
-
- protected:
-  void OnEvent() override;
-
- private:
-  HANDLE mParentEvent;
-  HANDLE mParentGuard;
-  HANDLE mChildEvent;
-  HANDLE mChildGuard;
-  HANDLE mFileMapping;
-  HANDLE mRegWait;
-  LPVOID mView;
-  DWORD mTimeout;
-
-  DISALLOW_COPY_AND_ASSIGN(MiniShmChild);
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // mozilla_plugins_MiniShmChild_h
diff --git a/dom/plugins/ipc/hangui/PluginHangUI.h b/dom/plugins/ipc/hangui/PluginHangUI.h
deleted file mode 100644
index c0880f18cc8e0..0000000000000
--- a/dom/plugins/ipc/hangui/PluginHangUI.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_plugins_PluginHangUI_h
-#define mozilla_plugins_PluginHangUI_h
-
-namespace mozilla {
-namespace plugins {
-
-enum HangUIUserResponse {
-  HANGUI_USER_RESPONSE_CANCEL = 1,
-  HANGUI_USER_RESPONSE_CONTINUE = 2,
-  HANGUI_USER_RESPONSE_STOP = 4,
-  HANGUI_USER_RESPONSE_DONT_SHOW_AGAIN = 8
-};
-
-enum PluginHangUIStructID {
-  PLUGIN_HANGUI_COMMAND = 0x10,
-  PLUGIN_HANGUI_RESULT
-};
-
-struct PluginHangUICommand {
-  enum { identifier = PLUGIN_HANGUI_COMMAND };
-  enum CmdCode { HANGUI_CMD_SHOW = 1, HANGUI_CMD_CANCEL = 2 };
-  CmdCode mCode;
-};
-
-struct PluginHangUIResponse {
-  enum { identifier = PLUGIN_HANGUI_RESULT };
-  unsigned int mResponseBits;
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // mozilla_plugins_PluginHangUI_h
diff --git a/dom/plugins/ipc/hangui/PluginHangUIChild.cpp b/dom/plugins/ipc/hangui/PluginHangUIChild.cpp
deleted file mode 100644
index 01bae5cb682c1..0000000000000
--- a/dom/plugins/ipc/hangui/PluginHangUIChild.cpp
+++ /dev/null
@@ -1,386 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "PluginHangUI.h"
-
-#include "PluginHangUIChild.h"
-#include "HangUIDlg.h"
-
-#include <assert.h>
-#include <commctrl.h>
-#include <windowsx.h>
-#include <algorithm>
-#include <sstream>
-#include <vector>
-
-namespace mozilla {
-namespace plugins {
-
-struct WinInfo {
-  WinInfo(HWND aHwnd, POINT& aPos, SIZE& aSize) : hwnd(aHwnd) {
-    pos.x = aPos.x;
-    pos.y = aPos.y;
-    size.cx = aSize.cx;
-    size.cy = aSize.cy;
-  }
-  HWND hwnd;
-  POINT pos;
-  SIZE size;
-};
-typedef std::vector<WinInfo> WinInfoVec;
-
-PluginHangUIChild* PluginHangUIChild::sSelf = nullptr;
-const int PluginHangUIChild::kExpectedMinimumArgc = 10;
-
-PluginHangUIChild::PluginHangUIChild()
-    : mResponseBits(0),
-      mParentWindow(nullptr),
-      mDlgHandle(nullptr),
-      mMainThread(nullptr),
-      mParentProcess(nullptr),
-      mRegWaitProcess(nullptr),
-      mIPCTimeoutMs(0) {}
-
-PluginHangUIChild::~PluginHangUIChild() {
-  if (mMainThread) {
-    CloseHandle(mMainThread);
-  }
-  if (mRegWaitProcess) {
-    UnregisterWaitEx(mRegWaitProcess, INVALID_HANDLE_VALUE);
-  }
-  if (mParentProcess) {
-    CloseHandle(mParentProcess);
-  }
-  sSelf = nullptr;
-}
-
-bool PluginHangUIChild::Init(int aArgc, wchar_t* aArgv[]) {
-  if (aArgc < kExpectedMinimumArgc) {
-    return false;
-  }
-  unsigned int i = 1;
-  mMessageText = aArgv[i];
-  mWindowTitle = aArgv[++i];
-  mWaitBtnText = aArgv[++i];
-  mKillBtnText = aArgv[++i];
-  mNoFutureText = aArgv[++i];
-  std::wistringstream issHwnd(aArgv[++i]);
-  issHwnd >> reinterpret_cast<HANDLE&>(mParentWindow);
-  if (!issHwnd) {
-    return false;
-  }
-  std::wistringstream issProc(aArgv[++i]);
-  issProc >> mParentProcess;
-  if (!issProc) {
-    return false;
-  }
-  // Only set the App User Model ID if it's present in the args
-  if (wcscmp(aArgv[++i], L"-")) {
-    HMODULE shell32 = LoadLibrary(L"shell32.dll");
-    if (shell32) {
-      SETAPPUSERMODELID fSetAppUserModelID = (SETAPPUSERMODELID)GetProcAddress(
-          shell32, "SetCurrentProcessExplicitAppUserModelID");
-      if (fSetAppUserModelID) {
-        fSetAppUserModelID(aArgv[i]);
-      }
-      FreeLibrary(shell32);
-    }
-  }
-  std::wistringstream issTimeout(aArgv[++i]);
-  issTimeout >> mIPCTimeoutMs;
-  if (!issTimeout) {
-    return false;
-  }
-
-  nsresult rv = mMiniShm.Init(this, std::wstring(aArgv[++i]),
-                              IsDebuggerPresent() ? INFINITE : mIPCTimeoutMs);
-  if (NS_FAILED(rv)) {
-    return false;
-  }
-  sSelf = this;
-  return true;
-}
-
-void PluginHangUIChild::OnMiniShmEvent(MiniShmBase* aMiniShmObj) {
-  const PluginHangUICommand* cmd = nullptr;
-  nsresult rv = aMiniShmObj->GetReadPtr(cmd);
-  assert(NS_SUCCEEDED(rv));
-  bool returnStatus = false;
-  if (NS_SUCCEEDED(rv)) {
-    switch (cmd->mCode) {
-      case PluginHangUICommand::HANGUI_CMD_SHOW:
-        returnStatus = RecvShow();
-        break;
-      case PluginHangUICommand::HANGUI_CMD_CANCEL:
-        returnStatus = RecvCancel();
-        break;
-      default:
-        break;
-    }
-  }
-}
-
-// static
-INT_PTR CALLBACK PluginHangUIChild::SHangUIDlgProc(HWND aDlgHandle,
-                                                   UINT aMsgCode,
-                                                   WPARAM aWParam,
-                                                   LPARAM aLParam) {
-  PluginHangUIChild* self = PluginHangUIChild::sSelf;
-  if (self) {
-    return self->HangUIDlgProc(aDlgHandle, aMsgCode, aWParam, aLParam);
-  }
-  return FALSE;
-}
-
-void PluginHangUIChild::ResizeButtons() {
-  // Control IDs are specified right-to-left as they appear in the dialog
-  UINT ids[] = {IDC_STOP, IDC_CONTINUE};
-  UINT numIds = sizeof(ids) / sizeof(ids[0]);
-
-  // Pass 1: Compute the ideal size
-  bool needResizing = false;
-  SIZE idealSize = {0};
-  WinInfoVec winInfo;
-  for (UINT i = 0; i < numIds; ++i) {
-    HWND wnd = GetDlgItem(mDlgHandle, ids[i]);
-    if (!wnd) {
-      return;
-    }
-
-    // Get the button's dimensions in screen coordinates
-    RECT curRect;
-    if (!GetWindowRect(wnd, &curRect)) {
-      return;
-    }
-
-    // Get (x,y) position of the button in client coordinates
-    POINT pt;
-    pt.x = curRect.left;
-    pt.y = curRect.top;
-    if (!ScreenToClient(mDlgHandle, &pt)) {
-      return;
-    }
-
-    // Request the button's text margins
-    RECT margins;
-    if (!Button_GetTextMargin(wnd, &margins)) {
-      return;
-    }
-
-    // Compute the button's width and height
-    SIZE curSize;
-    curSize.cx = curRect.right - curRect.left;
-    curSize.cy = curRect.bottom - curRect.top;
-
-    // Request the button's ideal width and height and add in the margins
-    SIZE size = {0};
-    if (!Button_GetIdealSize(wnd, &size)) {
-      return;
-    }
-    size.cx += margins.left + margins.right;
-    size.cy += margins.top + margins.bottom;
-
-    // Size all buttons to be the same width as the longest button encountered
-    idealSize.cx = std::max(idealSize.cx, size.cx);
-    idealSize.cy = std::max(idealSize.cy, size.cy);
-
-    // We won't bother resizing unless we need extra space
-    if (idealSize.cx > curSize.cx) {
-      needResizing = true;
-    }
-
-    // Save the relevant info for the resize, if any. We do this even if
-    // needResizing is false because another button may trigger a resize later.
-    winInfo.push_back(WinInfo(wnd, pt, curSize));
-  }
-
-  if (!needResizing) {
-    return;
-  }
-
-  // Pass 2: Resize the windows
-  int deltaX = 0;
-  HDWP hwp = BeginDeferWindowPos((int)winInfo.size());
-  if (!hwp) {
-    return;
-  }
-  for (WinInfoVec::const_iterator itr = winInfo.begin(); itr != winInfo.end();
-       ++itr) {
-    // deltaX accumulates the size changes so that each button's x coordinate
-    // can compensate for the width increases
-    deltaX += idealSize.cx - itr->size.cx;
-    hwp = DeferWindowPos(hwp, itr->hwnd, nullptr, itr->pos.x - deltaX,
-                         itr->pos.y, idealSize.cx, itr->size.cy,
-                         SWP_NOZORDER | SWP_NOACTIVATE);
-    if (!hwp) {
-      return;
-    }
-  }
-  EndDeferWindowPos(hwp);
-}
-
-INT_PTR
-PluginHangUIChild::HangUIDlgProc(HWND aDlgHandle, UINT aMsgCode, WPARAM aWParam,
-                                 LPARAM aLParam) {
-  mDlgHandle = aDlgHandle;
-  switch (aMsgCode) {
-    case WM_INITDIALOG: {
-      // Register a wait on the Firefox process so that we will be informed
-      // if it dies while the dialog is showing
-      RegisterWaitForSingleObject(&mRegWaitProcess, mParentProcess,
-                                  &SOnParentProcessExit, this, INFINITE,
-                                  WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE);
-      SetWindowText(aDlgHandle, mWindowTitle);
-      SetDlgItemText(aDlgHandle, IDC_MSG, mMessageText);
-      SetDlgItemText(aDlgHandle, IDC_NOFUTURE, mNoFutureText);
-      SetDlgItemText(aDlgHandle, IDC_CONTINUE, mWaitBtnText);
-      SetDlgItemText(aDlgHandle, IDC_STOP, mKillBtnText);
-      ResizeButtons();
-      HANDLE icon = LoadImage(nullptr, IDI_QUESTION, IMAGE_ICON, 0, 0,
-                              LR_DEFAULTSIZE | LR_SHARED);
-      if (icon) {
-        SendDlgItemMessage(aDlgHandle, IDC_DLGICON, STM_SETICON, (WPARAM)icon,
-                           0);
-      }
-      EnableWindow(mParentWindow, FALSE);
-      return TRUE;
-    }
-    case WM_CLOSE: {
-      mResponseBits |= HANGUI_USER_RESPONSE_CANCEL;
-      EndDialog(aDlgHandle, 0);
-      SetWindowLongPtr(aDlgHandle, DWLP_MSGRESULT, 0);
-      return TRUE;
-    }
-    case WM_COMMAND: {
-      switch (LOWORD(aWParam)) {
-        case IDC_CONTINUE:
-          if (HIWORD(aWParam) == BN_CLICKED) {
-            mResponseBits |= HANGUI_USER_RESPONSE_CONTINUE;
-            EndDialog(aDlgHandle, 1);
-            SetWindowLongPtr(aDlgHandle, DWLP_MSGRESULT, 0);
-            return TRUE;
-          }
-          break;
-        case IDC_STOP:
-          if (HIWORD(aWParam) == BN_CLICKED) {
-            mResponseBits |= HANGUI_USER_RESPONSE_STOP;
-            EndDialog(aDlgHandle, 1);
-            SetWindowLongPtr(aDlgHandle, DWLP_MSGRESULT, 0);
-            return TRUE;
-          }
-          break;
-        case IDC_NOFUTURE:
-          if (HIWORD(aWParam) == BN_CLICKED) {
-            if (Button_GetCheck(GetDlgItem(aDlgHandle, IDC_NOFUTURE)) ==
-                BST_CHECKED) {
-              mResponseBits |= HANGUI_USER_RESPONSE_DONT_SHOW_AGAIN;
-            } else {
-              mResponseBits &=
-                  ~static_cast<DWORD>(HANGUI_USER_RESPONSE_DONT_SHOW_AGAIN);
-            }
-            SetWindowLongPtr(aDlgHandle, DWLP_MSGRESULT, 0);
-            return TRUE;
-          }
-          break;
-        default:
-          break;
-      }
-      break;
-    }
-    case WM_DESTROY: {
-      EnableWindow(mParentWindow, TRUE);
-      SetForegroundWindow(mParentWindow);
-      break;
-    }
-    default:
-      break;
-  }
-  return FALSE;
-}
-
-// static
-VOID CALLBACK PluginHangUIChild::SOnParentProcessExit(PVOID aObject,
-                                                      BOOLEAN aIsTimer) {
-  // Simulate a cancel if the parent process died
-  PluginHangUIChild* object = static_cast<PluginHangUIChild*>(aObject);
-  object->RecvCancel();
-}
-
-bool PluginHangUIChild::RecvShow() {
-  return (
-      QueueUserAPC(&ShowAPC, mMainThread, reinterpret_cast<ULONG_PTR>(this)));
-}
-
-bool PluginHangUIChild::Show() {
-  INT_PTR dlgResult =
-      DialogBox(GetModuleHandle(nullptr), MAKEINTRESOURCE(IDD_HANGUIDLG),
-                nullptr, &SHangUIDlgProc);
-  mDlgHandle = nullptr;
-  assert(dlgResult != -1);
-  bool result = false;
-  if (dlgResult != -1) {
-    PluginHangUIResponse* response = nullptr;
-    nsresult rv = mMiniShm.GetWritePtr(response);
-    if (NS_SUCCEEDED(rv)) {
-      response->mResponseBits = mResponseBits;
-      result = NS_SUCCEEDED(mMiniShm.Send());
-    }
-  }
-  return result;
-}
-
-// static
-VOID CALLBACK PluginHangUIChild::ShowAPC(ULONG_PTR aContext) {
-  PluginHangUIChild* object = reinterpret_cast<PluginHangUIChild*>(aContext);
-  object->Show();
-}
-
-bool PluginHangUIChild::RecvCancel() {
-  if (mDlgHandle) {
-    PostMessage(mDlgHandle, WM_CLOSE, 0, 0);
-  }
-  return true;
-}
-
-bool PluginHangUIChild::WaitForDismissal() {
-  if (!SetMainThread()) {
-    return false;
-  }
-  DWORD waitResult = WaitForSingleObjectEx(mParentProcess, mIPCTimeoutMs, TRUE);
-  return waitResult == WAIT_OBJECT_0 || waitResult == WAIT_IO_COMPLETION;
-}
-
-bool PluginHangUIChild::SetMainThread() {
-  if (mMainThread) {
-    CloseHandle(mMainThread);
-    mMainThread = nullptr;
-  }
-  mMainThread = OpenThread(THREAD_SET_CONTEXT, FALSE, GetCurrentThreadId());
-  return !(!mMainThread);
-}
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#ifdef __MINGW32__
-extern "C"
-#endif
-    int
-    wmain(int argc, wchar_t* argv[]) {
-  INITCOMMONCONTROLSEX icc = {sizeof(INITCOMMONCONTROLSEX),
-                              ICC_STANDARD_CLASSES};
-  if (!InitCommonControlsEx(&icc)) {
-    return 1;
-  }
-  mozilla::plugins::PluginHangUIChild hangui;
-  if (!hangui.Init(argc, argv)) {
-    return 1;
-  }
-  if (!hangui.WaitForDismissal()) {
-    return 1;
-  }
-  return 0;
-}
diff --git a/dom/plugins/ipc/hangui/PluginHangUIChild.h b/dom/plugins/ipc/hangui/PluginHangUIChild.h
deleted file mode 100644
index d21c7176662a8..0000000000000
--- a/dom/plugins/ipc/hangui/PluginHangUIChild.h
+++ /dev/null
@@ -1,100 +0,0 @@
-/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* vim: set ts=2 et sw=2 tw=80: */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_plugins_PluginHangUIChild_h
-#define mozilla_plugins_PluginHangUIChild_h
-
-#include "MiniShmChild.h"
-
-#include <string>
-
-#include <windows.h>
-
-namespace mozilla {
-namespace plugins {
-
-/**
- * This class implements the plugin-hang-ui.
- *
- * NOTE: PluginHangUIChild is *not* an IPDL actor! In this case, "Child"
- *       is describing the fact that plugin-hang-ui is a child process to the
- *       firefox process, which is the PluginHangUIParent.
- *       PluginHangUIParent and PluginHangUIChild are a matched pair.
- * @see PluginHangUIParent
- */
-class PluginHangUIChild : public MiniShmObserver {
- public:
-  PluginHangUIChild();
-  virtual ~PluginHangUIChild();
-
-  bool Init(int aArgc, wchar_t* aArgv[]);
-
-  /**
-   * Displays the Plugin Hang UI and does not return until the UI has
-   * been dismissed.
-   *
-   * @return true if the UI was displayed and the user response was
-   *         successfully sent back to the parent. Otherwise false.
-   */
-  bool Show();
-
-  /**
-   * Causes the calling thread to wait either for the Hang UI to be
-   * dismissed or for the parent process to terminate. This should
-   * be called by the main thread.
-   *
-   * @return true unless there was an error initiating the wait
-   */
-  bool WaitForDismissal();
-
-  virtual void OnMiniShmEvent(MiniShmBase* aMiniShmObj) override;
-
- private:
-  bool RecvShow();
-
-  bool RecvCancel();
-
-  bool SetMainThread();
-
-  void ResizeButtons();
-
-  INT_PTR
-  HangUIDlgProc(HWND aDlgHandle, UINT aMsgCode, WPARAM aWParam, LPARAM aLParam);
-
-  static VOID CALLBACK ShowAPC(ULONG_PTR aContext);
-
-  static INT_PTR CALLBACK SHangUIDlgProc(HWND aDlgHandle, UINT aMsgCode,
-                                         WPARAM aWParam, LPARAM aLParam);
-
-  static VOID CALLBACK SOnParentProcessExit(PVOID aObject, BOOLEAN aIsTimer);
-
-  static PluginHangUIChild* sSelf;
-
-  const wchar_t* mMessageText;
-  const wchar_t* mWindowTitle;
-  const wchar_t* mWaitBtnText;
-  const wchar_t* mKillBtnText;
-  const wchar_t* mNoFutureText;
-  unsigned int mResponseBits;
-  HWND mParentWindow;
-  HWND mDlgHandle;
-  HANDLE mMainThread;
-  HANDLE mParentProcess;
-  HANDLE mRegWaitProcess;
-  DWORD mIPCTimeoutMs;
-  MiniShmChild mMiniShm;
-
-  static const int kExpectedMinimumArgc;
-
-  typedef HRESULT(WINAPI* SETAPPUSERMODELID)(PCWSTR);
-
-  DISALLOW_COPY_AND_ASSIGN(PluginHangUIChild);
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // mozilla_plugins_PluginHangUIChild_h
diff --git a/dom/plugins/ipc/hangui/module.ver b/dom/plugins/ipc/hangui/module.ver
deleted file mode 100644
index d11506f4a1819..0000000000000
--- a/dom/plugins/ipc/hangui/module.ver
+++ /dev/null
@@ -1,6 +0,0 @@
-WIN32_MODULE_COMPANYNAME=Mozilla Corporation
-WIN32_MODULE_PRODUCTVERSION=@MOZ_APP_WINVERSION@
-WIN32_MODULE_PRODUCTVERSION_STRING=@MOZ_APP_VERSION@
-WIN32_MODULE_DESCRIPTION=Plugin Hang UI for @MOZ_APP_DISPLAYNAME@
-WIN32_MODULE_PRODUCTNAME=@MOZ_APP_DISPLAYNAME@
-WIN32_MODULE_NAME=@MOZ_APP_DISPLAYNAME@
diff --git a/dom/plugins/ipc/hangui/moz.build b/dom/plugins/ipc/hangui/moz.build
deleted file mode 100644
index db07f43d9be43..0000000000000
--- a/dom/plugins/ipc/hangui/moz.build
+++ /dev/null
@@ -1,27 +0,0 @@
-# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
-# vim: set filetype=python:
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-Program("plugin-hang-ui")
-
-UNIFIED_SOURCES += [
-    "MiniShmChild.cpp",
-    "PluginHangUIChild.cpp",
-]
-include("/ipc/chromium/chromium-config.mozbuild")
-
-DEFINES["NS_NO_XPCOM"] = True
-DEFINES["_HAS_EXCEPTIONS"] = 0
-
-DisableStlWrapping()
-
-if CONFIG["CC_TYPE"] in ("clang", "gcc"):
-    WIN32_EXE_LDFLAGS += ["-municode"]
-
-RCINCLUDE = "HangUIDlg.rc"
-
-OS_LIBS += [
-    "comctl32",
-]
diff --git a/dom/plugins/ipc/hangui/plugin-hang-ui.exe.manifest b/dom/plugins/ipc/hangui/plugin-hang-ui.exe.manifest
deleted file mode 100644
index f5b7345f992eb..0000000000000
--- a/dom/plugins/ipc/hangui/plugin-hang-ui.exe.manifest
+++ /dev/null
@@ -1,37 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
-<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
-<assemblyIdentity
-        version="1.0.0.0"
-        processorArchitecture="*"
-        name="plugin-hang-ui"
-        type="win32"
-/>
-<description>Firefox Plugin Hang User Interface</description>
-<dependency>
-        <dependentAssembly>
-                <assemblyIdentity
-                        type="win32"
-                        name="Microsoft.Windows.Common-Controls"
-                        version="6.0.0.0"
-                        processorArchitecture="*"
-                        publicKeyToken="6595b64144ccf1df"
-                        language="*"
-                />
-        </dependentAssembly>
-</dependency>
-  <ms_asmv3:trustInfo xmlns:ms_asmv3="urn:schemas-microsoft-com:asm.v3">
-    <ms_asmv3:security>
-      <ms_asmv3:requestedPrivileges>
-        <ms_asmv3:requestedExecutionLevel level="asInvoker" uiAccess="false" />
-      </ms_asmv3:requestedPrivileges>
-    </ms_asmv3:security>
-  </ms_asmv3:trustInfo>
-  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
-    <application>
-      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
-      <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
-      <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
-      <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
-    </application>
-  </compatibility>
-</assembly>
diff --git a/dom/plugins/ipc/moz.build b/dom/plugins/ipc/moz.build
deleted file mode 100644
index 4bc7d8c91bb70..0000000000000
--- a/dom/plugins/ipc/moz.build
+++ /dev/null
@@ -1,124 +0,0 @@
-# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
-# vim: set filetype=python:
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-EXPORTS.mozilla += [
-    "PluginLibrary.h",
-]
-
-EXPORTS.mozilla.plugins += [
-    "AStream.h",
-    "BrowserStreamChild.h",
-    "BrowserStreamParent.h",
-    "ChildTimer.h",
-    "FunctionBrokerIPCUtils.h",
-    "IpdlTuple.h",
-    "NPEventAndroid.h",
-    "NPEventOSX.h",
-    "NPEventUnix.h",
-    "NPEventWindows.h",
-    "PluginBridge.h",
-    "PluginInstanceChild.h",
-    "PluginInstanceParent.h",
-    "PluginMessageUtils.h",
-    "PluginModuleChild.h",
-    "PluginModuleParent.h",
-    "PluginProcessChild.h",
-    "PluginProcessParent.h",
-    "PluginQuirks.h",
-    "PluginScriptableObjectChild.h",
-    "PluginScriptableObjectParent.h",
-    "PluginScriptableObjectUtils-inl.h",
-    "PluginScriptableObjectUtils.h",
-    "PluginUtilsOSX.h",
-    "StreamNotifyChild.h",
-    "StreamNotifyParent.h",
-]
-
-if CONFIG["OS_ARCH"] == "WINNT":
-    UNIFIED_SOURCES += [
-        "PluginHangUIParent.cpp",
-    ]
-    SOURCES += [
-        "MiniShmParent.cpp",  # Issues with CreateEvent
-    ]
-    DEFINES["MOZ_HANGUI_PROCESS_NAME"] = '"plugin-hang-ui%s"' % CONFIG["BIN_SUFFIX"]
-    LOCAL_INCLUDES += [
-        "/widget",
-        "hangui",
-    ]
-
-UNIFIED_SOURCES += [
-    "BrowserStreamChild.cpp",
-    "BrowserStreamParent.cpp",
-    "ChildTimer.cpp",
-    "FunctionBroker.cpp",
-    "FunctionBrokerChild.cpp",
-    "FunctionBrokerIPCUtils.cpp",
-    "FunctionBrokerParent.cpp",
-    "FunctionHook.cpp",
-    "PluginBackgroundDestroyer.cpp",
-    "PluginInstanceParent.cpp",
-    "PluginMessageUtils.cpp",
-    "PluginModuleChild.cpp",
-    "PluginModuleParent.cpp",
-    "PluginProcessChild.cpp",
-    "PluginProcessParent.cpp",
-    "PluginQuirks.cpp",
-    "PluginScriptableObjectChild.cpp",
-    "PluginScriptableObjectParent.cpp",
-]
-
-SOURCES += [
-    "PluginInstanceChild.cpp",  # 'PluginThreadCallback' : ambiguous symbol
-]
-
-if CONFIG["MOZ_WIDGET_TOOLKIT"] == "cocoa":
-    UNIFIED_SOURCES += [
-        "PluginUtilsOSX.mm",
-    ]
-
-IPDL_SOURCES += [
-    "PBrowserStream.ipdl",
-    "PFunctionBroker.ipdl",
-    "PluginTypes.ipdlh",
-    "PPluginBackgroundDestroyer.ipdl",
-    "PPluginInstance.ipdl",
-    "PPluginModule.ipdl",
-    "PPluginScriptableObject.ipdl",
-    "PStreamNotify.ipdl",
-]
-
-include("/ipc/chromium/chromium-config.mozbuild")
-
-# Add libFuzzer configuration directives
-include("/tools/fuzzing/libfuzzer-config.mozbuild")
-
-FINAL_LIBRARY = "xul"
-LOCAL_INCLUDES += [
-    "../base",
-    "/xpcom/base/",
-    "/xpcom/threads/",
-]
-
-if CONFIG["MOZ_SANDBOX"] and CONFIG["OS_ARCH"] == "WINNT":
-    LOCAL_INCLUDES += [
-        "/security/sandbox/chromium",
-        "/security/sandbox/chromium-shim",
-        "/security/sandbox/win/src/sandboxpermissions",
-    ]
-
-DEFINES["FORCE_PR_LOG"] = True
-
-if CONFIG["MOZ_WIDGET_TOOLKIT"] != "gtk":
-    CXXFLAGS += CONFIG["TK_CFLAGS"]
-else:
-    # Force build against gtk+2 for struct offsets and such.
-    CXXFLAGS += CONFIG["MOZ_GTK2_CFLAGS"]
-
-CXXFLAGS += CONFIG["MOZ_CAIRO_CFLAGS"]
-
-if CONFIG["CC_TYPE"] in ("clang", "gcc"):
-    CXXFLAGS += ["-Wno-error=shadow"]
diff --git a/dom/webidl/HTMLObjectElement.webidl b/dom/webidl/HTMLObjectElement.webidl
index 3365d633f3fc6..cdd957bd2819a 100644
--- a/dom/webidl/HTMLObjectElement.webidl
+++ b/dom/webidl/HTMLObjectElement.webidl
@@ -194,13 +194,6 @@ interface mixin MozObjectLoadingContent {
   [ChromeOnly]
   readonly attribute unsigned long pluginFallbackType;
 
-  /**
-   * If this object currently owns a running plugin, regardless of whether or
-   * not one is pending spawn/despawn.
-   */
-  [ChromeOnly]
-  readonly attribute boolean hasRunningPlugin;
-
   /**
    * Disable the use of fake plugins and reload the tag if necessary
    */
diff --git a/ipc/glue/ProcessUtils_mac.mm b/ipc/glue/ProcessUtils_mac.mm
index 0991738f9aef5..8d9f74e7fbcd5 100644
--- a/ipc/glue/ProcessUtils_mac.mm
+++ b/ipc/glue/ProcessUtils_mac.mm
@@ -4,15 +4,104 @@
 
 #include "ProcessUtils.h"
 
+#include "nsObjCExceptions.h"
+#include "nsCocoaUtils.h"
 #include "nsString.h"
+#include "mozilla/Sprintf.h"
 
-#include "mozilla/plugins/PluginUtilsOSX.h"
+#define UNDOCUMENTED_SESSION_CONSTANT ((int)-2)
 
 namespace mozilla {
 namespace ipc {
 
-void SetThisProcessName(const char* aName) {
-  mozilla::plugins::PluginUtilsOSX::SetProcessName(aName);
+static void* sApplicationASN = NULL;
+static void* sApplicationInfoItem = NULL;
+
+void SetThisProcessName(const char* aProcessName) {
+  NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
+  nsAutoreleasePool localPool;
+
+  if (!aProcessName || strcmp(aProcessName, "") == 0) {
+    return;
+  }
+
+  NSString* currentName =
+      [[[NSBundle mainBundle] localizedInfoDictionary] objectForKey:(NSString*)kCFBundleNameKey];
+
+  char formattedName[1024];
+  SprintfLiteral(formattedName, "%s %s", [currentName UTF8String], aProcessName);
+
+  aProcessName = formattedName;
+
+  // This function is based on Chrome/Webkit's and relies on potentially dangerous SPI.
+  typedef CFTypeRef (*LSGetASNType)();
+  typedef OSStatus (*LSSetInformationItemType)(int, CFTypeRef, CFStringRef, CFStringRef,
+                                               CFDictionaryRef*);
+
+  CFBundleRef launchServices = ::CFBundleGetBundleWithIdentifier(CFSTR("com.apple.LaunchServices"));
+  if (!launchServices) {
+    NS_WARNING("Failed to set process name: Could not open LaunchServices bundle");
+    return;
+  }
+
+  if (!sApplicationASN) {
+    sApplicationASN =
+        ::CFBundleGetFunctionPointerForName(launchServices, CFSTR("_LSGetCurrentApplicationASN"));
+    if (!sApplicationASN) {
+      NS_WARNING("Failed to set process name: Could not get function pointer "
+                 "for LaunchServices");
+      return;
+    }
+  }
+
+  LSGetASNType getASNFunc = reinterpret_cast<LSGetASNType>(sApplicationASN);
+
+  if (!sApplicationInfoItem) {
+    sApplicationInfoItem = ::CFBundleGetFunctionPointerForName(
+        launchServices, CFSTR("_LSSetApplicationInformationItem"));
+  }
+
+  LSSetInformationItemType setInformationItemFunc =
+      reinterpret_cast<LSSetInformationItemType>(sApplicationInfoItem);
+
+  void* displayNameKeyAddr =
+      ::CFBundleGetDataPointerForName(launchServices, CFSTR("_kLSDisplayNameKey"));
+
+  CFStringRef displayNameKey = nil;
+  if (displayNameKeyAddr) {
+    displayNameKey = reinterpret_cast<CFStringRef>(*(CFStringRef*)displayNameKeyAddr);
+  }
+
+  // Rename will fail without this
+  ProcessSerialNumber psn;
+  if (::GetCurrentProcess(&psn) != noErr) {
+    return;
+  }
+
+  CFTypeRef currentAsn = getASNFunc ? getASNFunc() : nullptr;
+
+  if (!getASNFunc || !setInformationItemFunc || !displayNameKey || !currentAsn) {
+    NS_WARNING("Failed to set process name: Accessing launchServices failed");
+    return;
+  }
+
+  CFStringRef processName = ::CFStringCreateWithCString(nil, aProcessName, kCFStringEncodingASCII);
+  if (!processName) {
+    NS_WARNING("Failed to set process name: Could not create CFStringRef");
+    return;
+  }
+
+  OSErr err =
+      setInformationItemFunc(UNDOCUMENTED_SESSION_CONSTANT, currentAsn, displayNameKey, processName,
+                             nil);  // Optional out param
+  ::CFRelease(processName);
+  if (err != noErr) {
+    NS_WARNING("Failed to set process name: LSSetInformationItemType err");
+    return;
+  }
+
+  return;
+  NS_OBJC_END_TRY_ABORT_BLOCK;
 }
 
 }  // namespace ipc
diff --git a/ipc/ipdl/sync-messages.ini b/ipc/ipdl/sync-messages.ini
index 4bfc4ac43e3b9..bb4e8832800a2 100644
--- a/ipc/ipdl/sync-messages.ini
+++ b/ipc/ipdl/sync-messages.ini
@@ -657,14 +657,8 @@ description = Legacy NPAPI IPC
 description = Legacy NPAPI IPC
 [PFunctionBroker::BrokerFunction]
 description = Legacy NPAPI IPC
-[PPluginInstance::CreateChildPluginWindow]
-description = Legacy NPAPI IPC
-[PPluginInstance::NPP_SetWindow]
-description = Legacy NPAPI IPC
 [PPluginInstance::NPP_GetValue_NPPVpluginWantsAllNetworkStreams]
 description = Legacy NPAPI IPC
-[PPluginInstance::NPP_GetValue_NPPVpluginScriptableNPObject]
-description = Legacy NPAPI IPC
 [PPluginInstance::NPP_SetValue_NPNVprivateModeBool]
 description = Legacy NPAPI IPC
 [PPluginInstance::NPP_GetValue_NPPVpluginNativeAccessibleAtkPlugId]
@@ -673,28 +667,12 @@ description = Legacy NPAPI IPC
 description = Legacy NPAPI IPC
 [PPluginInstance::NPP_SetValue_NPNVmuteAudioBool]
 description = Legacy NPAPI IPC
-[PPluginInstance::NPP_HandleEvent]
-description = Legacy NPAPI IPC
-[PPluginInstance::NPP_HandleEvent_Shmem]
-description = Legacy NPAPI IPC
-[PPluginInstance::NPP_HandleEvent_IOSurface]
-description = Legacy NPAPI IPC
-[PPluginInstance::Paint]
-description = Legacy NPAPI IPC
 [PPluginInstance::NPP_Destroy]
 description = Legacy NPAPI IPC
-[PPluginInstance::NPN_GetValue_NPNVWindowNPObject]
-description = Legacy NPAPI IPC
-[PPluginInstance::NPN_GetValue_NPNVPluginElementNPObject]
-description = Legacy NPAPI IPC
 [PPluginInstance::NPN_GetValue_NPNVprivateModeBool]
 description = Legacy NPAPI IPC
-[PPluginInstance::NPN_GetValue_NPNVnetscapeWindow]
-description = Legacy NPAPI IPC
 [PPluginInstance::NPN_GetValue_NPNVdocumentOrigin]
 description = Legacy NPAPI IPC
-[PPluginInstance::NPN_GetValue_DrawingModelSupport]
-description = Legacy NPAPI IPC
 [PPluginInstance::NPN_GetValue_SupportsAsyncBitmapSurface]
 description = Legacy NPAPI IPC
 [PPluginInstance::NPN_GetValue_SupportsAsyncDXGISurface]
@@ -717,8 +695,6 @@ description = Legacy NPAPI IPC
 description = Legacy NPAPI IPC
 [PPluginInstance::NPN_PostURL]
 description = Legacy NPAPI IPC
-[PPluginInstance::PStreamNotify]
-description = Legacy NPAPI IPC
 [PPluginInstance::RevokeCurrentDirectSurface]
 description = Legacy NPAPI IPC
 [PPluginInstance::InitDXGISurface]
@@ -729,22 +705,12 @@ description = Legacy NPAPI IPC
 description = Legacy NPAPI IPC
 [PPluginInstance::ShowDirectDXGISurface]
 description = Legacy NPAPI IPC
-[PPluginInstance::Show]
-description = Legacy NPAPI IPC
 [PPluginInstance::NPN_PushPopupsEnabledState]
 description = Legacy NPAPI IPC
 [PPluginInstance::NPN_PopPopupsEnabledState]
 description = Legacy NPAPI IPC
-[PPluginInstance::NPN_GetValueForURL]
-description = Legacy NPAPI IPC
-[PPluginInstance::NPN_SetValueForURL]
-description = Legacy NPAPI IPC
-[PPluginInstance::NPN_ConvertPoint]
-description = Legacy NPAPI IPC
 [PPluginInstance::GetCompositionString]
 description = Legacy NPAPI IPC
-[PPluginInstance::NPP_NewStream]
-description = Legacy NPAPI IPC
 [PPluginInstance::PluginFocusChange]
 description = Legacy NPAPI IPC
 [PPluginInstance::SetPluginFocus]
@@ -832,10 +798,6 @@ description = test only
 description = test only
 [PContent::SyncMessage]
 description = JS MessageManager implementation
-[PContent::LoadPlugin]
-description = Legacy NPAPI IPC
-[PContent::ConnectPluginBridge]
-description = Legacy NPAPI IPC
 [PContent::IsSecureURI]
 description = legacy sync IPC - please add detailed description
 [PContent::PURLClassifier]
diff --git a/tools/lint/rejected-words.yml b/tools/lint/rejected-words.yml
index e663ecc4821b3..a9260c471ae1f 100644
--- a/tools/lint/rejected-words.yml
+++ b/tools/lint/rejected-words.yml
@@ -129,7 +129,6 @@ avoid-blacklist-and-whitelist:
         - dom/media/webrtc/transport/stun_socket_filter.cpp
         - dom/media/webrtc/transport/test/ice_unittest.cpp
         - dom/plugins/base/nsPluginHost.h
-        - dom/plugins/ipc/PluginQuirks.cpp
         - dom/push/PushServiceWebSocket.jsm
         - dom/security/nsCSPContext.cpp
         - dom/security/nsCSPService.cpp
diff --git a/widget/nsIPluginWidget.h b/widget/nsIPluginWidget.h
index 9dcd04679bf2a..becc577784ce7 100644
--- a/widget/nsIPluginWidget.h
+++ b/widget/nsIPluginWidget.h
@@ -13,8 +13,6 @@
     }                                                \
   }
 
-class nsIPluginInstanceOwner;
-
 /**
  * This is used by Mac only.
  */
@@ -29,9 +27,6 @@ class NS_NO_VTABLE nsIPluginWidget : public nsISupports {
 
   NS_IMETHOD EndDrawPlugin(void) = 0;
 
-  NS_IMETHOD SetPluginInstanceOwner(
-      nsIPluginInstanceOwner* pluginInstanceOwner) = 0;
-
   NS_IMETHOD SetPluginEventModel(int inEventModel) = 0;
 
   NS_IMETHOD GetPluginEventModel(int* outEventModel) = 0;
diff --git a/widget/windows/nsWindow.cpp b/widget/windows/nsWindow.cpp
index f2d78c075c91b..b9501a95f26ee 100644
--- a/widget/windows/nsWindow.cpp
+++ b/widget/windows/nsWindow.cpp
@@ -4639,70 +4639,6 @@ bool nsWindow::DispatchMouseEvent(EventMessage aEventMessage, WPARAM wParam,
           ("Msg Time: %d Click Count: %d\n", curMsgTime, event.mClickCount));
 #endif
 
-  NPEvent pluginEvent;
-
-  switch (aEventMessage) {
-    case eMouseDown:
-      switch (aButton) {
-        case MouseButton::ePrimary:
-          pluginEvent.event = WM_LBUTTONDOWN;
-          break;
-        case MouseButton::eMiddle:
-          pluginEvent.event = WM_MBUTTONDOWN;
-          break;
-        case MouseButton::eSecondary:
-          pluginEvent.event = WM_RBUTTONDOWN;
-          break;
-        default:
-          break;
-      }
-      break;
-    case eMouseUp:
-      switch (aButton) {
-        case MouseButton::ePrimary:
-          pluginEvent.event = WM_LBUTTONUP;
-          break;
-        case MouseButton::eMiddle:
-          pluginEvent.event = WM_MBUTTONUP;
-          break;
-        case MouseButton::eSecondary:
-          pluginEvent.event = WM_RBUTTONUP;
-          break;
-        default:
-          break;
-      }
-      break;
-    case eMouseDoubleClick:
-      switch (aButton) {
-        case MouseButton::ePrimary:
-          pluginEvent.event = WM_LBUTTONDBLCLK;
-          break;
-        case MouseButton::eMiddle:
-          pluginEvent.event = WM_MBUTTONDBLCLK;
-          break;
-        case MouseButton::eSecondary:
-          pluginEvent.event = WM_RBUTTONDBLCLK;
-          break;
-        default:
-          break;
-      }
-      break;
-    case eMouseMove:
-      pluginEvent.event = WM_MOUSEMOVE;
-      break;
-    case eMouseExitFromWidget:
-      pluginEvent.event = WM_MOUSELEAVE;
-      break;
-    default:
-      pluginEvent.event = WM_NULL;
-      break;
-  }
-
-  pluginEvent.wParam = wParam;  // plugins NEED raw OS event flags!
-  pluginEvent.lParam = lParam;
-
-  event.mPluginEvent.Copy(pluginEvent);
-
   // call the event callback
   if (mWidgetListener) {
     if (aEventMessage == eMouseMove) {
diff --git a/widget/windows/nsWindowGfx.cpp b/widget/windows/nsWindowGfx.cpp
index 672345edb5458..ad3aeaddac27f 100644
--- a/widget/windows/nsWindowGfx.cpp
+++ b/widget/windows/nsWindowGfx.cpp
@@ -18,8 +18,6 @@
  **************************************************************/
 
 #include "mozilla/dom/ContentParent.h"
-#include "mozilla/plugins/PluginInstanceParent.h"
-using mozilla::plugins::PluginInstanceParent;
 
 #include "nsWindowGfx.h"
 #include "nsAppRunner.h"
@@ -136,13 +134,6 @@ void nsWindow::ForcePresent() {
 }
 
 bool nsWindow::OnPaint(HDC aDC, uint32_t aNestingLevel) {
-  // We never have reentrant paint events, except when we're running our RPC
-  // windows event spin loop. If we don't trap for this, we'll try to paint,
-  // but view manager will refuse to paint the surface, resulting is black
-  // flashes on the plugin rendering surface.
-  if (mozilla::ipc::MessageChannel::IsSpinLoopActive() && mPainting)
-    return false;
-
   DeviceResetReason resetReason = DeviceResetReason::OK;
   if (gfxWindowsPlatform::GetPlatform()->DidRenderingDeviceReset(
           &resetReason)) {
@@ -168,43 +159,6 @@ bool nsWindow::OnPaint(HDC aDC, uint32_t aNestingLevel) {
     return false;
   }
 
-  // After we CallUpdateWindow to the child, occasionally a WM_PAINT message
-  // is posted to the parent event loop with an empty update rect. Do a
-  // dummy paint so that Windows stops dispatching WM_PAINT in an inifinite
-  // loop. See bug 543788.
-  if (IsPlugin()) {
-    RECT updateRect;
-    if (!GetUpdateRect(mWnd, &updateRect, FALSE) ||
-        (updateRect.left == updateRect.right &&
-         updateRect.top == updateRect.bottom)) {
-      PAINTSTRUCT ps;
-      BeginPaint(mWnd, &ps);
-      EndPaint(mWnd, &ps);
-      return true;
-    }
-
-    if (mWindowType == eWindowType_plugin_ipc_chrome) {
-      // Fire off an async request to the plugin to paint its window
-      mozilla::dom::ContentParent::SendAsyncUpdate(this);
-      ValidateRect(mWnd, nullptr);
-      return true;
-    }
-
-    PluginInstanceParent* instance = reinterpret_cast<PluginInstanceParent*>(
-        ::GetPropW(mWnd, L"PluginInstanceParentProperty"));
-    if (instance) {
-      Unused << instance->CallUpdateWindow();
-    } else {
-      // We should never get here since in-process plugins should have
-      // subclassed our HWND and handled WM_PAINT, but in some cases that
-      // could fail. Return without asserting since it's not our fault.
-      NS_WARNING("Plugin failed to subclass our window");
-    }
-
-    ValidateRect(mWnd, nullptr);
-    return true;
-  }
-
   PAINTSTRUCT ps;
 
   // Avoid starting the GPU process for the initial navigator:blank window.
@@ -258,8 +212,6 @@ bool nsWindow::OnPaint(HDC aDC, uint32_t aNestingLevel) {
   }
 #endif
 
-  mPainting = true;
-
 #ifdef WIDGET_DEBUG_OUTPUT
   HRGN debugPaintFlashRegion = nullptr;
   HDC debugPaintFlashDC = nullptr;
@@ -433,8 +385,6 @@ bool nsWindow::OnPaint(HDC aDC, uint32_t aNestingLevel) {
   }
 #endif  // WIDGET_DEBUG_OUTPUT
 
-  mPainting = false;
-
   // Re-get the listener since painting may have killed it.
   listener = GetPaintListener();
   if (listener) listener->DidPaintWindow();
