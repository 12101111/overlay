From f7c49caeefc1a3ffd4dab675c317197c17a75580 Mon Sep 17 00:00:00 2001
From: David Parks <daparks@mozilla.com>
Date: Mon, 5 Apr 2021 23:48:42 +0000
Subject: [PATCH] Bug 1682030 - Remove NPAPI overlay from JS Plugin actors 
 r=Gijs

Removes NPAPI support from JS plugin actors, most of which was CTP-and-fallback overlay related, leaving them to only do GMP crash handling.

Differential Revision: https://phabricator.services.mozilla.com/D107157
---
 browser/actors/ContextMenuChild.jsm   |  38 -
 browser/actors/ContextMenuParent.jsm  |   7 -
 browser/actors/PluginChild.jsm        | 991 +-------------------------
 browser/actors/PluginParent.jsm       | 542 +-------------
 browser/base/content/nsContextMenu.js |   9 +-
 browser/components/BrowserGlue.jsm    |   8 +-
 dom/docs/ipc/jsactors.rst             |  12 +-
 xpcom/ds/StaticAtoms.py               |   5 -
 8 files changed, 21 insertions(+), 1591 deletions(-)

diff --git a/browser/actors/ContextMenuChild.jsm b/browser/actors/ContextMenuChild.jsm
index e4df8f49e890e..e827869325bf5 100644
--- a/browser/actors/ContextMenuChild.jsm
+++ b/browser/actors/ContextMenuChild.jsm
@@ -261,18 +261,6 @@ class ContextMenuChild extends JSWindowActorChild {
           imageName: null,
         });
       }
-
-      case "ContextMenu:PluginCommand": {
-        let target = ContentDOMReference.resolve(message.data.targetIdentifier);
-        let actor = this.manager.getActor("Plugin");
-        let { command } = message.data;
-        if (command == "play") {
-          actor.showClickToPlayNotification(target, true);
-        } else if (command == "hide") {
-          actor.hideClickToPlayOverlay(target);
-        }
-        break;
-      }
     }
 
     return undefined;
@@ -530,22 +518,6 @@ class ContextMenuChild extends JSWindowActorChild {
       !aEvent.composedTarget.nodePrincipal.isSystemPrincipal &&
       !Services.prefs.getBoolPref("dom.event.contextmenu.enabled")
     ) {
-      let plugin = null;
-
-      try {
-        plugin = aEvent.composedTarget.QueryInterface(
-          Ci.nsIObjectLoadingContent
-        );
-      } catch (e) {}
-
-      if (
-        plugin &&
-        plugin.displayedType == Ci.nsIObjectLoadingContent.TYPE_PLUGIN
-      ) {
-        // Don't open a context menu for plugins.
-        return;
-      }
-
       defaultPrevented = false;
     }
 
@@ -877,7 +849,6 @@ class ContextMenuChild extends JSWindowActorChild {
     context.onAudio = false;
     context.onCanvas = false;
     context.onCompletedImage = false;
-    context.onCTPPlugin = false;
     context.onDRMMedia = false;
     context.onPiPVideo = false;
     context.onEditable = false;
@@ -1111,15 +1082,6 @@ class ContextMenuChild extends JSWindowActorChild {
           );
         }
       }
-    } else if (
-      (context.target instanceof this.contentWindow.HTMLEmbedElement ||
-        context.target instanceof this.contentWindow.HTMLObjectElement) &&
-      context.target.displayedType ==
-        this.contentWindow.HTMLObjectElement.TYPE_NULL &&
-      context.target.pluginFallbackType ==
-        this.contentWindow.HTMLObjectElement.PLUGIN_CLICK_TO_PLAY
-    ) {
-      context.onCTPPlugin = true;
     }
 
     context.canSpellCheck = this._isSpellCheckEnabled(context.target);
diff --git a/browser/actors/ContextMenuParent.jsm b/browser/actors/ContextMenuParent.jsm
index f57946504ea01..d6c354d553e83 100644
--- a/browser/actors/ContextMenuParent.jsm
+++ b/browser/actors/ContextMenuParent.jsm
@@ -88,11 +88,4 @@ class ContextMenuParent extends JSWindowActorParent {
       handlingUserInput,
     });
   }
-
-  pluginCommand(command, targetIdentifier) {
-    this.sendAsyncMessage("ContextMenu:PluginCommand", {
-      command,
-      targetIdentifier,
-    });
-  }
 }
diff --git a/browser/actors/PluginChild.jsm b/browser/actors/PluginChild.jsm
index c7b20178b73f2..881203eea01a5 100644
--- a/browser/actors/PluginChild.jsm
+++ b/browser/actors/PluginChild.jsm
@@ -6,874 +6,21 @@
 
 var EXPORTED_SYMBOLS = ["PluginChild"];
 
-const { AppConstants } = ChromeUtils.import(
-  "resource://gre/modules/AppConstants.jsm"
-);
-const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
-const { XPCOMUtils } = ChromeUtils.import(
-  "resource://gre/modules/XPCOMUtils.jsm"
-);
-
-XPCOMUtils.defineLazyGetter(this, "gNavigatorBundle", function() {
-  const url = "chrome://browser/locale/browser.properties";
-  return Services.strings.createBundle(url);
-});
-
-XPCOMUtils.defineLazyServiceGetter(
-  this,
-  "gPluginHost",
-  "@mozilla.org/plugin/host;1",
-  "nsIPluginHost"
-);
-
-const OVERLAY_DISPLAY = {
-  HIDDEN: 0, // The overlay will be transparent
-  BLANK: 1, // The overlay will be just a grey box
-  TINY: 2, // The overlay with a 16x16 plugin icon
-  REDUCED: 3, // The overlay with a 32x32 plugin icon
-  NOTEXT: 4, // The overlay with a 48x48 plugin icon and the close button
-  FULL: 5, // The full overlay: 48x48 plugin icon, close button and label
-};
-
-// This gets sent through the content process message manager because the parent
-// can't know exactly which child needs to hear about the progress of the
-// submission, so we listen "manually" on the CPMM instead of through the actor
-// definition.
-const kSubmitMsg = "PluginParent:NPAPIPluginCrashReportSubmitted";
-
-/**
- * Map the plugin's name to a filtered version more suitable for UI.
- *
- * N.B. This should be completely dead code at this point.
- *
- * @param aName The full-length name string of the plugin.
- * @return the simplified name string.
- */
-function makeNicePluginName(aName) {
-  if (aName == "Shockwave Flash") {
-    return "Adobe Flash";
-  }
-  // Regex checks if aName begins with "Java" + non-letter char
-  if (/^Java\W/.test(aName)) {
-    return "Java";
-  }
-
-  // Clean up the plugin name by stripping off parenthetical clauses,
-  // trailing version numbers or "plugin".
-  // EG, "Foo Bar (Linux) Plugin 1.23_02" --> "Foo Bar"
-  // Do this by first stripping the numbers, etc. off the end, and then
-  // removing "Plugin" (and then trimming to get rid of any whitespace).
-  // (Otherwise, something like "Java(TM) Plug-in 1.7.0_07" gets mangled)
-  let newName = aName
-    .replace(/\(.*?\)/g, "")
-    .replace(/[\s\d\.\-\_\(\)]+$/, "")
-    .replace(/\bplug-?in\b/i, "")
-    .trim();
-  return newName;
-}
-
+// Handle GMP crashes
 class PluginChild extends JSWindowActorChild {
-  constructor() {
-    super();
-
-    // Cache of plugin crash information sent from the parent
-    this.pluginCrashData = new Map();
-    Services.cpmm.addMessageListener(kSubmitMsg, this);
-  }
-
-  didDestroy() {
-    Services.cpmm.removeMessageListener(kSubmitMsg, this);
-    if (this._addedListeners) {
-      this.contentWindow.removeEventListener("pagehide", this, {
-        capture: true,
-        mozSystemGroup: true,
-      });
-      this.contentWindow.removeEventListener("pageshow", this, {
-        capture: true,
-        mozSystemGroup: true,
-      });
-    }
-  }
-
-  receiveMessage(msg) {
-    switch (msg.name) {
-      case "PluginParent:ActivatePlugins":
-        this.activatePlugins(msg.data.activationInfo, msg.data.newState);
-        break;
-      case "PluginParent:NPAPIPluginCrashReportSubmitted":
-        this.NPAPIPluginCrashReportSubmitted({
-          runID: msg.data.runID,
-          state: msg.data.state,
-        });
-        break;
-      case "PluginParent:Test:ClearCrashData":
-        // This message should ONLY ever be sent by automated tests.
-        if (Services.prefs.getBoolPref("plugins.testmode")) {
-          this.pluginCrashData.clear();
-        }
-    }
-  }
-
-  observe(aSubject, aTopic, aData) {
-    switch (aTopic) {
-      case "decoder-doctor-notification":
-        let data = JSON.parse(aData);
-        let type = data.type.toLowerCase();
-        if (
-          type == "cannot-play" &&
-          this.haveShownNotification &&
-          aSubject.top.document == this.document &&
-          data.formats.toLowerCase().includes("application/x-mpegurl", 0)
-        ) {
-          this.contentWindow.pluginRequiresReload = true;
-        }
-    }
-  }
-
-  onPageShow(event) {
-    // Ignore events that aren't from the main document.
-    if (!this.contentWindow || event.target != this.document) {
-      return;
-    }
-
-    // The PluginClickToPlay events are not fired when navigating using the
-    // BF cache. |persisted| is true when the page is loaded from the
-    // BF cache, so this code reshows the notification if necessary.
-    if (event.persisted) {
-      this.reshowClickToPlayNotification();
-    }
-  }
-
-  onPageHide(event) {
-    // Ignore events that aren't from the main document.
-    if (!this.contentWindow || event.target != this.document) {
-      return;
-    }
-
-    this.clearPluginCaches();
-    this.haveShownNotification = false;
-  }
-
-  getPluginUI(pluginElement, anonid) {
-    if (
-      pluginElement.openOrClosedShadowRoot &&
-      pluginElement.openOrClosedShadowRoot.isUAWidget()
-    ) {
-      return pluginElement.openOrClosedShadowRoot.getElementById(anonid);
-    }
-    return null;
-  }
-
-  _getPluginInfo(pluginElement) {
-    if (this.isKnownPlugin(pluginElement)) {
-      let pluginTag = gPluginHost.getPluginTagForType(pluginElement.actualType);
-      let pluginName = makeNicePluginName(pluginTag.name);
-      let fallbackType = pluginElement.defaultFallbackType;
-      let permissionString = gPluginHost.getPermissionStringForType(
-        pluginElement.actualType
-      );
-      return { pluginTag, pluginName, fallbackType, permissionString };
-    }
-    return {
-      fallbackType: null,
-      permissionString: null,
-      pluginName: gNavigatorBundle.GetStringFromName(
-        "pluginInfo.unknownPlugin"
-      ),
-      pluginTag: null,
-    };
-  }
-
-  /**
-   * _getPluginInfoForTag is called when iterating the plugins for a document,
-   * and what we get from nsIDOMWindowUtils is an nsIPluginTag, and not an
-   * nsIObjectLoadingContent. This only should happen if the plugin is
-   * click-to-play (see bug 1186948).
-   */
-  _getPluginInfoForTag(pluginTag) {
-    // Since we should only have entered _getPluginInfoForTag when
-    // examining a click-to-play plugin, we can safely hard-code
-    // this fallback type, since we don't actually have an
-    // nsIObjectLoadingContent to check.
-    let fallbackType = Ci.nsIObjectLoadingContent.PLUGIN_CLICK_TO_PLAY;
-    if (pluginTag) {
-      let pluginName = makeNicePluginName(pluginTag.name);
-      let permissionString = gPluginHost.getPermissionStringForTag(pluginTag);
-      return { pluginTag, pluginName, permissionString, fallbackType };
-    }
-    return {
-      fallbackType,
-      permissionString: null,
-      pluginName: gNavigatorBundle.GetStringFromName(
-        "pluginInfo.unknownPlugin"
-      ),
-      pluginTag: null,
-    };
-  }
-
-  /**
-   * Update the visibility of the plugin overlay.
-   */
-  setVisibility(plugin, overlay, overlayDisplayState) {
-    overlay.classList.toggle(
-      "visible",
-      overlayDisplayState != OVERLAY_DISPLAY.HIDDEN
-    );
-    if (overlayDisplayState != OVERLAY_DISPLAY.HIDDEN) {
-      overlay.removeAttribute("dismissed");
-    }
-  }
-
-  /**
-   * Adjust the style in which the overlay will be displayed. It might be adjusted
-   * based on its size, or if there's some other element covering all corners of
-   * the overlay.
-   *
-   * This function will handle adjusting the style of the overlay, but will
-   * not handle hiding it. That is done by setVisibility with the return value
-   * from this function.
-   *
-   * @param {Element} plugin  The plug-in element
-   * @param {Element} overlay The overlay element inside the UA Shadow DOM of
-   *                          the plug-in element
-   * @param {boolean} flushLayout Allow flush layout during computation and
-   *                              adjustment.
-   * @returns A value from OVERLAY_DISPLAY.
-   */
-  computeAndAdjustOverlayDisplay(plugin, overlay, flushLayout) {
-    let fallbackType = plugin.pluginFallbackType;
-    if (plugin.pluginFallbackTypeOverride !== undefined) {
-      fallbackType = plugin.pluginFallbackTypeOverride;
-    }
-    if (fallbackType == Ci.nsIObjectLoadingContent.PLUGIN_CLICK_TO_PLAY_QUIET) {
-      return OVERLAY_DISPLAY.HIDDEN;
-    }
-
-    // If the overlay size is 0, we haven't done layout yet. Presume that
-    // plugins are visible until we know otherwise.
-    if (flushLayout && overlay.scrollWidth == 0) {
-      return OVERLAY_DISPLAY.FULL;
-    }
-
-    let overlayDisplay = OVERLAY_DISPLAY.FULL;
-    let cwu = plugin.ownerGlobal.windowUtils;
-
-    // Is the <object>'s size too small to hold what we want to show?
-    let pluginRect = flushLayout
-      ? plugin.getBoundingClientRect()
-      : cwu.getBoundsWithoutFlushing(plugin);
-    let pluginWidth = Math.ceil(pluginRect.width);
-    let pluginHeight = Math.ceil(pluginRect.height);
-
-    let layoutNeedsFlush =
-      !flushLayout &&
-      cwu.needsFlush(cwu.FLUSH_STYLE) &&
-      cwu.needsFlush(cwu.FLUSH_LAYOUT);
-
-    // We must set the attributes while here inside this function in order
-    // for a possible re-style to occur, which will make the scrollWidth/Height
-    // checks below correct. Otherwise, we would be requesting e.g. a TINY
-    // overlay here, but the default styling would be used, and that would make
-    // it overflow, causing it to change to BLANK instead of remaining as TINY.
-
-    if (layoutNeedsFlush) {
-      // Set the content to be oversized when we the overlay size is 0,
-      // so that we could receive an overflow event afterwards when there is
-      // a layout.
-      overlayDisplay = OVERLAY_DISPLAY.FULL;
-      overlay.setAttribute("sizing", "oversized");
-      overlay.removeAttribute("notext");
-    } else if (pluginWidth <= 32 || pluginHeight <= 32) {
-      overlay.setAttribute("sizing", "blank");
-      overlayDisplay = OVERLAY_DISPLAY.BLANK;
-    } else if (pluginWidth <= 80 || pluginHeight <= 60) {
-      overlayDisplay = OVERLAY_DISPLAY.TINY;
-      overlay.setAttribute("sizing", "tiny");
-      overlay.setAttribute("notext", "notext");
-    } else if (pluginWidth <= 120 || pluginHeight <= 80) {
-      overlayDisplay = OVERLAY_DISPLAY.REDUCED;
-      overlay.setAttribute("sizing", "reduced");
-      overlay.setAttribute("notext", "notext");
-    } else if (pluginWidth <= 240 || pluginHeight <= 160) {
-      overlayDisplay = OVERLAY_DISPLAY.NOTEXT;
-      overlay.removeAttribute("sizing");
-      overlay.setAttribute("notext", "notext");
-    } else {
-      overlayDisplay = OVERLAY_DISPLAY.FULL;
-      overlay.removeAttribute("sizing");
-      overlay.removeAttribute("notext");
-    }
-
-    if (fallbackType == Ci.nsIObjectLoadingContent.PLUGIN_BLOCK_ALL) {
-      overlay.setAttribute("blockall", "blockall");
-      return OVERLAY_DISPLAY.HIDDEN;
-    }
-
-    // The hit test below only works with correct layout information,
-    // don't do it if layout needs flush.
-    // We also don't want to access scrollWidth/scrollHeight if
-    // the layout needs flush.
-    if (layoutNeedsFlush) {
-      return overlayDisplay;
-    }
-
-    // XXX bug 446693. The text-shadow on the submitted-report text at
-    //     the bottom causes scrollHeight to be larger than it should be.
-    let overflows =
-      overlay.scrollWidth > pluginWidth ||
-      overlay.scrollHeight - 5 > pluginHeight;
-    if (overflows) {
-      overlay.setAttribute("sizing", "blank");
-      return OVERLAY_DISPLAY.BLANK;
-    }
-
-    // Is the plugin covered up by other content so that it is not clickable?
-    // Floating point can confuse .elementFromPoint, so inset just a bit
-    let left = pluginRect.left + 2;
-    let right = pluginRect.right - 2;
-    let top = pluginRect.top + 2;
-    let bottom = pluginRect.bottom - 2;
-    let centerX = left + (right - left) / 2;
-    let centerY = top + (bottom - top) / 2;
-    let points = [
-      [left, top],
-      [left, bottom],
-      [right, top],
-      [right, bottom],
-      [centerX, centerY],
-    ];
-
-    for (let [x, y] of points) {
-      if (x < 0 || y < 0) {
-        continue;
-      }
-      let el = cwu.elementFromPoint(x, y, true, true);
-      if (el === plugin) {
-        return overlayDisplay;
-      }
-    }
-
-    overlay.setAttribute("sizing", "blank");
-    return OVERLAY_DISPLAY.BLANK;
-  }
-
-  addLinkClickCallback(linkNode, callbackName /* callbackArgs...*/) {
-    // XXX just doing (callback)(arg) was giving a same-origin error. bug?
-    let self = this;
-    let callbackArgs = Array.prototype.slice.call(arguments).slice(2);
-    linkNode.addEventListener(
-      "click",
-      function(evt) {
-        if (!evt.isTrusted) {
-          return;
-        }
-        evt.preventDefault();
-        if (!callbackArgs.length) {
-          callbackArgs = [evt];
-        }
-        self[callbackName].apply(self, callbackArgs);
-      },
-      true
-    );
-
-    linkNode.addEventListener(
-      "keydown",
-      function(evt) {
-        if (!evt.isTrusted) {
-          return;
-        }
-        if (evt.keyCode == evt.DOM_VK_RETURN) {
-          evt.preventDefault();
-          if (!callbackArgs.length) {
-            callbackArgs = [evt];
-          }
-          evt.preventDefault();
-          self[callbackName].apply(self, callbackArgs);
-        }
-      },
-      true
-    );
-  }
-
-  // Helper to get the binding handler type from a plugin object
-  _getBindingType(plugin) {
-    if (!(plugin instanceof Ci.nsIObjectLoadingContent)) {
-      return null;
-    }
-
-    switch (plugin.pluginFallbackType) {
-      case Ci.nsIObjectLoadingContent.PLUGIN_UNSUPPORTED:
-        return "PluginNotFound";
-      case Ci.nsIObjectLoadingContent.PLUGIN_DISABLED:
-        return "PluginDisabled";
-      case Ci.nsIObjectLoadingContent.PLUGIN_BLOCKLISTED:
-        return "PluginBlocklisted";
-      case Ci.nsIObjectLoadingContent.PLUGIN_OUTDATED:
-        return "PluginOutdated";
-      case Ci.nsIObjectLoadingContent.PLUGIN_CLICK_TO_PLAY:
-      case Ci.nsIObjectLoadingContent.PLUGIN_CLICK_TO_PLAY_QUIET:
-        return "PluginClickToPlay";
-      case Ci.nsIObjectLoadingContent.PLUGIN_VULNERABLE_UPDATABLE:
-        return "PluginVulnerableUpdatable";
-      case Ci.nsIObjectLoadingContent.PLUGIN_VULNERABLE_NO_UPDATE:
-        return "PluginVulnerableNoUpdate";
-      case Ci.nsIObjectLoadingContent.PLUGIN_BLOCK_ALL:
-        return "PluginBlockAll";
-      default:
-        // Not all states map to a handler
-        return null;
-    }
-  }
-
   handleEvent(event) {
     // Ignore events for other frames.
     let eventDoc = event.target.ownerDocument || event.target.document;
     if (eventDoc && eventDoc != this.document) {
       return;
     }
-    if (!this._addedListeners) {
-      // Only add pageshow/pagehide listeners here. We don't want this actor
-      // to be instantiated for every frame, we only care if a plugin actually
-      // gets used in a frame. So we don't add these listeners in the actor
-      // specification, but only at runtime once one of our Plugin* events
-      // fires.
-      this.contentWindow.addEventListener("pagehide", this, {
-        capture: true,
-        mozSystemGroup: true,
-      });
-      this.contentWindow.addEventListener("pageshow", this, {
-        capture: true,
-        mozSystemGroup: true,
-      });
-      this._addedListeners = true;
-    }
 
     let eventType = event.type;
-
-    if (eventType == "pagehide") {
-      this.onPageHide(event);
-      return;
-    }
-
-    if (eventType == "pageshow") {
-      this.onPageShow(event);
-      return;
-    }
-
-    if (eventType == "click") {
-      this.onOverlayClick(event);
-      return;
-    }
-
-    if (
-      eventType == "PluginCrashed" &&
-      !(event.target instanceof Ci.nsIObjectLoadingContent)
-    ) {
-      // If the event target is not a plugin object (i.e., an <object> or
-      // <embed> element), this call is for a window-global plugin.
-      this.onPluginCrashed(event.target, event);
-      return;
-    }
-
-    if (eventType == "HiddenPlugin") {
-      let pluginTag = event.tag.QueryInterface(Ci.nsIPluginTag);
-      this.showClickToPlayNotification(pluginTag, false);
-    }
-
-    let pluginElement = event.target;
-
-    if (!(pluginElement instanceof Ci.nsIObjectLoadingContent)) {
-      return;
-    }
-
-    if (eventType == "PluginBindingAttached") {
-      // The plugin binding fires this event when it is created.
-      // As an untrusted event, ensure that this object actually has a binding
-      // and make sure we don't handle it twice
-      let overlay = this.getPluginUI(pluginElement, "main");
-      if (!overlay || overlay._bindingHandled) {
-        return;
-      }
-      overlay._bindingHandled = true;
-
-      // Lookup the handler for this binding
-      eventType = this._getBindingType(pluginElement);
-      if (!eventType) {
-        // Not all bindings have handlers
-        return;
-      }
-    }
-
-    let shouldShowNotification = false;
-    switch (eventType) {
-      case "PluginCrashed":
-        this.onPluginCrashed(pluginElement, event);
-        break;
-
-      case "PluginBlockAll":
-      case "PluginNotFound": {
-        /* NOP */
-        break;
-      }
-
-      case "PluginBlocklisted":
-      case "PluginOutdated":
-        shouldShowNotification = true;
-        break;
-
-      case "PluginVulnerableUpdatable":
-      case "PluginVulnerableNoUpdate":
-      case "PluginClickToPlay":
-        this._handleClickToPlayEvent(pluginElement);
-        let { pluginName } = this._getPluginInfo(pluginElement);
-        let messageString = gNavigatorBundle.formatStringFromName(
-          "PluginClickToActivate2",
-          [pluginName]
-        );
-        let overlayText = this.getPluginUI(pluginElement, "clickToPlay");
-        overlayText.textContent = messageString;
-        shouldShowNotification = true;
-        break;
-
-      case "PluginDisabled":
-        let manageLink = this.getPluginUI(pluginElement, "managePluginsLink");
-        this.addLinkClickCallback(
-          manageLink,
-          "forwardCallback",
-          "managePlugins"
-        );
-        shouldShowNotification = true;
-        break;
-
-      case "PluginInstantiated":
-        shouldShowNotification = true;
-        break;
-    }
-
-    // Show the in-content UI if it's not too big. The crashed plugin handler already did this.
-    let overlay = this.getPluginUI(pluginElement, "main");
-    if (eventType != "PluginCrashed") {
-      if (overlay != null) {
-        this.setVisibility(
-          pluginElement,
-          overlay,
-          this.computeAndAdjustOverlayDisplay(pluginElement, overlay, false)
-        );
-
-        let resizeListener = () => {
-          this.setVisibility(
-            pluginElement,
-            overlay,
-            this.computeAndAdjustOverlayDisplay(pluginElement, overlay, true)
-          );
-        };
-        pluginElement.addEventListener("overflow", resizeListener);
-        pluginElement.addEventListener("underflow", resizeListener);
-      }
-    }
-
-    let closeIcon = this.getPluginUI(pluginElement, "closeIcon");
-    if (closeIcon) {
-      closeIcon.addEventListener(
-        "click",
-        clickEvent => {
-          if (clickEvent.button == 0 && clickEvent.isTrusted) {
-            this.hideClickToPlayOverlay(pluginElement);
-            overlay.setAttribute("dismissed", "true");
-          }
-        },
-        true
-      );
-    }
-
-    if (shouldShowNotification) {
-      this.showClickToPlayNotification(pluginElement, false);
-    }
-  }
-
-  isKnownPlugin(objLoadingContent) {
-    return (
-      objLoadingContent.getContentTypeForMIMEType(
-        objLoadingContent.actualType
-      ) == Ci.nsIObjectLoadingContent.TYPE_PLUGIN
-    );
-  }
-
-  canActivatePlugin(objLoadingContent) {
-    // if this isn't a known plugin, we can't activate it
-    // (this also guards pluginHost.getPermissionStringForType against
-    // unexpected input)
-    if (!this.isKnownPlugin(objLoadingContent)) {
-      return false;
-    }
-
-    let permissionString = gPluginHost.getPermissionStringForType(
-      objLoadingContent.actualType
-    );
-    let principal = objLoadingContent.ownerGlobal.top.document.nodePrincipal;
-    let pluginPermission = Services.perms.testPermissionFromPrincipal(
-      principal,
-      permissionString
-    );
-
-    let isFallbackTypeValid =
-      objLoadingContent.pluginFallbackType >=
-        Ci.nsIObjectLoadingContent.PLUGIN_CLICK_TO_PLAY &&
-      objLoadingContent.pluginFallbackType <=
-        Ci.nsIObjectLoadingContent.PLUGIN_CLICK_TO_PLAY_QUIET;
-
-    return (
-      !objLoadingContent.activated &&
-      pluginPermission != Ci.nsIPermissionManager.DENY_ACTION &&
-      isFallbackTypeValid
-    );
-  }
-
-  hideClickToPlayOverlay(pluginElement) {
-    let overlay = this.getPluginUI(pluginElement, "main");
-    if (overlay) {
-      overlay.classList.remove("visible");
-    }
-  }
-
-  // Forward a link click callback to the chrome process.
-  forwardCallback(name, pluginId) {
-    this.sendAsyncMessage("PluginContent:LinkClickCallback", {
-      name,
-      pluginId,
-    });
-  }
-
-  submitReport(plugin) {
-    if (!AppConstants.MOZ_CRASHREPORTER) {
-      return;
-    }
-    if (!plugin) {
-      Cu.reportError(
-        "Attempted to submit crash report without an associated plugin."
-      );
-      return;
-    }
-    if (!(plugin instanceof Ci.nsIObjectLoadingContent)) {
-      Cu.reportError(
-        "Attempted to submit crash report on plugin that does not" +
-          "implement nsIObjectLoadingContent."
-      );
-      return;
-    }
-
-    let runID = plugin.runID;
-    let submitURLOptIn = this.getPluginUI(plugin, "submitURLOptIn").checked;
-    let keyVals = {};
-    let userComment = this.getPluginUI(plugin, "submitComment").value.trim();
-    if (userComment) {
-      keyVals.PluginUserComment = userComment;
-    }
-    if (submitURLOptIn) {
-      keyVals.PluginContentURL = plugin.ownerDocument.URL;
-    }
-
-    this.sendAsyncMessage("PluginContent:SubmitReport", {
-      runID,
-      keyVals,
-      submitURLOptIn,
-    });
-  }
-
-  reloadPage() {
-    this.contentWindow.location.reload();
-  }
-
-  // Event listener for click-to-play plugins.
-  _handleClickToPlayEvent(plugin) {
-    let doc = plugin.ownerDocument;
-    // guard against giving pluginHost.getPermissionStringForType a type
-    // not associated with any known plugin
-    if (!this.isKnownPlugin(plugin)) {
-      return;
-    }
-    let permissionString = gPluginHost.getPermissionStringForType(
-      plugin.actualType
-    );
-    let principal = doc.defaultView.top.document.nodePrincipal;
-    let pluginPermission = Services.perms.testPermissionFromPrincipal(
-      principal,
-      permissionString
-    );
-
-    let overlay = this.getPluginUI(plugin, "main");
-
-    if (
-      pluginPermission == Ci.nsIPermissionManager.DENY_ACTION ||
-      pluginPermission ==
-        Ci.nsIObjectLoadingContent.PLUGIN_PERMISSION_PROMPT_ACTION_QUIET
-    ) {
-      if (overlay) {
-        overlay.classList.remove("visible");
-      }
-      return;
-    }
-
-    if (overlay) {
-      overlay.addEventListener("click", this, true);
+    if (eventType == "PluginCrashed") {
+      this.onPluginCrashed(event);
     }
   }
 
-  onOverlayClick(event) {
-    let plugin = event.target.containingShadowRoot.host;
-    let overlay = this.getPluginUI(plugin, "main");
-    // Have to check that the target is not the link to update the plugin
-    if (
-      !(
-        ChromeUtils.getClassName(event.originalTarget) === "HTMLAnchorElement"
-      ) &&
-      event.originalTarget.getAttribute("anonid") != "closeIcon" &&
-      event.originalTarget.id != "closeIcon" &&
-      !overlay.hasAttribute("dismissed") &&
-      !overlay.hasAttribute("blockall") &&
-      event.button == 0 &&
-      event.isTrusted
-    ) {
-      this.showClickToPlayNotification(plugin, true);
-      event.stopPropagation();
-      event.preventDefault();
-    }
-  }
-
-  reshowClickToPlayNotification() {
-    let { plugins } = this.contentWindow.windowUtils;
-    for (let plugin of plugins) {
-      let overlay = this.getPluginUI(plugin, "main");
-      if (overlay) {
-        overlay.removeEventListener("click", this, true);
-      }
-      if (this.canActivatePlugin(plugin)) {
-        this._handleClickToPlayEvent(plugin);
-      }
-    }
-    this.showClickToPlayNotification(null, false);
-  }
-
-  /**
-   * Activate the plugins that the user has specified.
-   */
-  activatePlugins(activationInfo, newState) {
-    let { plugins } = this.contentWindow.windowUtils;
-
-    let pluginFound = false;
-    for (let plugin of plugins) {
-      if (!this.isKnownPlugin(plugin)) {
-        continue;
-      }
-      if (
-        activationInfo.permissionString ==
-        gPluginHost.getPermissionStringForType(plugin.actualType)
-      ) {
-        let overlay = this.getPluginUI(plugin, "main");
-        pluginFound = true;
-        if (
-          newState == "block" ||
-          newState == "blockalways" ||
-          newState == "continueblocking"
-        ) {
-          if (overlay) {
-            overlay.addEventListener("click", this, true);
-          }
-          plugin.pluginFallbackTypeOverride = activationInfo.fallbackType;
-          plugin.reload(true);
-        } else if (this.canActivatePlugin(plugin)) {
-          if (overlay) {
-            overlay.removeEventListener("click", this, true);
-          }
-          plugin.playPlugin();
-        }
-      }
-    }
-
-    // If there are no instances of the plugin on the page any more or if we've
-    // noted that the content needs to be reloaded due to replacing HLS, what the
-    // user probably needs is for us to allow and then refresh.
-    if (
-      newState != "block" &&
-      newState != "blockalways" &&
-      newState != "continueblocking" &&
-      (!pluginFound || this.contentWindow.pluginRequiresReload)
-    ) {
-      this.reloadPage();
-    }
-  }
-
-  showClickToPlayNotification(pluginElOrTag, showNow) {
-    let plugins = [];
-
-    // If pluginElOrTag is null, that means the user has navigated back to a page with
-    // plugins, and we need to collect all the plugins.
-    if (pluginElOrTag === null) {
-      // cwu.plugins may contain non-plugin <object>s, filter them out
-      plugins = this.contentWindow.windowUtils.plugins.filter(
-        p =>
-          p.getContentTypeForMIMEType(p.actualType) ==
-          Ci.nsIObjectLoadingContent.TYPE_PLUGIN
-      );
-
-      if (!plugins.length) {
-        this.removeNotification();
-        return;
-      }
-    } else {
-      plugins = [pluginElOrTag];
-    }
-
-    // Iterate over the plugins and ensure we have one value for each
-    // permission string - though in principle there should only be 1 anyway
-    // (for flash), in practice there are still some automated tests where we
-    // could encounter other ones.
-    let permissionMap = new Map();
-    for (let p of plugins) {
-      let pluginInfo;
-      if (p instanceof Ci.nsIPluginTag) {
-        pluginInfo = this._getPluginInfoForTag(p);
-      } else {
-        pluginInfo = this._getPluginInfo(p);
-      }
-      if (pluginInfo.permissionString === null) {
-        Cu.reportError("No permission string for active plugin.");
-        continue;
-      }
-      if (!permissionMap.has(pluginInfo.permissionString)) {
-        permissionMap.set(pluginInfo.permissionString, pluginInfo);
-        continue;
-      }
-    }
-    if (permissionMap.size > 1) {
-      Cu.reportError(
-        "Err, we're not meant to have more than 1 plugin anymore!"
-      );
-    }
-    if (!permissionMap.size) {
-      return;
-    }
-
-    this.haveShownNotification = true;
-
-    let permissionItem = permissionMap.values().next().value;
-    let plugin = {
-      id: permissionItem.pluginTag.id,
-      fallbackType: permissionItem.fallbackType,
-    };
-
-    let msg = "PluginContent:ShowClickToPlayNotification";
-    this.sendAsyncMessage(msg, { plugin, showNow });
-  }
-
-  removeNotification() {
-    this.sendAsyncMessage("PluginContent:RemoveNotification");
-  }
-
-  clearPluginCaches() {
-    this.pluginCrashData.clear();
-  }
-
   /**
    * Determines whether or not the crashed plugin is contained within current
    * full screen DOM element.
@@ -920,15 +67,15 @@ class PluginChild extends JSWindowActorChild {
   }
 
   /**
-   * The PluginCrashed event handler. Note that the PluginCrashed event is
-   * fired for both NPAPI and Gecko Media plugins. In the latter case, the
-   * target of the event is the document that the GMP is being used in.
+   * The PluginCrashed event handler. The target of the event is the
+   * document that GMP is being used in.
    */
-  async onPluginCrashed(target, aEvent) {
+  async onPluginCrashed(aEvent) {
     if (!(aEvent instanceof this.contentWindow.PluginCrashedEvent)) {
       return;
     }
 
+    let { target, gmpPlugin, pluginID } = aEvent;
     let fullScreenElement = this.contentWindow.top.document
       .mozFullScreenElement;
     if (fullScreenElement) {
@@ -937,130 +84,6 @@ class PluginChild extends JSWindowActorChild {
       }
     }
 
-    if (aEvent.gmpPlugin) {
-      this.GMPCrashed(aEvent);
-      return;
-    }
-
-    if (!(target instanceof Ci.nsIObjectLoadingContent)) {
-      return;
-    }
-
-    let crashData = this.pluginCrashData.get(target.runID);
-    if (!crashData) {
-      // We haven't received information from the parent yet about
-      // this crash, so go get it:
-      crashData = await this.sendQuery("PluginContent:GetCrashData", {
-        runID: target.runID,
-      });
-      this.pluginCrashData.set(target.runID, crashData);
-    }
-
-    this.setCrashedNPAPIPluginState({
-      pluginElement: target,
-      state: crashData.state,
-      pluginName: crashData.pluginName,
-    });
-  }
-
-  setCrashedNPAPIPluginState({ pluginElement, state, pluginName }) {
-    let overlay = this.getPluginUI(pluginElement, "main");
-    let statusDiv = this.getPluginUI(pluginElement, "submitStatus");
-    let optInCB = this.getPluginUI(pluginElement, "submitURLOptIn");
-
-    this.getPluginUI(pluginElement, "submitButton").addEventListener(
-      "click",
-      event => {
-        if (event.button != 0 || !event.isTrusted) {
-          return;
-        }
-        this.submitReport(pluginElement);
-      }
-    );
-
-    optInCB.checked = Services.prefs.getBoolPref(
-      "dom.ipc.plugins.reportCrashURL",
-      true
-    );
-
-    statusDiv.setAttribute("status", state);
-
-    let helpIcon = this.getPluginUI(pluginElement, "helpIcon");
-    this.addLinkClickCallback(helpIcon, "openHelpPage");
-
-    let crashText = this.getPluginUI(pluginElement, "crashedText");
-
-    let message = gNavigatorBundle.formatStringFromName(
-      "crashedpluginsMessage.title",
-      [pluginName]
-    );
-    crashText.textContent = message;
-
-    let link = this.getPluginUI(pluginElement, "reloadLink");
-    this.addLinkClickCallback(link, "reloadPage");
-
-    // This might trigger force reflow, but plug-in crashing code path shouldn't be hot.
-    let overlayDisplayState = this.computeAndAdjustOverlayDisplay(
-      pluginElement,
-      overlay,
-      true
-    );
-
-    // Is the <object>'s size too small to hold what we want to show?
-    if (overlayDisplayState != OVERLAY_DISPLAY.FULL) {
-      // First try hiding the crash report submission UI.
-      statusDiv.removeAttribute("status");
-
-      overlayDisplayState = this.computeAndAdjustOverlayDisplay(
-        pluginElement,
-        overlay,
-        true
-      );
-    }
-    this.setVisibility(pluginElement, overlay, overlayDisplayState);
-
-    let doc = pluginElement.ownerDocument;
-    let runID = pluginElement.runID;
-
-    if (overlayDisplayState == OVERLAY_DISPLAY.FULL) {
-      doc.mozNoPluginCrashedNotification = true;
-
-      // Notify others that the crash reporter UI is now ready.
-      // Currently, this event is only used by tests.
-      let winUtils = this.contentWindow.windowUtils;
-      let event = new this.contentWindow.CustomEvent(
-        "PluginCrashReporterDisplayed",
-        {
-          bubbles: true,
-        }
-      );
-      winUtils.dispatchEventToChromeOnly(pluginElement, event);
-    } else if (!doc.mozNoPluginCrashedNotification) {
-      // If another plugin on the page was large enough to show our UI, we don't
-      // want to show a notification bar.
-      this.sendAsyncMessage("PluginContent:ShowPluginCrashedNotification", {
-        pluginCrashID: { runID },
-      });
-    }
-  }
-
-  NPAPIPluginCrashReportSubmitted({ runID, state }) {
-    this.pluginCrashData.delete(runID);
-    let { plugins } = this.contentWindow.windowUtils;
-
-    for (let pluginElement of plugins) {
-      if (
-        pluginElement instanceof Ci.nsIObjectLoadingContent &&
-        pluginElement.runID == runID
-      ) {
-        let statusDiv = this.getPluginUI(pluginElement, "submitStatus");
-        statusDiv.setAttribute("status", state);
-      }
-    }
-  }
-
-  GMPCrashed(aEvent) {
-    let { target, gmpPlugin, pluginID } = aEvent;
     if (!gmpPlugin || !target.document) {
       // TODO: Throw exception? How did we get here?
       return;
diff --git a/browser/actors/PluginParent.jsm b/browser/actors/PluginParent.jsm
index 2c621964722b2..396d32d174bf0 100644
--- a/browser/actors/PluginParent.jsm
+++ b/browser/actors/PluginParent.jsm
@@ -15,13 +15,6 @@ const { XPCOMUtils } = ChromeUtils.import(
   "resource://gre/modules/XPCOMUtils.jsm"
 );
 
-XPCOMUtils.defineLazyServiceGetter(
-  this,
-  "gPluginHost",
-  "@mozilla.org/plugin/host;1",
-  "nsIPluginHost"
-);
-
 ChromeUtils.defineModuleGetter(
   this,
   "CrashSubmit",
@@ -33,154 +26,15 @@ XPCOMUtils.defineLazyGetter(this, "gNavigatorBundle", function() {
   return Services.strings.createBundle(url);
 });
 
-const kNotificationId = "click-to-play-plugins";
-
-const {
-  PLUGIN_ACTIVE,
-  PLUGIN_VULNERABLE_NO_UPDATE,
-  PLUGIN_VULNERABLE_UPDATABLE,
-  PLUGIN_CLICK_TO_PLAY_QUIET,
-} = Ci.nsIObjectLoadingContent;
-
-/**
- * Map the plugin's name to a filtered version more suitable for UI.
- *
- * N.B. This should be completely dead code at this point.
- *
- * @param aName The full-length name string of the plugin.
- * @return the simplified name string.
- */
-function makeNicePluginName(aName) {
-  if (aName == "Shockwave Flash") {
-    return "Adobe Flash";
-  }
-  // Regex checks if aName begins with "Java" + non-letter char
-  if (/^Java\W/.test(aName)) {
-    return "Java";
-  }
-
-  // Clean up the plugin name by stripping off parenthetical clauses,
-  // trailing version numbers or "plugin".
-  // EG, "Foo Bar (Linux) Plugin 1.23_02" --> "Foo Bar"
-  // Do this by first stripping the numbers, etc. off the end, and then
-  // removing "Plugin" (and then trimming to get rid of any whitespace).
-  // (Otherwise, something like "Java(TM) Plug-in 1.7.0_07" gets mangled)
-  let newName = aName
-    .replace(/\(.*?\)/g, "")
-    .replace(/[\s\d\.\-\_\(\)]+$/, "")
-    .replace(/\bplug-?in\b/i, "")
-    .trim();
-  return newName;
-}
-
 const PluginManager = {
-  _initialized: false,
-
-  pluginMap: new Map(),
-  crashReports: new Map(),
   gmpCrashes: new Map(),
-  _pendingCrashQueries: new Map(),
-
-  // BrowserGlue.jsm ensures we catch all plugin crashes.
-  // Barring crashes, we don't need to do anything until/unless an
-  // actor gets instantiated, in which case we also care about the
-  // plugin list changing.
-  ensureInitialized() {
-    if (this._initialized) {
-      return;
-    }
-    this._initialized = true;
-    this._updatePluginMap();
-    Services.obs.addObserver(this, "plugins-list-updated");
-    Services.obs.addObserver(this, "profile-after-change");
-  },
-
-  destroy() {
-    if (!this._initialized) {
-      return;
-    }
-    Services.obs.removeObserver(this, "plugins-list-updated");
-    Services.obs.removeObserver(this, "profile-after-change");
-    this.crashReports = new Map();
-    this.gmpCrashes = new Map();
-    this.pluginMap = new Map();
-  },
 
   observe(subject, topic, data) {
     switch (topic) {
-      case "plugins-list-updated":
-        this._updatePluginMap();
-        break;
-      case "plugin-crashed":
-        this.ensureInitialized();
-        this._registerNPAPICrash(subject);
-        break;
       case "gmp-plugin-crash":
-        this.ensureInitialized();
         this._registerGMPCrash(subject);
         break;
-      case "profile-after-change":
-        this.destroy();
-        break;
-    }
-  },
-
-  getPluginTagById(id) {
-    return this.pluginMap.get(id);
-  },
-
-  _updatePluginMap() {
-    this.pluginMap = new Map();
-    let plugins = gPluginHost.getPluginTags();
-    for (let plugin of plugins) {
-      this.pluginMap.set(plugin.id, plugin);
-    }
-  },
-
-  // Crashed-plugin observer. Notified once per plugin crash, before events
-  // are dispatched to individual plugin instances. However, because of IPC,
-  // the event and the observer notification may still race.
-  _registerNPAPICrash(subject) {
-    let propertyBag = subject;
-    if (
-      !(propertyBag instanceof Ci.nsIWritablePropertyBag2) ||
-      !propertyBag.hasKey("runID") ||
-      !propertyBag.hasKey("pluginName")
-    ) {
-      Cu.reportError(
-        "A NPAPI plugin crashed, but the notification is incomplete."
-      );
-      return;
     }
-
-    let runID = propertyBag.getPropertyAsUint32("runID");
-    let uglyPluginName = propertyBag.getPropertyAsAString("pluginName");
-    let pluginName = makeNicePluginName(uglyPluginName);
-    let pluginDumpID = propertyBag.getPropertyAsAString("pluginDumpID");
-
-    let state;
-    let crashReporter = Services.appinfo.QueryInterface(Ci.nsICrashReporter);
-    if (!AppConstants.MOZ_CRASHREPORTER || !crashReporter.enabled) {
-      // This state tells the user that crash reporting is disabled, so we
-      // cannot send a report.
-      state = "noSubmit";
-    } else if (!pluginDumpID) {
-      // If we don't have a minidumpID, we can't submit anything.
-      // This can happen if the plugin is killed from the task manager.
-      // This state tells the user that this is the case.
-      state = "noReport";
-    } else {
-      // This state asks the user to submit a crash report.
-      state = "please";
-    }
-
-    let crashInfo = { runID, state, pluginName, pluginDumpID };
-    this.crashReports.set(runID, crashInfo);
-    let listeners = this._pendingCrashQueries.get(runID) || [];
-    for (let listener of listeners) {
-      listener(crashInfo);
-    }
-    this._pendingCrashQueries.delete(runID);
   },
 
   _registerGMPCrash(subject) {
@@ -217,14 +71,10 @@ const PluginManager = {
   },
 
   /**
-   * Submit a crash report for a crashed NPAPI plugin.
+   * Submit a crash report for a crashed plugin.
    *
    * @param pluginCrashID
-   *        An object with either a runID (for NPAPI crashes) or a pluginID
-   *        property (for GMP plugin crashes).
-   *        A run ID is a unique identifier for a particular run of a plugin
-   *        process - and is analogous to a process ID (though it is managed
-   *        by Gecko instead of the operating system).
+   *        An object with a pluginID.
    * @param keyVals
    *        An object whose key-value pairs will be merged
    *        with the ".extra" file submitted with the report.
@@ -242,132 +92,26 @@ const PluginManager = {
     }
 
     let { pluginDumpID } = report;
-    let submissionPromise = CrashSubmit.submit(pluginDumpID, {
+    CrashSubmit.submit(pluginDumpID, {
       recordSubmission: true,
       extraExtraKeyVals: keyVals,
     });
 
-    this.broadcastState(pluginCrashID, "submitting");
-
-    submissionPromise.then(
-      () => {
-        this.broadcastState(pluginCrashID, "success");
-      },
-      () => {
-        this.broadcastState(pluginCrashID, "failed");
-      }
-    );
-
-    if (pluginCrashID.hasOwnProperty("runID")) {
-      this.crashReports.delete(pluginCrashID.runID);
-    } else {
-      this.gmpCrashes.delete(pluginCrashID.pluginID);
-    }
-  },
-
-  broadcastState(pluginCrashID, state) {
-    if (!pluginCrashID.hasOwnProperty("runID")) {
-      return;
-    }
-    let { runID } = pluginCrashID;
-    Services.ppmm.broadcastAsyncMessage(
-      "PluginParent:NPAPIPluginCrashReportSubmitted",
-      { runID, state }
-    );
+    this.gmpCrashes.delete(pluginCrashID.pluginID);
   },
 
   getCrashReport(pluginCrashID) {
-    if (pluginCrashID.hasOwnProperty("pluginID")) {
-      return this.gmpCrashes.get(pluginCrashID.pluginID);
-    }
-    return this.crashReports.get(pluginCrashID.runID);
-  },
-
-  /**
-   * Called by actors when they want crash info on behalf of the child.
-   * Will either return such info immediately if we have it, or return
-   * a promise, which resolves when we do have it. The promise resolution
-   * function is kept around for when we get the `plugin-crashed` observer
-   * notification.
-   */
-  awaitPluginCrashInfo(runID) {
-    if (this.crashReports.has(runID)) {
-      return this.crashReports.get(runID);
-    }
-    let listeners = this._pendingCrashQueries.get(runID);
-    if (!listeners) {
-      listeners = [];
-      this._pendingCrashQueries.set(runID, listeners);
-    }
-    return new Promise(resolve => listeners.push(resolve));
-  },
-
-  /**
-   * This allows dependency injection, where an automated test can
-   * dictate how and when we respond to a child's inquiry about a crash.
-   * This is helpful when testing different orderings for plugin crash
-   * notifications (ie race conditions).
-   *
-   * Concretely, for the toplevel browsingContext of the `browser` we're
-   * passed, call the passed `handler` function the next time the child
-   * asks for crash data (using PluginContent:GetCrashData). We'll return
-   * the result of the function to the child. The message in question
-   * uses the actor query API, so promises and/or async functions will
-   * Just Work.
-   */
-  mockResponse(browser, handler) {
-    let { currentWindowGlobal } = browser.frameLoader.browsingContext;
-    currentWindowGlobal.getActor("Plugin")._mockedResponder = handler;
+    return this.gmpCrashes.get(pluginCrashID.pluginID);
   },
 };
 
 class PluginParent extends JSWindowActorParent {
-  constructor() {
-    super();
-    PluginManager.ensureInitialized();
-  }
-
   receiveMessage(msg) {
     let browser = this.manager.rootFrameLoader.ownerElement;
-    let win = browser.ownerGlobal;
     switch (msg.name) {
-      case "PluginContent:ShowClickToPlayNotification":
-        this.showClickToPlayNotification(
-          browser,
-          msg.data.plugin,
-          msg.data.showNow
-        );
-        break;
-      case "PluginContent:RemoveNotification":
-        this.removeNotification(browser);
-        break;
       case "PluginContent:ShowPluginCrashedNotification":
         this.showPluginCrashedNotification(browser, msg.data.pluginCrashID);
         break;
-      case "PluginContent:SubmitReport":
-        if (AppConstants.MOZ_CRASHREPORTER) {
-          this.submitReport(
-            msg.data.runID,
-            msg.data.keyVals,
-            msg.data.submitURLOptIn
-          );
-        }
-        break;
-      case "PluginContent:LinkClickCallback":
-        switch (msg.data.name) {
-          case "managePlugins":
-          case "openHelpPage":
-            this[msg.data.name](win);
-            break;
-        }
-        break;
-      case "PluginContent:GetCrashData":
-        if (this._mockedResponder) {
-          let rv = this._mockedResponder(msg.data);
-          delete this._mockedResponder;
-          return rv;
-        }
-        return PluginManager.awaitPluginCrashInfo(msg.data.runID);
 
       default:
         Cu.reportError(
@@ -379,284 +123,14 @@ class PluginParent extends JSWindowActorParent {
     return null;
   }
 
-  // Callback for user clicking on a disabled plugin
-  managePlugins(window) {
-    window.BrowserOpenAddonsMgr("addons://list/plugin");
-  }
-
-  submitReport(runID, keyVals, submitURLOptIn) {
-    if (!AppConstants.MOZ_CRASHREPORTER) {
-      return;
-    }
-    Services.prefs.setBoolPref(
-      "dom.ipc.plugins.reportCrashURL",
-      !!submitURLOptIn
-    );
-    PluginManager.submitCrashReport({ runID }, keyVals);
-  }
-
-  // Callback for user clicking a "reload page" link
-  reloadPage(browser) {
-    browser.reload();
-  }
-
-  // Callback for user clicking the help icon
-  openHelpPage(window) {
-    window.openHelpLink("plugin-crashed", false);
-  }
-
-  _clickToPlayNotificationEventCallback(event) {
-    if (event == "showing") {
-      Services.telemetry
-        .getHistogramById("PLUGINS_NOTIFICATION_SHOWN")
-        .add(!this.options.showNow);
-    } else if (event == "dismissed") {
-      // Once the popup is dismissed, clicking the icon should show the full
-      // list again
-      this.options.showNow = false;
-    }
-  }
-
-  /**
-   * Called from the plugin doorhanger to set the new permissions for a plugin
-   * and activate plugins if necessary.
-   * aNewState should be one of:
-   * - "allownow"
-   * - "block"
-   * - "continue"
-   * - "continueblocking"
-   */
-  _updatePluginPermission(aBrowser, aActivationInfo, aNewState) {
-    let permission;
-    let histogram = Services.telemetry.getHistogramById(
-      "PLUGINS_NOTIFICATION_USER_ACTION_2"
-    );
-
-    let window = aBrowser.ownerGlobal;
-    let notification = window.PopupNotifications.getNotification(
-      kNotificationId,
-      aBrowser
-    );
-
-    // Update the permission manager.
-    // Also update the current state of activationInfo.fallbackType so that
-    // subsequent opening of the notification shows the current state.
-    switch (aNewState) {
-      case "allownow":
-        permission = Ci.nsIPermissionManager.ALLOW_ACTION;
-        histogram.add(0);
-        aActivationInfo.fallbackType = PLUGIN_ACTIVE;
-        notification.options.extraAttr = "active";
-        break;
-
-      case "block":
-        permission = Ci.nsIPermissionManager.PROMPT_ACTION;
-        histogram.add(2);
-        aActivationInfo.fallbackType = PLUGIN_CLICK_TO_PLAY_QUIET;
-        notification.options.extraAttr = "inactive";
-        break;
-
-      // In case a plugin has already been allowed/disallowed in another tab, the
-      // buttons matching the existing block state shouldn't change any permissions
-      // but should run the plugin-enablement code below.
-      case "continue":
-        aActivationInfo.fallbackType = PLUGIN_ACTIVE;
-        notification.options.extraAttr = "active";
-        break;
-
-      case "continueblocking":
-        aActivationInfo.fallbackType = PLUGIN_CLICK_TO_PLAY_QUIET;
-        notification.options.extraAttr = "inactive";
-        break;
-
-      default:
-        Cu.reportError(Error("Unexpected plugin state: " + aNewState));
-        return;
-    }
-
-    if (aNewState != "continue" && aNewState != "continueblocking") {
-      let { principal } = notification.options;
-      Services.perms.addFromPrincipal(
-        principal,
-        aActivationInfo.permissionString,
-        permission,
-        Ci.nsIPermissionManager.EXPIRE_SESSION,
-        0 // do not expire (only expire at the end of the session)
-      );
-    }
-
-    this.sendAsyncMessage("PluginParent:ActivatePlugins", {
-      activationInfo: aActivationInfo,
-      newState: aNewState,
-    });
-  }
-
-  showClickToPlayNotification(browser, plugin, showNow) {
-    let window = browser.ownerGlobal;
-    if (!window.PopupNotifications) {
-      return;
-    }
-    let notification = window.PopupNotifications.getNotification(
-      kNotificationId,
-      browser
-    );
-
-    if (!plugin) {
-      this.removeNotification(browser);
-      return;
-    }
-
-    // We assume that we can only have 1 notification at a time anyway.
-    if (notification) {
-      if (showNow) {
-        notification.options.showNow = true;
-        notification.reshow();
-      }
-      return;
-    }
-
-    // Construct a notification for the plugin:
-    let { id, fallbackType } = plugin;
-    let pluginTag = PluginManager.getPluginTagById(id);
-    if (!pluginTag) {
-      return;
-    }
-    let permissionString = gPluginHost.getPermissionStringForTag(pluginTag);
-    let active = fallbackType == PLUGIN_ACTIVE;
-
-    let { top } = this.browsingContext;
-    if (!top.currentWindowGlobal) {
-      return;
-    }
-    let principal = top.currentWindowGlobal.documentPrincipal;
-
-    let options = {
-      dismissed: !showNow,
-      hideClose: true,
-      persistent: showNow,
-      eventCallback: this._clickToPlayNotificationEventCallback,
-      showNow,
-      popupIconClass: "plugin-icon",
-      extraAttr: active ? "active" : "inactive",
-      principal,
-    };
-
-    let description;
-    if (
-      fallbackType == Ci.nsIObjectLoadingContent.PLUGIN_VULNERABLE_UPDATABLE
-    ) {
-      description = gNavigatorBundle.GetStringFromName(
-        "flashActivate.outdated.message"
-      );
-    } else {
-      description = gNavigatorBundle.GetStringFromName("flashActivate.message");
-    }
-
-    let badge = window.document.getElementById("plugin-icon-badge");
-    badge.setAttribute("animate", "true");
-    badge.addEventListener("animationend", function animListener(event) {
-      if (
-        event.animationName == "blink-badge" &&
-        badge.hasAttribute("animate")
-      ) {
-        badge.removeAttribute("animate");
-        badge.removeEventListener("animationend", animListener);
-      }
-    });
-
-    let weakBrowser = Cu.getWeakReference(browser);
-
-    let activationInfo = { id, fallbackType, permissionString };
-    // Note: in both of these action callbacks, we check the fallbackType on the
-    // activationInfo object, not the local variable. This is important because
-    // the activationInfo object is effectively read/write - the notification
-    // will stay up, and for blocking after allowing (or vice versa) to work, we
-    // need to always read the updated value.
-    let mainAction = {
-      callback: () => {
-        let browserRef = weakBrowser.get();
-        if (!browserRef) {
-          return;
-        }
-        let perm =
-          activationInfo.fallbackType == PLUGIN_ACTIVE
-            ? "continue"
-            : "allownow";
-        this._updatePluginPermission(browserRef, activationInfo, perm);
-      },
-      label: gNavigatorBundle.GetStringFromName("flashActivate.allow"),
-      accessKey: gNavigatorBundle.GetStringFromName(
-        "flashActivate.allow.accesskey"
-      ),
-      dismiss: true,
-    };
-    let secondaryActions = [
-      {
-        callback: () => {
-          let browserRef = weakBrowser.get();
-          if (!browserRef) {
-            return;
-          }
-          let perm =
-            activationInfo.fallbackType == PLUGIN_ACTIVE
-              ? "block"
-              : "continueblocking";
-          this._updatePluginPermission(browserRef, activationInfo, perm);
-        },
-        label: gNavigatorBundle.GetStringFromName("flashActivate.noAllow"),
-        accessKey: gNavigatorBundle.GetStringFromName(
-          "flashActivate.noAllow.accesskey"
-        ),
-        dismiss: true,
-      },
-    ];
-
-    window.PopupNotifications.show(
-      browser,
-      kNotificationId,
-      description,
-      "plugins-notification-icon",
-      mainAction,
-      secondaryActions,
-      options
-    );
-
-    // Check if the plugin is insecure and update the notification icon accordingly.
-    let haveInsecure = false;
-    switch (fallbackType) {
-      // haveInsecure will trigger the red flashing icon and the infobar
-      // styling below
-      case PLUGIN_VULNERABLE_UPDATABLE:
-      case PLUGIN_VULNERABLE_NO_UPDATE:
-        haveInsecure = true;
-    }
-
-    window.document
-      .getElementById("plugins-notification-icon")
-      .classList.toggle("plugin-blocked", haveInsecure);
-  }
-
-  removeNotification(browser) {
-    let { PopupNotifications } = browser.ownerGlobal;
-    let notification = PopupNotifications.getNotification(
-      kNotificationId,
-      browser
-    );
-    if (notification) {
-      PopupNotifications.remove(notification);
-    }
-  }
-
   /**
-   * Shows a plugin-crashed notification bar for a browser that has had an
-   * invisible NPAPI plugin crash, or a GMP plugin crash.
+   * Shows a plugin-crashed notification bar for a browser that has had a
+   * GMP plugin crash.
    *
    * @param browser
    *        The browser to show the notification for.
    * @param pluginCrashID
-   *        The unique-per-process identifier for the NPAPI plugin or GMP.
-   *        This will have either a runID or pluginID property, identifying
-   *        an npapi plugin or gmp plugin crash, respectively.
+   *        The unique-per-process identifier for GMP.
    */
   showPluginCrashedNotification(browser, pluginCrashID) {
     // If there's already an existing notification bar, don't do anything.
diff --git a/browser/base/content/nsContextMenu.js b/browser/base/content/nsContextMenu.js
index 8f98510988a6b..eb6a3c6d9d160 100644
--- a/browser/base/content/nsContextMenu.js
+++ b/browser/base/content/nsContextMenu.js
@@ -211,7 +211,6 @@ class nsContextMenu {
     this.onAudio = context.onAudio;
     this.onCanvas = context.onCanvas;
     this.onCompletedImage = context.onCompletedImage;
-    this.onCTPPlugin = context.onCTPPlugin;
     this.onDRMMedia = context.onDRMMedia;
     this.onPiPVideo = context.onPiPVideo;
     this.onEditable = context.onEditable;
@@ -940,8 +939,8 @@ class nsContextMenu {
   }
 
   initClickToPlayItems() {
-    this.showItem("context-ctp-play", this.onCTPPlugin);
-    this.showItem("context-ctp-hide", this.onCTPPlugin);
+    this.showItem("context-ctp-play", false);
+    this.showItem("context-ctp-hide", false);
   }
 
   initPasswordManagerItems() {
@@ -1849,11 +1848,11 @@ class nsContextMenu {
   }
 
   playPlugin() {
-    this.actor.pluginCommand("play", this.targetIdentifier);
+    /* no-op.  TODO: Remove me. */
   }
 
   hidePlugin() {
-    this.actor.pluginCommand("hide", this.targetIdentifier);
+    /* no-op.  TODO: Remove me. */
   }
 
   // Generate email address and put it on clipboard.
diff --git a/browser/components/BrowserGlue.jsm b/browser/components/BrowserGlue.jsm
index 5c7dac94d84e7..03f600cf0792f 100644
--- a/browser/components/BrowserGlue.jsm
+++ b/browser/components/BrowserGlue.jsm
@@ -607,6 +607,7 @@ let JSWINDOWACTORS = {
     allFrames: true,
   },
 
+  // GMP crash reporting
   Plugin: {
     parent: {
       moduleURI: "resource:///actors/PluginParent.jsm",
@@ -614,15 +615,8 @@ let JSWINDOWACTORS = {
     child: {
       moduleURI: "resource:///actors/PluginChild.jsm",
       events: {
-        PluginBindingAttached: { capture: true, wantUntrusted: true },
         PluginCrashed: { capture: true },
-        PluginOutdated: { capture: true },
-        PluginInstantiated: { capture: true },
-        PluginRemoved: { capture: true },
-        HiddenPlugin: { capture: true },
       },
-
-      observers: ["decoder-doctor-notification"],
     },
 
     allFrames: true,
diff --git a/dom/docs/ipc/jsactors.rst b/dom/docs/ipc/jsactors.rst
index afd307ce805b8..52bdd2b7282c6 100644
--- a/dom/docs/ipc/jsactors.rst
+++ b/dom/docs/ipc/jsactors.rst
@@ -398,12 +398,7 @@ Here's an example ``JSWindowActor`` registration pulled from ``BrowserGlue.jsm``
       child: {
         moduleURI: "resource:///actors/PluginChild.jsm",
         events: {
-          PluginBindingAttached: { capture: true, wantUntrusted: true },
           PluginCrashed: { capture: true },
-          PluginOutdated: { capture: true },
-          PluginInstantiated: { capture: true },
-          PluginRemoved: { capture: true },
-          HiddenPlugin: { capture: true },
         },
 
         observers: ["decoder-doctor-notification"],
@@ -412,7 +407,7 @@ Here's an example ``JSWindowActor`` registration pulled from ``BrowserGlue.jsm``
       allFrames: true,
     },
 
-This example is for the JSWindowActor implementation of click-to-play for Flash.
+This example is for the JSWindowActor implementation of crash reporting for GMP.
 
 Let's examine parent registration:
 
@@ -434,12 +429,7 @@ Let's look at the second chunk:
       child: {
         moduleURI: "resource:///actors/PluginChild.jsm",
         events: {
-          PluginBindingAttached: { capture: true, wantUntrusted: true },
           PluginCrashed: { capture: true },
-          PluginOutdated: { capture: true },
-          PluginInstantiated: { capture: true },
-          PluginRemoved: { capture: true },
-          HiddenPlugin: { capture: true },
         },
 
         observers: ["decoder-doctor-notification"],
diff --git a/xpcom/ds/StaticAtoms.py b/xpcom/ds/StaticAtoms.py
index a47f00906ccba..baf369d19d643 100644
--- a/xpcom/ds/StaticAtoms.py
+++ b/xpcom/ds/StaticAtoms.py
@@ -1915,7 +1915,6 @@
     Atom("onDOMWindowFocus", "onDOMWindowFocus"),
     Atom("onFullZoomChange", "onFullZoomChange"),
     Atom("onGloballyAutoplayBlocked", "onGloballyAutoplayBlocked"),
-    Atom("onHiddenPlugin", "onHiddenPlugin"),
     Atom("onMozApplicationManifest", "onMozApplicationManifest"),
     Atom("onMozDOMFullscreen_Entered", "onMozDOMFullscreen:Entered"),
     Atom("onMozDOMFullscreen_Exit", "onMozDOMFullscreen:Exit"),
@@ -1929,11 +1928,7 @@
     Atom("onMozOpenDateTimePicker", "onMozOpenDateTimePicker"),
     Atom("onMozSessionStorageChanged", "onMozSessionStorageChanged"),
     Atom("onMozTogglePictureInPicture", "onMozTogglePictureInPicture"),
-    Atom("onPluginBindingAttached", "onPluginBindingAttached"),
     Atom("onPluginCrashed", "onPluginCrashed"),
-    Atom("onPluginInstantiated", "onPluginInstantiated"),
-    Atom("onPluginOutdated", "onPluginOutdated"),
-    Atom("onPluginRemoved", "onPluginRemoved"),
     Atom("onPrintingError", "onPrintingError"),
     Atom("onTextZoomChange", "onTextZoomChange"),
     Atom("onUAWidgetSetupOrChange", "onUAWidgetSetupOrChange"),
