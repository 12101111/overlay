From 45f5dd79ffa404c8f6b3c5c77627d4a639b19fed Mon Sep 17 00:00:00 2001
From: David Parks <daparks@mozilla.com>
Date: Mon, 5 Apr 2021 23:48:34 +0000
Subject: [PATCH] Bug 1682030 - Remove PPluginWidget.  
 r=jmathies,ipc-reviewers,nika

Removes the NPAPI plugin widget actor and its proxy, as part of removing all of NPAPI plugin support.

Differential Revision: https://phabricator.services.mozilla.com/D107141
---
 dom/base/nsFrameLoader.cpp                 |  19 ---
 dom/ipc/BrowserChild.cpp                   |  52 -------
 dom/ipc/BrowserChild.h                     |  10 --
 dom/ipc/BrowserParent.cpp                  |  29 ----
 dom/ipc/BrowserParent.h                    |   7 -
 dom/ipc/ContentParent.cpp                  |  16 +-
 dom/ipc/PBrowser.ipdl                      |   9 --
 dom/ipc/PPluginWidget.ipdl                 |  63 --------
 dom/ipc/moz.build                          |   1 -
 dom/plugins/base/nsPluginInstanceOwner.cpp |  25 ---
 dom/plugins/ipc/PluginWidgetChild.cpp      |  60 -------
 dom/plugins/ipc/PluginWidgetChild.h        |  41 -----
 dom/plugins/ipc/PluginWidgetParent.cpp     | 168 --------------------
 dom/plugins/ipc/PluginWidgetParent.h       |  64 --------
 dom/plugins/ipc/moz.build                  |  11 --
 ipc/ipdl/sync-messages.ini                 |   2 -
 toolkit/xre/nsEmbedFunctions.cpp           |   6 -
 widget/PluginWidgetProxy.cpp               | 173 ---------------------
 widget/PluginWidgetProxy.h                 |  80 ----------
 widget/moz.build                           |   8 -
 widget/nsIWidget.h                         |  12 --
 widget/windows/nsWindow.cpp                |  29 +---
 22 files changed, 3 insertions(+), 882 deletions(-)
 delete mode 100644 dom/ipc/PPluginWidget.ipdl
 delete mode 100644 dom/plugins/ipc/PluginWidgetChild.cpp
 delete mode 100644 dom/plugins/ipc/PluginWidgetChild.h
 delete mode 100644 dom/plugins/ipc/PluginWidgetParent.cpp
 delete mode 100644 dom/plugins/ipc/PluginWidgetParent.h
 delete mode 100644 widget/PluginWidgetProxy.cpp
 delete mode 100644 widget/PluginWidgetProxy.h

diff --git a/dom/base/nsFrameLoader.cpp b/dom/base/nsFrameLoader.cpp
index 643eb56fe9..e481d9c57a 100644
--- a/dom/base/nsFrameLoader.cpp
+++ b/dom/base/nsFrameLoader.cpp
@@ -117,11 +117,6 @@
 
 #include "mozilla/ContentPrincipal.h"
 
-#ifdef XP_WIN
-#  include "mozilla/plugins/PPluginWidgetParent.h"
-#  include "../plugins/ipc/PluginWidgetParent.h"
-#endif
-
 #ifdef MOZ_XUL
 #  include "nsXULPopupManager.h"
 #endif
@@ -1292,20 +1287,6 @@ nsresult nsFrameLoader::SwapWithOtherRemoteLoader(
   otherBrowserParent->SetBrowserDOMWindow(browserDOMWindow);
   browserParent->SetBrowserDOMWindow(otherBrowserDOMWindow);
 
-#ifdef XP_WIN
-  // Native plugin windows used by this remote content need to be reparented.
-  if (nsPIDOMWindowOuter* newWin = ourDoc->GetWindow()) {
-    RefPtr<nsIWidget> newParent =
-        nsGlobalWindowOuter::Cast(newWin)->GetMainWidget();
-    const ManagedContainer<mozilla::plugins::PPluginWidgetParent>& plugins =
-        otherBrowserParent->ManagedPPluginWidgetParent();
-    for (auto iter = plugins.ConstIter(); !iter.Done(); iter.Next()) {
-      static_cast<mozilla::plugins::PluginWidgetParent*>(iter.Get()->GetKey())
-          ->SetParent(newParent);
-    }
-  }
-#endif  // XP_WIN
-
   MaybeUpdatePrimaryBrowserParent(eBrowserParentRemoved);
   aOther->MaybeUpdatePrimaryBrowserParent(eBrowserParentRemoved);
 
diff --git a/dom/ipc/BrowserChild.cpp b/dom/ipc/BrowserChild.cpp
index c8e2e1f503..babdf1130f 100644
--- a/dom/ipc/BrowserChild.cpp
+++ b/dom/ipc/BrowserChild.cpp
@@ -91,7 +91,6 @@
 #include "mozilla/layers/LayerTransactionChild.h"
 #include "mozilla/layers/ShadowLayers.h"
 #include "mozilla/layers/WebRenderLayerManager.h"
-#include "mozilla/plugins/PPluginWidgetChild.h"
 #include "nsBrowserStatusFilter.h"
 #include "nsColorPickerProxy.h"
 #include "nsCommandParams.h"
@@ -141,10 +140,6 @@
 #include "nsWindowWatcher.h"
 #include "nsIXULRuntime.h"
 
-#ifdef XP_WIN
-#  include "mozilla/plugins/PluginWidgetChild.h"
-#endif
-
 #ifdef MOZ_WAYLAND
 #  include "nsAppRunner.h"
 #endif
@@ -3265,53 +3260,6 @@ mozilla::ipc::IPCResult BrowserChild::RecvReleaseAllPointerCapture() {
   return IPC_OK();
 }
 
-mozilla::plugins::PPluginWidgetChild* BrowserChild::AllocPPluginWidgetChild() {
-#ifdef XP_WIN
-  return new mozilla::plugins::PluginWidgetChild();
-#else
-  MOZ_ASSERT_UNREACHABLE("AllocPPluginWidgetChild only supports Windows");
-  return nullptr;
-#endif
-}
-
-bool BrowserChild::DeallocPPluginWidgetChild(
-    mozilla::plugins::PPluginWidgetChild* aActor) {
-  delete aActor;
-  return true;
-}
-
-#ifdef XP_WIN
-nsresult BrowserChild::CreatePluginWidget(nsIWidget* aParent,
-                                          nsIWidget** aOut) {
-  *aOut = nullptr;
-  mozilla::plugins::PluginWidgetChild* child =
-      static_cast<mozilla::plugins::PluginWidgetChild*>(
-          SendPPluginWidgetConstructor());
-  if (!child) {
-    NS_ERROR("couldn't create PluginWidgetChild");
-    return NS_ERROR_UNEXPECTED;
-  }
-  nsCOMPtr<nsIWidget> pluginWidget =
-      nsIWidget::CreatePluginProxyWidget(this, child);
-  if (!pluginWidget) {
-    NS_ERROR("couldn't create PluginWidgetProxy");
-    return NS_ERROR_UNEXPECTED;
-  }
-
-  nsWidgetInitData initData;
-  initData.mWindowType = eWindowType_plugin_ipc_content;
-  initData.clipChildren = true;
-  initData.clipSiblings = true;
-  nsresult rv = pluginWidget->Create(
-      aParent, nullptr, LayoutDeviceIntRect(0, 0, 0, 0), &initData);
-  if (NS_FAILED(rv)) {
-    NS_WARNING("Creating native plugin widget on the chrome side failed.");
-  }
-  pluginWidget.forget(aOut);
-  return rv;
-}
-#endif  // XP_WIN
-
 PPaymentRequestChild* BrowserChild::AllocPPaymentRequestChild() {
   MOZ_CRASH(
       "We should never be manually allocating PPaymentRequestChild actors");
diff --git a/dom/ipc/BrowserChild.h b/dom/ipc/BrowserChild.h
index b60efb515d..57e58c5352 100644
--- a/dom/ipc/BrowserChild.h
+++ b/dom/ipc/BrowserChild.h
@@ -558,16 +558,6 @@ class BrowserChild final : public nsMessageManagerScriptExecutor,
 
   mozilla::ipc::IPCResult RecvWillChangeProcess(
       WillChangeProcessResolver&& aResolve);
-  /**
-   * Native widget remoting protocol for use with windowed plugins with e10s.
-   */
-  PPluginWidgetChild* AllocPPluginWidgetChild();
-
-  bool DeallocPPluginWidgetChild(PPluginWidgetChild* aActor);
-
-#ifdef XP_WIN
-  nsresult CreatePluginWidget(nsIWidget* aParent, nsIWidget** aOut);
-#endif
 
   PPaymentRequestChild* AllocPPaymentRequestChild();
 
diff --git a/dom/ipc/BrowserParent.cpp b/dom/ipc/BrowserParent.cpp
index 2d7e5f3f38..0c9d699ffd 100644
--- a/dom/ipc/BrowserParent.cpp
+++ b/dom/ipc/BrowserParent.cpp
@@ -45,7 +45,6 @@
 #include "mozilla/layers/AsyncDragMetrics.h"
 #include "mozilla/layers/InputAPZContext.h"
 #include "mozilla/layout/RemoteLayerTreeOwner.h"
-#include "mozilla/plugins/PPluginWidgetParent.h"
 #include "mozilla/LookAndFeel.h"
 #include "mozilla/MiscEvents.h"
 #include "mozilla/MouseEvents.h"
@@ -135,7 +134,6 @@
 #include "VsyncSource.h"
 
 #ifdef XP_WIN
-#  include "mozilla/plugins/PluginWidgetParent.h"
 #  include "FxRWindowManager.h"
 #endif
 
@@ -623,18 +621,6 @@ void BrowserParent::DestroyInternal() {
   // and auto-cleanup will kick in.  Otherwise, the child side will
   // destroy itself and send back __delete__().
   Unused << SendDestroy();
-
-#ifdef XP_WIN
-  // Let all PluginWidgets know we are tearing down. Prevents
-  // these objects from sending async events after the child side
-  // is shut down.
-  const ManagedContainer<PPluginWidgetParent>& kids =
-      ManagedPPluginWidgetParent();
-  for (auto iter = kids.ConstIter(); !iter.Done(); iter.Next()) {
-    static_cast<mozilla::plugins::PluginWidgetParent*>(iter.Get()->GetKey())
-        ->ParentDestroy();
-  }
-#endif
 }
 
 void BrowserParent::Destroy() {
@@ -3702,22 +3688,6 @@ mozilla::ipc::IPCResult BrowserParent::RecvRemoteIsReadyToHandleInputEvents() {
   return IPC_OK();
 }
 
-mozilla::plugins::PPluginWidgetParent*
-BrowserParent::AllocPPluginWidgetParent() {
-#ifdef XP_WIN
-  return new mozilla::plugins::PluginWidgetParent();
-#else
-  MOZ_ASSERT_UNREACHABLE("AllocPPluginWidgetParent only supports Windows");
-  return nullptr;
-#endif
-}
-
-bool BrowserParent::DeallocPPluginWidgetParent(
-    mozilla::plugins::PPluginWidgetParent* aActor) {
-  delete aActor;
-  return true;
-}
-
 PPaymentRequestParent* BrowserParent::AllocPPaymentRequestParent() {
   RefPtr<PaymentRequestParent> actor = new PaymentRequestParent();
   return actor.forget().take();
diff --git a/dom/ipc/BrowserParent.h b/dom/ipc/BrowserParent.h
index 744e1b7811..3fe3f2a188 100644
--- a/dom/ipc/BrowserParent.h
+++ b/dom/ipc/BrowserParent.h
@@ -657,13 +657,6 @@ class BrowserParent final : public PBrowserParent,
 
   void StopIMEStateManagement();
 
-  /**
-   * Native widget remoting protocol for use with windowed plugins with e10s.
-   */
-  PPluginWidgetParent* AllocPPluginWidgetParent();
-
-  bool DeallocPPluginWidgetParent(PPluginWidgetParent* aActor);
-
   PPaymentRequestParent* AllocPPaymentRequestParent();
 
   bool DeallocPPaymentRequestParent(PPaymentRequestParent* aActor);
diff --git a/dom/ipc/ContentParent.cpp b/dom/ipc/ContentParent.cpp
index 1728e50428..f249cc02ea 100644
--- a/dom/ipc/ContentParent.cpp
+++ b/dom/ipc/ContentParent.cpp
@@ -1225,22 +1225,8 @@ already_AddRefed<ContentParent> ContentParent::GetNewOrUsedJSPluginProcess(
 }
 
 #if defined(XP_WIN)
-extern const wchar_t* kPluginWidgetContentParentProperty;
-
 /*static*/
-void ContentParent::SendAsyncUpdate(nsIWidget* aWidget) {
-  if (!aWidget || aWidget->Destroyed()) {
-    return;
-  }
-  // Fire off an async request to the plugin to paint its window
-  HWND hwnd = (HWND)aWidget->GetNativeData(NS_NATIVE_WINDOW);
-  NS_ASSERTION(hwnd, "Expected valid hwnd value.");
-  ContentParent* cp = reinterpret_cast<ContentParent*>(
-      ::GetPropW(hwnd, kPluginWidgetContentParentProperty));
-  if (cp && cp->CanSend()) {
-    Unused << cp->SendUpdateWindow((uintptr_t)hwnd);
-  }
-}
+void ContentParent::SendAsyncUpdate(nsIWidget* aWidget) {}
 #endif  // defined(XP_WIN)
 
 static nsIDocShell* GetOpenerDocShellHelper(Element* aFrameElement) {
diff --git a/dom/ipc/PBrowser.ipdl b/dom/ipc/PBrowser.ipdl
index c9ceb5c752..5257623e91 100644
--- a/dom/ipc/PBrowser.ipdl
+++ b/dom/ipc/PBrowser.ipdl
@@ -11,7 +11,6 @@ include protocol PContent;
 include protocol PDocAccessible;
 #endif
 include protocol PFilePicker;
-include protocol PPluginWidget;
 include protocol PRemotePrintJob;
 include protocol PChildToParentStream;
 include protocol PParentToChildStream;
@@ -191,7 +190,6 @@ nested(upto inside_cpow) sync refcounted protocol PBrowser
 #endif
 
     manages PFilePicker;
-    manages PPluginWidget;
     manages PPaymentRequest;
     manages PWindowGlobal;
     manages PBrowserBridge;
@@ -214,13 +212,6 @@ parent:
                          uint32_t aMsaaID, IAccessibleHolder aDocCOMProxy);
 #endif
 
-    /*
-     * Creates a new remoted nsIWidget connection for windowed plugins
-     * in e10s mode. This is always initiated from the child in response
-     * to windowed plugin creation.
-     */
-    sync PPluginWidget();
-
     async PPaymentRequest();
 
     /**
diff --git a/dom/ipc/PPluginWidget.ipdl b/dom/ipc/PPluginWidget.ipdl
deleted file mode 100644
index 1e5d308292..0000000000
--- a/dom/ipc/PPluginWidget.ipdl
+++ /dev/null
@@ -1,63 +0,0 @@
-        /* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-include protocol PBrowser;
-
-include "mozilla/dom/BindingIPCUtils.h";
-include "mozilla/GfxMessageUtils.h";
-
-using mozilla::dom::CallerType from "mozilla/dom/BindingDeclarations.h";
-using nsIntRect from "nsRect.h";
-
-namespace mozilla {
-namespace plugins {
-
-/**
- * PPluginWidget - a nsIWidget'ish protocol for windowed plugins in e10s.
- * On windows we create native widgets in chrome which we then manage
- * from content.  On the566595 content side there's PluginWidgetProxy which
- * implements nsIWidget. We hand this around layout and plugins code. Anything
- * not dealt with via PluginWidgetProxy falls through to PuppetWidget. Native
- * widget exists on the chrome side (PluginWidgetParent) attached to the
- * browser window as a child. Window management calls are forwarded from
- * PluginWidgetProxy to PluginWidgetParent over this interface.
- *
- * Note lifetime management for PluginWidgetProxy (the plugin widget) and the
- * connection (PluginWidgetChild) are separated. PluginWidgetChild will
- * be torn down first by the tab, followed by the deref'ing of the nsIWidget
- * via layout.
- */
-sync protocol PPluginWidget {
-  manager PBrowser;
-
-parent:
-  async __delete__();
-
-  /**
-   * Used to set the ID of a scroll capture container from the parent process,
-   * so that we can create a proxy container in the layer tree.
-   * @param aScrollCaptureId async container ID of the parent container
-   * @param aPluginInstanceId plugin ID on which to set the scroll capture ID
-   */
-  sync Create() returns (nsresult aResult, uint64_t aScrollCaptureId,
-                         uintptr_t aPluginInstanceId);
-  async SetFocus(bool aRaise, CallerType aCallerType);
-
-  /**
-   * Returns NS_NATIVE_PLUGIN_PORT and its variants: a sharable native
-   * window for plugins. On Linux, this returns an XID for a socket widget
-   * embedded in the chrome side native window. On Windows this returns the
-   * native HWND of the plugin widget.
-   */
-  sync GetNativePluginPort() returns (uintptr_t value);
-
-  /**
-   * Sends an NS_NATIVE_CHILD_WINDOW to be adopted by the widget's native window
-   * on the chrome side. This is only currently used on Windows.
-   */
-  sync SetNativeChildWindow(uintptr_t childWindow);
-};
-
-}
-}
diff --git a/dom/ipc/moz.build b/dom/ipc/moz.build
index caa1bfc88e..83ba062407 100644
--- a/dom/ipc/moz.build
+++ b/dom/ipc/moz.build
@@ -152,7 +152,6 @@ IPDL_SOURCES += [
     "PFilePicker.ipdl",
     "PInProcess.ipdl",
     "PLoginReputation.ipdl",
-    "PPluginWidget.ipdl",
     "PProcessHangMonitor.ipdl",
     "PrefsTypes.ipdlh",
     "PTabContext.ipdlh",
diff --git a/dom/plugins/base/nsPluginInstanceOwner.cpp b/dom/plugins/base/nsPluginInstanceOwner.cpp
index e836c30d68..5f3bd03dee 100644
--- a/dom/plugins/base/nsPluginInstanceOwner.cpp
+++ b/dom/plugins/base/nsPluginInstanceOwner.cpp
@@ -1429,31 +1429,6 @@ NS_IMETHODIMP nsPluginInstanceOwner::CreateWidget(void) {
     nsresult rv = NS_ERROR_FAILURE;
 
     nsCOMPtr<nsIWidget> parentWidget;
-    Document* doc = nullptr;
-    nsCOMPtr<nsIContent> content = do_QueryReferent(mContent);
-    if (content) {
-      doc = content->OwnerDoc();
-      parentWidget = nsContentUtils::WidgetForDocument(doc);
-      // If we're running in the content process, we need a remote widget
-      // created in chrome.
-      if (XRE_IsContentProcess()) {
-        if (nsCOMPtr<nsPIDOMWindowOuter> window = doc->GetWindow()) {
-          if (nsCOMPtr<nsPIDOMWindowOuter> topWindow =
-                  window->GetInProcessTop()) {
-            dom::BrowserChild* tc = dom::BrowserChild::GetFrom(topWindow);
-            if (tc) {
-              // This returns a PluginWidgetProxy which remotes a number of
-              // calls.
-              rv = tc->CreatePluginWidget(parentWidget.get(),
-                                          getter_AddRefs(mWidget));
-              if (NS_FAILED(rv)) {
-                return rv;
-              }
-            }
-          }
-        }
-      }
-    }
 
     // A failure here is terminal since we can't fall back on the non-e10s code
     // path below.
diff --git a/dom/plugins/ipc/PluginWidgetChild.cpp b/dom/plugins/ipc/PluginWidgetChild.cpp
deleted file mode 100644
index c25c8529fd..0000000000
--- a/dom/plugins/ipc/PluginWidgetChild.cpp
+++ /dev/null
@@ -1,60 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "mozilla/plugins/PluginWidgetChild.h"
-
-#include "mozilla/dom/BrowserChild.h"
-#include "mozilla/plugins/PluginWidgetParent.h"
-#include "PluginWidgetProxy.h"
-
-#include "mozilla/Unused.h"
-#include "mozilla/DebugOnly.h"
-#include "nsDebug.h"
-
-#include "mozilla/plugins/PluginInstanceParent.h"
-
-#define PWLOG(...)
-//#define PWLOG(...) printf_stderr(__VA_ARGS__)
-
-namespace mozilla {
-namespace plugins {
-
-PluginWidgetChild::PluginWidgetChild() : mWidget(nullptr) {
-  PWLOG("PluginWidgetChild::PluginWidgetChild()\n");
-  MOZ_COUNT_CTOR(PluginWidgetChild);
-}
-
-PluginWidgetChild::~PluginWidgetChild() {
-  PWLOG("PluginWidgetChild::~PluginWidgetChild()\n");
-  MOZ_COUNT_DTOR(PluginWidgetChild);
-}
-
-// Called by the proxy widget when it is destroyed by layout. Only gets
-// called once.
-void PluginWidgetChild::ProxyShutdown() {
-  PWLOG("PluginWidgetChild::ProxyShutdown()\n");
-  if (mWidget) {
-    mWidget = nullptr;
-    auto tab = static_cast<mozilla::dom::BrowserChild*>(Manager());
-    if (!tab->IsDestroyed()) {
-      Unused << Send__delete__(this);
-    }
-  }
-}
-
-void PluginWidgetChild::KillWidget() {
-  PWLOG("PluginWidgetChild::KillWidget()\n");
-  if (mWidget) {
-    mWidget->ChannelDestroyed();
-  }
-  mWidget = nullptr;
-}
-
-void PluginWidgetChild::ActorDestroy(ActorDestroyReason aWhy) {
-  PWLOG("PluginWidgetChild::ActorDestroy(%d)\n", aWhy);
-  KillWidget();
-}
-
-}  // namespace plugins
-}  // namespace mozilla
diff --git a/dom/plugins/ipc/PluginWidgetChild.h b/dom/plugins/ipc/PluginWidgetChild.h
deleted file mode 100644
index 1fc2d6ee98..0000000000
--- a/dom/plugins/ipc/PluginWidgetChild.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_plugins_PluginWidgetChild_h
-#define mozilla_plugins_PluginWidgetChild_h
-
-#ifndef XP_WIN
-#  error "This header should be Windows-only."
-#endif
-
-#include "mozilla/plugins/PPluginWidgetChild.h"
-
-namespace mozilla {
-namespace widget {
-class PluginWidgetProxy;
-}  // namespace widget
-namespace plugins {
-
-class PluginWidgetChild : public PPluginWidgetChild {
- public:
-  PluginWidgetChild();
-  virtual ~PluginWidgetChild();
-
-  virtual void ActorDestroy(ActorDestroyReason aWhy) override;
-
-  void SetWidget(mozilla::widget::PluginWidgetProxy* aWidget) {
-    mWidget = aWidget;
-  }
-  void ProxyShutdown();
-
- private:
-  void KillWidget();
-
-  mozilla::widget::PluginWidgetProxy* mWidget;
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // mozilla_plugins_PluginWidgetChild_h
diff --git a/dom/plugins/ipc/PluginWidgetParent.cpp b/dom/plugins/ipc/PluginWidgetParent.cpp
deleted file mode 100644
index 0def364dc9..0000000000
--- a/dom/plugins/ipc/PluginWidgetParent.cpp
+++ /dev/null
@@ -1,168 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "PluginWidgetParent.h"
-#include "mozilla/dom/BrowserParent.h"
-#include "mozilla/dom/ContentParent.h"
-#include "nsComponentManagerUtils.h"
-#include "nsWidgetsCID.h"
-
-#include "mozilla/Unused.h"
-#include "mozilla/DebugOnly.h"
-#include "nsDebug.h"
-
-using namespace mozilla;
-using namespace mozilla::widget;
-
-#define PWLOG(...)
-//#define PWLOG(...) printf_stderr(__VA_ARGS__)
-
-namespace mozilla {
-namespace dom {
-// For nsWindow
-const wchar_t* kPluginWidgetContentParentProperty =
-    L"kPluginWidgetParentProperty";
-}  // namespace dom
-}  // namespace mozilla
-
-namespace mozilla {
-namespace plugins {
-
-// This macro returns IPC_OK() to prevent an abort in the child process when
-// ipc message delivery fails.
-#define ENSURE_CHANNEL                                   \
-  {                                                      \
-    if (!mWidget) {                                      \
-      NS_WARNING("called on an invalid remote widget."); \
-      return IPC_OK();                                   \
-    }                                                    \
-  }
-
-PluginWidgetParent::PluginWidgetParent() {
-  PWLOG("PluginWidgetParent::PluginWidgetParent()\n");
-  MOZ_COUNT_CTOR(PluginWidgetParent);
-}
-
-PluginWidgetParent::~PluginWidgetParent() {
-  PWLOG("PluginWidgetParent::~PluginWidgetParent()\n");
-  MOZ_COUNT_DTOR(PluginWidgetParent);
-  // A destroy call can actually get skipped if a widget is associated
-  // with the last out-of-process page, make sure and cleanup any left
-  // over widgets if we have them.
-  KillWidget();
-}
-
-mozilla::dom::BrowserParent* PluginWidgetParent::GetBrowserParent() {
-  return static_cast<mozilla::dom::BrowserParent*>(Manager());
-}
-
-void PluginWidgetParent::SetParent(nsIWidget* aParent) {
-  // This will trigger sync send messages to the plugin process window
-  // procedure and a cascade of events to that window related to focus
-  // and activation.
-  if (mWidget && aParent) {
-    mWidget->SetParent(aParent);
-  }
-}
-
-// When plugins run in chrome, nsPluginNativeWindow(Plat) implements platform
-// specific functionality that wraps plugin widgets. With e10s we currently
-// bypass this code on Window, and reuse a bit of it on Linux. Content still
-// makes use of some of the utility functions as well.
-
-mozilla::ipc::IPCResult PluginWidgetParent::RecvCreate(
-    nsresult* aResult, uint64_t* aScrollCaptureId,
-    uintptr_t* aPluginInstanceId) {
-  PWLOG("PluginWidgetParent::RecvCreate()\n");
-
-  *aScrollCaptureId = 0;
-  *aPluginInstanceId = 0;
-
-  mWidget = nsIWidget::CreateChildWindow();
-  *aResult = mWidget ? NS_OK : NS_ERROR_FAILURE;
-
-  // This returns the top level window widget
-  nsCOMPtr<nsIWidget> parentWidget = GetBrowserParent()->GetWidget();
-  // If this fails, bail.
-  if (!parentWidget) {
-    *aResult = NS_ERROR_NOT_AVAILABLE;
-    KillWidget();
-    return IPC_OK();
-  }
-
-  nsWidgetInitData initData;
-  initData.mWindowType = eWindowType_plugin_ipc_chrome;
-  initData.clipChildren = true;
-  initData.clipSiblings = true;
-  *aResult = mWidget->Create(parentWidget.get(), nullptr,
-                             LayoutDeviceIntRect(0, 0, 0, 0), &initData);
-  if (NS_FAILED(*aResult)) {
-    KillWidget();
-    // This should never fail, abort.
-    return IPC_FAIL_NO_REASON(this);
-  }
-
-  mWidget->EnableDragDrop(true);
-
-  // This is a special call we make to nsBaseWidget to register this
-  // window as a remote plugin window which is expected to receive
-  // visibility updates from the compositor, which ships this data
-  // over with corresponding layer updates.
-  mWidget->RegisterPluginWindowForRemoteUpdates();
-
-  return IPC_OK();
-}
-
-void PluginWidgetParent::KillWidget() {
-  PWLOG("PluginWidgetParent::KillWidget() widget=%p\n", (void*)mWidget.get());
-  if (mWidget) {
-    mWidget->UnregisterPluginWindowForRemoteUpdates();
-    mWidget->Destroy();
-    ::RemovePropW((HWND)mWidget->GetNativeData(NS_NATIVE_WINDOW),
-                  mozilla::dom::kPluginWidgetContentParentProperty);
-    mWidget = nullptr;
-  }
-}
-
-void PluginWidgetParent::ActorDestroy(ActorDestroyReason aWhy) {
-  PWLOG("PluginWidgetParent::ActorDestroy(%d)\n", aWhy);
-  KillWidget();
-}
-
-// Called by BrowserParent's Destroy() in response to an early tear down (Early
-// in that this is happening before layout in the child has had a chance
-// to destroy the child widget.) when the tab is closing.
-void PluginWidgetParent::ParentDestroy() {
-  PWLOG("PluginWidgetParent::ParentDestroy()\n");
-}
-
-mozilla::ipc::IPCResult PluginWidgetParent::RecvSetFocus(
-    const bool& aRaise, const mozilla::dom::CallerType& aCallerType) {
-  ENSURE_CHANNEL;
-  PWLOG("PluginWidgetParent::RecvSetFocus(%d)\n", aRaise);
-  mWidget->SetFocus(aRaise ? nsIWidget::Raise::Yes : nsIWidget::Raise::No,
-                    aCallerType);
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginWidgetParent::RecvGetNativePluginPort(
-    uintptr_t* value) {
-  ENSURE_CHANNEL;
-  *value = (uintptr_t)mWidget->GetNativeData(NS_NATIVE_PLUGIN_PORT);
-  NS_ASSERTION(*value, "no native port??");
-  PWLOG("PluginWidgetParent::RecvGetNativeData() %p\n", (void*)*value);
-  return IPC_OK();
-}
-
-mozilla::ipc::IPCResult PluginWidgetParent::RecvSetNativeChildWindow(
-    const uintptr_t& aChildWindow) {
-  ENSURE_CHANNEL;
-  PWLOG("PluginWidgetParent::RecvSetNativeChildWindow(%p)\n",
-        (void*)aChildWindow);
-  mWidget->SetNativeData(NS_NATIVE_CHILD_WINDOW, aChildWindow);
-  return IPC_OK();
-}
-
-}  // namespace plugins
-}  // namespace mozilla
diff --git a/dom/plugins/ipc/PluginWidgetParent.h b/dom/plugins/ipc/PluginWidgetParent.h
deleted file mode 100644
index 78228345cb..0000000000
--- a/dom/plugins/ipc/PluginWidgetParent.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_plugins_PluginWidgetParent_h
-#define mozilla_plugins_PluginWidgetParent_h
-
-#ifndef XP_WIN
-#  error "This header should be Windows-only."
-#endif
-
-#include "mozilla/plugins/PPluginWidgetParent.h"
-#include "mozilla/UniquePtr.h"
-#include "nsIWidget.h"
-#include "nsCOMPtr.h"
-
-namespace mozilla {
-
-namespace dom {
-class BrowserParent;
-}  // namespace dom
-
-namespace plugins {
-
-class PluginWidgetParent : public PPluginWidgetParent {
- public:
-  PluginWidgetParent();
-  virtual ~PluginWidgetParent();
-
-  virtual void ActorDestroy(ActorDestroyReason aWhy) override;
-  virtual mozilla::ipc::IPCResult RecvCreate(
-      nsresult* aResult, uint64_t* aScrollCaptureId,
-      uintptr_t* aPluginInstanceId) override;
-  virtual mozilla::ipc::IPCResult RecvSetFocus(
-      const bool& aRaise, const mozilla::dom::CallerType& aCallerType) override;
-  virtual mozilla::ipc::IPCResult RecvGetNativePluginPort(
-      uintptr_t* value) override;
-  mozilla::ipc::IPCResult RecvSetNativeChildWindow(
-      const uintptr_t& aChildWindow) override;
-
-  // Helper for compositor checks on the channel
-  bool ActorDestroyed() { return !mWidget; }
-
-  // Called by PBrowser when it receives a Destroy() call from the child.
-  void ParentDestroy();
-
-  // Sets mWidget's parent
-  void SetParent(nsIWidget* aParent);
-
- private:
-  // The tab our connection is associated with.
-  mozilla::dom::BrowserParent* GetBrowserParent();
-
- private:
-  void KillWidget();
-
-  // The chrome side native widget.
-  nsCOMPtr<nsIWidget> mWidget;
-};
-
-}  // namespace plugins
-}  // namespace mozilla
-
-#endif  // mozilla_plugins_PluginWidgetParent_h
diff --git a/dom/plugins/ipc/moz.build b/dom/plugins/ipc/moz.build
index 007b23dc24..e72b75908a 100644
--- a/dom/plugins/ipc/moz.build
+++ b/dom/plugins/ipc/moz.build
@@ -89,17 +89,6 @@ if CONFIG["MOZ_WIDGET_TOOLKIT"] == "cocoa":
         "PluginUtilsOSX.mm",
     ]
 
-if CONFIG["MOZ_WIDGET_TOOLKIT"] == "windows":
-    EXPORTS.mozilla.plugins += [
-        "PluginWidgetChild.h",
-        "PluginWidgetParent.h",
-    ]
-    UNIFIED_SOURCES += ["D3D11SurfaceHolder.cpp", "PluginUtilsWin.cpp"]
-    SOURCES += [
-        "PluginWidgetChild.cpp",
-        "PluginWidgetParent.cpp",
-    ]
-
 IPDL_SOURCES += [
     "PBrowserStream.ipdl",
     "PFunctionBroker.ipdl",
diff --git a/ipc/ipdl/sync-messages.ini b/ipc/ipdl/sync-messages.ini
index f9f665cbf2..4bfc4ac43e 100644
--- a/ipc/ipdl/sync-messages.ini
+++ b/ipc/ipdl/sync-messages.ini
@@ -808,8 +808,6 @@ description = legacy sync IPC - please add detailed description
 description = legacy sync IPC - please add detailed description
 [PBrowser::SyncMessage]
 description = JS MessageManager implementation
-[PBrowser::PPluginWidget]
-description = Legacy NPAPI IPC
 [PBrowser::DispatchFocusToTopLevelWindow]
 description = legacy sync IPC - please add detailed description
 [PBrowser::NotifyIMEMouseButtonEvent]
diff --git a/toolkit/xre/nsEmbedFunctions.cpp b/toolkit/xre/nsEmbedFunctions.cpp
index bccd63bc8a..45774d6091 100644
--- a/toolkit/xre/nsEmbedFunctions.cpp
+++ b/toolkit/xre/nsEmbedFunctions.cpp
@@ -62,7 +62,6 @@
 #include "mozilla/ipc/IOThreadChild.h"
 #include "mozilla/ipc/ProcessChild.h"
 
-#include "mozilla/plugins/PluginProcessChild.h"
 #include "mozilla/dom/ContentProcess.h"
 #include "mozilla/dom/ContentParent.h"
 
@@ -136,7 +135,6 @@ using mozilla::ipc::ScopedXREEmbed;
 
 using mozilla::dom::ContentParent;
 using mozilla::dom::ContentProcess;
-using mozilla::plugins::PluginProcessChild;
 
 using mozilla::gmp::GMPProcessChild;
 
@@ -644,10 +642,6 @@ nsresult XRE_InitChildProcess(int aArgc, char* aArgv[],
           MOZ_CRASH("This makes no sense");
           break;
 
-        case GeckoProcessType_Plugin:
-          process = MakeUnique<PluginProcessChild>(parentPID);
-          break;
-
         case GeckoProcessType_Content:
           process = MakeUnique<ContentProcess>(parentPID);
           break;
diff --git a/widget/PluginWidgetProxy.cpp b/widget/PluginWidgetProxy.cpp
deleted file mode 100644
index a12cc164e3..0000000000
--- a/widget/PluginWidgetProxy.cpp
+++ /dev/null
@@ -1,173 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "PluginWidgetProxy.h"
-#include "mozilla/dom/BrowserChild.h"
-#include "mozilla/plugins/PluginWidgetChild.h"
-#include "mozilla/plugins/PluginInstanceParent.h"
-#include "nsDebug.h"
-
-#define PWLOG(...)
-// #define PWLOG(...) printf_stderr(__VA_ARGS__)
-
-/* static */
-already_AddRefed<nsIWidget> nsIWidget::CreatePluginProxyWidget(
-    BrowserChild* aBrowserChild, mozilla::plugins::PluginWidgetChild* aActor) {
-  nsCOMPtr<nsIWidget> widget =
-      new mozilla::widget::PluginWidgetProxy(aBrowserChild, aActor);
-  return widget.forget();
-}
-
-namespace mozilla {
-namespace widget {
-
-using mozilla::plugins::PluginInstanceParent;
-
-NS_IMPL_ISUPPORTS_INHERITED(PluginWidgetProxy, PuppetWidget, nsIWidget)
-
-#define ENSURE_CHANNEL                             \
-  do {                                             \
-    if (!mActor) {                                 \
-      NS_WARNING("called on an invalid channel."); \
-      return NS_ERROR_FAILURE;                     \
-    }                                              \
-  } while (0)
-
-PluginWidgetProxy::PluginWidgetProxy(
-    dom::BrowserChild* aBrowserChild,
-    mozilla::plugins::PluginWidgetChild* aActor)
-    : PuppetWidget(aBrowserChild), mActor(aActor), mCachedPluginPort(0) {
-  // See ChannelDestroyed() in the header
-  mActor->SetWidget(this);
-}
-
-PluginWidgetProxy::~PluginWidgetProxy() {
-  PWLOG("PluginWidgetProxy::~PluginWidgetProxy()\n");
-}
-
-nsresult PluginWidgetProxy::Create(nsIWidget* aParent,
-                                   nsNativeWidget aNativeParent,
-                                   const LayoutDeviceIntRect& aRect,
-                                   nsWidgetInitData* aInitData) {
-  ENSURE_CHANNEL;
-  PWLOG("PluginWidgetProxy::Create()\n");
-
-  nsresult rv = NS_ERROR_UNEXPECTED;
-  uint64_t scrollCaptureId;
-  uintptr_t pluginInstanceId;
-  mActor->SendCreate(&rv, &scrollCaptureId, &pluginInstanceId);
-  if (NS_FAILED(rv)) {
-    NS_WARNING("failed to create chrome widget, plugins won't paint.");
-    return rv;
-  }
-
-  BaseCreate(aParent, aInitData);
-  mParent = aParent;
-
-  mBounds = aRect;
-  mEnabled = true;
-  mVisible = true;
-
-  PluginInstanceParent* instance =
-      PluginInstanceParent::LookupPluginInstanceByID(pluginInstanceId);
-  if (instance) {
-    Unused << NS_WARN_IF(
-        NS_FAILED(instance->SetScrollCaptureId(scrollCaptureId)));
-  }
-
-  return NS_OK;
-}
-
-void PluginWidgetProxy::SetParent(nsIWidget* aNewParent) {
-  nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
-  nsIWidget* parent = GetParent();
-  if (parent) {
-    parent->RemoveChild(this);
-  }
-  if (aNewParent) {
-    aNewParent->AddChild(this);
-  }
-  mParent = aNewParent;
-}
-
-nsIWidget* PluginWidgetProxy::GetParent(void) { return mParent.get(); }
-
-void PluginWidgetProxy::Destroy() {
-  PWLOG("PluginWidgetProxy::Destroy()\n");
-
-  if (mActor) {
-    // Communicate that the layout widget has been torn down before the sub
-    // protocol.
-    mActor->ProxyShutdown();
-    mActor = nullptr;
-  }
-
-  PuppetWidget::Destroy();
-}
-
-void PluginWidgetProxy::GetWindowClipRegion(
-    nsTArray<LayoutDeviceIntRect>* aRects) {
-  if (mClipRects && mClipRectCount) {
-    aRects->AppendElements(mClipRects.get(), mClipRectCount);
-  }
-}
-
-void* PluginWidgetProxy::GetNativeData(uint32_t aDataType) {
-  if (!mActor) {
-    return nullptr;
-  }
-  auto tab = static_cast<mozilla::dom::BrowserChild*>(mActor->Manager());
-  if (tab && tab->IsDestroyed()) {
-    return nullptr;
-  }
-  switch (aDataType) {
-    case NS_NATIVE_PLUGIN_PORT:
-    case NS_NATIVE_WINDOW:
-    case NS_NATIVE_SHAREABLE_WINDOW:
-      break;
-    default:
-      NS_WARNING(
-          "PluginWidgetProxy::GetNativeData received request for unsupported "
-          "data type.");
-      return nullptr;
-  }
-  // The parent side window handle or xid never changes so we can
-  // cache this for our lifetime.
-  if (mCachedPluginPort) {
-    return (void*)mCachedPluginPort;
-  }
-  mActor->SendGetNativePluginPort(&mCachedPluginPort);
-  PWLOG("PluginWidgetProxy::GetNativeData %p\n", (void*)mCachedPluginPort);
-  return (void*)mCachedPluginPort;
-}
-
-void PluginWidgetProxy::SetNativeData(uint32_t aDataType, uintptr_t aVal) {
-  if (!mActor) {
-    return;
-  }
-
-  auto tab = static_cast<mozilla::dom::BrowserChild*>(mActor->Manager());
-  if (tab && tab->IsDestroyed()) {
-    return;
-  }
-
-  switch (aDataType) {
-    case NS_NATIVE_CHILD_WINDOW:
-      mActor->SendSetNativeChildWindow(aVal);
-      break;
-    default:
-      NS_ERROR("SetNativeData called with unsupported data type.");
-  }
-}
-
-void PluginWidgetProxy::SetFocus(Raise aRaise,
-                                 mozilla::dom::CallerType aCallerType) {
-  if (mActor) {
-    PWLOG("PluginWidgetProxy::SetFocus(%d)\n", aRaise == Raise::Yes);
-    mActor->SendSetFocus(aRaise == Raise::Yes, aCallerType);
-  }
-}
-
-}  // namespace widget
-}  // namespace mozilla
diff --git a/widget/PluginWidgetProxy.h b/widget/PluginWidgetProxy.h
deleted file mode 100644
index dde703c095..0000000000
--- a/widget/PluginWidgetProxy.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef mozilla_widget_RemotePlugin_h__
-#define mozilla_widget_RemotePlugin_h__
-
-#ifndef XP_WIN
-#  error "Plugin widgets are Windows-only."
-#endif
-
-#include "PuppetWidget.h"
-#include "mozilla/dom/BrowserChild.h"
-
-/*
- * PluginWidgetProxy is a nsIWidget wrapper we hand around in plugin and layout
- * code. It wraps a native widget it creates in the chrome process. Since this
- * is for plugins, only a limited set of the widget apis need to be overridden,
- * the rest of the implementation is in PuppetWidget or nsBaseWidget.
- */
-
-namespace mozilla {
-namespace plugins {
-class PluginWidgetChild;
-}  // namespace plugins
-namespace widget {
-
-class PluginWidgetProxy final : public PuppetWidget {
- public:
-  explicit PluginWidgetProxy(dom::BrowserChild* aBrowserChild,
-                             mozilla::plugins::PluginWidgetChild* aChannel);
-
- protected:
-  virtual ~PluginWidgetProxy();
-
- public:
-  NS_DECL_ISUPPORTS_INHERITED
-
-  // nsIWidget
-  using PuppetWidget::Create;  // for Create signature not overridden here
-  [[nodiscard]] virtual nsresult Create(
-      nsIWidget* aParent, nsNativeWidget aNativeParent,
-      const LayoutDeviceIntRect& aRect,
-      nsWidgetInitData* aInitData = nullptr) override;
-  virtual void Destroy() override;
-  virtual void SetFocus(Raise, mozilla::dom::CallerType aCallerType) override;
-  virtual void SetParent(nsIWidget* aNewParent) override;
-
-  virtual nsIWidget* GetParent(void) override;
-  virtual void* GetNativeData(uint32_t aDataType) override;
-  void SetNativeData(uint32_t aDataType, uintptr_t aVal) override;
-  virtual nsTransparencyMode GetTransparencyMode() override {
-    return eTransparencyOpaque;
-  }
-  virtual void GetWindowClipRegion(
-      nsTArray<LayoutDeviceIntRect>* aRects) override;
-
- public:
-  /**
-   * When tabs are closed PPluginWidget can terminate before plugin code is
-   * finished tearing us down. When this happens plugin calls over mActor
-   * fail triggering an abort in the content process. To protect against this
-   * the connection tells us when it is torn down here so we can avoid making
-   * calls while content finishes tearing us down.
-   */
-  void ChannelDestroyed() { mActor = nullptr; }
-
- private:
-  // Our connection with the chrome widget, created on PBrowser.
-  mozilla::plugins::PluginWidgetChild* mActor;
-  // PuppetWidget does not implement parent apis, but we need
-  // them for plugin widgets.
-  nsCOMPtr<nsIWidget> mParent;
-  uintptr_t mCachedPluginPort;
-};
-
-}  // namespace widget
-}  // namespace mozilla
-
-#endif
diff --git a/widget/moz.build b/widget/moz.build
index df5d495f64..c2f3a93c94 100644
--- a/widget/moz.build
+++ b/widget/moz.build
@@ -273,14 +273,6 @@ if CONFIG["MOZ_X11"]:
         "WindowSurfaceX11SHM.cpp",
     ]
 
-if toolkit == "windows":
-    EXPORTS += [
-        "PluginWidgetProxy.h",
-    ]
-    SOURCES += [
-        "PluginWidgetProxy.cpp",
-    ]
-
 if toolkit in ("cocoa", "windows"):
     UNIFIED_SOURCES += [
         "nsBaseClipboard.cpp",
diff --git a/widget/nsIWidget.h b/widget/nsIWidget.h
index 16c368c6de..9892817855 100644
--- a/widget/nsIWidget.h
+++ b/widget/nsIWidget.h
@@ -73,9 +73,6 @@ namespace dom {
 class BrowserChild;
 enum class CallerType : uint32_t;
 }  // namespace dom
-namespace plugins {
-class PluginWidgetChild;
-}  // namespace plugins
 namespace layers {
 class AsyncDragMetrics;
 class Compositor;
@@ -1955,15 +1952,6 @@ class nsIWidget : public nsISupports {
 
   static already_AddRefed<nsIWidget> CreateHeadlessWidget();
 
-  /**
-   * Allocate and return a "plugin proxy widget", a subclass of PuppetWidget
-   * used in wrapping a PPluginWidget connection for remote widgets. Note
-   * this call creates the base object, it does not create the widget. Use
-   * nsIWidget's Create to do this.
-   */
-  static already_AddRefed<nsIWidget> CreatePluginProxyWidget(
-      BrowserChild* aBrowserChild, mozilla::plugins::PluginWidgetChild* aActor);
-
   /**
    * Reparent this widget's native widget.
    * @param aNewParent the native widget of aNewParent is the new native
diff --git a/widget/windows/nsWindow.cpp b/widget/windows/nsWindow.cpp
index 6717d9a34d..d053dbbdb9 100644
--- a/widget/windows/nsWindow.cpp
+++ b/widget/windows/nsWindow.cpp
@@ -218,7 +218,6 @@
 #include "InputData.h"
 
 #include "mozilla/Telemetry.h"
-#include "mozilla/plugins/PluginProcessParent.h"
 #include "mozilla/webrender/WebRenderAPI.h"
 #include "mozilla/layers/IAPZCTreeManager.h"
 
@@ -3721,36 +3720,12 @@ void* nsWindow::GetNativeData(uint32_t aDataType) {
   return nullptr;
 }
 
-static void SetChildStyleAndParent(HWND aChildWindow, HWND aParentWindow) {
-  // Make sure the window is styled to be a child window.
-  LONG_PTR style = GetWindowLongPtr(aChildWindow, GWL_STYLE);
-  style |= WS_CHILD;
-  style &= ~WS_POPUP;
-  SetWindowLongPtr(aChildWindow, GWL_STYLE, style);
-
-  // Do the reparenting. Note that this call will probably cause a sync native
-  // message to the process that owns the child window.
-  ::SetParent(aChildWindow, aParentWindow);
-}
-
 void nsWindow::SetNativeData(uint32_t aDataType, uintptr_t aVal) {
   switch (aDataType) {
     case NS_NATIVE_CHILD_WINDOW:
     case NS_NATIVE_CHILD_OF_SHAREABLE_WINDOW: {
-      HWND childHwnd = reinterpret_cast<HWND>(aVal);
-      DWORD childProc = 0;
-      GetWindowThreadProcessId(childHwnd, &childProc);
-      if (!PluginProcessParent::IsPluginProcessId(
-              static_cast<base::ProcessId>(childProc))) {
-        MOZ_ASSERT_UNREACHABLE(
-            "SetNativeData window origin was not a plugin process.");
-        break;
-      }
-      HWND parentHwnd = aDataType == NS_NATIVE_CHILD_WINDOW
-                            ? mWnd
-                            : WinUtils::GetTopLevelHWND(mWnd);
-      SetChildStyleAndParent(childHwnd, parentHwnd);
-      RecreateDirectManipulationIfNeeded();
+      MOZ_ASSERT_UNREACHABLE(
+          "SetNativeData window origin was not a plugin process.");
       break;
     }
     default:
