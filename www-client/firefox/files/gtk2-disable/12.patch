From 30be5dc7897fa35a5e60d163d28ebd57371e21dd Mon Sep 17 00:00:00 2001
From: David Parks <daparks@mozilla.com>
Date: Mon, 5 Apr 2021 23:48:39 +0000
Subject: [PATCH] Bug 1682030 - Remove more dead NPAPI code from dom/plugins
 and related spots.  r=jmathies,mconley,emilio

This is the second of two patches in this series that removes a large amount of now dead code from dom/plugins as part of removing all NPAPI plugin support.

Differential Revision: https://phabricator.services.mozilla.com/D107150
---
 dom/base/nsContentUtils.cpp                   |   30 -
 dom/base/nsIObjectLoadingContent.idl          |   11 -
 dom/base/nsObjectLoadingContent.cpp           |  234 +--
 dom/base/nsObjectLoadingContent.h             |   44 -
 dom/bindings/BindingUtils.cpp                 |   13 -
 dom/html/HTMLEmbedElement.cpp                 |   10 +-
 dom/html/HTMLObjectElement.cpp                |    9 +-
 dom/ipc/ContentParent.cpp                     |   11 +-
 dom/ipc/ContentParent.h                       |    2 -
 dom/ipc/PContent.ipdl                         |    2 -
 dom/ipc/ProcessHangMonitor.cpp                |   11 +-
 dom/media/webrtc/common/YuvStamper.h          |    2 +-
 dom/plugins/base/moz.build                    |   10 +-
 dom/plugins/base/npapi.h                      |  922 ------------
 dom/plugins/base/nptypes.h                    |   89 --
 dom/plugins/base/nsNPAPIPluginInstance.cpp    |  586 --------
 dom/plugins/base/nsNPAPIPluginInstance.h      |  295 ----
 dom/plugins/base/nsPluginHost.cpp             | 1334 +----------------
 dom/plugins/base/nsPluginHost.h               |  211 +--
 dom/plugins/base/nsPluginTags.cpp             |  508 +------
 dom/plugins/base/nsPluginTags.h               |  108 +-
 dom/plugins/base/nspluginroot.idl             |    8 -
 gfx/layers/ipc/PCompositorManager.ipdl        |    2 +-
 layout/base/nsRefreshDriver.cpp               |    7 -
 toolkit/xre/nsEmbedFunctions.cpp              |    4 +
 .../exthandler/nsExternalHelperAppService.cpp |    7 -
 widget/cocoa/TextInputHandler.mm              |   10 -
 widget/cocoa/nsCocoaUtils.h                   |    6 -
 widget/cocoa/nsCocoaUtils.mm                  |    5 -
 widget/nsBaseWidget.cpp                       |    1 -
 widget/windows/KeyboardLayout.cpp             |    3 +-
 31 files changed, 44 insertions(+), 4451 deletions(-)
 delete mode 100644 dom/plugins/base/npapi.h
 delete mode 100644 dom/plugins/base/nptypes.h
 delete mode 100644 dom/plugins/base/nsNPAPIPluginInstance.cpp
 delete mode 100644 dom/plugins/base/nsNPAPIPluginInstance.h
 delete mode 100644 dom/plugins/base/nspluginroot.idl

diff --git a/dom/base/nsContentUtils.cpp b/dom/base/nsContentUtils.cpp
index 21a501a462582..1142dafe27dde 100644
--- a/dom/base/nsContentUtils.cpp
+++ b/dom/base/nsContentUtils.cpp
@@ -8,10 +8,6 @@
 
 #include "nsContentUtils.h"
 
-// nsNPAPIPluginInstance must be included before mozilla/dom/Document.h, which
-// is included in mozAutoDocUpdate.h.
-#include "nsNPAPIPluginInstance.h"
-
 #include <algorithm>
 #include <cstddef>
 #include <cstdint>
@@ -344,7 +340,6 @@
 #include "nsMappedAttributes.h"
 #include "nsMargin.h"
 #include "nsMimeTypes.h"
-#include "nsNPAPIPluginInstance.h"
 #include "nsNameSpaceManager.h"
 #include "nsNetCID.h"
 #include "nsNetUtil.h"
@@ -6804,32 +6799,7 @@ bool nsContentUtils::HaveEqualPrincipals(Document* aDoc1, Document* aDoc2) {
 /* static */
 bool nsContentUtils::HasPluginWithUncontrolledEventDispatch(
     nsIContent* aContent) {
-#ifdef XP_MACOSX
-  // We control dispatch to all mac plugins.
   return false;
-#else
-  if (!aContent || !aContent->IsInComposedDoc()) {
-    return false;
-  }
-
-  nsCOMPtr<nsIObjectLoadingContent> olc = do_QueryInterface(aContent);
-  if (!olc) {
-    return false;
-  }
-
-  RefPtr<nsNPAPIPluginInstance> plugin = olc->GetPluginInstance();
-  if (!plugin) {
-    return false;
-  }
-
-  bool isWindowless = false;
-  nsresult res = plugin->IsWindowless(&isWindowless);
-  if (NS_FAILED(res)) {
-    return false;
-  }
-
-  return !isWindowless;
-#endif
 }
 
 /* static */
diff --git a/dom/base/nsIObjectLoadingContent.idl b/dom/base/nsIObjectLoadingContent.idl
index f8f6908dd673a..b1e02402ab7d3 100644
--- a/dom/base/nsIObjectLoadingContent.idl
+++ b/dom/base/nsIObjectLoadingContent.idl
@@ -13,11 +13,6 @@ interface nsIURI;
 
 webidl BrowsingContext;
 
-%{C++
-class nsNPAPIPluginInstance;
-%}
-[ptr] native nsNPAPIPluginInstancePtr(nsNPAPIPluginInstance);
-
 /**
  * This interface represents a content node that loads objects.
  *
@@ -95,12 +90,6 @@ interface nsIObjectLoadingContent : nsISupports
   unsigned long getContentTypeForMIMEType(in AUTF8String aMimeType);
 
   /**
-   * Returns the plugin instance if it has already been instantiated. This
-   * will never instantiate the plugin and so is safe to call even when
-   * content script must not execute.
-   */
-  [notxpcom,nostdcall] readonly attribute nsNPAPIPluginInstancePtr pluginInstance;
-
   /*
    * Notifications from pluginhost that our instance crashed or was destroyed.
    */
diff --git a/dom/base/nsObjectLoadingContent.cpp b/dom/base/nsObjectLoadingContent.cpp
index c7166e31ebceb..754984b84e4e8 100644
--- a/dom/base/nsObjectLoadingContent.cpp
+++ b/dom/base/nsObjectLoadingContent.cpp
@@ -23,7 +23,6 @@
 #include "nsIInterfaceRequestorUtils.h"
 #include "nsIOService.h"
 #include "nsIPermissionManager.h"
-#include "nsNPAPIPluginInstance.h"
 #include "nsPluginHost.h"
 #include "nsIHttpChannel.h"
 #include "nsINestedURI.h"
@@ -99,6 +98,7 @@
 #include "nsChannelClassifier.h"
 #include "nsFocusManager.h"
 #include "ReferrerInfo.h"
+#include "nsIEffectiveTLDService.h"
 
 #ifdef XP_WIN
 // Thanks so much, Microsoft! :(
@@ -917,10 +917,6 @@ nsObjectLoadingContent::GetDisplayedType(uint32_t* aType) {
   return NS_OK;
 }
 
-nsNPAPIPluginInstance* nsObjectLoadingContent::GetPluginInstance() {
-  return nullptr;
-}
-
 NS_IMETHODIMP
 nsObjectLoadingContent::GetContentTypeForMIMEType(const nsACString& aMIMEType,
                                                   uint32_t* aType) {
@@ -2442,51 +2438,6 @@ nsObjectLoadingContent::PluginCrashed(nsIPluginTag* aPluginTag,
   return NS_OK;
 }
 
-nsNPAPIPluginInstance* nsObjectLoadingContent::ScriptRequestPluginInstance(
-    JSContext* aCx) {
-  // The below methods pull the cx off the stack, so make sure they match.
-  //
-  // NB: Sometimes there's a null cx on the stack, in which case |cx| is the
-  // safe JS context. But in that case, IsCallerChrome() will return true,
-  // so the ensuing expression is short-circuited.
-  // XXXbz the NB comment above doesn't really make sense.  At the moment, all
-  // the callers to this except maybe SetupProtoChain have a useful JSContext*
-  // that could be used for nsContentUtils::IsSystemCaller...  We do need to
-  // sort out what the SetupProtoChain callers look like.
-  MOZ_ASSERT_IF(nsContentUtils::GetCurrentJSContext(),
-                aCx == nsContentUtils::GetCurrentJSContext());
-  // FIXME(emilio): Doesn't account for UA widgets, but probably doesn't matter?
-  bool callerIsContentJS = (nsContentUtils::GetCurrentJSContext() &&
-                            !nsContentUtils::IsCallerChrome());
-
-  nsCOMPtr<nsIContent> thisContent =
-      do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
-
-  // The first time content script attempts to access placeholder content, fire
-  // an event.  Fallback types >= eFallbackClickToPlay are plugin-replacement
-  // types, see header.
-  if (callerIsContentJS && !mScriptRequested && InActiveDocument(thisContent) &&
-      mType == eType_Null && mFallbackType >= eFallbackClickToPlay &&
-      mFallbackType <= eFallbackClickToPlayQuiet) {
-    nsCOMPtr<nsIRunnable> ev =
-        new nsSimplePluginEvent(thisContent, u"PluginScripted"_ns);
-    nsresult rv = NS_DispatchToCurrentThread(ev);
-    if (NS_FAILED(rv)) {
-      MOZ_ASSERT_UNREACHABLE("failed to dispatch PluginScripted event");
-    }
-    mScriptRequested = true;
-  } else if (callerIsContentJS && mType == eType_Plugin &&
-             nsContentUtils::IsSafeToRunScript() &&
-             InActiveDocument(thisContent)) {
-    // If we're configured as a plugin in an active document and it's safe to
-    // run scripts right now, try spawning synchronously
-    SyncStartPluginInstance();
-  }
-
-  // Note that returning a null plugin is expected (and happens often)
-  return nullptr;
-}
-
 NS_IMETHODIMP
 nsObjectLoadingContent::SyncStartPluginInstance() {
   NS_ASSERTION(
@@ -2623,24 +2574,6 @@ nsObjectLoadingContent::StopPluginInstance() {
   return NS_OK;
 }
 
-void nsObjectLoadingContent::NotifyContentObjectWrapper() {
-  nsCOMPtr<nsIContent> thisContent =
-      do_QueryInterface(static_cast<nsIImageLoadingContent*>(this));
-
-  AutoJSAPI jsapi;
-  jsapi.Init();
-  JSContext* cx = jsapi.cx();
-
-  JS::Rooted<JSObject*> obj(cx, thisContent->GetWrapper());
-  if (!obj) {
-    // Nothing to do here if there's no wrapper for mContent. The proto
-    // chain will be fixed appropriately when the wrapper is created.
-    return;
-  }
-
-  SetupProtoChain(cx, obj);
-}
-
 void nsObjectLoadingContent::PlayPlugin(SystemCallerGuarantee,
                                         ErrorResult& aRv) {
   // This is a ChromeOnly method, so no need to check caller type here.
@@ -2922,141 +2855,9 @@ Document* nsObjectLoadingContent::GetContentDocument(
   return sub_doc;
 }
 
-void nsObjectLoadingContent::SetupProtoChain(JSContext* aCx,
-                                             JS::Handle<JSObject*> aObject) {
-  if (mType != eType_Plugin) {
-    return;
-  }
-
-  if (!nsContentUtils::IsSafeToRunScript()) {
-    RefPtr<SetupProtoChainRunner> runner = new SetupProtoChainRunner(this);
-    nsContentUtils::AddScriptRunner(runner);
-    return;
-  }
-
-  // We get called on random realms here for some reason
-  // (perhaps because WrapObject can happen on a random realm?)
-  // so make sure to enter the realm of aObject.
-  MOZ_ASSERT(aCx == nsContentUtils::GetCurrentJSContext());
-
-  MOZ_ASSERT(IsDOMObject(aObject));
-  JSAutoRealm ar(aCx, aObject);
-
-  RefPtr<nsNPAPIPluginInstance> pi = ScriptRequestPluginInstance(aCx);
-
-  if (!pi) {
-    // No plugin around for this object.
-    return;
-  }
-
-  JS::Rooted<JSObject*> pi_obj(
-      aCx);  // XPConnect-wrapped peer object, when we get it.
-  JS::Rooted<JSObject*> pi_proto(aCx);  // 'pi.__proto__'
-
-  nsresult rv = GetPluginJSObject(aCx, pi, &pi_obj, &pi_proto);
-  if (NS_FAILED(rv)) {
-    return;
-  }
-
-  if (!pi_obj) {
-    // Didn't get a plugin instance JSObject, nothing we can do then.
-    return;
-  }
-
-  // If we got an xpconnect-wrapped plugin object, set obj's
-  // prototype's prototype to the scriptable plugin.
-
-  JS::Handle<JSObject*> my_proto = GetDOMClass(aObject)->mGetProto(aCx);
-  MOZ_ASSERT(my_proto);
-
-  // Set 'this.__proto__' to pi
-  if (!::JS_SetPrototype(aCx, aObject, pi_obj)) {
-    return;
-  }
-
-  if (pi_proto && JS::GetClass(pi_proto) != js::ObjectClassPtr) {
-    // The plugin wrapper has a proto that's not Object.prototype, set
-    // 'pi.__proto__.__proto__' to the original 'this.__proto__'
-    if (pi_proto != my_proto && !::JS_SetPrototype(aCx, pi_proto, my_proto)) {
-      return;
-    }
-  } else {
-    // 'pi' didn't have a prototype, or pi's proto was
-    // 'Object.prototype' (i.e. pi is an NPRuntime wrapped JS object)
-    // set 'pi.__proto__' to the original 'this.__proto__'
-    if (!::JS_SetPrototype(aCx, pi_obj, my_proto)) {
-      return;
-    }
-  }
-
-  // Before this proto dance the objects involved looked like this:
-  //
-  // this.__proto__.__proto__
-  //   ^      ^         ^
-  //   |      |         |__ Object.prototype
-  //   |      |
-  //   |      |__ WebIDL prototype (shared)
-  //   |
-  //   |__ WebIDL object
-  //
-  // pi.__proto__
-  // ^      ^
-  // |      |__ Object.prototype or some other object
-  // |
-  // |__ Plugin NPRuntime JS object wrapper
-  //
-  // Now, after the above prototype setup the prototype chain should
-  // look like this if pi.__proto__ was Object.prototype:
-  //
-  // this.__proto__.__proto__.__proto__
-  //   ^      ^         ^         ^
-  //   |      |         |         |__ Object.prototype
-  //   |      |         |
-  //   |      |         |__ WebIDL prototype (shared)
-  //   |      |
-  //   |      |__ Plugin NPRuntime JS object wrapper
-  //   |
-  //   |__ WebIDL object
-  //
-  // or like this if pi.__proto__ was some other object:
-  //
-  // this.__proto__.__proto__.__proto__.__proto__
-  //   ^      ^         ^         ^         ^
-  //   |      |         |         |         |__ Object.prototype
-  //   |      |         |         |
-  //   |      |         |         |__ WebIDL prototype (shared)
-  //   |      |         |
-  //   |      |         |__ old pi.__proto__
-  //   |      |
-  //   |      |__ Plugin NPRuntime JS object wrapper
-  //   |
-  //   |__ WebIDL object
-  //
-}
-
-// static
-nsresult nsObjectLoadingContent::GetPluginJSObject(
-    JSContext* cx, nsNPAPIPluginInstance* plugin_inst,
-    JS::MutableHandle<JSObject*> plugin_obj,
-    JS::MutableHandle<JSObject*> plugin_proto) {
-  if (plugin_inst) {
-    plugin_inst->GetJSObject(cx, plugin_obj.address());
-    if (plugin_obj) {
-      if (!::JS_GetPrototype(cx, plugin_obj, plugin_proto)) {
-        return NS_ERROR_UNEXPECTED;
-      }
-    }
-  }
-
-  return NS_OK;
-}
-
 bool nsObjectLoadingContent::DoResolve(
     JSContext* aCx, JS::Handle<JSObject*> aObject, JS::Handle<jsid> aId,
     JS::MutableHandle<JS::PropertyDescriptor> aDesc) {
-  // We don't resolve anything; we just try to make sure we're instantiated.
-  // This purposefully does not fire for chrome/xray resolves, see bug 967694
-  Unused << ScriptRequestPluginInstance(aCx);
   return true;
 }
 
@@ -3068,12 +2869,7 @@ bool nsObjectLoadingContent::MayResolve(jsid aId) {
 
 void nsObjectLoadingContent::GetOwnPropertyNames(
     JSContext* aCx, JS::MutableHandleVector<jsid> /* unused */,
-    bool /* unused */, ErrorResult& aRv) {
-  // Just like DoResolve, just make sure we're instantiated.  That will do
-  // the work our Enumerate hook needs to do.  This purposefully does not fire
-  // for xray resolves, see bug 967694
-  Unused << ScriptRequestPluginInstance(aCx);
-}
+    bool /* unused */, ErrorResult& aRv) {}
 
 void nsObjectLoadingContent::MaybeFireErrorEvent() {
   nsCOMPtr<nsIContent> thisContent =
@@ -3130,29 +2926,3 @@ void nsObjectLoadingContent::SubdocumentIntrinsicSizeOrRatioChanged(
     sdf->SubdocumentIntrinsicSizeOrRatioChanged();
   }
 }
-
-// SetupProtoChainRunner implementation
-nsObjectLoadingContent::SetupProtoChainRunner::SetupProtoChainRunner(
-    nsObjectLoadingContent* aContent)
-    : mContent(aContent) {}
-
-NS_IMETHODIMP
-nsObjectLoadingContent::SetupProtoChainRunner::Run() {
-  AutoJSAPI jsapi;
-  jsapi.Init();
-  JSContext* cx = jsapi.cx();
-
-  nsCOMPtr<nsIContent> content;
-  CallQueryInterface(mContent.get(), getter_AddRefs(content));
-  JS::Rooted<JSObject*> obj(cx, content->GetWrapper());
-  if (!obj) {
-    // No need to set up our proto chain if we don't even have an object
-    return NS_OK;
-  }
-  nsObjectLoadingContent* objectLoadingContent =
-      static_cast<nsObjectLoadingContent*>(mContent.get());
-  objectLoadingContent->SetupProtoChain(cx, obj);
-  return NS_OK;
-}
-
-NS_IMPL_ISUPPORTS(nsObjectLoadingContent::SetupProtoChainRunner, nsIRunnable)
diff --git a/dom/base/nsObjectLoadingContent.h b/dom/base/nsObjectLoadingContent.h
index 77dfad7fc616f..f2866b37d87de 100644
--- a/dom/base/nsObjectLoadingContent.h
+++ b/dom/base/nsObjectLoadingContent.h
@@ -157,22 +157,6 @@ class nsObjectLoadingContent : public nsImageLoadingContent,
    */
   void NotifyOwnerDocumentActivityChanged();
 
-  /**
-   * When a plug-in is instantiated, it can create a scriptable
-   * object that the page wants to interact with.  We expose this
-   * object by placing it on the prototype chain of our element,
-   * between the element itself and its most-derived DOM prototype.
-   *
-   * SetupProtoChain handles actually inserting the plug-in
-   * scriptable object into the proto chain if needed.
-   *
-   * DoResolve is a hook that allows us to find out when the web
-   * page is looking up a property name on our object and make sure
-   * that our plug-in, if any, is instantiated.
-   */
-  // Helper for WebIDL node wrapping
-  void SetupProtoChain(JSContext* aCx, JS::Handle<JSObject*> aObject);
-
   // Helper for WebIDL NeedResolve
   bool DoResolve(JSContext* aCx, JS::Handle<JSObject*> aObject,
                  JS::Handle<jsid> aId,
@@ -428,8 +412,6 @@ class nsObjectLoadingContent : public nsImageLoadingContent,
    */
   void QueueCheckPluginStopEvent();
 
-  void NotifyContentObjectWrapper();
-
   /**
    * Opens the channel pointed to by mURI into mChannel.
    */
@@ -576,32 +558,6 @@ class nsObjectLoadingContent : public nsImageLoadingContent,
   void MaybeRewriteYoutubeEmbed(nsIURI* aURI, nsIURI* aBaseURI,
                                 nsIURI** aRewrittenURI);
 
-  // Helper class for SetupProtoChain
-  class SetupProtoChainRunner final : public nsIRunnable {
-    ~SetupProtoChainRunner() = default;
-
-   public:
-    NS_DECL_ISUPPORTS
-
-    explicit SetupProtoChainRunner(nsObjectLoadingContent* aContent);
-
-    NS_IMETHOD Run() override;
-
-   private:
-    // We store an nsIObjectLoadingContent because we can
-    // unambiguously refcount that.
-    RefPtr<nsIObjectLoadingContent> mContent;
-  };
-
-  // Utility getter for getting our nsNPAPIPluginInstance in a safe way.
-  nsNPAPIPluginInstance* ScriptRequestPluginInstance(JSContext* aCx);
-
-  // Utility method for getting our plugin JSObject
-  static nsresult GetPluginJSObject(JSContext* cx,
-                                    nsNPAPIPluginInstance* plugin_inst,
-                                    JS::MutableHandle<JSObject*> plugin_obj,
-                                    JS::MutableHandle<JSObject*> plugin_proto);
-
   // Utility for firing an error event, if we're an <object>.
   void MaybeFireErrorEvent();
 
diff --git a/dom/bindings/BindingUtils.cpp b/dom/bindings/BindingUtils.cpp
index 59ab43f7ba8ec..2af959a0b7bbe 100644
--- a/dom/bindings/BindingUtils.cpp
+++ b/dom/bindings/BindingUtils.cpp
@@ -2259,19 +2259,6 @@ void UpdateReflectorGlobal(JSContext* aCx, JS::Handle<JSObject*> aObjArg,
       MOZ_CRASH();
     }
   }
-
-  JS::Rooted<JSObject*> maybeObjLC(aCx, aObj);
-  nsObjectLoadingContent* htmlobject;
-  nsresult rv = UNWRAP_OBJECT(HTMLObjectElement, &maybeObjLC, htmlobject);
-  if (NS_FAILED(rv)) {
-    rv = UNWRAP_OBJECT(HTMLEmbedElement, &maybeObjLC, htmlobject);
-    if (NS_FAILED(rv)) {
-      htmlobject = nullptr;
-    }
-  }
-  if (htmlobject) {
-    htmlobject->SetupProtoChain(aCx, aObj);
-  }
 }
 
 GlobalObject::GlobalObject(JSContext* aCx, JSObject* aObject)
diff --git a/dom/html/HTMLEmbedElement.cpp b/dom/html/HTMLEmbedElement.cpp
index 263b2ec725c77..e7c44d48da83d 100644
--- a/dom/html/HTMLEmbedElement.cpp
+++ b/dom/html/HTMLEmbedElement.cpp
@@ -256,15 +256,7 @@ nsresult HTMLEmbedElement::CopyInnerTo(HTMLEmbedElement* aDest) {
 
 JSObject* HTMLEmbedElement::WrapNode(JSContext* aCx,
                                      JS::Handle<JSObject*> aGivenProto) {
-  JSObject* obj;
-  obj = HTMLEmbedElement_Binding::Wrap(aCx, this, aGivenProto);
-
-  if (!obj) {
-    return nullptr;
-  }
-  JS::Rooted<JSObject*> rootedObj(aCx, obj);
-  SetupProtoChain(aCx, rootedObj);
-  return rootedObj;
+  return HTMLEmbedElement_Binding::Wrap(aCx, this, aGivenProto);
 }
 
 nsContentPolicyType HTMLEmbedElement::GetContentPolicyType() const {
diff --git a/dom/html/HTMLObjectElement.cpp b/dom/html/HTMLObjectElement.cpp
index 2c0c6acc54328..f2c085bf1a602 100644
--- a/dom/html/HTMLObjectElement.cpp
+++ b/dom/html/HTMLObjectElement.cpp
@@ -15,7 +15,6 @@
 #include "nsGkAtoms.h"
 #include "nsError.h"
 #include "mozilla/dom/Document.h"
-#include "nsNPAPIPluginInstance.h"
 #include "nsIWidget.h"
 #include "nsContentUtils.h"
 #ifdef XP_MACOSX
@@ -300,13 +299,7 @@ nsresult HTMLObjectElement::CopyInnerTo(Element* aDest) {
 
 JSObject* HTMLObjectElement::WrapNode(JSContext* aCx,
                                       JS::Handle<JSObject*> aGivenProto) {
-  JS::Rooted<JSObject*> obj(
-      aCx, HTMLObjectElement_Binding::Wrap(aCx, this, aGivenProto));
-  if (!obj) {
-    return nullptr;
-  }
-  SetupProtoChain(aCx, obj);
-  return obj;
+  return HTMLObjectElement_Binding::Wrap(aCx, this, aGivenProto);
 }
 
 }  // namespace mozilla::dom
diff --git a/dom/ipc/ContentParent.cpp b/dom/ipc/ContentParent.cpp
index 9cd35b55e670e..e9147b3def1a0 100644
--- a/dom/ipc/ContentParent.cpp
+++ b/dom/ipc/ContentParent.cpp
@@ -170,6 +170,7 @@
 #include "nsConsoleService.h"
 #include "nsContentPermissionHelper.h"
 #include "nsContentUtils.h"
+#include "nsCRT.h"
 #include "nsDebugImpl.h"
 #include "nsDirectoryServiceDefs.h"
 #include "nsDocShell.h"
@@ -3151,10 +3152,6 @@ bool ContentParent::InitInternal(ProcessPriority aInitialPriority) {
     group->Subscribe(this);
   }
 
-  // Start up nsPluginHost and run FindPlugins to cache the plugin list.
-  // If this isn't our first content process, just send over cached list.
-  RefPtr<nsPluginHost> pluginHost = nsPluginHost::GetInst();
-  pluginHost->SendPluginsToContent(this);
   MaybeEnableRemoteInputEventQueue();
 
   return true;
@@ -6313,12 +6310,6 @@ bool ContentParent::DeallocPSessionStorageObserverParent(
   return mozilla::dom::DeallocPSessionStorageObserverParent(aActor);
 }
 
-mozilla::ipc::IPCResult ContentParent::RecvMaybeReloadPlugins() {
-  RefPtr<nsPluginHost> pluginHost = nsPluginHost::GetInst();
-  pluginHost->ReloadPlugins();
-  return IPC_OK();
-}
-
 mozilla::ipc::IPCResult ContentParent::RecvDeviceReset() {
   GPUProcessManager* pm = GPUProcessManager::Get();
   if (pm) {
diff --git a/dom/ipc/ContentParent.h b/dom/ipc/ContentParent.h
index fdb51e072ee17..310d1df545d53 100644
--- a/dom/ipc/ContentParent.h
+++ b/dom/ipc/ContentParent.h
@@ -337,8 +337,6 @@ class ContentParent final
 
   mozilla::ipc::IPCResult RecvCreateGMPService();
 
-  mozilla::ipc::IPCResult RecvMaybeReloadPlugins();
-
   mozilla::ipc::IPCResult RecvUngrabPointer(const uint32_t& aTime);
 
   mozilla::ipc::IPCResult RecvRemovePermission(const IPC::Principal& aPrincipal,
diff --git a/dom/ipc/PContent.ipdl b/dom/ipc/PContent.ipdl
index e7cb79a34dd8e..3686797c176e3 100644
--- a/dom/ipc/PContent.ipdl
+++ b/dom/ipc/PContent.ipdl
@@ -1532,8 +1532,6 @@ parent:
 
     async AddMemoryReport(MemoryReport aReport);
 
-    async MaybeReloadPlugins();
-
     async BHRThreadHang(HangDetails aHangDetails);
 
     async AddPerformanceMetrics(nsID aID, PerformanceInfo[] aMetrics);
diff --git a/dom/ipc/ProcessHangMonitor.cpp b/dom/ipc/ProcessHangMonitor.cpp
index ebdeb675a73dd..01c8789c40678 100644
--- a/dom/ipc/ProcessHangMonitor.cpp
+++ b/dom/ipc/ProcessHangMonitor.cpp
@@ -1067,16 +1067,7 @@ HangMonitoredProcess::GetPluginName(nsACString& aPluginName) {
     return NS_ERROR_NOT_AVAILABLE;
   }
 
-  uint32_t id = mHangData.get_PluginHangData().pluginId();
-
-  RefPtr<nsPluginHost> host = nsPluginHost::GetInst();
-  nsPluginTag* tag = host->PluginWithId(id);
-  if (!tag) {
-    return NS_ERROR_UNEXPECTED;
-  }
-
-  aPluginName = tag->Name();
-  return NS_OK;
+  return NS_ERROR_UNEXPECTED;
 }
 
 NS_IMETHODIMP
diff --git a/dom/media/webrtc/common/YuvStamper.h b/dom/media/webrtc/common/YuvStamper.h
index 7ce9038fda1e4..f355055cd9239 100644
--- a/dom/media/webrtc/common/YuvStamper.h
+++ b/dom/media/webrtc/common/YuvStamper.h
@@ -5,7 +5,7 @@
 #ifndef YUV_STAMPER_H_
 #define YUV_STAMPER_H_
 
-#include "nptypes.h"
+#include <cstdint>
 
 namespace mozilla {
 
diff --git a/dom/plugins/base/moz.build b/dom/plugins/base/moz.build
index 9411e2bbfee6c..93a6f1c014a06 100644
--- a/dom/plugins/base/moz.build
+++ b/dom/plugins/base/moz.build
@@ -6,29 +6,21 @@
 
 XPIDL_SOURCES += [
     "nsIPluginTag.idl",
-    "nspluginroot.idl",
 ]
 
 XPIDL_MODULE = "plugin"
 
 EXPORTS += [
-    "npapi.h",
-    "nptypes.h",
-    "nsNPAPIPluginInstance.h",
     "nsPluginHost.h",
     "nsPluginLogging.h",
     "nsPluginTags.h",
 ]
 
 UNIFIED_SOURCES += [
-    "nsNPAPIPluginInstance.cpp",
+    "nsPluginHost.cpp",
     "nsPluginTags.cpp",
 ]
 
-SOURCES += [
-    "nsPluginHost.cpp",  # Conflict with NS_NPAPIPLUGIN_CALLBACK
-]
-
 LOCAL_INCLUDES += [
     "/dom/base",
     "/layout/generic",
diff --git a/dom/plugins/base/npapi.h b/dom/plugins/base/npapi.h
deleted file mode 100644
index d6b189baef9e5..0000000000000
--- a/dom/plugins/base/npapi.h
+++ /dev/null
@@ -1,922 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef npapi_h_
-#define npapi_h_
-
-#include "nptypes.h"
-
-#if defined(_WIN32) && !defined(__SYMBIAN32__)
-#  include <windef.h>
-#  ifndef XP_WIN
-#    define XP_WIN 1
-#  endif
-#endif
-
-#if defined(__SYMBIAN32__)
-#  ifndef XP_SYMBIAN
-#    define XP_SYMBIAN 1
-#    undef XP_WIN
-#  endif
-#endif
-
-#if defined(__APPLE_CC__) && !defined(XP_UNIX)
-#  ifndef XP_MACOSX
-#    define XP_MACOSX 1
-#  endif
-#endif
-
-#if defined(XP_MACOSX) && defined(__LP64__)
-#  define NP_NO_QUICKDRAW
-#  define NP_NO_CARBON
-#endif
-
-#if defined(XP_MACOSX)
-#  include <ApplicationServices/ApplicationServices.h>
-#  include <OpenGL/OpenGL.h>
-#  ifndef NP_NO_CARBON
-#    include <Carbon/Carbon.h>
-#  endif
-#endif
-
-#if defined(XP_UNIX)
-#  include <stdio.h>
-#  if defined(MOZ_X11)
-#    include <X11/Xlib.h>
-#    include <X11/Xutil.h>
-#    include "X11UndefineNone.h"
-#  endif
-#endif
-
-#if defined(XP_SYMBIAN)
-#  include <QEvent>
-#  include <QRegion>
-#endif
-
-/*----------------------------------------------------------------------*/
-/*                        Plugin Version Constants                      */
-/*----------------------------------------------------------------------*/
-
-#define NP_VERSION_MAJOR 0
-#define NP_VERSION_MINOR 29
-
-/* clang-format off */
-/* The OS/2 version of Netscape uses RC_DATA to define the
-   mime types, file extensions, etc that are required.
-   Use a vertical bar to separate types, end types with \0.
-   FileVersion and ProductVersion are 32bit ints, all other
-   entries are strings that MUST be terminated with a \0.
-
-AN EXAMPLE:
-
-RCDATA NP_INFO_ProductVersion { 1,0,0,1,}
-
-RCDATA NP_INFO_MIMEType    { "video/x-video|",
-                             "video/x-flick\0" }
-RCDATA NP_INFO_FileExtents { "avi|",
-                             "flc\0" }
-RCDATA NP_INFO_FileOpenName{ "MMOS2 video player(*.avi)|",
-                             "MMOS2 Flc/Fli player(*.flc)\0" }
-
-RCDATA NP_INFO_FileVersion       { 1,0,0,1 }
-RCDATA NP_INFO_CompanyName       { "Netscape Communications\0" }
-RCDATA NP_INFO_FileDescription   { "NPAVI32 Extension DLL\0"
-RCDATA NP_INFO_InternalName      { "NPAVI32\0" )
-RCDATA NP_INFO_LegalCopyright    { "Copyright Netscape Communications \251 1996\0"
-RCDATA NP_INFO_OriginalFilename  { "NVAPI32.DLL" }
-RCDATA NP_INFO_ProductName       { "NPAVI32 Dynamic Link Library\0" }
-*/
-/* clang-format on */
-/* RC_DATA types for version info - required */
-#define NP_INFO_ProductVersion 1
-#define NP_INFO_MIMEType 2
-#define NP_INFO_FileOpenName 3
-#define NP_INFO_FileExtents 4
-/* RC_DATA types for version info - used if found */
-#define NP_INFO_FileDescription 5
-#define NP_INFO_ProductName 6
-/* RC_DATA types for version info - optional */
-#define NP_INFO_CompanyName 7
-#define NP_INFO_FileVersion 8
-#define NP_INFO_InternalName 9
-#define NP_INFO_LegalCopyright 10
-#define NP_INFO_OriginalFilename 11
-
-#ifndef RC_INVOKED
-
-/*----------------------------------------------------------------------*/
-/*                       Definition of Basic Types                      */
-/*----------------------------------------------------------------------*/
-
-typedef unsigned char NPBool;
-typedef int16_t NPError;
-typedef int16_t NPReason;
-typedef char* NPMIMEType;
-
-/*----------------------------------------------------------------------*/
-/*                       Structures and definitions                     */
-/*----------------------------------------------------------------------*/
-
-#  if !defined(__LP64__)
-#    if defined(XP_MACOSX)
-#      pragma options align = mac68k
-#    endif
-#  endif /* __LP64__ */
-
-/*
- *  NPP is a plug-in's opaque instance handle
- */
-typedef struct _NPP {
-  void* pdata; /* plug-in private data */
-  void* ndata; /* netscape private data */
-} NPP_t;
-
-typedef NPP_t* NPP;
-
-typedef struct _NPStream {
-  void* pdata; /* plug-in private data */
-  void* ndata; /* netscape private data */
-  const char* url;
-  uint32_t end;
-  uint32_t lastmodified;
-  void* notifyData;
-  const char* headers; /* Response headers from host.
-                        * Exists only for >= NPVERS_HAS_RESPONSE_HEADERS.
-                        * Used for HTTP only; nullptr for non-HTTP.
-                        * Available from NPP_NewStream onwards.
-                        * Plugin should copy this data before storing it.
-                        * Includes HTTP status line and all headers,
-                        * preferably verbatim as received from server,
-                        * headers formatted as in HTTP ("Header: Value"),
-                        * and newlines (\n, NOT \r\n) separating lines.
-                        * Terminated by \n\0 (NOT \n\n\0). */
-} NPStream;
-
-typedef struct _NPByteRange {
-  int32_t offset; /* negative offset means from the end */
-  uint32_t length;
-  struct _NPByteRange* next;
-} NPByteRange;
-
-typedef struct _NPSavedData {
-  int32_t len;
-  void* buf;
-} NPSavedData;
-
-typedef struct _NPRect {
-  uint16_t top;
-  uint16_t left;
-  uint16_t bottom;
-  uint16_t right;
-} NPRect;
-
-typedef struct _NPSize {
-  int32_t width;
-  int32_t height;
-} NPSize;
-
-typedef enum { NPFocusNext = 0, NPFocusPrevious = 1 } NPFocusDirection;
-
-/* These formats describe the format in the memory byte-order. This means if
- * a 32-bit value of a pixel is viewed on a little-endian system the layout will
- * be 0xAARRGGBB. The Alpha channel will be stored in the most significant
- * bits. */
-typedef enum {
-  /* 32-bit per pixel 8-bit per channel - premultiplied alpha */
-  NPImageFormatBGRA32 = 0x1,
-  /* 32-bit per pixel 8-bit per channel - 1 unused channel */
-  NPImageFormatBGRX32 = 0x2
-} NPImageFormat;
-
-typedef struct _NPAsyncSurface {
-  uint32_t version;
-  NPSize size;
-  NPImageFormat format;
-  union {
-    struct {
-      uint32_t stride;
-      void* data;
-    } bitmap;
-#  if defined(XP_WIN)
-    HANDLE sharedHandle;
-#  endif
-  };
-} NPAsyncSurface;
-
-/* Return values for NPP_HandleEvent */
-#  define kNPEventNotHandled 0
-#  define kNPEventHandled 1
-/* Exact meaning must be spec'd in event model. */
-#  define kNPEventStartIME 2
-
-#  if defined(XP_UNIX)
-/*
- * Unix specific structures and definitions
- */
-
-/*
- * Callback Structures.
- *
- * These are used to pass additional platform specific information.
- */
-enum { NP_SETWINDOW = 1, NP_PRINT };
-
-typedef struct {
-  int32_t type;
-} NPAnyCallbackStruct;
-
-typedef struct {
-  int32_t type;
-#    if defined(MOZ_X11)
-  Display* display;
-  Visual* visual;
-  Colormap colormap;
-  unsigned int depth;
-#    endif
-} NPSetWindowCallbackStruct;
-
-typedef struct {
-  int32_t type;
-  FILE* fp;
-} NPPrintCallbackStruct;
-
-#  endif /* XP_UNIX */
-
-#  if defined(XP_WIN)
-/*
- * Windows specific structures and definitions
- */
-
-/*
- * Information about the default audio device.  These values share meaning with
- * the parameters to the Windows API IMMNotificationClient object.
- * This is the value of the NPNVaudioDeviceChangeDetails variable.
- */
-typedef struct _NPAudioDeviceChangeDetails {
-  int32_t flow;
-  int32_t role;
-  const wchar_t* defaultDevice;  // this pointer is only valid during the call
-                                 // to NPPSetValue.
-} NPAudioDeviceChangeDetails;
-
-#  endif /* XP_WIN */
-
-/*
- * This is the value of the NPNVaudioDeviceStateChanged variable.
- */
-typedef struct _NPAudioDeviceStateChanged {
-  /* Name of device that changed state.  This string is only valid during
-   * the call to NPPSetValue.
-   */
-  const wchar_t* device;
-  uint32_t newState;
-} NPAudioDeviceStateChanged;
-
-typedef enum {
-  NPDrawingModelDUMMY
-#  if defined(XP_MACOSX)
-#    ifndef NP_NO_QUICKDRAW
-  ,
-  NPDrawingModelQuickDraw = 0
-#    endif
-  ,
-  NPDrawingModelCoreGraphics = 1,
-  NPDrawingModelOpenGL = 2,
-  NPDrawingModelCoreAnimation = 3,
-  NPDrawingModelInvalidatingCoreAnimation = 4
-#  endif
-#  if defined(XP_WIN)
-  ,
-  NPDrawingModelSyncWin = 5
-#  endif
-#  if defined(MOZ_X11)
-  ,
-  NPDrawingModelSyncX = 6
-#  endif
-  ,
-  NPDrawingModelAsyncBitmapSurface = 7
-#  if defined(XP_WIN)
-  ,
-  NPDrawingModelAsyncWindowsDXGISurface = 8
-#  endif
-} NPDrawingModel;
-
-#  ifdef XP_MACOSX
-typedef enum {
-#    ifndef NP_NO_CARBON
-  NPEventModelCarbon = 0,
-#    endif
-  NPEventModelCocoa = 1
-} NPEventModel;
-#  endif
-
-/*
- *   The following masks are applied on certain platforms to NPNV and
- *   NPPV selectors that pass around pointers to COM interfaces. Newer
- *   compilers on some platforms may generate vtables that are not
- *   compatible with older compilers. To prevent older plugins from
- *   not understanding a new browser's ABI, these masks change the
- *   values of those selectors on those platforms. To remain backwards
- *   compatible with different versions of the browser, plugins can
- *   use these masks to dynamically determine and use the correct C++
- *   ABI that the browser is expecting. This does not apply to Windows
- *   as Microsoft's COM ABI will likely not change.
- */
-
-#  define NP_ABI_GCC3_MASK 0x10000000
-/*
- *   gcc 3.x generated vtables on UNIX and OSX are incompatible with
- *   previous compilers.
- */
-#  if (defined(XP_UNIX) && defined(__GNUC__) && (__GNUC__ >= 3))
-#    define _NP_ABI_MIXIN_FOR_GCC3 NP_ABI_GCC3_MASK
-#  else
-#    define _NP_ABI_MIXIN_FOR_GCC3 0
-#  endif
-
-#  if defined(XP_MACOSX)
-#    define NP_ABI_MACHO_MASK 0x01000000
-#    define _NP_ABI_MIXIN_FOR_MACHO NP_ABI_MACHO_MASK
-#  else
-#    define _NP_ABI_MIXIN_FOR_MACHO 0
-#  endif
-
-#  define NP_ABI_MASK (_NP_ABI_MIXIN_FOR_GCC3 | _NP_ABI_MIXIN_FOR_MACHO)
-
-/*
- * List of variable names for which NPP_GetValue shall be implemented
- */
-typedef enum {
-  NPPVpluginNameString = 1,
-  NPPVpluginDescriptionString,
-  NPPVpluginWindowBool,
-  NPPVpluginTransparentBool,
-  NPPVjavaClass,
-  NPPVpluginWindowSize,
-  NPPVpluginTimerInterval,
-  NPPVpluginScriptableInstance = (10 | NP_ABI_MASK),
-  NPPVpluginScriptableIID = 11,
-  NPPVjavascriptPushCallerBool = 12,
-  NPPVpluginKeepLibraryInMemory = 13,
-  NPPVpluginNeedsXEmbed = 14,
-
-  /* Get the NPObject for scripting the plugin. Introduced in NPAPI minor
-   * version 14.
-   */
-  NPPVpluginScriptableNPObject = 15,
-
-  /* Get the plugin value (as \0-terminated UTF-8 string data) for
-   * form submission if the plugin is part of a form. Use
-   * NPN_MemAlloc() to allocate memory for the string data. Introduced
-   * in NPAPI minor version 15.
-   */
-  NPPVformValue = 16,
-
-  NPPVpluginUrlRequestsDisplayedBool = 17,
-
-  /* Checks if the plugin is interested in receiving the http body of
-   * all http requests (including failed ones, http status != 200).
-   */
-  NPPVpluginWantsAllNetworkStreams = 18,
-
-  /* Browsers can retrieve a native ATK accessibility plug ID via this variable.
-   */
-  NPPVpluginNativeAccessibleAtkPlugId = 19,
-
-  /* Checks to see if the plug-in would like the browser to load the "src"
-     attribute. */
-  NPPVpluginCancelSrcStream = 20,
-
-  NPPVsupportsAdvancedKeyHandling = 21,
-
-  NPPVpluginUsesDOMForCursorBool = 22,
-
-  /* Used for negotiating drawing models */
-  NPPVpluginDrawingModel = 1000
-#  if defined(XP_MACOSX)
-  /* Used for negotiating event models */
-  ,
-  NPPVpluginEventModel = 1001
-  /* In the NPDrawingModelCoreAnimation drawing model, the browser asks the
-     plug-in for a Core Animation layer. */
-  ,
-  NPPVpluginCoreAnimationLayer = 1003
-#  endif
-  /* Notification that the plugin just started or stopped playing audio */
-  ,
-  NPPVpluginIsPlayingAudio = 4000
-#  if defined(XP_WIN)
-  /* Notification that the plugin requests notification when the default audio
-     device has changed */
-  ,
-  NPPVpluginRequiresAudioDeviceChanges = 4001
-#  endif
-
-} NPPVariable;
-
-/*
- * List of variable names for which NPN_GetValue should be implemented.
- */
-typedef enum {
-  NPNVxDisplay = 1,
-  NPNVxtAppContext,
-  NPNVnetscapeWindow,
-  NPNVjavascriptEnabledBool,
-  NPNVasdEnabledBool,
-  NPNVisOfflineBool,
-
-  NPNVserviceManager = (10 | NP_ABI_MASK),
-  NPNVDOMElement = (11 | NP_ABI_MASK),
-  NPNVDOMWindow = (12 | NP_ABI_MASK),
-  NPNVToolkit = (13 | NP_ABI_MASK),
-  NPNVSupportsXEmbedBool = 14,
-
-  /* Get the NPObject wrapper for the browser window. */
-  NPNVWindowNPObject = 15,
-
-  /* Get the NPObject wrapper for the plugins DOM element. */
-  NPNVPluginElementNPObject = 16,
-
-  NPNVSupportsWindowless = 17,
-
-  NPNVprivateModeBool = 18,
-
-  NPNVsupportsAdvancedKeyHandling = 21,
-
-  NPNVdocumentOrigin = 22,
-
-  NPNVCSSZoomFactor = 23,
-
-  NPNVpluginDrawingModel =
-      1000 /* Get the current drawing model (NPDrawingModel) */
-#  if defined(XP_MACOSX) || defined(XP_WIN)
-  ,
-  NPNVcontentsScaleFactor = 1001
-#  endif
-#  if defined(XP_MACOSX)
-#    ifndef NP_NO_QUICKDRAW
-  ,
-  NPNVsupportsQuickDrawBool = 2000
-#    endif
-  ,
-  NPNVsupportsCoreGraphicsBool = 2001,
-  NPNVsupportsOpenGLBool = 2002,
-  NPNVsupportsCoreAnimationBool = 2003,
-  NPNVsupportsInvalidatingCoreAnimationBool = 2004
-#  endif
-  ,
-  NPNVsupportsAsyncBitmapSurfaceBool = 2007
-#  if defined(XP_WIN)
-  ,
-  NPNVsupportsAsyncWindowsDXGISurfaceBool = 2008,
-  NPNVpreferredDXGIAdapter = 2009
-#  endif
-#  if defined(XP_MACOSX)
-#    ifndef NP_NO_CARBON
-  ,
-  NPNVsupportsCarbonBool =
-      3000 /* TRUE if the browser supports the Carbon event model */
-#    endif
-  ,
-  NPNVsupportsCocoaBool =
-      3001 /* TRUE if the browser supports the Cocoa event model */
-  ,
-  NPNVsupportsUpdatedCocoaTextInputBool =
-      3002 /* TRUE if the browser supports the updated
-              Cocoa text input specification. */
-#  endif
-  ,
-  NPNVmuteAudioBool =
-      4000 /* Request that the browser wants to mute or unmute the plugin */
-#  if defined(XP_WIN)
-  ,
-  NPNVaudioDeviceChangeDetails =
-      4001 /* Provides information about the new default audio device */
-  ,
-  NPNVaudioDeviceStateChanged =
-      4002 /* Provides information if any audio device changes state */
-#  endif
-#  if defined(XP_MACOSX)
-  ,
-  NPNVsupportsCompositingCoreAnimationPluginsBool =
-      74656 /* TRUE if the browser supports
-               CA model compositing */
-#  endif
-  ,
-  NPNVLast
-} NPNVariable;
-
-typedef enum { NPNURLVCookie = 501, NPNURLVProxy } NPNURLVariable;
-
-/*
- * The type of Toolkit the widgets use
- */
-typedef enum { NPNVGtk12 = 1, NPNVGtk2 } NPNToolkitType;
-
-/*
- * The type of a NPWindow - it specifies the type of the data structure
- * returned in the window field.
- */
-typedef enum { NPWindowTypeWindow = 1, NPWindowTypeDrawable } NPWindowType;
-
-typedef struct _NPWindow {
-  void* window;   /* Platform specific window handle */
-                  /* OS/2: x - Position of bottom left corner */
-                  /* OS/2: y - relative to visible netscape window */
-  int32_t x;      /* Position of top left corner relative */
-  int32_t y;      /* to a netscape page. */
-  uint32_t width; /* Maximum window size */
-  uint32_t height;
-  NPRect clipRect; /* Clipping rectangle in port coordinates */
-#  if (defined(XP_UNIX) || defined(XP_SYMBIAN)) && !defined(XP_MACOSX)
-  void* ws_info;     /* Platform-dependent additional data */
-#  endif             /* XP_UNIX */
-  NPWindowType type; /* Is this a window or a drawable? */
-} NPWindow;
-
-typedef struct _NPImageExpose {
-  char* data;       /* image pointer */
-  int32_t stride;   /* Stride of data image pointer */
-  int32_t depth;    /* Depth of image pointer */
-  int32_t x;        /* Expose x */
-  int32_t y;        /* Expose y */
-  uint32_t width;   /* Expose width */
-  uint32_t height;  /* Expose height */
-  NPSize dataSize;  /* Data buffer size */
-  float translateX; /* translate X matrix value */
-  float translateY; /* translate Y matrix value */
-  float scaleX;     /* scale X matrix value */
-  float scaleY;     /* scale Y matrix value */
-} NPImageExpose;
-
-typedef struct _NPFullPrint {
-  NPBool pluginPrinted; /* Set TRUE if plugin handled fullscreen printing */
-  NPBool printOne;      /* TRUE if plugin should print one copy to default
-                           printer */
-  void* platformPrint;  /* Platform-specific printing info */
-} NPFullPrint;
-
-typedef struct _NPEmbedPrint {
-  NPWindow window;
-  void* platformPrint; /* Platform-specific printing info */
-} NPEmbedPrint;
-
-typedef struct _NPPrint {
-  uint16_t mode; /* NP_FULL or NP_EMBED */
-  union {
-    NPFullPrint fullPrint;   /* if mode is NP_FULL */
-    NPEmbedPrint embedPrint; /* if mode is NP_EMBED */
-  } print;
-} NPPrint;
-
-#  if defined(XP_MACOSX)
-#    ifndef NP_NO_CARBON
-typedef EventRecord NPEvent;
-#    endif
-#  elif defined(XP_SYMBIAN)
-typedef QEvent NPEvent;
-#  elif defined(XP_WIN)
-typedef struct _NPEvent {
-  uint16_t event;
-  uintptr_t wParam;
-  intptr_t lParam;
-} NPEvent;
-#  elif defined(XP_UNIX) && defined(MOZ_X11)
-typedef XEvent NPEvent;
-#  else
-typedef void* NPEvent;
-#  endif
-
-#  if defined(XP_MACOSX)
-typedef void* NPRegion;
-#    ifndef NP_NO_QUICKDRAW
-typedef RgnHandle NPQDRegion;
-#    endif
-typedef CGPathRef NPCGRegion;
-#  elif defined(XP_WIN)
-typedef HRGN NPRegion;
-#  elif defined(XP_UNIX) && defined(MOZ_X11)
-typedef Region NPRegion;
-#  elif defined(XP_SYMBIAN)
-typedef QRegion* NPRegion;
-#  else
-typedef void* NPRegion;
-#  endif
-
-typedef struct _NPNSString NPNSString;
-typedef struct _NPNSWindow NPNSWindow;
-typedef struct _NPNSMenu NPNSMenu;
-
-#  if defined(XP_MACOSX)
-typedef NPNSMenu NPMenu;
-#  else
-typedef void* NPMenu;
-#  endif
-
-typedef enum {
-  NPCoordinateSpacePlugin = 1,
-  NPCoordinateSpaceWindow,
-  NPCoordinateSpaceFlippedWindow,
-  NPCoordinateSpaceScreen,
-  NPCoordinateSpaceFlippedScreen
-} NPCoordinateSpace;
-
-#  if defined(XP_MACOSX)
-
-#    ifndef NP_NO_QUICKDRAW
-typedef struct NP_Port {
-  CGrafPtr port;
-  int32_t portx; /* position inside the topmost window */
-  int32_t porty;
-} NP_Port;
-#    endif /* NP_NO_QUICKDRAW */
-
-/*
- * NP_CGContext is the type of the NPWindow's 'window' when the plugin specifies
- * NPDrawingModelCoreGraphics as its drawing model.
- */
-
-typedef struct NP_CGContext {
-  CGContextRef context;
-  void* window; /* A WindowRef under the Carbon event model. */
-} NP_CGContext;
-
-/*
- * NP_GLContext is the type of the NPWindow's 'window' when the plugin specifies
- * NPDrawingModelOpenGL as its drawing model.
- */
-
-typedef struct NP_GLContext {
-  CGLContextObj context;
-#    ifdef NP_NO_CARBON
-  NPNSWindow* window;
-#    else
-  void* window; /* Can be either an NSWindow or a WindowRef depending on the
-                   event model */
-#    endif
-} NP_GLContext;
-
-typedef enum {
-  NPCocoaEventDrawRect = 1,
-  NPCocoaEventMouseDown,
-  NPCocoaEventMouseUp,
-  NPCocoaEventMouseMoved,
-  NPCocoaEventMouseEntered,
-  NPCocoaEventMouseExited,
-  NPCocoaEventMouseDragged,
-  NPCocoaEventKeyDown,
-  NPCocoaEventKeyUp,
-  NPCocoaEventFlagsChanged,
-  NPCocoaEventFocusChanged,
-  NPCocoaEventWindowFocusChanged,
-  NPCocoaEventScrollWheel,
-  NPCocoaEventTextInput
-} NPCocoaEventType;
-
-typedef struct _NPCocoaEvent {
-  NPCocoaEventType type;
-  uint32_t version;
-  union {
-    struct {
-      uint32_t modifierFlags;
-      double pluginX;
-      double pluginY;
-      int32_t buttonNumber;
-      int32_t clickCount;
-      double deltaX;
-      double deltaY;
-      double deltaZ;
-    } mouse;
-    struct {
-      uint32_t modifierFlags;
-      NPNSString* characters;
-      NPNSString* charactersIgnoringModifiers;
-      NPBool isARepeat;
-      uint16_t keyCode;
-    } key;
-    struct {
-      CGContextRef context;
-      double x;
-      double y;
-      double width;
-      double height;
-    } draw;
-    struct {
-      NPBool hasFocus;
-    } focus;
-    struct {
-      NPNSString* text;
-    } text;
-  } data;
-} NPCocoaEvent;
-
-#    ifndef NP_NO_CARBON
-/* Non-standard event types that can be passed to HandleEvent */
-enum NPEventType {
-  NPEventType_GetFocusEvent = (osEvt + 16),
-  NPEventType_LoseFocusEvent,
-  NPEventType_AdjustCursorEvent,
-  NPEventType_MenuCommandEvent,
-  NPEventType_ClippingChangedEvent,
-  NPEventType_ScrollingBeginsEvent = 1000,
-  NPEventType_ScrollingEndsEvent
-};
-#    endif /* NP_NO_CARBON */
-
-#  endif /* XP_MACOSX */
-
-/*
- * Values for mode passed to NPP_New:
- */
-#  define NP_EMBED 1
-#  define NP_FULL 2
-
-/*
- * Values for stream type passed to NPP_NewStream:
- */
-#  define NP_NORMAL 1
-#  define NP_SEEK 2
-#  define NP_ASFILE 3
-#  define NP_ASFILEONLY 4
-
-#  define NP_MAXREADY (((unsigned)(~0) << 1) >> 1)
-
-/*
- * Flags for NPP_ClearSiteData.
- */
-#  define NP_CLEAR_ALL 0
-#  define NP_CLEAR_CACHE (1 << 0)
-
-#  if !defined(__LP64__)
-#    if defined(XP_MACOSX)
-#      pragma options align = reset
-#    endif
-#  endif /* __LP64__ */
-
-/*----------------------------------------------------------------------*/
-/*       Error and Reason Code definitions                              */
-/*----------------------------------------------------------------------*/
-
-/*
- * Values of type NPError:
- */
-#  define NPERR_BASE 0
-#  define NPERR_NO_ERROR (NPERR_BASE + 0)
-#  define NPERR_GENERIC_ERROR (NPERR_BASE + 1)
-#  define NPERR_INVALID_INSTANCE_ERROR (NPERR_BASE + 2)
-#  define NPERR_INVALID_FUNCTABLE_ERROR (NPERR_BASE + 3)
-#  define NPERR_MODULE_LOAD_FAILED_ERROR (NPERR_BASE + 4)
-#  define NPERR_OUT_OF_MEMORY_ERROR (NPERR_BASE + 5)
-#  define NPERR_INVALID_PLUGIN_ERROR (NPERR_BASE + 6)
-#  define NPERR_INVALID_PLUGIN_DIR_ERROR (NPERR_BASE + 7)
-#  define NPERR_INCOMPATIBLE_VERSION_ERROR (NPERR_BASE + 8)
-#  define NPERR_INVALID_PARAM (NPERR_BASE + 9)
-#  define NPERR_INVALID_URL (NPERR_BASE + 10)
-#  define NPERR_FILE_NOT_FOUND (NPERR_BASE + 11)
-#  define NPERR_NO_DATA (NPERR_BASE + 12)
-#  define NPERR_STREAM_NOT_SEEKABLE (NPERR_BASE + 13)
-#  define NPERR_TIME_RANGE_NOT_SUPPORTED (NPERR_BASE + 14)
-#  define NPERR_MALFORMED_SITE (NPERR_BASE + 15)
-
-/*
- * Values of type NPReason:
- */
-#  define NPRES_BASE 0
-#  define NPRES_DONE (NPRES_BASE + 0)
-#  define NPRES_NETWORK_ERR (NPRES_BASE + 1)
-#  define NPRES_USER_BREAK (NPRES_BASE + 2)
-
-/*
- * Don't use these obsolete error codes any more.
- */
-#  define NP_NOERR NP_NOERR_is_obsolete_use_NPERR_NO_ERROR
-#  define NP_EINVAL NP_EINVAL_is_obsolete_use_NPERR_GENERIC_ERROR
-#  define NP_EABORT NP_EABORT_is_obsolete_use_NPRES_USER_BREAK
-
-/*
- * Version feature information
- */
-#  define NPVERS_HAS_STREAMOUTPUT 8
-#  define NPVERS_HAS_NOTIFICATION 9
-#  define NPVERS_HAS_LIVECONNECT 9
-#  define NPVERS_68K_HAS_LIVECONNECT 11
-#  define NPVERS_HAS_WINDOWLESS 11
-#  define NPVERS_HAS_XPCONNECT_SCRIPTING 13
-#  define NPVERS_HAS_NPRUNTIME_SCRIPTING 14
-#  define NPVERS_HAS_FORM_VALUES 15
-#  define NPVERS_HAS_POPUPS_ENABLED_STATE 16
-#  define NPVERS_HAS_RESPONSE_HEADERS 17
-#  define NPVERS_HAS_NPOBJECT_ENUM 18
-#  define NPVERS_HAS_PLUGIN_THREAD_ASYNC_CALL 19
-#  define NPVERS_HAS_ALL_NETWORK_STREAMS 20
-#  define NPVERS_HAS_URL_AND_AUTH_INFO 21
-#  define NPVERS_HAS_PRIVATE_MODE 22
-#  define NPVERS_MACOSX_HAS_COCOA_EVENTS 23
-#  define NPVERS_HAS_ADVANCED_KEY_HANDLING 25
-#  define NPVERS_HAS_URL_REDIRECT_HANDLING 26
-#  define NPVERS_HAS_CLEAR_SITE_DATA 27
-
-/*----------------------------------------------------------------------*/
-/*                        Function Prototypes                           */
-/*----------------------------------------------------------------------*/
-
-#  ifdef __cplusplus
-extern "C" {
-#  endif
-
-/* NPP_* functions are provided by the plugin and called by the navigator. */
-
-#  if defined(XP_UNIX)
-const char* NPP_GetMIMEDescription(void);
-#  endif
-
-NPError NPP_New(NPMIMEType pluginType, NPP instance, uint16_t mode,
-                int16_t argc, char* argn[], char* argv[], NPSavedData* saved);
-NPError NPP_Destroy(NPP instance, NPSavedData** save);
-NPError NPP_SetWindow(NPP instance, NPWindow* window);
-NPError NPP_NewStream(NPP instance, NPMIMEType type, NPStream* stream,
-                      NPBool seekable, uint16_t* stype);
-NPError NPP_DestroyStream(NPP instance, NPStream* stream, NPReason reason);
-int32_t NPP_WriteReady(NPP instance, NPStream* stream);
-int32_t NPP_Write(NPP instance, NPStream* stream, int32_t offset, int32_t len,
-                  void* buffer);
-void NPP_StreamAsFile(NPP instance, NPStream* stream, const char* fname);
-void NPP_Print(NPP instance, NPPrint* platformPrint);
-int16_t NPP_HandleEvent(NPP instance, void* event);
-void NPP_URLNotify(NPP instance, const char* url, NPReason reason,
-                   void* notifyData);
-NPError NPP_GetValue(NPP instance, NPPVariable variable, void* value);
-NPError NPP_SetValue(NPP instance, NPNVariable variable, void* value);
-NPBool NPP_GotFocus(NPP instance, NPFocusDirection direction);
-void NPP_LostFocus(NPP instance);
-void NPP_URLRedirectNotify(NPP instance, const char* url, int32_t status,
-                           void* notifyData);
-NPError NPP_ClearSiteData(const char* site, uint64_t flags, uint64_t maxAge);
-char** NPP_GetSitesWithData(void);
-void NPP_DidComposite(NPP instance);
-
-/* NPN_* functions are provided by the navigator and called by the plugin. */
-void NPN_Version(int* plugin_major, int* plugin_minor, int* netscape_major,
-                 int* netscape_minor);
-NPError NPN_GetURLNotify(NPP instance, const char* url, const char* target,
-                         void* notifyData);
-NPError NPN_GetURL(NPP instance, const char* url, const char* target);
-NPError NPN_PostURLNotify(NPP instance, const char* url, const char* target,
-                          uint32_t len, const char* buf, NPBool file,
-                          void* notifyData);
-NPError NPN_PostURL(NPP instance, const char* url, const char* target,
-                    uint32_t len, const char* buf, NPBool file);
-NPError NPN_RequestRead(NPStream* stream, NPByteRange* rangeList);
-NPError NPN_NewStream(NPP instance, NPMIMEType type, const char* target,
-                      NPStream** stream);
-int32_t NPN_Write(NPP instance, NPStream* stream, int32_t len, void* buffer);
-NPError NPN_DestroyStream(NPP instance, NPStream* stream, NPReason reason);
-void NPN_Status(NPP instance, const char* message);
-const char* NPN_UserAgent(NPP instance);
-void* NPN_MemAlloc(uint32_t size);
-void NPN_MemFree(void* ptr);
-uint32_t NPN_MemFlush(uint32_t size);
-void NPN_ReloadPlugins(NPBool reloadPages);
-NPError NPN_GetValue(NPP instance, NPNVariable variable, void* value);
-NPError NPN_SetValue(NPP instance, NPPVariable variable, void* value);
-void NPN_InvalidateRect(NPP instance, NPRect* invalidRect);
-void NPN_InvalidateRegion(NPP instance, NPRegion invalidRegion);
-void NPN_ForceRedraw(NPP instance);
-void NPN_PushPopupsEnabledState(NPP instance, NPBool enabled);
-void NPN_PopPopupsEnabledState(NPP instance);
-void NPN_PluginThreadAsyncCall(NPP instance, void (*func)(void*),
-                               void* userData);
-NPError NPN_GetValueForURL(NPP instance, NPNURLVariable variable,
-                           const char* url, char** value, uint32_t* len);
-NPError NPN_SetValueForURL(NPP instance, NPNURLVariable variable,
-                           const char* url, const char* value, uint32_t len);
-NPError NPN_GetAuthenticationInfo(NPP instance, const char* protocol,
-                                  const char* host, int32_t port,
-                                  const char* scheme, const char* realm,
-                                  char** username, uint32_t* ulen,
-                                  char** password, uint32_t* plen);
-uint32_t NPN_ScheduleTimer(NPP instance, uint32_t interval, NPBool repeat,
-                           void (*timerFunc)(NPP npp, uint32_t timerID));
-void NPN_UnscheduleTimer(NPP instance, uint32_t timerID);
-NPError NPN_PopUpContextMenu(NPP instance, NPMenu* menu);
-NPBool NPN_ConvertPoint(NPP instance, double sourceX, double sourceY,
-                        NPCoordinateSpace sourceSpace, double* destX,
-                        double* destY, NPCoordinateSpace destSpace);
-NPBool NPN_HandleEvent(NPP instance, void* event, NPBool handled);
-NPBool NPN_UnfocusInstance(NPP instance, NPFocusDirection direction);
-void NPN_URLRedirectResponse(NPP instance, void* notifyData, NPBool allow);
-NPError NPN_InitAsyncSurface(NPP instance, NPSize* size, NPImageFormat format,
-                             void* initData, NPAsyncSurface* surface);
-NPError NPN_FinalizeAsyncSurface(NPP instance, NPAsyncSurface* surface);
-void NPN_SetCurrentAsyncSurface(NPP instance, NPAsyncSurface* surface,
-                                NPRect* changed);
-
-#  ifdef __cplusplus
-} /* end extern "C" */
-#  endif
-
-#endif /* RC_INVOKED */
-
-#endif /* npapi_h_ */
diff --git a/dom/plugins/base/nptypes.h b/dom/plugins/base/nptypes.h
deleted file mode 100644
index 02e32ed99c332..0000000000000
--- a/dom/plugins/base/nptypes.h
+++ /dev/null
@@ -1,89 +0,0 @@
-/* -*- Mode: C; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef nptypes_h_
-#define nptypes_h_
-
-/*
- * Header file for ensuring that C99 types ([u]int32_t, [u]int64_t and bool) and
- * true/false macros are available.
- */
-
-#if defined(WIN32)
-/*
- * Win32 and OS/2 don't know C99, so define [u]int_16/32/64 here. The bool
- * is predefined tho, both in C and C++.
- */
-typedef short int16_t;
-typedef unsigned short uint16_t;
-typedef int int32_t;
-typedef unsigned int uint32_t;
-typedef long long int64_t;
-typedef unsigned long long uint64_t;
-#elif defined(_AIX) || defined(__sun) || defined(__osf__) || defined(IRIX) || \
-    defined(HPUX)
-/*
- * AIX and SunOS ship a inttypes.h header that defines [u]int32_t,
- * but not bool for C.
- */
-#  include <inttypes.h>
-
-#  ifndef __cplusplus
-typedef int bool;
-#    define true 1
-#    define false 0
-#  endif
-#elif defined(bsdi) || defined(FREEBSD) || defined(OPENBSD)
-/*
- * BSD/OS, FreeBSD, and OpenBSD ship sys/types.h that define int32_t and
- * u_int32_t.
- */
-#  include <sys/types.h>
-
-/*
- * BSD/OS ships no header that defines uint32_t, nor bool (for C)
- */
-#  if defined(bsdi)
-typedef u_int32_t uint32_t;
-typedef u_int64_t uint64_t;
-
-#    if !defined(__cplusplus)
-typedef int bool;
-#      define true 1
-#      define false 0
-#    endif
-#  else
-/*
- * FreeBSD and OpenBSD define uint32_t and bool.
- */
-#    include <inttypes.h>
-#    include <stdbool.h>
-#  endif
-#elif defined(BEOS)
-#  include <inttypes.h>
-#else
-/*
- * For those that ship a standard C99 stdint.h header file, include
- * it. Can't do the same for stdbool.h tho, since some systems ship
- * with a stdbool.h file that doesn't compile!
- */
-#  include <stdint.h>
-
-#  ifndef __cplusplus
-#    if !defined(__GNUC__) || (__GNUC__ > 2 || __GNUC_MINOR__ > 95)
-#      include <stdbool.h>
-#    else
-/*
- * GCC 2.91 can't deal with a typedef for bool, but a #define
- * works.
- */
-#      define bool int
-#      define true 1
-#      define false 0
-#    endif
-#  endif
-#endif
-
-#endif /* nptypes_h_ */
diff --git a/dom/plugins/base/nsNPAPIPluginInstance.cpp b/dom/plugins/base/nsNPAPIPluginInstance.cpp
deleted file mode 100644
index 451ac227cd852..0000000000000
--- a/dom/plugins/base/nsNPAPIPluginInstance.cpp
+++ /dev/null
@@ -1,586 +0,0 @@
-/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "mozilla/DebugOnly.h"
-
-#include "mozilla/Logging.h"
-#include "nscore.h"
-#include "prenv.h"
-
-#include "nsNPAPIPluginInstance.h"
-#include "nsPluginHost.h"
-#include "nsPluginLogging.h"
-#include "nsContentUtils.h"
-
-#include "nsThreadUtils.h"
-#include "mozilla/dom/Document.h"
-#include "nsIDocShell.h"
-#include "nsIScriptGlobalObject.h"
-#include "nsIScriptContext.h"
-#include "nsDirectoryServiceDefs.h"
-#include "nsSize.h"
-#include "nsNetCID.h"
-#include "nsIContent.h"
-#include "nsVersionComparator.h"
-#include "mozilla/Preferences.h"
-#include "mozilla/Unused.h"
-#include "nsILoadContext.h"
-#include "mozilla/dom/Element.h"
-#include "mozilla/dom/HTMLObjectElementBinding.h"
-#include "AudioChannelService.h"
-#include "mozilla/ProfilerLabels.h"
-
-using namespace mozilla;
-using namespace mozilla::dom;
-
-using namespace mozilla;
-using namespace mozilla::layers;
-
-NS_IMPL_ISUPPORTS(nsNPAPIPluginInstance, nsIAudioChannelAgentCallback)
-
-nsNPAPIPluginInstance::nsNPAPIPluginInstance()
-    : mDrawingModel(kDefaultDrawingModel),
-      mRunning(NOT_STARTED),
-      mWindowless(false),
-      mTransparent(false),
-      mCached(false),
-      mUsesDOMForCursor(false),
-      mInPluginInitCall(false),
-      mMIMEType(nullptr)
-#ifdef XP_MACOSX
-      ,
-      mCurrentPluginEvent(nullptr)
-#endif
-      ,
-      mCachedParamLength(0),
-      mCachedParamNames(nullptr),
-      mCachedParamValues(nullptr) {
-  mNPP.pdata = nullptr;
-  mNPP.ndata = this;
-
-  PLUGIN_LOG(PLUGIN_LOG_BASIC, ("nsNPAPIPluginInstance ctor: this=%p\n", this));
-}
-
-nsNPAPIPluginInstance::~nsNPAPIPluginInstance() {
-  PLUGIN_LOG(PLUGIN_LOG_BASIC, ("nsNPAPIPluginInstance dtor: this=%p\n", this));
-
-  if (mMIMEType) {
-    free(mMIMEType);
-    mMIMEType = nullptr;
-  }
-
-  if (!mCachedParamValues || !mCachedParamNames) {
-    return;
-  }
-  MOZ_ASSERT(mCachedParamValues && mCachedParamNames);
-
-  for (uint32_t i = 0; i < mCachedParamLength; i++) {
-    if (mCachedParamNames[i]) {
-      free(mCachedParamNames[i]);
-      mCachedParamNames[i] = nullptr;
-    }
-    if (mCachedParamValues[i]) {
-      free(mCachedParamValues[i]);
-      mCachedParamValues[i] = nullptr;
-    }
-  }
-
-  free(mCachedParamNames);
-  mCachedParamNames = nullptr;
-
-  free(mCachedParamValues);
-  mCachedParamValues = nullptr;
-}
-
-uint32_t nsNPAPIPluginInstance::gInUnsafePluginCalls = 0;
-
-void nsNPAPIPluginInstance::Destroy() {
-  Stop();
-  mAudioChannelAgent = nullptr;
-}
-
-TimeStamp nsNPAPIPluginInstance::StopTime() { return mStopTime; }
-
-nsresult nsNPAPIPluginInstance::Stop() { return NS_ERROR_FAILURE; }
-
-already_AddRefed<nsPIDOMWindowOuter> nsNPAPIPluginInstance::GetDOMWindow() {
-  return nullptr;
-}
-
-nsresult nsNPAPIPluginInstance::Start() { return NS_ERROR_FAILURE; }
-
-nsresult nsNPAPIPluginInstance::SetWindow(NPWindow* window) {
-  return NS_ERROR_FAILURE;
-}
-
-nsresult nsNPAPIPluginInstance::Print(NPPrint* platformPrint) {
-  return NS_ERROR_FAILURE;
-}
-
-nsresult nsNPAPIPluginInstance::HandleEvent(
-    void* event, int16_t* result, NSPluginCallReentry aSafeToReenterGecko) {
-  return NS_ERROR_FAILURE;
-}
-
-nsresult nsNPAPIPluginInstance::GetValueFromPlugin(NPPVariable variable,
-                                                   void* value) {
-  return NS_ERROR_FAILURE;
-}
-
-nsresult nsNPAPIPluginInstance::GetNPP(NPP* aNPP) {
-  if (aNPP)
-    *aNPP = &mNPP;
-  else
-    return NS_ERROR_NULL_POINTER;
-
-  return NS_OK;
-}
-
-NPError nsNPAPIPluginInstance::SetWindowless(bool aWindowless) {
-  mWindowless = aWindowless;
-  return NPERR_NO_ERROR;
-}
-
-NPError nsNPAPIPluginInstance::SetTransparent(bool aTransparent) {
-  mTransparent = aTransparent;
-  return NPERR_NO_ERROR;
-}
-
-NPError nsNPAPIPluginInstance::SetUsesDOMForCursor(bool aUsesDOMForCursor) {
-  mUsesDOMForCursor = aUsesDOMForCursor;
-  return NPERR_NO_ERROR;
-}
-
-bool nsNPAPIPluginInstance::UsesDOMForCursor() { return mUsesDOMForCursor; }
-
-void nsNPAPIPluginInstance::SetDrawingModel(NPDrawingModel aModel) {
-  mDrawingModel = aModel;
-}
-
-void nsNPAPIPluginInstance::RedrawPlugin() {}
-
-#if defined(XP_MACOSX)
-void nsNPAPIPluginInstance::SetEventModel(NPEventModel aModel) {}
-#endif
-
-nsresult nsNPAPIPluginInstance::GetDrawingModel(int32_t* aModel) {
-  *aModel = (int32_t)mDrawingModel;
-  return NS_OK;
-}
-
-nsresult nsNPAPIPluginInstance::IsRemoteDrawingCoreAnimation(bool* aDrawing) {
-  return NS_ERROR_FAILURE;
-}
-
-nsresult nsNPAPIPluginInstance::ContentsScaleFactorChanged(
-    double aContentsScaleFactor) {
-  return NS_ERROR_FAILURE;
-}
-
-nsresult nsNPAPIPluginInstance::CSSZoomFactorChanged(float aCSSZoomFactor) {
-  return NS_ERROR_FAILURE;
-}
-
-nsresult nsNPAPIPluginInstance::GetJSObject(JSContext* cx,
-                                            JSObject** outObject) {
-  return NS_ERROR_FAILURE;
-}
-
-void nsNPAPIPluginInstance::SetCached(bool aCache) { mCached = aCache; }
-
-bool nsNPAPIPluginInstance::ShouldCache() { return mCached; }
-
-nsresult nsNPAPIPluginInstance::IsWindowless(bool* isWindowless) {
-#if defined(XP_MACOSX)
-  // All OS X plugins are windowless.
-  *isWindowless = true;
-#else
-  *isWindowless = mWindowless;
-#endif
-  return NS_OK;
-}
-
-nsresult nsNPAPIPluginInstance::AsyncSetWindow(NPWindow* window) {
-  return NS_ERROR_FAILURE;
-}
-
-nsresult nsNPAPIPluginInstance::GetImageContainer(ImageContainer** aContainer) {
-  return NS_ERROR_FAILURE;
-}
-
-nsresult nsNPAPIPluginInstance::GetImageSize(nsIntSize* aSize) {
-  return NS_ERROR_FAILURE;
-}
-
-#if defined(XP_WIN)
-nsresult nsNPAPIPluginInstance::GetScrollCaptureContainer(
-    ImageContainer** aContainer) {
-  return NS_ERROR_FAILURE;
-}
-#endif
-
-nsresult nsNPAPIPluginInstance::HandledWindowedPluginKeyEvent(
-    const NativeEventData& aKeyEventData, bool aIsConsumed) {
-  if (NS_WARN_IF(!mPlugin)) {
-    return NS_ERROR_FAILURE;
-  }
-
-  PluginLibrary* library = mPlugin->GetLibrary();
-  if (NS_WARN_IF(!library)) {
-    return NS_ERROR_FAILURE;
-  }
-  return library->HandledWindowedPluginKeyEvent(&mNPP, aKeyEventData,
-                                                aIsConsumed);
-  return NS_ERROR_FAILURE;
-}
-
-void nsNPAPIPluginInstance::DidComposite() {}
-
-nsresult nsNPAPIPluginInstance::NotifyPainted(void) {
-  MOZ_ASSERT_UNREACHABLE("Dead code, shouldn't be called.");
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-nsresult nsNPAPIPluginInstance::GetIsOOP(bool* aIsAsync) {
-  return NS_ERROR_FAILURE;
-}
-
-nsresult nsNPAPIPluginInstance::SetBackgroundUnknown() {
-  return NS_ERROR_FAILURE;
-}
-
-nsresult nsNPAPIPluginInstance::BeginUpdateBackground(
-    nsIntRect* aRect, DrawTarget** aDrawTarget) {
-  return NS_ERROR_FAILURE;
-}
-
-nsresult nsNPAPIPluginInstance::EndUpdateBackground(nsIntRect* aRect) {
-  return NS_ERROR_FAILURE;
-}
-
-nsresult nsNPAPIPluginInstance::IsTransparent(bool* isTransparent) {
-  *isTransparent = mTransparent;
-  return NS_OK;
-}
-
-nsresult nsNPAPIPluginInstance::GetFormValue(nsAString& aValue) {
-  aValue.Truncate();
-
-  char* value = nullptr;
-  nsresult rv = GetValueFromPlugin(NPPVformValue, &value);
-  if (NS_FAILED(rv) || !value) return NS_ERROR_FAILURE;
-
-  CopyUTF8toUTF16(MakeStringSpan(value), aValue);
-
-  // NPPVformValue allocates with NPN_MemAlloc(), which uses
-  // nsMemory.
-  free(value);
-
-  return NS_OK;
-}
-
-nsresult nsNPAPIPluginInstance::PushPopupsEnabledState(bool aEnabled) {
-  nsCOMPtr<nsPIDOMWindowOuter> window = GetDOMWindow();
-  if (!window) return NS_ERROR_FAILURE;
-
-  PopupBlocker::PopupControlState oldState =
-      PopupBlocker::PushPopupControlState(
-          aEnabled ? PopupBlocker::openAllowed : PopupBlocker::openAbused,
-          true);
-
-  // XXX(Bug 1631371) Check if this should use a fallible operation as it
-  // pretended earlier.
-  mPopupStates.AppendElement(oldState);
-
-  return NS_OK;
-}
-
-nsresult nsNPAPIPluginInstance::PopPopupsEnabledState() {
-  if (mPopupStates.IsEmpty()) {
-    // Nothing to pop.
-    return NS_OK;
-  }
-
-  nsCOMPtr<nsPIDOMWindowOuter> window = GetDOMWindow();
-  if (!window) return NS_ERROR_FAILURE;
-
-  PopupBlocker::PopPopupControlState(mPopupStates.PopLastElement());
-
-  return NS_OK;
-}
-
-nsresult nsNPAPIPluginInstance::GetPluginAPIVersion(uint16_t* version) {
-  return NS_ERROR_FAILURE;
-}
-
-nsresult nsNPAPIPluginInstance::PrivateModeStateChanged(bool enabled) {
-  return NS_ERROR_FAILURE;
-}
-
-nsresult nsNPAPIPluginInstance::IsPrivateBrowsing(bool* aEnabled) {
-  return NS_ERROR_FAILURE;
-}
-
-static void PluginTimerCallback(nsITimer* aTimer, void* aClosure) {
-  nsNPAPITimer* t = (nsNPAPITimer*)aClosure;
-  NPP npp = t->npp;
-  uint32_t id = t->id;
-
-  PLUGIN_LOG(PLUGIN_LOG_NOISY,
-             ("nsNPAPIPluginInstance running plugin timer callback this=%p\n",
-              npp->ndata));
-
-  // Some plugins (Flash on Android) calls unscheduletimer
-  // from this callback.
-  t->inCallback = true;
-  (*(t->callback))(npp, id);
-  t->inCallback = false;
-
-  // Make sure we still have an instance and the timer is still alive
-  // after the callback.
-  nsNPAPIPluginInstance* inst = (nsNPAPIPluginInstance*)npp->ndata;
-  if (!inst || !inst->TimerWithID(id, nullptr)) return;
-
-  // use UnscheduleTimer to clean up if this is a one-shot timer
-  uint32_t timerType;
-  t->timer->GetType(&timerType);
-  if (t->needUnschedule || timerType == nsITimer::TYPE_ONE_SHOT)
-    inst->UnscheduleTimer(id);
-}
-
-nsNPAPITimer* nsNPAPIPluginInstance::TimerWithID(uint32_t id, uint32_t* index) {
-  uint32_t len = mTimers.Length();
-  for (uint32_t i = 0; i < len; i++) {
-    if (mTimers[i]->id == id) {
-      if (index) *index = i;
-      return mTimers[i];
-    }
-  }
-  return nullptr;
-}
-
-uint32_t nsNPAPIPluginInstance::ScheduleTimer(
-    uint32_t interval, NPBool repeat,
-    void (*timerFunc)(NPP npp, uint32_t timerID)) {
-  if (RUNNING != mRunning) return 0;
-
-  nsNPAPITimer* newTimer = new nsNPAPITimer();
-
-  newTimer->inCallback = newTimer->needUnschedule = false;
-  newTimer->npp = &mNPP;
-
-  // generate ID that is unique to this instance
-  uint32_t uniqueID = mTimers.Length();
-  while ((uniqueID == 0) || TimerWithID(uniqueID, nullptr)) uniqueID++;
-  newTimer->id = uniqueID;
-
-  // create new xpcom timer, scheduled correctly
-  nsresult rv;
-  const short timerType = (repeat ? (short)nsITimer::TYPE_REPEATING_SLACK
-                                  : (short)nsITimer::TYPE_ONE_SHOT);
-  rv = NS_NewTimerWithFuncCallback(
-      getter_AddRefs(newTimer->timer), PluginTimerCallback, newTimer, interval,
-      timerType, "nsNPAPIPluginInstance::ScheduleTimer");
-  if (NS_FAILED(rv)) {
-    delete newTimer;
-    return 0;
-  }
-
-  // save callback function
-  newTimer->callback = timerFunc;
-
-  // add timer to timers array
-  mTimers.AppendElement(newTimer);
-
-  return newTimer->id;
-}
-
-void nsNPAPIPluginInstance::UnscheduleTimer(uint32_t timerID) {
-  // find the timer struct by ID
-  uint32_t index;
-  nsNPAPITimer* t = TimerWithID(timerID, &index);
-  if (!t) return;
-
-  if (t->inCallback) {
-    t->needUnschedule = true;
-    return;
-  }
-
-  // cancel the timer
-  t->timer->Cancel();
-
-  // remove timer struct from array
-  mTimers.RemoveElementAt(index);
-
-  // delete timer
-  delete t;
-}
-
-NPBool nsNPAPIPluginInstance::ConvertPoint(double sourceX, double sourceY,
-                                           NPCoordinateSpace sourceSpace,
-                                           double* destX, double* destY,
-                                           NPCoordinateSpace destSpace) {
-  return false;
-}
-
-nsresult nsNPAPIPluginInstance::GetDOMElement(Element** result) {
-  return NS_ERROR_FAILURE;
-}
-
-nsresult nsNPAPIPluginInstance::InvalidateRect(NPRect* invalidRect) {
-  return NS_ERROR_FAILURE;
-}
-
-nsresult nsNPAPIPluginInstance::InvalidateRegion(NPRegion invalidRegion) {
-  return NS_ERROR_FAILURE;
-}
-
-nsresult nsNPAPIPluginInstance::GetMIMEType(const char** result) {
-  if (!mMIMEType)
-    *result = "";
-  else
-    *result = mMIMEType;
-
-  return NS_OK;
-}
-
-nsresult nsNPAPIPluginInstance::AsyncSetWindow(NPWindow& window) {
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-void nsNPAPIPluginInstance::URLRedirectResponse(void* notifyData,
-                                                NPBool allow) {}
-
-NPError nsNPAPIPluginInstance::InitAsyncSurface(NPSize* size,
-                                                NPImageFormat format,
-                                                void* initData,
-                                                NPAsyncSurface* surface) {
-  return NPERR_GENERIC_ERROR;
-}
-
-NPError nsNPAPIPluginInstance::FinalizeAsyncSurface(NPAsyncSurface* surface) {
-  return NPERR_GENERIC_ERROR;
-}
-
-void nsNPAPIPluginInstance::SetCurrentAsyncSurface(NPAsyncSurface* surface,
-                                                   NPRect* changed) {}
-
-double nsNPAPIPluginInstance::GetContentsScaleFactor() { return -1.0; }
-
-float nsNPAPIPluginInstance::GetCSSZoomFactor() { return -1.0f; }
-
-nsresult nsNPAPIPluginInstance::GetRunID(uint32_t* aRunID) {
-  return NS_ERROR_FAILURE;
-}
-
-nsresult nsNPAPIPluginInstance::CreateAudioChannelAgentIfNeeded() {
-  if (mAudioChannelAgent) {
-    return NS_OK;
-  }
-
-  mAudioChannelAgent = new AudioChannelAgent();
-
-  nsCOMPtr<nsPIDOMWindowOuter> window = GetDOMWindow();
-  if (NS_WARN_IF(!window)) {
-    return NS_ERROR_FAILURE;
-  }
-
-  nsresult rv = mAudioChannelAgent->Init(window->GetCurrentInnerWindow(), this);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return rv;
-  }
-  return NS_OK;
-}
-
-void nsNPAPIPluginInstance::NotifyStartedPlaying() {
-  nsresult rv = CreateAudioChannelAgentIfNeeded();
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return;
-  }
-
-  MOZ_ASSERT(mAudioChannelAgent);
-  rv = mAudioChannelAgent->NotifyStartedPlaying(
-      mIsMuted ? AudioChannelService::AudibleState::eNotAudible
-               : AudioChannelService::AudibleState::eAudible);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return;
-  }
-
-  mAudioChannelAgent->PullInitialUpdate();
-}
-
-void nsNPAPIPluginInstance::NotifyStoppedPlaying() {
-  MOZ_ASSERT(mAudioChannelAgent);
-  nsresult rv = mAudioChannelAgent->NotifyStoppedPlaying();
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return;
-  }
-}
-
-NS_IMETHODIMP
-nsNPAPIPluginInstance::WindowVolumeChanged(float aVolume, bool aMuted) {
-  MOZ_LOG(AudioChannelService::GetAudioChannelLog(), LogLevel::Debug,
-          ("nsNPAPIPluginInstance, WindowVolumeChanged, "
-           "this = %p, aVolume = %f, aMuted = %s\n",
-           this, aVolume, aMuted ? "true" : "false"));
-  // We just support mute/unmute
-  if (mWindowMuted != aMuted) {
-    mWindowMuted = aMuted;
-    return UpdateMutedIfNeeded();
-  }
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsNPAPIPluginInstance::WindowSuspendChanged(nsSuspendedTypes aSuspend) {
-  MOZ_LOG(AudioChannelService::GetAudioChannelLog(), LogLevel::Debug,
-          ("nsNPAPIPluginInstance, WindowSuspendChanged, "
-           "this = %p, aSuspend = %s\n",
-           this, SuspendTypeToStr(aSuspend)));
-  const bool isSuspended = aSuspend != nsISuspendedTypes::NONE_SUSPENDED;
-  if (mWindowSuspended != isSuspended) {
-    mWindowSuspended = isSuspended;
-    // It doesn't support suspending, so we just do something like mute/unmute.
-    return UpdateMutedIfNeeded();
-  }
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsNPAPIPluginInstance::WindowAudioCaptureChanged(bool aCapture) {
-  return NS_OK;
-}
-
-void nsNPAPIPluginInstance::NotifyAudibleStateChanged() const {
-  // This happens when global window destroyed, we would notify agent's callback
-  // to mute its volume, but the nsNSNPAPI had released the agent before that.
-  if (!mAudioChannelAgent) {
-    return;
-  }
-  AudioChannelService::AudibleState audibleState =
-      mIsMuted ? AudioChannelService::AudibleState::eNotAudible
-               : AudioChannelService::AudibleState::eAudible;
-  // Because we don't really support suspending nsNPAPI, so all audible changes
-  // come from changing its volume.
-  mAudioChannelAgent->NotifyStartedAudible(
-      audibleState, AudioChannelService::AudibleChangedReasons::eVolumeChanged);
-}
-
-nsresult nsNPAPIPluginInstance::UpdateMutedIfNeeded() {
-  const bool shouldMute = mWindowSuspended || mWindowMuted;
-  if (mIsMuted == shouldMute) {
-    return NS_OK;
-  }
-
-  mIsMuted = shouldMute;
-  NotifyAudibleStateChanged();
-  nsresult rv = SetMuted(mIsMuted);
-  NS_WARNING_ASSERTION(NS_SUCCEEDED(rv), "SetMuted failed");
-  return rv;
-}
-
-nsresult nsNPAPIPluginInstance::SetMuted(bool aIsMuted) {
-  return NS_ERROR_FAILURE;
-}
diff --git a/dom/plugins/base/nsNPAPIPluginInstance.h b/dom/plugins/base/nsNPAPIPluginInstance.h
deleted file mode 100644
index d12511246aa6b..0000000000000
--- a/dom/plugins/base/nsNPAPIPluginInstance.h
+++ /dev/null
@@ -1,295 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#ifndef nsNPAPIPluginInstance_h_
-#define nsNPAPIPluginInstance_h_
-
-#include "nsSize.h"
-#include "nsCOMPtr.h"
-#include "nsTArray.h"
-#include "nsPIDOMWindow.h"
-#include "nsITimer.h"
-#include "nsHashKeys.h"
-#include <prinrval.h>
-#include "js/TypeDecls.h"
-#include "AudioChannelAgent.h"
-#include "npapi.h"
-
-#include "mozilla/EventForwards.h"
-#include "mozilla/TimeStamp.h"
-#include "mozilla/RefPtr.h"
-#include "mozilla/WeakPtr.h"
-#include "mozilla/dom/PopupBlocker.h"
-
-class nsIOutputStream;
-
-namespace mozilla {
-namespace dom {
-class Element;
-}  // namespace dom
-namespace layers {
-class ImageContainer;
-}  // namespace layers
-}  // namespace mozilla
-
-#if defined(OS_WIN)
-const NPDrawingModel kDefaultDrawingModel = NPDrawingModelSyncWin;
-#elif defined(MOZ_X11)
-const NPDrawingModel kDefaultDrawingModel = NPDrawingModelSyncX;
-#elif defined(XP_MACOSX)
-#  ifndef NP_NO_QUICKDRAW
-const NPDrawingModel kDefaultDrawingModel =
-    NPDrawingModelQuickDraw;  // Not supported
-#  else
-const NPDrawingModel kDefaultDrawingModel = NPDrawingModelCoreGraphics;
-#  endif
-#else
-const NPDrawingModel kDefaultDrawingModel = static_cast<NPDrawingModel>(0);
-#endif
-
-#if defined(OS_WIN)
-static const DWORD NPAPI_INVALID_WPARAM = 0xffffffff;
-#endif
-
-/**
- * Used to indicate whether it's OK to reenter Gecko and repaint, flush frames,
- * run scripts, etc, during this plugin call.
- * When NS_PLUGIN_CALL_UNSAFE_TO_REENTER_GECKO is set, we try to avoid dangerous
- * Gecko activities when the plugin spins a nested event loop, on a best-effort
- * basis.
- */
-enum NSPluginCallReentry {
-  NS_PLUGIN_CALL_SAFE_TO_REENTER_GECKO,
-  NS_PLUGIN_CALL_UNSAFE_TO_REENTER_GECKO
-};
-
-class nsNPAPITimer {
- public:
-  NPP npp;
-  uint32_t id;
-  nsCOMPtr<nsITimer> timer;
-  void (*callback)(NPP npp, uint32_t timerID);
-  bool inCallback;
-  bool needUnschedule;
-};
-
-class nsNPAPIPluginInstance final : public nsIAudioChannelAgentCallback,
-                                    public mozilla::SupportsWeakPtr {
- public:
-  typedef mozilla::gfx::DrawTarget DrawTarget;
-
-  NS_DECL_THREADSAFE_ISUPPORTS
-  NS_DECL_NSIAUDIOCHANNELAGENTCALLBACK
-
-  nsresult Start();
-  nsresult Stop();
-  nsresult SetWindow(NPWindow* window);
-  nsresult NewStreamFromPlugin(const char* type, const char* target,
-                               nsIOutputStream** result);
-  nsresult Print(NPPrint* platformPrint);
-  nsresult HandleEvent(void* event, int16_t* result,
-                       NSPluginCallReentry aSafeToReenterGecko =
-                           NS_PLUGIN_CALL_UNSAFE_TO_REENTER_GECKO);
-  nsresult GetValueFromPlugin(NPPVariable variable, void* value);
-  nsresult GetDrawingModel(int32_t* aModel);
-  nsresult IsRemoteDrawingCoreAnimation(bool* aDrawing);
-  nsresult ContentsScaleFactorChanged(double aContentsScaleFactor);
-  nsresult CSSZoomFactorChanged(float aCSSZoomFactor);
-  nsresult GetJSObject(JSContext* cx, JSObject** outObject);
-  bool ShouldCache();
-  nsresult IsWindowless(bool* isWindowless);
-  nsresult AsyncSetWindow(NPWindow* window);
-  nsresult GetImageContainer(mozilla::layers::ImageContainer** aContainer);
-  nsresult GetImageSize(nsIntSize* aSize);
-  nsresult NotifyPainted(void);
-  nsresult GetIsOOP(bool* aIsOOP);
-  nsresult SetBackgroundUnknown();
-  nsresult BeginUpdateBackground(nsIntRect* aRect, DrawTarget** aContext);
-  nsresult EndUpdateBackground(nsIntRect* aRect);
-  nsresult IsTransparent(bool* isTransparent);
-  nsresult GetFormValue(nsAString& aValue);
-  nsresult PushPopupsEnabledState(bool aEnabled);
-  nsresult PopPopupsEnabledState();
-  nsresult GetPluginAPIVersion(uint16_t* version);
-  nsresult InvalidateRect(NPRect* invalidRect);
-  nsresult InvalidateRegion(NPRegion invalidRegion);
-  nsresult GetMIMEType(const char** result);
-#if defined(XP_WIN)
-  nsresult GetScrollCaptureContainer(
-      mozilla::layers::ImageContainer** aContainer);
-#endif
-  void DidComposite();
-
-  bool HasAudioChannelAgent() const { return !!mAudioChannelAgent; }
-
-  void NotifyStartedPlaying();
-  void NotifyStoppedPlaying();
-
-  nsresult SetMuted(bool aIsMuted);
-
-  nsresult GetNPP(NPP* aNPP);
-
-  NPError SetWindowless(bool aWindowless);
-
-  NPError SetTransparent(bool aTransparent);
-
-  NPError SetWantsAllNetworkStreams(bool aWantsAllNetworkStreams);
-
-  NPError SetUsesDOMForCursor(bool aUsesDOMForCursor);
-  bool UsesDOMForCursor();
-
-  void SetDrawingModel(NPDrawingModel aModel);
-  void RedrawPlugin();
-#ifdef XP_MACOSX
-  void SetEventModel(NPEventModel aModel);
-
-  void* GetCurrentEvent() { return mCurrentPluginEvent; }
-#endif
-
-  nsNPAPIPluginInstance();
-
-  // To be called when an instance becomes orphaned, when
-  // it's plugin is no longer guaranteed to be around.
-  void Destroy();
-
-  // Indicates whether the plugin is running normally.
-  bool IsRunning() { return RUNNING == mRunning; }
-  bool HasStartedDestroying() { return mRunning >= DESTROYING; }
-
-  // Indicates whether the plugin is running normally or being shut down
-  bool CanFireNotifications() {
-    return mRunning == RUNNING || mRunning == DESTROYING;
-  }
-
-  // return is only valid when the plugin is not running
-  mozilla::TimeStamp StopTime();
-
-  // cache this NPAPI plugin
-  void SetCached(bool aCache);
-
-  already_AddRefed<nsPIDOMWindowOuter> GetDOMWindow();
-
-  nsresult PrivateModeStateChanged(bool aEnabled);
-
-  nsresult IsPrivateBrowsing(bool* aEnabled);
-
-  nsresult GetDOMElement(mozilla::dom::Element** result);
-
-  nsNPAPITimer* TimerWithID(uint32_t id, uint32_t* index);
-  uint32_t ScheduleTimer(uint32_t interval, NPBool repeat,
-                         void (*timerFunc)(NPP npp, uint32_t timerID));
-  void UnscheduleTimer(uint32_t timerID);
-  NPBool ConvertPoint(double sourceX, double sourceY,
-                      NPCoordinateSpace sourceSpace, double* destX,
-                      double* destY, NPCoordinateSpace destSpace);
-
-  nsresult AsyncSetWindow(NPWindow& window);
-
-  void URLRedirectResponse(void* notifyData, NPBool allow);
-
-  NPError InitAsyncSurface(NPSize* size, NPImageFormat format, void* initData,
-                           NPAsyncSurface* surface);
-  NPError FinalizeAsyncSurface(NPAsyncSurface* surface);
-  void SetCurrentAsyncSurface(NPAsyncSurface* surface, NPRect* changed);
-
-  // Returns the contents scale factor of the screen the plugin is drawn on.
-  double GetContentsScaleFactor();
-
-  // Returns the css zoom factor of the document the plugin is drawn on.
-  float GetCSSZoomFactor();
-
-  nsresult GetRunID(uint32_t* aRunID);
-
-  static bool InPluginCallUnsafeForReentry() {
-    return gInUnsafePluginCalls > 0;
-  }
-  static void BeginPluginCall(NSPluginCallReentry aReentryState) {
-    if (aReentryState == NS_PLUGIN_CALL_UNSAFE_TO_REENTER_GECKO) {
-      ++gInUnsafePluginCalls;
-    }
-  }
-  static void EndPluginCall(NSPluginCallReentry aReentryState) {
-    if (aReentryState == NS_PLUGIN_CALL_UNSAFE_TO_REENTER_GECKO) {
-      NS_ASSERTION(gInUnsafePluginCalls > 0, "Must be in plugin call");
-      --gInUnsafePluginCalls;
-    }
-  }
-
- protected:
-  virtual ~nsNPAPIPluginInstance();
-
-  nsresult CreateAudioChannelAgentIfNeeded();
-
-  void NotifyAudibleStateChanged() const;
-
-  nsresult UpdateMutedIfNeeded();
-
-  // The structure used to communicate between the plugin instance and
-  // the browser.
-  NPP_t mNPP;
-
-  NPDrawingModel mDrawingModel;
-
-  enum { NOT_STARTED, RUNNING, DESTROYING, DESTROYED } mRunning;
-
-  // these are used to store the windowless properties
-  // which the browser will later query
-  bool mWindowless;
-  bool mTransparent;
-  bool mCached;
-  bool mUsesDOMForCursor;
-
- public:
-  // True while creating the plugin, or calling NPP_SetWindow() on it.
-  bool mInPluginInitCall;
-
- private:
-  nsTArray<mozilla::dom::PopupBlocker::PopupControlState> mPopupStates;
-
-  char* mMIMEType;
-
-  nsTArray<nsNPAPITimer*> mTimers;
-
-#ifdef XP_MACOSX
-  // non-null during a HandleEvent call
-  void* mCurrentPluginEvent;
-#endif
-
-  // Timestamp for the last time this plugin was stopped.
-  // This is only valid when the plugin is actually stopped!
-  mozilla::TimeStamp mStopTime;
-
-  static uint32_t gInUnsafePluginCalls;
-
-  // The arrays can only be released when the plugin instance is destroyed,
-  // because the plugin, in in-process mode, might keep a reference to them.
-  uint32_t mCachedParamLength;
-  char** mCachedParamNames;
-  char** mCachedParamValues;
-
-  RefPtr<mozilla::dom::AudioChannelAgent> mAudioChannelAgent;
-  bool mIsMuted = false;
-  bool mWindowMuted = false;
-  bool mWindowSuspended = false;
-};
-
-void NS_NotifyBeginPluginCall(NSPluginCallReentry aReentryState);
-void NS_NotifyPluginCall(NSPluginCallReentry aReentryState);
-
-#define NS_TRY_SAFE_CALL_RETURN(ret, fun, pluginInst, pluginCallReentry) \
-  PR_BEGIN_MACRO                                                         \
-  NS_NotifyBeginPluginCall(pluginCallReentry);                           \
-  ret = fun;                                                             \
-  NS_NotifyPluginCall(pluginCallReentry);                                \
-  PR_END_MACRO
-
-#define NS_TRY_SAFE_CALL_VOID(fun, pluginInst, pluginCallReentry) \
-  PR_BEGIN_MACRO                                                  \
-  NS_NotifyBeginPluginCall(pluginCallReentry);                    \
-  fun;                                                            \
-  NS_NotifyPluginCall(pluginCallReentry);                         \
-  PR_END_MACRO
-
-#endif  // nsNPAPIPluginInstance_h_
diff --git a/dom/plugins/base/nsPluginHost.cpp b/dom/plugins/base/nsPluginHost.cpp
index c72f3f84e050d..1c94e60002dce 100644
--- a/dom/plugins/base/nsPluginHost.cpp
+++ b/dom/plugins/base/nsPluginHost.cpp
@@ -7,299 +7,26 @@
 
 #include "nsPluginHost.h"
 
-#include <inttypes.h>
-#include <stdio.h>
-#include <string.h>
+#include "nscore.h"
+
 #include <cstdlib>
-#include <new>
-#include <utility>
-#include "ReferrerInfo.h"
-#include "js/RootingAPI.h"
-#include "mozilla/ArrayIterator.h"
-#include "mozilla/Assertions.h"
-#include "mozilla/ClearOnShutdown.h"
-#include "mozilla/DebugOnly.h"
-#include "mozilla/Logging.h"
-#include "mozilla/MacroForEach.h"
-#include "mozilla/NotNull.h"
-#include "mozilla/PluginLibrary.h"
+#include <stdio.h>
+#include "nsPluginLogging.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/ProfilerLabels.h"
-#include "mozilla/Services.h"
-#include "mozilla/SpinEventLoopUntil.h"
-#include "mozilla/StaticPtr.h"
-#include "mozilla/Telemetry.h"
-#include "mozilla/TelemetryHistogramEnums.h"
-#include "mozilla/TextUtils.h"
-#include "mozilla/TimeStamp.h"
-#include "mozilla/Unused.h"
-#include "mozilla/dom/BindingDeclarations.h"
-#include "mozilla/dom/ContentParent.h"
-#include "mozilla/dom/Document.h"
-#include "mozilla/dom/Element.h"
-#include "mozilla/dom/FakePluginTagInitBinding.h"
-#include "mozilla/dom/Promise.h"
-#include "mozilla/dom/PromiseNativeHandler.h"
-#include "mozilla/dom/ReferrerPolicyBinding.h"
-#include "mozilla/fallible.h"
-#include "mozilla/ipc/URIParams.h"
-#include "mozilla/ipc/URIUtils.h"
-#include "mozilla/mozalloc.h"
-#include "mozilla/plugins/PluginTypes.h"
-#include "npapi.h"
-#include "npfunctions.h"
-#include "nsComponentManagerUtils.h"
-#include "nsIAsyncShutdown.h"
 #include "nsIBlocklistService.h"
-#include "nsICategoryManager.h"
-#include "nsIChannel.h"
-#include "nsIContent.h"
-#include "nsIContentPolicy.h"
-#include "nsID.h"
-#include "nsIEffectiveTLDService.h"
-#include "nsIFile.h"
-#include "nsIHttpChannel.h"
-#include "nsIHttpProtocolHandler.h"
-#include "nsIIDNService.h"
-#include "nsIInputStream.h"
-#include "nsILoadInfo.h"
-#include "nsIObjectLoadingContent.h"
-#include "nsIObserverService.h"
-#include "nsIPluginInstanceOwner.h"
-#include "nsIPluginTag.h"
-#include "nsIPrefBranch.h"
-#include "nsIProtocolHandler.h"
-#include "nsIReferrerInfo.h"
-#include "nsIRequest.h"
-#include "nsIScriptChannel.h"
-#include "nsISeekableStream.h"
-#include "nsIStringStream.h"
-#include "nsISupportsUtils.h"
-#include "nsIURI.h"
-#include "nsIUploadChannel.h"
-#include "nsIWeakReference.h"
-#include "nsIWeakReferenceUtils.h"
-#include "nsIWritablePropertyBag2.h"
-#include "nsLiteralString.h"
-#include "nsNPAPIPlugin.h"
-#include "nsNPAPIPluginInstance.h"
-#include "nsNetCID.h"
-#include "nsNetUtil.h"
-#include "nsObjectLoadingContent.h"
-#include "nsPluginInstanceOwner.h"
-#include "nsPluginLogging.h"
-#include "nsPluginNativeWindow.h"
-#include "nsPluginTags.h"
-#include "nsServiceManagerUtils.h"
-#include "nsString.h"
-#include "nsStringFlags.h"
-#include "nsTArray.h"
-#include "nsTLiteralString.h"
-#include "nsTPromiseFlatString.h"
-#include "nsTStringRepr.h"
-#include "nsThreadUtils.h"
-#include "nsVersionComparator.h"
-#include "nsXPCOM.h"
-#include "nsXPCOMCID.h"
+#include "mozilla/ClearOnShutdown.h"
 #include "nsXULAppAPI.h"
-#include "nscore.h"
-#include "plstr.h"
-
-#if defined(XP_WIN)
-#  include "nsIWindowMediator.h"
-#  include "nsIBaseWindow.h"
-#  include <windows.h>
-#  include <winbase.h>
-#endif
-#if (MOZ_WIDGET_GTK)
-#  include "mozilla/WidgetUtilsGtk.h"
-#endif
 
 using namespace mozilla;
-using mozilla::TimeStamp;
-using mozilla::dom::Document;
-using mozilla::dom::FakePluginMimeEntry;
-using mozilla::dom::FakePluginTagInit;
-using mozilla::dom::Promise;
-
-// Null out a strong ref to a linked list iteratively to avoid
-// exhausting the stack (bug 486349).
-#define NS_ITERATIVE_UNREF_LIST(type_, list_, mNext_) \
-  {                                                   \
-    while (list_) {                                   \
-      type_ temp = list_->mNext_;                     \
-      list_->mNext_ = nullptr;                        \
-      list_ = temp;                                   \
-    }                                                 \
-  }
-
-static const char* kPrefDisableFullPage =
-    "plugin.disable_full_page_plugin_for_types";
 
 LazyLogModule nsPluginLogging::gNPNLog(NPN_LOG_NAME);
 LazyLogModule nsPluginLogging::gNPPLog(NPP_LOG_NAME);
 LazyLogModule nsPluginLogging::gPluginLog(PLUGIN_LOG_NAME);
 
-// #defines for plugin cache and prefs
-#define NS_PREF_MAX_NUM_CACHED_INSTANCES \
-  "browser.plugins.max_num_cached_plugins"
-// Raise this from '10' to '50' to work around a bug in Apple's current Java
-// plugins on OS X Lion and SnowLeopard.  See bug 705931.
-#define DEFAULT_NUMBER_OF_STOPPED_INSTANCES 50
-
-nsIFile* nsPluginHost::sPluginTempDir;
 StaticRefPtr<nsPluginHost> nsPluginHost::sInst;
 
-// Helper to check for a MIME in a comma-delimited preference
-static bool IsTypeInList(const nsCString& aMimeType, nsCString aTypeList) {
-  nsAutoCString searchStr;
-  searchStr.Assign(',');
-  searchStr.Append(aTypeList);
-  searchStr.Append(',');
-
-  nsACString::const_iterator start, end;
-
-  searchStr.BeginReading(start);
-  searchStr.EndReading(end);
-
-  nsAutoCString commaSeparated;
-  commaSeparated.Assign(',');
-  commaSeparated += aMimeType;
-  commaSeparated.Append(',');
-
-  // Lower-case the search string and MIME type to properly handle a mixed-case
-  // type, as MIME types are case insensitive.
-  ToLowerCase(searchStr);
-  ToLowerCase(commaSeparated);
-
-  return FindInReadable(commaSeparated, start, end);
-}
-
-namespace mozilla::plugins {
-class BlocklistPromiseHandler final
-    : public mozilla::dom::PromiseNativeHandler {
- public:
-  NS_DECL_ISUPPORTS
-
-  BlocklistPromiseHandler(nsPluginTag* aTag, const bool aShouldSoftblock)
-      : mTag(aTag), mShouldDisableWhenSoftblocked(aShouldSoftblock) {
-    MOZ_ASSERT(mTag, "Should always be passed a plugin tag");
-    sPendingBlocklistStateRequests++;
-  }
-
-  void MaybeWriteBlocklistChanges() {
-    // We're called immediately when the promise resolves/rejects, and (as a
-    // backup) when the handler is destroyed. To ensure we only run once, we use
-    // mTag as a sentinel, setting it to nullptr when we run.
-    if (!mTag) {
-      return;
-    }
-    mTag = nullptr;
-    sPendingBlocklistStateRequests--;
-    // If this was the only remaining pending request, check if we need to write
-    // state and if so update the child processes.
-    if (!sPendingBlocklistStateRequests) {
-      if (sPluginBlocklistStatesChangedSinceLastWrite) {
-        sPluginBlocklistStatesChangedSinceLastWrite = false;
-
-        RefPtr<nsPluginHost> host = nsPluginHost::GetInst();
-        // We update blocklist info in content processes asynchronously
-        // by just sending a new plugin list to content.
-        host->IncrementChromeEpoch();
-        host->BroadcastPluginsToContent();
-      }
-
-      // Now notify observers that we're done updating plugin state.
-      nsCOMPtr<nsIObserverService> obsService =
-          mozilla::services::GetObserverService();
-      if (obsService) {
-        obsService->NotifyObservers(
-            nullptr, "plugin-blocklist-updates-finished", nullptr);
-      }
-    }
-  }
-
-  void ResolvedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue) override {
-    if (!aValue.isInt32()) {
-      MOZ_ASSERT(false, "Blocklist should always return int32");
-      return;
-    }
-    int32_t newState = aValue.toInt32();
-    MOZ_ASSERT(newState >= 0 && newState < nsIBlocklistService::STATE_MAX,
-               "Shouldn't get an out of bounds blocklist state");
-
-    // Check the old and new state and see if there was a change:
-    uint32_t oldState = mTag->GetBlocklistState();
-    bool changed = oldState != (uint32_t)newState;
-    mTag->SetBlocklistState(newState);
-
-    if (newState == nsIBlocklistService::STATE_SOFTBLOCKED &&
-        mShouldDisableWhenSoftblocked) {
-      mTag->SetEnabledState(nsIPluginTag::STATE_DISABLED);
-      changed = true;
-    }
-    sPluginBlocklistStatesChangedSinceLastWrite |= changed;
-
-    MaybeWriteBlocklistChanges();
-  }
-  void RejectedCallback(JSContext* aCx, JS::Handle<JS::Value> aValue) override {
-    MOZ_ASSERT(false, "Shouldn't reject plugin blocklist state request");
-    MaybeWriteBlocklistChanges();
-  }
-
- private:
-  ~BlocklistPromiseHandler() {
-    // If we have multiple plugins and the last pending request is GC'd
-    // and so never resolves/rejects, ensure we still write the blocklist.
-    MaybeWriteBlocklistChanges();
-  }
-
-  RefPtr<nsPluginTag> mTag;
-  bool mShouldDisableWhenSoftblocked;
-
-  // Whether we changed any of the plugins' blocklist states since
-  // we last started fetching them (async). This is reset to false
-  // every time we finish fetching plugin blocklist information.
-  // When this happens, if the previous value was true, we store the
-  // updated list on disk and send it to child processes.
-  static bool sPluginBlocklistStatesChangedSinceLastWrite;
-  // How many pending blocklist state requests we've got
-  static uint32_t sPendingBlocklistStateRequests;
-};
-
-NS_IMPL_ISUPPORTS0(BlocklistPromiseHandler)
-
-bool BlocklistPromiseHandler::sPluginBlocklistStatesChangedSinceLastWrite =
-    false;
-uint32_t BlocklistPromiseHandler::sPendingBlocklistStateRequests = 0;
-}  // namespace mozilla::plugins
-
-nsPluginHost::nsPluginHost()
-    : mPluginsLoaded(false),
-      mOverrideInternalTypes(false),
-      mPluginsDisabled(false),
-      mPluginEpoch(0) {
-  // check to see if pref is set at startup to let plugins take over in
-  // full page mode for certain image mime types that we handle internally
-  mOverrideInternalTypes =
-      Preferences::GetBool("plugin.override_internal_types", false);
-
-  bool waylandBackend = false;
-#if defined(MOZ_WIDGET_GTK)
-  waylandBackend = mozilla::widget::GdkIsWaylandDisplay();
-#endif
-  mPluginsDisabled =
-      Preferences::GetBool("plugin.disable", false) || waylandBackend;
-  if (!waylandBackend) {
-    Preferences::AddStrongObserver(this, "plugin.disable");
-  }
-
-  nsCOMPtr<nsIObserverService> obsService =
-      mozilla::services::GetObserverService();
-  if (obsService) {
-    obsService->AddObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID, false);
-  }
-
+nsPluginHost::nsPluginHost() : mPluginEpoch(0) {
 #ifdef PLUGIN_LOGGING
   MOZ_LOG(nsPluginLogging::gNPNLog, PLUGIN_LOG_ALWAYS,
           ("NPN Logging Active!\n"));
@@ -311,31 +38,21 @@ nsPluginHost::nsPluginHost()
   PLUGIN_LOG(PLUGIN_LOG_ALWAYS, ("nsPluginHost::ctor\n"));
   PR_LogFlush();
 #endif
-  // We need to ensure that plugin tag sandbox info is available. This needs to
-  // be done from the main thread:
-  nsPluginTag::EnsureSandboxInformation();
 
   // Load plugins on creation, as there's a good chance we'll need to send them
   // to content processes directly after creation.
   if (XRE_IsParentProcess()) {
     // Always increment the chrome epoch when we bring up the nsPluginHost in
-    // the parent process. If the only plugins we have are cached in
-    // pluginreg.dat, we won't see any plugin changes in LoadPlugins and the
-    // epoch will stay the same between the parent and child process, meaning
-    // plugins will never update in the child process.
+    // the parent process.
     IncrementChromeEpoch();
-    LoadPlugins();
   }
 }
 
 nsPluginHost::~nsPluginHost() {
   PLUGIN_LOG(PLUGIN_LOG_ALWAYS, ("nsPluginHost::dtor\n"));
-
-  UnloadPlugins();
 }
 
-NS_IMPL_ISUPPORTS(nsPluginHost, nsIObserver, nsITimerCallback,
-                  nsISupportsWeakReference, nsINamed)
+NS_IMPL_ISUPPORTS(nsPluginHost, nsISupportsWeakReference)
 
 already_AddRefed<nsPluginHost> nsPluginHost::GetInst() {
   if (!sInst) {
@@ -346,141 +63,6 @@ already_AddRefed<nsPluginHost> nsPluginHost::GetInst() {
   return do_AddRef(sInst);
 }
 
-bool nsPluginHost::IsRunningPlugin(nsPluginTag* aPluginTag) { return false; }
-
-nsresult nsPluginHost::ReloadPlugins() {
-  PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsPluginHost::ReloadPlugins\n"));
-  return NS_ERROR_PLUGINS_PLUGINSNOTCHANGED;
-}
-
-void nsPluginHost::ClearNonRunningPlugins() {
-  // shutdown plugins and kill the list if there are no running plugins
-  RefPtr<nsPluginTag> prev;
-  RefPtr<nsPluginTag> next;
-
-  for (RefPtr<nsPluginTag> p = mPlugins; p != nullptr;) {
-    next = p->mNext;
-
-    // only remove our plugin from the list if it's not running.
-    if (!IsRunningPlugin(p)) {
-      if (p == mPlugins)
-        mPlugins = next;
-      else
-        prev->mNext = next;
-
-      p->mNext = nullptr;
-
-      // attempt to unload plugins whenever they are removed from the list
-      p->TryUnloadPlugin(false);
-
-      p = next;
-      continue;
-    }
-
-    prev = p;
-    p = next;
-  }
-}
-
-nsresult nsPluginHost::ActuallyReloadPlugins() {
-  nsresult rv = NS_OK;
-  ClearNonRunningPlugins();
-
-  // set flags
-  mPluginsLoaded = false;
-
-  // load them again
-  rv = LoadPlugins();
-
-  if (XRE_IsParentProcess()) {
-    // If the plugin list changed, update content. If the plugin list changed
-    // for the content process, it will also reload plugins.
-    BroadcastPluginsToContent();
-  }
-
-  PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsPluginHost::ReloadPlugins End\n"));
-
-  return rv;
-}
-
-#define NS_RETURN_UASTRING_SIZE 128
-
-nsresult nsPluginHost::UserAgent(const char** retstring) {
-  static char resultString[NS_RETURN_UASTRING_SIZE];
-  nsresult res;
-
-  nsCOMPtr<nsIHttpProtocolHandler> http =
-      do_GetService(NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX "http", &res);
-  if (NS_FAILED(res)) return res;
-
-  nsAutoCString uaString;
-  res = http->GetUserAgent(uaString);
-
-  if (NS_SUCCEEDED(res)) {
-    if (NS_RETURN_UASTRING_SIZE > uaString.Length()) {
-      PL_strcpy(resultString, uaString.get());
-    } else {
-      // Copy as much of UA string as we can (terminate at right-most space).
-      PL_strncpy(resultString, uaString.get(), NS_RETURN_UASTRING_SIZE);
-      for (int i = NS_RETURN_UASTRING_SIZE - 1; i >= 0; i--) {
-        if (i == 0) {
-          resultString[NS_RETURN_UASTRING_SIZE - 1] = '\0';
-        } else if (resultString[i] == ' ') {
-          resultString[i] = '\0';
-          break;
-        }
-      }
-    }
-    *retstring = resultString;
-  } else {
-    *retstring = nullptr;
-  }
-
-  PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-             ("nsPluginHost::UserAgent return=%s\n", *retstring));
-
-  return res;
-}
-
-nsresult nsPluginHost::UnloadPlugins() {
-  PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsPluginHost::UnloadPlugins Called\n"));
-
-  if (!mPluginsLoaded) return NS_OK;
-
-  // we should call nsIPluginInstance::Stop and nsIPluginInstance::SetWindow
-  // for those plugins who want it
-  DestroyRunningInstances(nullptr);
-
-  nsPluginTag* pluginTag;
-  for (pluginTag = mPlugins; pluginTag; pluginTag = pluginTag->mNext) {
-    pluginTag->TryUnloadPlugin(true);
-  }
-
-  NS_ITERATIVE_UNREF_LIST(RefPtr<nsPluginTag>, mPlugins, mNext);
-
-  // Lets remove any of the temporary files that we created.
-  if (sPluginTempDir) {
-    sPluginTempDir->Remove(true);
-    NS_RELEASE(sPluginTempDir);
-  }
-
-  mPluginsLoaded = false;
-
-  return NS_OK;
-}
-
-void nsPluginHost::OnPluginInstanceDestroyed(nsPluginTag* aPluginTag) {}
-
-nsPluginTag* nsPluginHost::FindTagForLibrary(PRLibrary* aLibrary) {
-  nsPluginTag* pluginTag;
-  for (pluginTag = mPlugins; pluginTag; pluginTag = pluginTag->mNext) {
-    if (pluginTag->mLibrary == aLibrary) {
-      return pluginTag;
-    }
-  }
-  return nullptr;
-}
-
 bool nsPluginHost::HavePluginForType(const nsACString& aMimeType,
                                      PluginFilter aFilter) {
   bool checkEnabled = aFilter & eExcludeDisabled;
@@ -491,13 +73,10 @@ bool nsPluginHost::HavePluginForType(const nsACString& aMimeType,
 nsIInternalPluginTag* nsPluginHost::FindPluginForType(
     const nsACString& aMimeType, bool aIncludeFake, bool aCheckEnabled) {
   if (aIncludeFake) {
-    nsFakePluginTag* fakeTag = FindFakePluginForType(aMimeType, aCheckEnabled);
-    if (fakeTag) {
-      return fakeTag;
-    }
+    return FindFakePluginForType(aMimeType, aCheckEnabled);
   }
 
-  return FindNativePluginForType(aMimeType, aCheckEnabled);
+  return nullptr;
 }
 
 NS_IMETHODIMP
@@ -545,94 +124,6 @@ nsPluginHost::GetPermissionStringForTag(nsIPluginTag* aTag,
   return NS_OK;
 }
 
-bool nsPluginHost::HavePluginForExtension(const nsACString& aExtension,
-                                          /* out */ nsACString& aMimeType,
-                                          PluginFilter aFilter) {
-  // As of FF 52, we only support flash and test plugins, so if the extension
-  // types don't match for that, exit before we start loading plugins.
-  //
-  // XXX: Remove tst case when bug 1351885 lands.
-  if (!aExtension.LowerCaseEqualsLiteral("swf") &&
-      !aExtension.LowerCaseEqualsLiteral("tst")) {
-    return false;
-  }
-
-  bool checkEnabled = aFilter & eExcludeDisabled;
-  bool allowFake = !(aFilter & eExcludeFake);
-  return FindNativePluginForExtension(aExtension, aMimeType, checkEnabled) ||
-         (allowFake &&
-          FindFakePluginForExtension(aExtension, aMimeType, checkEnabled));
-}
-
-void nsPluginHost::GetPlugins(
-    nsTArray<nsCOMPtr<nsIInternalPluginTag>>& aPluginArray,
-    bool aIncludeDisabled) {
-  aPluginArray.Clear();
-
-  LoadPlugins();
-
-  // Append fake plugins, then normal plugins.
-
-  uint32_t numFake = mFakePlugins.Length();
-  for (uint32_t i = 0; i < numFake; i++) {
-    aPluginArray.AppendElement(mFakePlugins[i]);
-  }
-
-  // Regular plugins
-  nsPluginTag* plugin = mPlugins;
-  while (plugin != nullptr) {
-    if (plugin->IsEnabled() || aIncludeDisabled) {
-      aPluginArray.AppendElement(plugin);
-    }
-    plugin = plugin->mNext;
-  }
-}
-
-nsPluginTag* nsPluginHost::FindPreferredPlugin(
-    const nsTArray<nsPluginTag*>& matches) {
-  // We prefer the plugin with the highest version number.
-  /// XXX(johns): This seems to assume the only time multiple plugins will have
-  ///             the same MIME type is if they're multiple versions of the same
-  ///             plugin -- but since plugin filenames and pretty names can both
-  ///             update, it's probably less arbitrary than just going at it
-  ///             alphabetically.
-
-  if (matches.IsEmpty()) {
-    return nullptr;
-  }
-
-  nsPluginTag* preferredPlugin = matches[0];
-  for (unsigned int i = 1; i < matches.Length(); i++) {
-    if (mozilla::Version(matches[i]->Version().get()) >
-        preferredPlugin->Version().get()) {
-      preferredPlugin = matches[i];
-    }
-  }
-
-  return preferredPlugin;
-}
-
-nsFakePluginTag* nsPluginHost::FindFakePluginForExtension(
-    const nsACString& aExtension,
-    /* out */ nsACString& aMimeType, bool aCheckEnabled) {
-  if (aExtension.IsEmpty()) {
-    return nullptr;
-  }
-
-  int32_t numFakePlugins = mFakePlugins.Length();
-  for (int32_t i = 0; i < numFakePlugins; i++) {
-    nsFakePluginTag* plugin = mFakePlugins[i];
-    bool active;
-    if ((!aCheckEnabled ||
-         (NS_SUCCEEDED(plugin->GetActive(&active)) && active)) &&
-        plugin->HasExtension(aExtension, aMimeType)) {
-      return plugin;
-    }
-  }
-
-  return nullptr;
-}
-
 nsFakePluginTag* nsPluginHost::FindFakePluginForType(
     const nsACString& aMimeType, bool aCheckEnabled) {
   int32_t numFakePlugins = mFakePlugins.Length();
@@ -649,204 +140,8 @@ nsFakePluginTag* nsPluginHost::FindFakePluginForType(
   return nullptr;
 }
 
-nsPluginTag* nsPluginHost::FindNativePluginForType(const nsACString& aMimeType,
-                                                   bool aCheckEnabled) {
-  if (aMimeType.IsEmpty()) {
-    return nullptr;
-  }
-
-  // As of FF 52, we only support flash and test plugins, so if the mime types
-  // don't match for that, exit before we start loading plugins.
-  if (!nsPluginHost::CanUsePluginForMIMEType(aMimeType)) {
-    return nullptr;
-  }
-
-  LoadPlugins();
-
-  nsTArray<nsPluginTag*> matchingPlugins;
-
-  nsPluginTag* plugin = mPlugins;
-  while (plugin) {
-    if ((!aCheckEnabled || plugin->IsActive()) &&
-        plugin->HasMimeType(aMimeType)) {
-      matchingPlugins.AppendElement(plugin);
-    }
-    plugin = plugin->mNext;
-  }
-
-  return FindPreferredPlugin(matchingPlugins);
-}
-
-nsPluginTag* nsPluginHost::FindNativePluginForExtension(
-    const nsACString& aExtension,
-    /* out */ nsACString& aMimeType, bool aCheckEnabled) {
-  if (aExtension.IsEmpty()) {
-    return nullptr;
-  }
-
-  LoadPlugins();
-
-  nsTArray<nsPluginTag*> matchingPlugins;
-  nsCString matchingMime;  // Don't mutate aMimeType unless returning a match
-  nsPluginTag* plugin = mPlugins;
-
-  while (plugin) {
-    if (!aCheckEnabled || plugin->IsActive()) {
-      if (plugin->HasExtension(aExtension, matchingMime)) {
-        matchingPlugins.AppendElement(plugin);
-      }
-    }
-    plugin = plugin->mNext;
-  }
-
-  nsPluginTag* preferredPlugin = FindPreferredPlugin(matchingPlugins);
-  if (!preferredPlugin) {
-    return nullptr;
-  }
-
-  // Re-fetch the matching type because of how FindPreferredPlugin works...
-  preferredPlugin->HasExtension(aExtension, aMimeType);
-  return preferredPlugin;
-}
-
-nsresult nsPluginHost::EnsurePluginLoaded(nsPluginTag* aPluginTag) {
-  return NS_ERROR_FAILURE;
-}
-
-class nsPluginUnloadRunnable : public Runnable {
- public:
-  explicit nsPluginUnloadRunnable(uint32_t aPluginId)
-      : Runnable("nsPluginUnloadRunnable"), mPluginId(aPluginId) {}
-
-  NS_IMETHOD Run() override {
-    RefPtr<nsPluginHost> host = nsPluginHost::GetInst();
-    if (!host) {
-      return NS_OK;
-    }
-    nsPluginTag* pluginTag = host->PluginWithId(mPluginId);
-    if (!pluginTag) {
-      return NS_OK;
-    }
-
-    MOZ_ASSERT(pluginTag->mContentProcessRunningCount > 0);
-    pluginTag->mContentProcessRunningCount--;
-
-    if (!pluginTag->mContentProcessRunningCount) {
-      if (!host->IsRunningPlugin(pluginTag)) {
-        pluginTag->TryUnloadPlugin(false);
-      }
-    }
-    return NS_OK;
-  }
-
- protected:
-  uint32_t mPluginId;
-};
-
-void nsPluginHost::NotifyContentModuleDestroyed(uint32_t aPluginId) {
-  MOZ_ASSERT(XRE_IsParentProcess());
-
-  // This is called in response to a message from the plugin. Don't unload the
-  // plugin until the message handler is off the stack.
-  RefPtr<nsPluginUnloadRunnable> runnable =
-      new nsPluginUnloadRunnable(aPluginId);
-  NS_DispatchToMainThread(runnable);
-}
-
-// Normalize 'host' to ACE.
-nsresult nsPluginHost::NormalizeHostname(nsCString& host) {
-  if (IsAscii(host)) {
-    ToLowerCase(host);
-    return NS_OK;
-  }
-
-  if (!mIDNService) {
-    nsresult rv;
-    mIDNService = do_GetService(NS_IDNSERVICE_CONTRACTID, &rv);
-    NS_ENSURE_SUCCESS(rv, rv);
-  }
-
-  return mIDNService->ConvertUTF8toACE(host, host);
-}
-
-// Enumerate a 'sites' array returned by GetSitesWithData and determine if
-// any of them have a base domain in common with 'domain'; if so, append them
-// to the 'result' array. If 'firstMatchOnly' is true, return after finding the
-// first match.
-nsresult nsPluginHost::EnumerateSiteData(const nsACString& domain,
-                                         const nsTArray<nsCString>& sites,
-                                         nsTArray<nsCString>& result,
-                                         bool firstMatchOnly) {
-  NS_ASSERTION(!domain.IsVoid(), "null domain string");
-
-  nsresult rv;
-  if (!mTLDService) {
-    mTLDService = do_GetService(NS_EFFECTIVETLDSERVICE_CONTRACTID, &rv);
-    NS_ENSURE_SUCCESS(rv, rv);
-  }
-
-  // Get the base domain from the domain.
-  nsCString baseDomain;
-  rv = mTLDService->GetBaseDomainFromHost(domain, 0, baseDomain);
-  bool isIP = rv == NS_ERROR_HOST_IS_IP_ADDRESS;
-  if (isIP || rv == NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS) {
-    // The base domain is the site itself. However, we must be careful to
-    // normalize.
-    baseDomain = domain;
-    rv = NormalizeHostname(baseDomain);
-    NS_ENSURE_SUCCESS(rv, rv);
-  } else if (NS_FAILED(rv)) {
-    return rv;
-  }
-
-  // Enumerate the array of sites with data.
-  for (uint32_t i = 0; i < sites.Length(); ++i) {
-    const nsCString& site = sites[i];
-
-    // Check if the site is an IP address.
-    bool siteIsIP =
-        site.Length() >= 2 && site.First() == '[' && site.Last() == ']';
-    if (siteIsIP != isIP) continue;
-
-    nsCString siteBaseDomain;
-    if (siteIsIP) {
-      // Strip the '[]'.
-      siteBaseDomain = Substring(site, 1, site.Length() - 2);
-    } else {
-      // Determine the base domain of the site.
-      rv = mTLDService->GetBaseDomainFromHost(site, 0, siteBaseDomain);
-      if (rv == NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS) {
-        // The base domain is the site itself. However, we must be careful to
-        // normalize.
-        siteBaseDomain = site;
-        rv = NormalizeHostname(siteBaseDomain);
-        NS_ENSURE_SUCCESS(rv, rv);
-      } else if (NS_FAILED(rv)) {
-        return rv;
-      }
-    }
-
-    // At this point, we can do an exact comparison of the two domains.
-    if (baseDomain != siteBaseDomain) {
-      continue;
-    }
-
-    // Append the site to the result array.
-    result.AppendElement(site);
-
-    // If we're supposed to return early, do so.
-    if (firstMatchOnly) {
-      break;
-    }
-  }
-
-  return NS_OK;
-}
-
 static bool MimeTypeIsAllowedForFakePlugin(const nsString& aMimeType) {
   static const char* const allowedFakePlugins[] = {
-      // Flash
-      "application/x-shockwave-flash",
       // PDF
       "application/pdf",
       "application/vnd.adobe.pdf",
@@ -890,51 +185,9 @@ bool nsPluginHost::IsLiveTag(nsIPluginTag* aPluginTag) {
       return true;
     }
   }
-
-  nsPluginTag* tag;
-  for (tag = mPlugins; tag; tag = tag->mNext) {
-    if (tag == internalTag) {
-      return true;
-    }
-  }
   return false;
 }
 
-// FIXME-jsplugins what should happen with jsplugins here, if anything?
-nsPluginTag* nsPluginHost::HaveSamePlugin(const nsPluginTag* aPluginTag) {
-  for (nsPluginTag* tag = mPlugins; tag; tag = tag->mNext) {
-    if (tag->HasSameNameAndMimes(aPluginTag)) {
-      return tag;
-    }
-  }
-  return nullptr;
-}
-
-nsPluginTag* nsPluginHost::PluginWithId(uint32_t aId) {
-  for (nsPluginTag* tag = mPlugins; tag; tag = tag->mNext) {
-    if (tag->mId == aId) {
-      return tag;
-    }
-  }
-  return nullptr;
-}
-
-void nsPluginHost::AddPluginTag(nsPluginTag* aPluginTag) {
-  aPluginTag->mNext = mPlugins;
-  mPlugins = aPluginTag;
-
-  if (aPluginTag->IsActive()) {
-    nsAutoCString disableFullPage;
-    Preferences::GetCString(kPrefDisableFullPage, disableFullPage);
-    for (uint32_t i = 0; i < aPluginTag->MimeTypes().Length(); i++) {
-      if (!IsTypeInList(aPluginTag->MimeTypes()[i], disableFullPage)) {
-        RegisterWithCategoryManager(aPluginTag->MimeTypes()[i],
-                                    ePluginRegister);
-      }
-    }
-  }
-}
-
 void nsPluginHost::IncrementChromeEpoch() {
   MOZ_ASSERT(XRE_IsParentProcess());
   mPluginEpoch++;
@@ -955,469 +208,10 @@ void nsPluginHost::SetChromeEpochForContent(uint32_t aEpoch) {
   mPluginEpoch = aEpoch;
 }
 
-already_AddRefed<nsIAsyncShutdownClient> GetProfileChangeTeardownPhase() {
-  nsCOMPtr<nsIAsyncShutdownService> asyncShutdownSvc =
-      services::GetAsyncShutdownService();
-  MOZ_ASSERT(asyncShutdownSvc);
-  if (NS_WARN_IF(!asyncShutdownSvc)) {
-    return nullptr;
-  }
-
-  nsCOMPtr<nsIAsyncShutdownClient> shutdownPhase;
-  DebugOnly<nsresult> rv =
-      asyncShutdownSvc->GetProfileChangeTeardown(getter_AddRefs(shutdownPhase));
-  MOZ_ASSERT(NS_SUCCEEDED(rv));
-  return shutdownPhase.forget();
-}
-
-nsresult nsPluginHost::LoadPlugins() { return NS_OK; }
-
-void nsPluginHost::FindingFinished() {}
-
-nsresult nsPluginHost::UpdateCachedSerializablePluginList() {
-  return NS_ERROR_FAILURE;
-}
-
-nsresult nsPluginHost::BroadcastPluginsToContent() { return NS_ERROR_FAILURE; }
-
-nsresult nsPluginHost::SendPluginsToContent(dom::ContentParent* parent) {
-  return NS_ERROR_FAILURE;
-}
-
-void nsPluginHost::UpdateInMemoryPluginInfo(nsPluginTag* aPluginTag) {
-  if (!aPluginTag) {
-    return;
-  }
-
-  // Update types with category manager
-  nsAutoCString disableFullPage;
-  Preferences::GetCString(kPrefDisableFullPage, disableFullPage);
-  for (uint32_t i = 0; i < aPluginTag->MimeTypes().Length(); i++) {
-    nsRegisterType shouldRegister;
-
-    if (IsTypeInList(aPluginTag->MimeTypes()[i], disableFullPage)) {
-      shouldRegister = ePluginUnregister;
-    } else {
-      nsPluginTag* plugin =
-          FindNativePluginForType(aPluginTag->MimeTypes()[i], true);
-      shouldRegister = plugin ? ePluginRegister : ePluginUnregister;
-    }
-
-    RegisterWithCategoryManager(aPluginTag->MimeTypes()[i], shouldRegister);
-  }
-
-  nsCOMPtr<nsIObserverService> obsService =
-      mozilla::services::GetObserverService();
-  if (obsService)
-    obsService->NotifyObservers(nullptr, "plugin-info-updated", nullptr);
-}
-
-// This function is not relevant for fake plugins.
-void nsPluginHost::UpdatePluginInfo(nsPluginTag* aPluginTag) {
-  MOZ_ASSERT(XRE_IsParentProcess());
-
-  IncrementChromeEpoch();
-
-  UpdateInMemoryPluginInfo(aPluginTag);
-}
-
-void nsPluginHost::RegisterWithCategoryManager(const nsCString& aMimeType,
-                                               nsRegisterType aType) {
-  PLUGIN_LOG(
-      PLUGIN_LOG_NORMAL,
-      ("nsPluginTag::RegisterWithCategoryManager type = %s, removing = %s\n",
-       aMimeType.get(), aType == ePluginUnregister ? "yes" : "no"));
-
-  nsCOMPtr<nsICategoryManager> catMan =
-      do_GetService(NS_CATEGORYMANAGER_CONTRACTID);
-  if (!catMan) {
-    return;
-  }
-
-  constexpr auto contractId =
-      "@mozilla.org/content/plugin/document-loader-factory;1"_ns;
-
-  if (aType == ePluginRegister) {
-    catMan->AddCategoryEntry("Gecko-Content-Viewers", aMimeType, contractId,
-                             false, /* persist: broken by bug 193031 */
-                             mOverrideInternalTypes);
-  } else {
-    if (aType == ePluginMaybeUnregister) {
-      // Bail out if this type is still used by an enabled plugin
-      if (HavePluginForType(aMimeType)) {
-        return;
-      }
-    } else {
-      MOZ_ASSERT(aType == ePluginUnregister, "Unknown nsRegisterType");
-    }
-
-    // Only delete the entry if a plugin registered for it
-    nsCString value;
-    nsresult rv =
-        catMan->GetCategoryEntry("Gecko-Content-Viewers", aMimeType, value);
-    if (NS_SUCCEEDED(rv) && value == contractId) {
-      catMan->DeleteCategoryEntry("Gecko-Content-Viewers", aMimeType, true);
-    }
-  }
-}
-
-nsresult nsPluginHost::AddHeadersToChannel(const char* aHeadersData,
-                                           uint32_t aHeadersDataLen,
-                                           nsIChannel* aGenericChannel) {
-  nsresult rv = NS_OK;
-
-  nsCOMPtr<nsIHttpChannel> aChannel = do_QueryInterface(aGenericChannel);
-  if (!aChannel) {
-    return NS_ERROR_NULL_POINTER;
-  }
-
-  // used during the manipulation of the String from the aHeadersData
-  nsAutoCString headersString;
-  nsAutoCString oneHeader;
-  nsAutoCString headerName;
-  nsAutoCString headerValue;
-  int32_t crlf = 0;
-  int32_t colon = 0;
-
-  // Turn the char * buffer into an nsString.
-  headersString = aHeadersData;
-
-  // Iterate over the nsString: for each "\r\n" delimited chunk,
-  // add the value as a header to the nsIHTTPChannel
-  while (true) {
-    crlf = headersString.Find("\r\n", true);
-    if (-1 == crlf) {
-      rv = NS_OK;
-      return rv;
-    }
-    headersString.Mid(oneHeader, 0, crlf);
-    headersString.Cut(0, crlf + 2);
-    oneHeader.StripWhitespace();
-    colon = oneHeader.Find(":");
-    if (-1 == colon) {
-      rv = NS_ERROR_NULL_POINTER;
-      return rv;
-    }
-    oneHeader.Left(headerName, colon);
-    colon++;
-    oneHeader.Mid(headerValue, colon, oneHeader.Length() - colon);
-
-    // FINALLY: we can set the header!
-
-    rv = aChannel->SetRequestHeader(headerName, headerValue, true);
-    if (NS_FAILED(rv)) {
-      rv = NS_ERROR_NULL_POINTER;
-      return rv;
-    }
-  }
-}
-
-nsresult nsPluginHost::StopPluginInstance(nsNPAPIPluginInstance* aInstance) {
-  return NS_ERROR_FAILURE;
-}
-
-nsresult nsPluginHost::NewPluginStreamListener(
-    nsIURI* aURI, nsNPAPIPluginInstance* aInstance,
-    nsIStreamListener** aStreamListener) {
-  return NS_ERROR_FAILURE;
-}
-
-NS_IMETHODIMP nsPluginHost::Observe(nsISupports* aSubject, const char* aTopic,
-                                    const char16_t* someData) {
-  if (!strcmp(NS_XPCOM_SHUTDOWN_OBSERVER_ID, aTopic)) {
-    UnloadPlugins();
-  }
-  if (!strcmp(NS_PREFBRANCH_PREFCHANGE_TOPIC_ID, aTopic)) {
-    mPluginsDisabled = Preferences::GetBool("plugin.disable", false);
-    // Unload or load plugins as needed
-    if (mPluginsDisabled) {
-      UnloadPlugins();
-    } else {
-      LoadPlugins();
-    }
-  }
-
-  return NS_OK;
-}
-
-nsresult nsPluginHost::ParsePostBufferToFixHeaders(const char* inPostData,
-                                                   uint32_t inPostDataLen,
-                                                   char** outPostData,
-                                                   uint32_t* outPostDataLen) {
-  if (!inPostData || !outPostData || !outPostDataLen)
-    return NS_ERROR_NULL_POINTER;
-
-  *outPostData = 0;
-  *outPostDataLen = 0;
-
-  const char CR = '\r';
-  const char LF = '\n';
-  const char CRLFCRLF[] = {CR, LF, CR, LF, '\0'};  // C string"\r\n\r\n"
-  const char ContentLenHeader[] = "Content-length";
-
-  AutoTArray<const char*, 8> singleLF;
-  const char* pSCntlh =
-      0;                 // pointer to start of ContentLenHeader in inPostData
-  const char* pSod = 0;  // pointer to start of data in inPostData
-  const char* pEoh = 0;  // pointer to end of headers in inPostData
-  const char* pEod =
-      inPostData + inPostDataLen;  // pointer to end of inPostData
-  if (*inPostData == LF) {
-    // If no custom headers are required, simply add a blank
-    // line ('\n') to the beginning of the file or buffer.
-    // so *inPostData == '\n' is valid
-    pSod = inPostData + 1;
-  } else {
-    const char* s = inPostData;  // tmp pointer to sourse inPostData
-    while (s < pEod) {
-      if (!pSCntlh && (*s == 'C' || *s == 'c') &&
-          (s + sizeof(ContentLenHeader) - 1 < pEod) &&
-          (!PL_strncasecmp(s, ContentLenHeader,
-                           sizeof(ContentLenHeader) - 1))) {
-        // lets assume this is ContentLenHeader for now
-        const char* p = pSCntlh = s;
-        p += sizeof(ContentLenHeader) - 1;
-        // search for first CR or LF == end of ContentLenHeader
-        for (; p < pEod; p++) {
-          if (*p == CR || *p == LF) {
-            // got delimiter,
-            // one more check; if previous char is a digit
-            // most likely pSCntlh points to the start of ContentLenHeader
-            if (*(p - 1) >= '0' && *(p - 1) <= '9') {
-              s = p;
-            }
-            break;  // for loop
-          }
-        }
-        if (pSCntlh == s) {  // curret ptr is the same
-          pSCntlh = 0;       // that was not ContentLenHeader
-          break;  // there is nothing to parse, break *WHILE LOOP* here
-        }
-      }
-
-      if (*s == CR) {
-        if (pSCntlh &&  // only if ContentLenHeader is found we are looking for
-                        // end of headers
-            ((s + sizeof(CRLFCRLF) - 1) <= pEod) &&
-            !memcmp(s, CRLFCRLF, sizeof(CRLFCRLF) - 1)) {
-          s += sizeof(CRLFCRLF) - 1;
-          pEoh = pSod = s;  // data stars here
-          break;
-        }
-      } else if (*s == LF) {
-        if (*(s - 1) != CR) {
-          singleLF.AppendElement(s);
-        }
-        if (pSCntlh && (s + 1 < pEod) && (*(s + 1) == LF)) {
-          s++;
-          singleLF.AppendElement(s);
-          s++;
-          pEoh = pSod = s;  // data stars here
-          break;
-        }
-      }
-      s++;
-    }
-  }
-
-  // deal with output buffer
-  if (!pSod) {  // lets assume whole buffer is a data
-    pSod = inPostData;
-  }
-
-  uint32_t newBufferLen = 0;
-  uint32_t dataLen = pEod - pSod;
-  uint32_t headersLen = pEoh ? pSod - inPostData : 0;
-
-  char* p;           // tmp ptr into new output buf
-  if (headersLen) {  // we got a headers
-    // this function does not make any assumption on correctness
-    // of ContentLenHeader value in this case.
-
-    newBufferLen = dataLen + headersLen;
-    // in case there were single LFs in headers
-    // reserve an extra space for CR will be added before each single LF
-    int cntSingleLF = singleLF.Length();
-    newBufferLen += cntSingleLF;
-
-    *outPostData = p = (char*)moz_xmalloc(newBufferLen);
-
-    // deal with single LF
-    const char* s = inPostData;
-    if (cntSingleLF) {
-      for (int i = 0; i < cntSingleLF; i++) {
-        const char* plf = singleLF.ElementAt(i);  // ptr to single LF in headers
-        int n = plf - s;                          // bytes to copy
-        if (n) {  // for '\n\n' there is nothing to memcpy
-          memcpy(p, s, n);
-          p += n;
-        }
-        *p++ = CR;
-        s = plf;
-        *p++ = *s++;
-      }
-    }
-    // are we done with headers?
-    headersLen = pEoh - s;
-    if (headersLen) {            // not yet
-      memcpy(p, s, headersLen);  // copy the rest
-      p += headersLen;
-    }
-  } else if (dataLen) {  // no ContentLenHeader is found but there is a data
-    // make new output buffer big enough
-    // to keep ContentLenHeader+value followed by data
-    uint32_t l = sizeof(ContentLenHeader) + sizeof(CRLFCRLF) + 32;
-    newBufferLen = dataLen + l;
-    *outPostData = p = (char*)moz_xmalloc(newBufferLen);
-    headersLen =
-        snprintf(p, l, "%s: %u%s", ContentLenHeader, dataLen, CRLFCRLF);
-    if (headersLen ==
-        l) {  // if snprintf has ate all extra space consider this as an error
-      free(p);
-      *outPostData = 0;
-      return NS_ERROR_FAILURE;
-    }
-    p += headersLen;
-    newBufferLen = headersLen + dataLen;
-  }
-  // at this point we've done with headers.
-  // there is a possibility that input buffer has only headers info in it
-  // which already parsed and copied into output buffer.
-  // copy the data
-  if (dataLen) {
-    memcpy(p, pSod, dataLen);
-  }
-
-  *outPostDataLen = newBufferLen;
-
-  return NS_OK;
-}
-
-nsresult nsPluginHost::GetPluginName(nsNPAPIPluginInstance* aPluginInstance,
-                                     const char** aPluginName) {
-  return NS_ERROR_FAILURE;
-}
-
-nsresult nsPluginHost::GetPluginTagForInstance(
-    nsNPAPIPluginInstance* aPluginInstance, nsIPluginTag** aPluginTag) {
-  return NS_ERROR_FAILURE;
-}
-
-NS_IMETHODIMP nsPluginHost::Notify(nsITimer* timer) {
-  RefPtr<nsPluginTag> pluginTag = mPlugins;
-  while (pluginTag) {
-    if (pluginTag->mUnloadTimer == timer) {
-      if (!IsRunningPlugin(pluginTag)) {
-        pluginTag->TryUnloadPlugin(false);
-      }
-      return NS_OK;
-    }
-    pluginTag = pluginTag->mNext;
-  }
-
-  return NS_ERROR_FAILURE;
-}
-
-NS_IMETHODIMP
-nsPluginHost::GetName(nsACString& aName) {
-  aName.AssignLiteral("nsPluginHost");
-  return NS_OK;
-}
-
-#ifdef XP_WIN
-// Re-enable any top level browser windows that were disabled by modal dialogs
-// displayed by the crashed plugin.
-static void CheckForDisabledWindows() {
-  nsCOMPtr<nsIWindowMediator> wm(do_GetService(NS_WINDOWMEDIATOR_CONTRACTID));
-  if (!wm) return;
-
-  nsCOMPtr<nsISimpleEnumerator> windowList;
-  wm->GetAppWindowEnumerator(nullptr, getter_AddRefs(windowList));
-  if (!windowList) return;
-
-  bool haveWindows;
-  do {
-    windowList->HasMoreElements(&haveWindows);
-    if (!haveWindows) return;
-
-    nsCOMPtr<nsISupports> supportsWindow;
-    windowList->GetNext(getter_AddRefs(supportsWindow));
-    nsCOMPtr<nsIBaseWindow> baseWin(do_QueryInterface(supportsWindow));
-    if (baseWin) {
-      nsCOMPtr<nsIWidget> widget;
-      baseWin->GetMainWidget(getter_AddRefs(widget));
-      if (widget && !widget->GetParent() && widget->IsVisible() &&
-          !widget->IsEnabled()) {
-        nsIWidget* child = widget->GetFirstChild();
-        bool enable = true;
-        while (child) {
-          if (child->WindowType() == eWindowType_dialog) {
-            enable = false;
-            break;
-          }
-          child = child->GetNextSibling();
-        }
-        if (enable) {
-          widget->Enable(true);
-        }
-      }
-    }
-  } while (haveWindows);
-}
-#endif
-
-nsNPAPIPluginInstance* nsPluginHost::FindInstance(const char* mimetype) {
-  for (uint32_t i = 0; i < mInstances.Length(); i++) {
-    nsNPAPIPluginInstance* instance = mInstances[i];
-
-    const char* mt;
-    nsresult rv = instance->GetMIMEType(&mt);
-    if (NS_FAILED(rv)) continue;
-
-    if (PL_strcasecmp(mt, mimetype) == 0) return instance;
-  }
-
-  return nullptr;
-}
-
-nsNPAPIPluginInstance* nsPluginHost::FindOldestStoppedInstance() {
-  nsNPAPIPluginInstance* oldestInstance = nullptr;
-  TimeStamp oldestTime = TimeStamp::Now();
-  for (uint32_t i = 0; i < mInstances.Length(); i++) {
-    nsNPAPIPluginInstance* instance = mInstances[i];
-    if (instance->IsRunning()) continue;
-
-    TimeStamp time = instance->StopTime();
-    if (time < oldestTime) {
-      oldestTime = time;
-      oldestInstance = instance;
-    }
-  }
-
-  return oldestInstance;
-}
-
-uint32_t nsPluginHost::StoppedInstanceCount() {
-  uint32_t stoppedCount = 0;
-  for (uint32_t i = 0; i < mInstances.Length(); i++) {
-    nsNPAPIPluginInstance* instance = mInstances[i];
-    if (!instance->IsRunning()) stoppedCount++;
-  }
-  return stoppedCount;
-}
-
-nsTArray<RefPtr<nsNPAPIPluginInstance>>* nsPluginHost::InstanceArray() {
-  return &mInstances;
-}
-
-void nsPluginHost::DestroyRunningInstances(nsPluginTag* aPluginTag) {}
-
 /* static */
 bool nsPluginHost::CanUsePluginForMIMEType(const nsACString& aMIMEType) {
-  // We only support flash as a plugin, so if the mime types don't match for
-  // those, exit before we start loading plugins.
-  //
-  // XXX: Remove test/java cases when bug 1351885 lands.
+  // We "support" these in the sense that we show a special transparent
+  // fallback element in their place.
   if (nsPluginHost::GetSpecialType(aMIMEType) ==
           nsPluginHost::eSpecialType_Flash ||
       MimeTypeIsAllowedForFakePlugin(NS_ConvertUTF8toUTF16(aMIMEType)) ||
@@ -1427,107 +221,3 @@ bool nsPluginHost::CanUsePluginForMIMEType(const nsACString& aMIMEType) {
 
   return false;
 }
-
-// Runnable that does an async destroy of a plugin.
-
-class nsPluginDestroyRunnable
-    : public Runnable,
-      public mozilla::LinkedListElement<nsPluginDestroyRunnable> {
- public:
-  explicit nsPluginDestroyRunnable(nsNPAPIPluginInstance* aInstance)
-      : Runnable("nsPluginDestroyRunnable"), mInstance(aInstance) {
-    sRunnableList.insertBack(this);
-  }
-
-  ~nsPluginDestroyRunnable() override { this->remove(); }
-
-  NS_IMETHOD Run() override {
-    RefPtr<nsNPAPIPluginInstance> instance;
-
-    // Null out mInstance to make sure this code in another runnable
-    // will do the right thing even if someone was holding on to this
-    // runnable longer than we expect.
-    instance.swap(mInstance);
-
-    if (PluginDestructionGuard::DelayDestroy(instance)) {
-      // It's still not safe to destroy the plugin, it's now up to the
-      // outermost guard on the stack to take care of the destruction.
-      return NS_OK;
-    }
-
-    for (auto r : sRunnableList) {
-      if (r != this && r->mInstance == instance) {
-        // There's another runnable scheduled to tear down
-        // instance. Let it do the job.
-        return NS_OK;
-      }
-    }
-
-    PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-               ("Doing delayed destroy of instance %p\n", instance.get()));
-
-    RefPtr<nsPluginHost> host = nsPluginHost::GetInst();
-    if (host) host->StopPluginInstance(instance);
-
-    PLUGIN_LOG(PLUGIN_LOG_NORMAL,
-               ("Done with delayed destroy of instance %p\n", instance.get()));
-
-    return NS_OK;
-  }
-
- protected:
-  RefPtr<nsNPAPIPluginInstance> mInstance;
-
-  static mozilla::LinkedList<nsPluginDestroyRunnable> sRunnableList;
-};
-
-mozilla::LinkedList<nsPluginDestroyRunnable>
-    nsPluginDestroyRunnable::sRunnableList;
-
-mozilla::LinkedList<PluginDestructionGuard> PluginDestructionGuard::sList;
-
-PluginDestructionGuard::PluginDestructionGuard(nsNPAPIPluginInstance* aInstance)
-    : mInstance(aInstance) {
-  Init();
-}
-
-PluginDestructionGuard::PluginDestructionGuard(NPP npp)
-    : mInstance(npp ? static_cast<nsNPAPIPluginInstance*>(npp->ndata)
-                    : nullptr) {
-  Init();
-}
-
-PluginDestructionGuard::~PluginDestructionGuard() {
-  NS_ASSERTION(NS_IsMainThread(), "Should be on the main thread");
-
-  this->remove();
-
-  if (mDelayedDestroy) {
-    // We've attempted to destroy the plugin instance we're holding on
-    // to while we were guarding it. Do the actual destroy now, off of
-    // a runnable.
-    RefPtr<nsPluginDestroyRunnable> evt =
-        new nsPluginDestroyRunnable(mInstance);
-
-    NS_DispatchToMainThread(evt);
-  }
-}
-
-// static
-bool PluginDestructionGuard::DelayDestroy(nsNPAPIPluginInstance* aInstance) {
-  NS_ASSERTION(NS_IsMainThread(), "Should be on the main thread");
-  NS_ASSERTION(aInstance, "Uh, I need an instance!");
-
-  // Find the first guard on the stack and make it do a delayed
-  // destroy upon destruction.
-
-  for (auto g : sList) {
-    if (g->mInstance == aInstance) {
-      g->mDelayedDestroy = true;
-
-      return true;
-    }
-  }
-
-  return false;
-}
diff --git a/dom/plugins/base/nsPluginHost.h b/dom/plugins/base/nsPluginHost.h
index fee351d892966..6566e979f30c6 100644
--- a/dom/plugins/base/nsPluginHost.h
+++ b/dom/plugins/base/nsPluginHost.h
@@ -6,56 +6,18 @@
 #ifndef nsPluginHost_h_
 #define nsPluginHost_h_
 
-#include "mozilla/LinkedList.h"
 #include "mozilla/StaticPtr.h"
 
-#include "nsIObserver.h"
 #include "nsCOMPtr.h"
 #include "prlink.h"
 #include "nsIPluginTag.h"
 #include "nsWeakReference.h"
-#include "MainThreadUtils.h"
 #include "nsTArray.h"
-#include "nsINamed.h"
-#include "nsTObserverArray.h"
-#include "nsITimer.h"
 #include "nsPluginTags.h"
-#include "nsIEffectiveTLDService.h"
-#include "nsIIDNService.h"
-#include "nsCRT.h"
-#include "mozilla/dom/PromiseNativeHandler.h"
-
-#ifdef XP_WIN
-#  include <minwindef.h>
-#  include "nsIWindowsRegKey.h"
-#endif
-
-namespace mozilla {
-namespace plugins {
-class BlocklistPromiseHandler;
-}  // namespace plugins
-namespace dom {
-class ContentParent;
-}  // namespace dom
-}  // namespace mozilla
 
 class nsIFile;
-class nsIChannel;
-class nsObjectLoadingContent;
-class nsPluginUnloadRunnable;
-class nsNPAPIPluginInstance;
-class nsIInputStream;
-class nsIStreamListener;
-#ifndef npapi_h_
-struct _NPP;
-typedef _NPP* NPP;
-#endif
 
-class nsPluginHost final : public nsIObserver,
-                           public nsITimerCallback,
-                           public nsSupportsWeakReference,
-                           public nsINamed {
-  friend class nsPluginTag;
+class nsPluginHost final : public nsSupportsWeakReference {
   friend class nsFakePluginTag;
   virtual ~nsPluginHost();
 
@@ -65,9 +27,6 @@ class nsPluginHost final : public nsIObserver,
   static already_AddRefed<nsPluginHost> GetInst();
 
   NS_DECL_ISUPPORTS
-  NS_DECL_NSIOBSERVER
-  NS_DECL_NSITIMERCALLBACK
-  NS_DECL_NSINAMED
 
   // Acts like a bitfield
   enum PluginFilter { eExcludeNone, eExcludeDisabled, eExcludeFake };
@@ -78,40 +37,14 @@ class nsPluginHost final : public nsIObserver,
   NS_IMETHOD GetPermissionStringForTag(nsIPluginTag* aTag,
                                        uint32_t aExcludeFlags,
                                        nsACString& aPermissionString);
-  NS_IMETHOD ReloadPlugins();
 
   // FIXME-jsplugins comment about fake
   bool HavePluginForType(const nsACString& aMimeType,
                          PluginFilter aFilter = eExcludeDisabled);
 
-  // FIXME-jsplugins what if fake has different extensions
-  bool HavePluginForExtension(const nsACString& aExtension,
-                              /* out */ nsACString& aMimeType,
-                              PluginFilter aFilter = eExcludeDisabled);
-
   void GetPlugins(nsTArray<nsCOMPtr<nsIInternalPluginTag>>& aPluginArray,
                   bool aIncludeDisabled = false);
 
-  nsresult UserAgent(const char** retstring);
-  nsresult ParsePostBufferToFixHeaders(const char* inPostData,
-                                       uint32_t inPostDataLen,
-                                       char** outPostData,
-                                       uint32_t* outPostDataLen);
-
-  nsresult GetPluginName(nsNPAPIPluginInstance* aPluginInstance,
-                         const char** aPluginName);
-  nsresult StopPluginInstance(nsNPAPIPluginInstance* aInstance);
-  nsresult GetPluginTagForInstance(nsNPAPIPluginInstance* aPluginInstance,
-                                   nsIPluginTag** aPluginTag);
-
-  nsresult AddHeadersToChannel(const char* aHeadersData,
-                               uint32_t aHeadersDataLen,
-                               nsIChannel* aGenericChannel);
-
-  // Helper that checks if a type is whitelisted in plugin.allowed_types.
-  // Always returns true if plugin.allowed_types is not set
-  static bool IsTypeWhitelisted(const char* aType);
-
   /**
    * Returns true if a plugin can be used to load the requested MIME type. Used
    * for short circuiting before sending things to plugin code.
@@ -128,48 +61,7 @@ class nsPluginHost final : public nsIObserver,
   };
   static SpecialType GetSpecialType(const nsACString& aMIMEType);
 
-  static nsresult PostPluginUnloadEvent(PRLibrary* aLibrary);
-
-  nsNPAPIPluginInstance* FindInstance(const char* mimetype);
-  nsNPAPIPluginInstance* FindOldestStoppedInstance();
-  uint32_t StoppedInstanceCount();
-
-  nsTArray<RefPtr<nsNPAPIPluginInstance>>* InstanceArray();
-
-  // Return the tag for |aLibrary| if found, nullptr if not.
-  nsPluginTag* FindTagForLibrary(PRLibrary* aLibrary);
-
-  nsPluginTag* PluginWithId(uint32_t aId);
-
-  void NotifyContentModuleDestroyed(uint32_t aPluginId);
-
-  nsresult NewPluginStreamListener(nsIURI* aURL,
-                                   nsNPAPIPluginInstance* aInstance,
-                                   nsIStreamListener** aStreamListener);
-
-  nsresult EnumerateSiteData(const nsACString& domain,
-                             const nsTArray<nsCString>& sites,
-                             nsTArray<nsCString>& result, bool firstMatchOnly);
-
-  nsresult UpdateCachedSerializablePluginList();
-  nsresult SendPluginsToContent(mozilla::dom::ContentParent* parent);
-
  private:
-  nsresult LoadPlugins();
-  nsresult UnloadPlugins();
-
-  friend class nsPluginUnloadRunnable;
-  friend class mozilla::plugins::BlocklistPromiseHandler;
-
-  void DestroyRunningInstances(nsPluginTag* aPluginTag);
-
-  // Writes updated plugins settings to disk and unloads the plugin
-  // if it is now disabled. Should only be called by the plugin tag in question
-  void UpdatePluginInfo(nsPluginTag* aPluginTag);
-
-  // FIXME-jsplugins comment here about when things may be fake
-  nsPluginTag* FindPreferredPlugin(const nsTArray<nsPluginTag*>& matches);
-
   // Find a plugin for the given type.  If aIncludeFake is true a fake plugin
   // will be preferred if one exists; otherwise a fake plugin will never be
   // returned.  If aCheckEnabled is false, disabled plugins can be returned.
@@ -189,45 +81,9 @@ class nsPluginHost final : public nsIObserver,
                                               /* out */ nsACString& aMimeType,
                                               bool aCheckEnabled);
 
-  // Find specifically a native (NPAPI) plugin for the given type.  If
-  // aCheckEnabled is false, disabled plugins can be returned.
-  nsPluginTag* FindNativePluginForType(const nsACString& aMimeType,
-                                       bool aCheckEnabled);
-
-  // Find specifically a native (NPAPI) plugin for the given extension.  If
-  // aCheckEnabled is false, disabled plugins can be returned.  aMimeType will
-  // be filled in with the MIME type the plugin is registered for.
-  nsPluginTag* FindNativePluginForExtension(const nsACString& aExtension,
-                                            /* out */ nsACString& aMimeType,
-                                            bool aCheckEnabled);
-
-  nsresult BroadcastPluginsToContent();
-
-  // FIXME revisit, no ns prefix
-  // Registers or unregisters the given mime type with the category manager
-  enum nsRegisterType {
-    ePluginRegister,
-    ePluginUnregister,
-    // Checks if this type should still be registered first
-    ePluginMaybeUnregister
-  };
-  void RegisterWithCategoryManager(const nsCString& aMimeType,
-                                   nsRegisterType aType);
-
-  void AddPluginTag(nsPluginTag* aPluginTag);
-
-  nsresult EnsurePluginLoaded(nsPluginTag* aPluginTag);
-
-  bool IsRunningPlugin(nsPluginTag* aPluginTag);
-
   // Checks to see if a tag object is in our list of live tags.
   bool IsLiveTag(nsIPluginTag* tag);
 
-  // Checks our list of live tags for an equivalent tag.
-  nsPluginTag* HaveSamePlugin(const nsPluginTag* aPluginTag);
-
-  void OnPluginInstanceDestroyed(nsPluginTag* aPluginTag);
-
   // To be used by the chrome process whenever the set of plugins changes.
   void IncrementChromeEpoch();
 
@@ -239,82 +95,17 @@ class nsPluginHost final : public nsIObserver,
   uint32_t ChromeEpochForContent();
   void SetChromeEpochForContent(uint32_t aEpoch);
 
-  void UpdateInMemoryPluginInfo(nsPluginTag* aPluginTag);
-
-  void ClearNonRunningPlugins();
-  nsresult ActuallyReloadPlugins();
-
-  void FindingFinished();
-
-  RefPtr<nsPluginTag> mPlugins;
-
   nsTArray<RefPtr<nsFakePluginTag>> mFakePlugins;
 
-  bool mPluginsLoaded;
-
-  // set by pref plugin.override_internal_types
-  bool mOverrideInternalTypes;
-
-  // set by pref plugin.disable
-  bool mPluginsDisabled;
-
-  // Any instances in this array will have valid plugin objects via GetPlugin().
-  // When removing an instance it might not die - be sure to null out it's
-  // plugin.
-  nsTArray<RefPtr<nsNPAPIPluginInstance>> mInstances;
-
-  // An nsIFile for the pluginreg.dat file in the profile.
-#ifdef XP_WIN
-  // In order to reload plugins when they change, we watch the registry via
-  // this object.
-  nsCOMPtr<nsIWindowsRegKey> mRegKeyHKLM;
-  nsCOMPtr<nsIWindowsRegKey> mRegKeyHKCU;
-#endif
-
-  nsCOMPtr<nsIEffectiveTLDService> mTLDService;
-  nsCOMPtr<nsIIDNService> mIDNService;
-
-  // Helpers for ClearSiteData and SiteHasData.
-  nsresult NormalizeHostname(nsCString& host);
-
-  nsWeakPtr mCurrentDocument;  // weak reference, we use it to id document only
-
   // This epoch increases each time we load the list of plugins from disk.
   // In the chrome process, this stores the actual epoch.
   // In the content process, this stores the last epoch value observed
   // when reading plugins from chrome.
   uint32_t mPluginEpoch;
 
-  static nsIFile* sPluginTempDir;
-
   // We need to hold a global ptr to ourselves because we register for
   // two different CIDs for some reason...
   static mozilla::StaticRefPtr<nsPluginHost> sInst;
 };
 
-class PluginDestructionGuard
-    : public mozilla::LinkedListElement<PluginDestructionGuard> {
- public:
-  explicit PluginDestructionGuard(nsNPAPIPluginInstance* aInstance);
-  explicit PluginDestructionGuard(NPP npp);
-
-  ~PluginDestructionGuard();
-
-  static bool DelayDestroy(nsNPAPIPluginInstance* aInstance);
-
- protected:
-  void Init() {
-    NS_ASSERTION(NS_IsMainThread(), "Should be on the main thread");
-
-    mDelayedDestroy = false;
-
-    sList.insertBack(this);
-  }
-
-  RefPtr<nsNPAPIPluginInstance> mInstance;
-  bool mDelayedDestroy;
-
-  static mozilla::LinkedList<PluginDestructionGuard> sList;
-};
-
 #endif  // nsPluginHost_h_
diff --git a/dom/plugins/base/nsPluginTags.cpp b/dom/plugins/base/nsPluginTags.cpp
index 6268f883eb99b..bdda65ccc4521 100644
--- a/dom/plugins/base/nsPluginTags.cpp
+++ b/dom/plugins/base/nsPluginTags.cpp
@@ -7,6 +7,7 @@
 
 #include "prlink.h"
 #include "plstr.h"
+#include "prenv.h"
 #include "nsPluginHost.h"
 #include "nsIBlocklistService.h"
 #include "nsPluginLogging.h"
@@ -20,39 +21,9 @@
 #include "mozilla/dom/FakePluginTagInitBinding.h"
 #include "mozilla/StaticPrefs_plugin.h"
 
-#if defined(XP_MACOSX) && defined(MOZ_SANDBOX)
-#  include "mozilla/SandboxSettings.h"
-#  include "nsCocoaFeatures.h"
-#endif
-
 using mozilla::dom::FakePluginTagInit;
 using namespace mozilla;
 
-// These legacy flags are used in the plugin registry. The states are now
-// stored in prefs, but we still need to be able to import them.
-#define NS_PLUGIN_FLAG_ENABLED 0x0001  // is this plugin enabled?
-// no longer used                   0x0002    // reuse only if regenerating
-// pluginreg.dat
-#define NS_PLUGIN_FLAG_FROMCACHE \
-  0x0004  // this plugintag info was loaded from cache
-// no longer used                   0x0008    // reuse only if regenerating
-// pluginreg.dat
-#define NS_PLUGIN_FLAG_CLICKTOPLAY 0x0020  // this is a click-to-play plugin
-
-static const char kPrefDefaultEnabledState[] = "plugin.default.state";
-
-// The defaults here will be read from prefs and overwritten
-#if defined(MOZ_SANDBOX)
-#  if defined(XP_WIN) || defined(XP_MACOSX)
-static int32_t sFlashSandboxLevel = 3;
-static int32_t sDefaultSandboxLevel = 0;
-#  endif
-#  if defined(XP_MACOSX)
-static bool sEnableSandboxLogging = false;
-#  endif
-#endif /* MOZ_SANDBOX */
-static bool sInitializedSandboxingInfo = false;
-
 // check comma delimited extensions
 static bool ExtensionInList(const nsCString& aExtensionList,
                             const nsACString& aExtension) {
@@ -190,476 +161,10 @@ bool nsIInternalPluginTag::HasMimeType(const nsACString& aMimeType) const {
                              nsCaseInsensitiveCStringArrayComparator());
 }
 
-/* nsPluginTag */
-
-nsPluginTag::nsPluginTag(const char* aName, const char* aDescription,
-                         const char* aFileName, const char* aFullPath,
-                         const char* aVersion, const char* const* aMimeTypes,
-                         const char* const* aMimeDescriptions,
-                         const char* const* aExtensions, int32_t aVariants,
-                         int64_t aLastModifiedTime, uint32_t aBlocklistState,
-                         bool aArgsAreUTF8)
-    : nsIInternalPluginTag(aName, aDescription, aFileName, aVersion),
-      mId(sNextId++),
-      mContentProcessRunningCount(0),
-      mHadLocalInstance(false),
-      mLibrary(nullptr),
-      mIsFlashPlugin(false),
-      mSupportsAsyncRender(false),
-      mFullPath(aFullPath),
-      mLastModifiedTime(aLastModifiedTime),
-      mSandboxLevel(0),
-      mIsSandboxLoggingEnabled(false),
-      mBlocklistState(aBlocklistState) {
-  InitMime(aMimeTypes, aMimeDescriptions, aExtensions,
-           static_cast<uint32_t>(aVariants));
-  InitSandboxLevel();
-  if (!aArgsAreUTF8) EnsureMembersAreUTF8();
-  FixupVersion();
-}
-
-nsPluginTag::nsPluginTag(uint32_t aId, const char* aName,
-                         const char* aDescription, const char* aFileName,
-                         const char* aFullPath, const char* aVersion,
-                         nsTArray<nsCString> aMimeTypes,
-                         nsTArray<nsCString> aMimeDescriptions,
-                         nsTArray<nsCString> aExtensions, bool aIsFlashPlugin,
-                         bool aSupportsAsyncRender, int64_t aLastModifiedTime,
-                         int32_t aSandboxLevel, uint32_t aBlocklistState)
-    : nsIInternalPluginTag(aName, aDescription, aFileName, aVersion, aMimeTypes,
-                           aMimeDescriptions, aExtensions),
-      mId(aId),
-      mContentProcessRunningCount(0),
-      mHadLocalInstance(false),
-      mLibrary(nullptr),
-      mIsFlashPlugin(aIsFlashPlugin),
-      mSupportsAsyncRender(aSupportsAsyncRender),
-      mLastModifiedTime(aLastModifiedTime),
-      mSandboxLevel(aSandboxLevel),
-      mIsSandboxLoggingEnabled(false),
-      mNiceFileName(),
-      mBlocklistState(aBlocklistState) {}
-
-nsPluginTag::~nsPluginTag() {
-  NS_ASSERTION(!mNext, "Risk of exhausting the stack space, bug 486349");
-}
-
-NS_IMPL_ISUPPORTS(nsPluginTag, nsPluginTag, nsIInternalPluginTag, nsIPluginTag)
-
-void nsPluginTag::InitMime(const char* const* aMimeTypes,
-                           const char* const* aMimeDescriptions,
-                           const char* const* aExtensions,
-                           uint32_t aVariantCount) {
-  if (!aMimeTypes) {
-    return;
-  }
-
-  for (uint32_t i = 0; i < aVariantCount; i++) {
-    if (!aMimeTypes[i]) {
-      continue;
-    }
-
-    nsAutoCString mimeType(aMimeTypes[i]);
-
-    // Convert the MIME type, which is case insensitive, to lowercase in order
-    // to properly handle a mixed-case type.
-    ToLowerCase(mimeType);
-
-    // Look for certain special plugins.
-    switch (nsPluginHost::GetSpecialType(mimeType)) {
-      case nsPluginHost::eSpecialType_Flash:
-        // VLC sometimes claims to implement the Flash MIME type, and we want
-        // to allow users to control that separately from Adobe Flash.
-        if (Name().EqualsLiteral("Shockwave Flash")) {
-          mIsFlashPlugin = true;
-        }
-        break;
-      case nsPluginHost::eSpecialType_Test:
-      case nsPluginHost::eSpecialType_None:
-      default:
-        break;
-    }
-
-    // Fill in our MIME type array.
-    mMimeTypes.AppendElement(mimeType);
-
-    // Now fill in the MIME descriptions.
-    if (aMimeDescriptions && aMimeDescriptions[i]) {
-      // we should cut off the list of suffixes which the mime
-      // description string may have, see bug 53895
-      // it is usually in form "some description (*.sf1, *.sf2)"
-      // so we can search for the opening round bracket
-      char cur = '\0';
-      char pre = '\0';
-      char* p = PL_strrchr(aMimeDescriptions[i], '(');
-      if (p && (p != aMimeDescriptions[i])) {
-        if ((p - 1) && *(p - 1) == ' ') {
-          pre = *(p - 1);
-          *(p - 1) = '\0';
-        } else {
-          cur = *p;
-          *p = '\0';
-        }
-      }
-      mMimeDescriptions.AppendElement(nsCString(aMimeDescriptions[i]));
-      // restore the original string
-      if (cur != '\0') {
-        *p = cur;
-      }
-      if (pre != '\0') {
-        *(p - 1) = pre;
-      }
-    } else {
-      mMimeDescriptions.AppendElement(nsCString());
-    }
-
-    // Now fill in the extensions.
-    if (aExtensions && aExtensions[i]) {
-      mExtensions.AppendElement(nsCString(aExtensions[i]));
-    } else {
-      mExtensions.AppendElement(nsCString());
-    }
-  }
-}
-
-void nsPluginTag::InitSandboxLevel() {
-  MOZ_ASSERT(sInitializedSandboxingInfo,
-             "Should have initialized global sandboxing info");
-#if defined(MOZ_SANDBOX)
-#  if defined(XP_MACOSX)
-  mSandboxLevel = mIsFlashPlugin ? sFlashSandboxLevel : sDefaultSandboxLevel;
-  mIsSandboxLoggingEnabled = mIsFlashPlugin && sEnableSandboxLogging;
-#  elif defined(XP_WIN)
-  mSandboxLevel = mIsFlashPlugin ? sFlashSandboxLevel : sDefaultSandboxLevel;
-#  endif /* defined(XP_MACOSX) / defined(XP_WIN) */
-#endif   /* defined(MOZ_SANDBOX) */
-}
-
-#if !defined(XP_WIN) && !defined(XP_MACOSX)
-static void ConvertToUTF8(nsCString& aString) {
-  Unused << UTF_8_ENCODING->DecodeWithoutBOMHandling(aString, aString);
-}
-#endif
-
-nsresult nsPluginTag::EnsureMembersAreUTF8() {
-#if defined(XP_WIN) || defined(XP_MACOSX)
-  return NS_OK;
-#else
-  ConvertToUTF8(mFileName);
-  ConvertToUTF8(mFullPath);
-  ConvertToUTF8(mName);
-  ConvertToUTF8(mDescription);
-  for (uint32_t i = 0; i < mMimeDescriptions.Length(); ++i) {
-    ConvertToUTF8(mMimeDescriptions[i]);
-  }
-  return NS_OK;
-#endif
-}
-
-void nsPluginTag::FixupVersion() {
-#if defined(XP_LINUX)
-  if (mIsFlashPlugin) {
-    mVersion.ReplaceChar(',', '.');
-  }
-#endif
-}
-
-NS_IMETHODIMP
-nsPluginTag::GetDescription(nsACString& aDescription) {
-  aDescription = mDescription;
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsPluginTag::GetIsFlashPlugin(bool* aIsFlash) {
-  *aIsFlash = mIsFlashPlugin;
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsPluginTag::GetFilename(nsACString& aFileName) {
-  aFileName = mFileName;
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsPluginTag::GetFullpath(nsACString& aFullPath) {
-  aFullPath = mFullPath;
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsPluginTag::GetVersion(nsACString& aVersion) {
-  aVersion = mVersion;
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsPluginTag::GetName(nsACString& aName) {
-  aName = mName;
-  return NS_OK;
-}
-
-bool nsPluginTag::IsActive() { return IsEnabled() && !IsBlocklisted(); }
-
-NS_IMETHODIMP
-nsPluginTag::GetActive(bool* aResult) {
-  *aResult = IsActive();
-  return NS_OK;
-}
-
-bool nsPluginTag::IsEnabled() {
-  const PluginState state = GetPluginState();
-  return (state == ePluginState_Enabled) || (state == ePluginState_Clicktoplay);
-}
-
-NS_IMETHODIMP
-nsPluginTag::GetDisabled(bool* aDisabled) {
-  *aDisabled = !IsEnabled();
-  return NS_OK;
-}
-
-bool nsPluginTag::IsBlocklisted() {
-  return mBlocklistState == nsIBlocklistService::STATE_BLOCKED;
-}
-
-NS_IMETHODIMP
-nsPluginTag::GetBlocklisted(bool* aBlocklisted) {
-  *aBlocklisted = IsBlocklisted();
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsPluginTag::GetIsEnabledStateLocked(bool* aIsEnabledStateLocked) {
-  return IsEnabledStateLockedForPlugin(this, aIsEnabledStateLocked);
-}
-
-bool nsPluginTag::IsClicktoplay() {
-  const PluginState state = GetPluginState();
-  return (state == ePluginState_Clicktoplay);
-}
-
-NS_IMETHODIMP
-nsPluginTag::GetClicktoplay(bool* aClicktoplay) {
-  *aClicktoplay = IsClicktoplay();
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsPluginTag::GetEnabledState(uint32_t* aEnabledState) {
-  int32_t enabledState;
-  nsresult rv = NS_OK;
-  if (mIsFlashPlugin) {
-    enabledState = StaticPrefs::plugin_state_flash();
-    if (enabledState == nsIPluginTag::STATE_ENABLED) {
-      enabledState = nsIPluginTag::STATE_CLICKTOPLAY;
-    }
-  } else {
-    rv = Preferences::GetInt(GetStatePrefNameForPlugin(this).get(),
-                             &enabledState);
-  }
-  if (NS_SUCCEEDED(rv) && enabledState >= nsIPluginTag::STATE_DISABLED &&
-      enabledState <= nsIPluginTag::STATE_ENABLED) {
-    *aEnabledState = (uint32_t)enabledState;
-    return rv;
-  }
-
-  // Something went wrong fetching the plugin's state (e.g. it wasn't flash
-  // and the preference was not present) - use the default state:
-  enabledState = Preferences::GetInt(kPrefDefaultEnabledState,
-                                     nsIPluginTag::STATE_ENABLED);
-  if (enabledState == nsIPluginTag::STATE_ENABLED && mIsFlashPlugin) {
-    enabledState = nsIPluginTag::STATE_CLICKTOPLAY;
-  }
-  if (enabledState >= nsIPluginTag::STATE_DISABLED &&
-      enabledState <= nsIPluginTag::STATE_ENABLED) {
-    *aEnabledState = (uint32_t)enabledState;
-    return NS_OK;
-  }
-
-  return NS_ERROR_UNEXPECTED;
-}
-
-NS_IMETHODIMP
-nsPluginTag::SetEnabledState(uint32_t aEnabledState) {
-  if (aEnabledState >= ePluginState_MaxValue) return NS_ERROR_ILLEGAL_VALUE;
-  if (aEnabledState == nsIPluginTag::STATE_ENABLED && mIsFlashPlugin) {
-    aEnabledState = nsIPluginTag::STATE_CLICKTOPLAY;
-  }
-  uint32_t oldState = nsIPluginTag::STATE_DISABLED;
-  GetEnabledState(&oldState);
-  if (oldState != aEnabledState) {
-    Preferences::SetInt(GetStatePrefNameForPlugin(this).get(), aEnabledState);
-    if (RefPtr<nsPluginHost> host = nsPluginHost::GetInst()) {
-      host->UpdatePluginInfo(this);
-    }
-  }
-  return NS_OK;
-}
-
-nsPluginTag::PluginState nsPluginTag::GetPluginState() {
-  uint32_t enabledState = nsIPluginTag::STATE_DISABLED;
-  GetEnabledState(&enabledState);
-  return (PluginState)enabledState;
-}
-
-void nsPluginTag::SetPluginState(PluginState state) {
-  static_assert((uint32_t)nsPluginTag::ePluginState_Disabled ==
-                    nsIPluginTag::STATE_DISABLED,
-                "nsPluginTag::ePluginState_Disabled must match "
-                "nsIPluginTag::STATE_DISABLED");
-  static_assert((uint32_t)nsPluginTag::ePluginState_Clicktoplay ==
-                    nsIPluginTag::STATE_CLICKTOPLAY,
-                "nsPluginTag::ePluginState_Clicktoplay must match "
-                "nsIPluginTag::STATE_CLICKTOPLAY");
-  static_assert((uint32_t)nsPluginTag::ePluginState_Enabled ==
-                    nsIPluginTag::STATE_ENABLED,
-                "nsPluginTag::ePluginState_Enabled must match "
-                "nsIPluginTag::STATE_ENABLED");
-  SetEnabledState((uint32_t)state);
-}
-
-NS_IMETHODIMP
-nsPluginTag::GetMimeTypes(nsTArray<nsCString>& aResults) {
-  aResults = mMimeTypes.Clone();
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsPluginTag::GetMimeDescriptions(nsTArray<nsCString>& aResults) {
-  aResults = mMimeDescriptions.Clone();
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsPluginTag::GetExtensions(nsTArray<nsCString>& aResults) {
-  aResults = mExtensions.Clone();
-  return NS_OK;
-}
-
-bool nsPluginTag::HasSameNameAndMimes(const nsPluginTag* aPluginTag) const {
-  NS_ENSURE_TRUE(aPluginTag, false);
-
-  if ((!mName.Equals(aPluginTag->mName)) ||
-      (mMimeTypes.Length() != aPluginTag->mMimeTypes.Length())) {
-    return false;
-  }
-
-  for (uint32_t i = 0; i < mMimeTypes.Length(); i++) {
-    if (!mMimeTypes[i].Equals(aPluginTag->mMimeTypes[i])) {
-      return false;
-    }
-  }
-
-  return true;
-}
-
-NS_IMETHODIMP
-nsPluginTag::GetLoaded(bool* aIsLoaded) { return NS_ERROR_FAILURE; }
-
-void nsPluginTag::TryUnloadPlugin(bool inShutdown) {}
-
-/* static */ void nsPluginTag::EnsureSandboxInformation() {
-  if (sInitializedSandboxingInfo) {
-    return;
-  }
-  MOZ_ASSERT(NS_IsMainThread(), "Should be on the main thread.");
-#if defined(XP_WIN) && defined(MOZ_SANDBOX)
-  Preferences::GetInt("dom.ipc.plugins.sandbox-level.default",
-                      &sDefaultSandboxLevel);
-  Preferences::GetInt("dom.ipc.plugins.sandbox-level.flash",
-                      &sFlashSandboxLevel);
-#  if defined(_AMD64_)
-  // Level 3 is now the default NPAPI sandbox level for 64-bit flash.
-  // We permit the user to drop the sandbox level by at most 1.  This should
-  // be kept up to date with the default value in the firefox.js pref file.
-  sFlashSandboxLevel = std::max(sFlashSandboxLevel, 2);
-#  endif
-#elif defined(XP_MACOSX) && defined(MOZ_SANDBOX)
-  int legacyOSMinorMax = Preferences::GetInt(
-      "dom.ipc.plugins.sandbox-level.flash.max-legacy-os-minor", 10);
-  const char* levelPref = "dom.ipc.plugins.sandbox-level.flash";
-
-  if (PR_GetEnv("MOZ_DISABLE_NPAPI_SANDBOX")) {
-    // Flash sandbox disabled
-    sFlashSandboxLevel = 0;
-  } else if (nsCocoaFeatures::macOSVersionMajor() == 10 &&
-             nsCocoaFeatures::macOSVersionMinor() <= legacyOSMinorMax) {
-    const char* legacyLevelPref = "dom.ipc.plugins.sandbox-level.flash.legacy";
-    int32_t compatLevel = Preferences::GetInt(legacyLevelPref, 0);
-    int32_t level = Preferences::GetInt(levelPref, 0);
-    sFlashSandboxLevel = std::min(compatLevel, level);
-  } else {
-    sFlashSandboxLevel = Preferences::GetInt(levelPref, 0);
-  }
-  sFlashSandboxLevel = ClampFlashSandboxLevel(sFlashSandboxLevel);
-
-  // At present, Flash is the only supported plugin on macOS.
-  // Other test plugins are used during testing and they will use
-  // the default plugin sandbox level.
-  Preferences::GetInt("dom.ipc.plugins.sandbox-level.default",
-                      &sDefaultSandboxLevel);
-
-  // Enable sandbox logging in the plugin process if it has
-  // been turned on via prefs or environment variables.
-  sEnableSandboxLogging =
-      sFlashSandboxLevel > 0 &&
-      (Preferences::GetBool("security.sandbox.logging.enabled") ||
-       PR_GetEnv("MOZ_SANDBOX_LOGGING") ||
-       PR_GetEnv("MOZ_SANDBOX_MAC_FLASH_LOGGING"));
-#endif
-  sInitializedSandboxingInfo = true;
-}
-
-const nsCString& nsPluginTag::GetNiceFileName() {
-  if (!mNiceFileName.IsEmpty()) {
-    return mNiceFileName;
-  }
-
-  if (mIsFlashPlugin) {
-    mNiceFileName.AssignLiteral("flash");
-    return mNiceFileName;
-  }
-
-  mNiceFileName = MakeNiceFileName(mFileName);
-  return mNiceFileName;
-}
-
-NS_IMETHODIMP
-nsPluginTag::GetNiceName(nsACString& aResult) {
-  aResult = GetNiceFileName();
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsPluginTag::GetBlocklistState(uint32_t* aResult) {
-  *aResult = mBlocklistState;
-  return NS_OK;
-}
-
-void nsPluginTag::SetBlocklistState(uint32_t aBlocklistState) {
-  mBlocklistState = aBlocklistState;
-}
-
-uint32_t nsPluginTag::BlocklistState() { return mBlocklistState; }
-
-NS_IMETHODIMP
-nsPluginTag::GetLastModifiedTime(PRTime* aLastModifiedTime) {
-  MOZ_ASSERT(aLastModifiedTime);
-  *aLastModifiedTime = mLastModifiedTime;
-  return NS_OK;
-}
-
-NS_IMETHODIMP
-nsPluginTag::GetId(uint32_t* aId) {
-  *aId = mId;
-  return NS_OK;
-}
-
 /* nsFakePluginTag */
 
 nsFakePluginTag::nsFakePluginTag()
-    : mId(sNextId++), mState(nsPluginTag::ePluginState_Disabled) {}
+    : mId(sNextId++), mState(ePluginState_Disabled) {}
 
 nsFakePluginTag::nsFakePluginTag(uint32_t aId,
                                  already_AddRefed<nsIURI>&& aHandlerURI,
@@ -675,7 +180,7 @@ nsFakePluginTag::nsFakePluginTag(uint32_t aId,
       mHandlerURI(aHandlerURI),
       mNiceName(aNiceName),
       mSandboxScript(aSandboxScript),
-      mState(nsPluginTag::ePluginState_Enabled) {}
+      mState(ePluginState_Enabled) {}
 
 nsFakePluginTag::~nsFakePluginTag() = default;
 
@@ -813,8 +318,7 @@ nsFakePluginTag::GetIsEnabledStateLocked(bool* aIsEnabledStateLocked) {
 }
 
 bool nsFakePluginTag::IsEnabled() {
-  return mState == nsPluginTag::ePluginState_Enabled ||
-         mState == nsPluginTag::ePluginState_Clicktoplay;
+  return mState == ePluginState_Enabled || mState == ePluginState_Clicktoplay;
 }
 
 NS_IMETHODIMP
@@ -825,7 +329,7 @@ nsFakePluginTag::GetDisabled(bool* aDisabled) {
 
 NS_IMETHODIMP
 nsFakePluginTag::GetClicktoplay(bool* aClicktoplay) {
-  *aClicktoplay = (mState == nsPluginTag::ePluginState_Clicktoplay);
+  *aClicktoplay = (mState == ePluginState_Clicktoplay);
   return NS_OK;
 }
 
@@ -838,7 +342,7 @@ nsFakePluginTag::GetEnabledState(uint32_t* aEnabledState) {
 NS_IMETHODIMP
 nsFakePluginTag::SetEnabledState(uint32_t aEnabledState) {
   // There are static asserts above enforcing that this enum matches
-  mState = (nsPluginTag::PluginState)aEnabledState;
+  mState = (PluginState)aEnabledState;
   // FIXME-jsplugins update
   return NS_OK;
 }
diff --git a/dom/plugins/base/nsPluginTags.h b/dom/plugins/base/nsPluginTags.h
index 1f88833b14a07..af93f71921d9d 100644
--- a/dom/plugins/base/nsPluginTags.h
+++ b/dom/plugins/base/nsPluginTags.h
@@ -15,7 +15,6 @@
 #include "nsString.h"
 
 class nsIURI;
-struct PRLibrary;
 
 namespace mozilla {
 namespace dom {
@@ -31,12 +30,6 @@ struct FakePluginTagInit;
     }                                                \
   }
 
-#define NS_PLUGINTAG_IID                             \
-  {                                                  \
-    0xcce2e8b9, 0x9702, 0x4d4b, {                    \
-      0xbe, 0xa4, 0x7c, 0x1e, 0x13, 0x1f, 0xaf, 0x78 \
-    }                                                \
-  }
 class nsIInternalPluginTag : public nsIPluginTag {
  public:
   NS_DECLARE_STATIC_IID_ACCESSOR(NS_IINTERNALPLUGINTAG_IID)
@@ -79,6 +72,14 @@ class nsIInternalPluginTag : public nsIPluginTag {
   bool HasExtension(const nsACString& aExtension,
                     /* out */ nsACString& aMatchingType) const;
 
+  // These must match the STATE_* values in nsIPluginTag.idl
+  enum PluginState {
+    ePluginState_Disabled = 0,
+    ePluginState_Clicktoplay = 1,
+    ePluginState_Enabled = 2,
+    ePluginState_MaxValue = 3,
+  };
+
  protected:
   ~nsIInternalPluginTag();
 
@@ -94,95 +95,8 @@ class nsIInternalPluginTag : public nsIPluginTag {
 };
 NS_DEFINE_STATIC_IID_ACCESSOR(nsIInternalPluginTag, NS_IINTERNALPLUGINTAG_IID)
 
-// A linked-list of plugin information that is used for instantiating plugins
-// and reflecting plugin information into JavaScript.
-class nsPluginTag final : public nsIInternalPluginTag {
- public:
-  NS_DECLARE_STATIC_IID_ACCESSOR(NS_PLUGINTAG_IID)
-
-  NS_DECL_THREADSAFE_ISUPPORTS
-  NS_DECL_NSIPLUGINTAG
-
-  // These must match the STATE_* values in nsIPluginTag.idl
-  enum PluginState {
-    ePluginState_Disabled = 0,
-    ePluginState_Clicktoplay = 1,
-    ePluginState_Enabled = 2,
-    ePluginState_MaxValue = 3,
-  };
-
-  nsPluginTag(const char* aName, const char* aDescription,
-              const char* aFileName, const char* aFullPath,
-              const char* aVersion, const char* const* aMimeTypes,
-              const char* const* aMimeDescriptions,
-              const char* const* aExtensions, int32_t aVariants,
-              int64_t aLastModifiedTime, uint32_t aBlocklistState,
-              bool aArgsAreUTF8 = false);
-  nsPluginTag(uint32_t aId, const char* aName, const char* aDescription,
-              const char* aFileName, const char* aFullPath,
-              const char* aVersion, nsTArray<nsCString> aMimeTypes,
-              nsTArray<nsCString> aMimeDescriptions,
-              nsTArray<nsCString> aExtensions, bool aIsFlashPlugin,
-              bool aSupportsAsyncRender, int64_t aLastModifiedTime,
-              int32_t aSandboxLevel, uint32_t aBlocklistState);
-
-  void TryUnloadPlugin(bool inShutdown);
-
-  static void EnsureSandboxInformation();
-
-  // plugin is enabled and not blocklisted
-  bool IsActive();
-
-  bool IsEnabled() override;
-  void SetEnabled(bool enabled);
-  bool IsClicktoplay();
-  bool IsBlocklisted();
-  uint32_t BlocklistState();
-
-  PluginState GetPluginState();
-  void SetPluginState(PluginState state);
-  void SetBlocklistState(uint32_t aBlocklistState);
-
-  bool HasSameNameAndMimes(const nsPluginTag* aPluginTag) const;
-  const nsCString& GetNiceFileName() override;
-
-  RefPtr<nsPluginTag> mNext;
-  uint32_t mId;
-
-  // Number of PluginModuleParents living in all content processes.
-  size_t mContentProcessRunningCount;
-
-  // True if we've ever created an instance of this plugin in the current
-  // process.
-  bool mHadLocalInstance;
-
-  PRLibrary* mLibrary;
-  bool mIsFlashPlugin;
-  bool mSupportsAsyncRender;
-  nsCString mFullPath;  // UTF-8
-  int64_t mLastModifiedTime;
-  nsCOMPtr<nsITimer> mUnloadTimer;
-  int32_t mSandboxLevel;
-  bool mIsSandboxLoggingEnabled;
-
- private:
-  virtual ~nsPluginTag();
-
-  nsCString mNiceFileName;  // UTF-8
-  uint32_t mBlocklistState;
-
-  void InitMime(const char* const* aMimeTypes,
-                const char* const* aMimeDescriptions,
-                const char* const* aExtensions, uint32_t aVariantCount);
-  void InitSandboxLevel();
-  nsresult EnsureMembersAreUTF8();
-  void FixupVersion();
-};
-NS_DEFINE_STATIC_IID_ACCESSOR(nsPluginTag, NS_PLUGINTAG_IID)
-
-// A class representing "fake" plugin tags; that is plugin tags not
-// corresponding to actual NPAPI plugins.  In practice these are all
-// JS-implemented plugins; maybe we want a better name for this class?
+// A class representing "fake" plugin tags for Javascript-based plugins.
+// There are currently no other types of supported plugins.
 class nsFakePluginTag : public nsIInternalPluginTag, public nsIFakePluginTag {
  public:
   NS_DECL_ISUPPORTS
@@ -231,7 +145,7 @@ class nsFakePluginTag : public nsIInternalPluginTag, public nsIFakePluginTag {
 
   nsString mSandboxScript;
 
-  nsPluginTag::PluginState mState;
+  PluginState mState;
 };
 
 #endif  // nsPluginTags_h_
diff --git a/dom/plugins/base/nspluginroot.idl b/dom/plugins/base/nspluginroot.idl
deleted file mode 100644
index c16181c5ea358..0000000000000
--- a/dom/plugins/base/nspluginroot.idl
+++ /dev/null
@@ -1,8 +0,0 @@
-/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-[ref] native NPWindowStarRef(NPWindow *);
-[ptr] native NPRectPtr(NPRect);
-native NPRegion(NPRegion);
diff --git a/gfx/layers/ipc/PCompositorManager.ipdl b/gfx/layers/ipc/PCompositorManager.ipdl
index 93f08e532b544..3b8ad2ca45fd5 100644
--- a/gfx/layers/ipc/PCompositorManager.ipdl
+++ b/gfx/layers/ipc/PCompositorManager.ipdl
@@ -15,7 +15,7 @@ using mozilla::TimeDuration from "mozilla/TimeStamp.h";
 using mozilla::CSSToLayoutDeviceScale from "Units.h";
 using mozilla::gfx::IntSize from "mozilla/gfx/2D.h";
 using mozilla::ipc::SharedMemoryBasic::Handle from "mozilla/ipc/SharedMemoryBasic.h";
-using mozilla::layers::CompositorOptions from "mozilla/layers/CompositorOptions.h";
+using mozilla::layers::CompositorOptions from "mozilla/layers/LayersMessageUtils.h";
 using mozilla::wr::ExternalImageId from "mozilla/webrender/WebRenderTypes.h";
 using mozilla::wr::MemoryReport from "mozilla/webrender/WebRenderTypes.h";
 using mozilla::wr::WebRenderError from "mozilla/webrender/WebRenderTypes.h";
diff --git a/layout/base/nsRefreshDriver.cpp b/layout/base/nsRefreshDriver.cpp
index 8388873703411..c225bdf508c48 100644
--- a/layout/base/nsRefreshDriver.cpp
+++ b/layout/base/nsRefreshDriver.cpp
@@ -58,7 +58,6 @@
 #include "mozilla/StaticPrefs_page_load.h"
 #include "nsViewManager.h"
 #include "GeckoProfiler.h"
-#include "nsNPAPIPluginInstance.h"
 #include "mozilla/dom/BrowserChild.h"
 #include "mozilla/dom/CallbackDebuggerNotification.h"
 #include "mozilla/dom/Event.h"
@@ -1971,12 +1970,6 @@ void nsRefreshDriver::Tick(VsyncId aId, TimeStamp aNowTime) {
   MOZ_ASSERT(!nsContentUtils::GetCurrentJSContext(),
              "Shouldn't have a JSContext on the stack");
 
-  if (nsNPAPIPluginInstance::InPluginCallUnsafeForReentry()) {
-    NS_ERROR("Refresh driver should not run during plugin call!");
-    // Try to survive this by just ignoring the refresh tick.
-    return;
-  }
-
   // We're either frozen or we were disconnected (likely in the middle
   // of a tick iteration).  Just do nothing here, since our
   // prescontext went away.
diff --git a/toolkit/xre/nsEmbedFunctions.cpp b/toolkit/xre/nsEmbedFunctions.cpp
index cc31f0a133ac6..67d5e511a9a1c 100644
--- a/toolkit/xre/nsEmbedFunctions.cpp
+++ b/toolkit/xre/nsEmbedFunctions.cpp
@@ -123,6 +123,10 @@ using mozilla::_ipdltest::IPDLUnitTestProcessChild;
 #  include "mozilla/ipc/ForkServer.h"
 #endif
 
+#if defined(MOZ_X11)
+#  include <X11/Xlib.h>
+#endif
+
 #include "VRProcessChild.h"
 
 using namespace mozilla;
diff --git a/uriloader/exthandler/nsExternalHelperAppService.cpp b/uriloader/exthandler/nsExternalHelperAppService.cpp
index 5bba1664d1a7f..47f626074dca7 100644
--- a/uriloader/exthandler/nsExternalHelperAppService.cpp
+++ b/uriloader/exthandler/nsExternalHelperAppService.cpp
@@ -2850,13 +2850,6 @@ nsExternalHelperAppService::GetTypeFromExtension(const nsACString& aFileExt,
     return NS_OK;
   }
 
-  // Try the plugins
-  RefPtr<nsPluginHost> pluginHost = nsPluginHost::GetInst();
-  if (pluginHost &&
-      pluginHost->HavePluginForExtension(aFileExt, aContentType)) {
-    return NS_OK;
-  }
-
   // Let's see if an extension added something
   nsCOMPtr<nsICategoryManager> catMan(
       do_GetService("@mozilla.org/categorymanager;1"));
diff --git a/widget/cocoa/TextInputHandler.mm b/widget/cocoa/TextInputHandler.mm
index 9518feb00d766..036cc6f773595 100644
--- a/widget/cocoa/TextInputHandler.mm
+++ b/widget/cocoa/TextInputHandler.mm
@@ -2239,16 +2239,6 @@ inline NSRange MakeNSRangeFrom(const Maybe<OffsetAndData<uint32_t>>& aOffsetAndD
   WidgetKeyboardEvent keyEvent(true, message, mWidget);
   InitKeyEvent(aNativeEvent, keyEvent, false);
 
-  // Attach a plugin event, in case keyEvent gets dispatched to a plugin.  Only
-  // one field is needed -- the type.  The other fields can be constructed as
-  // the need arises.  But Gecko doesn't have anything equivalent to the
-  // NPCocoaEventFlagsChanged type, and this needs to be passed accurately to
-  // any plugin to which this event is sent.
-  NPCocoaEvent cocoaEvent;
-  nsCocoaUtils::InitNPCocoaEvent(&cocoaEvent);
-  cocoaEvent.type = NPCocoaEventFlagsChanged;
-  keyEvent.mPluginEvent.Copy(cocoaEvent);
-
   KeyEventState currentKeyEvent(aNativeEvent);
   nsEventStatus status = nsEventStatus_eIgnore;
   mDispatcher->DispatchKeyboardEvent(message, keyEvent, status, &currentKeyEvent);
diff --git a/widget/cocoa/nsCocoaUtils.h b/widget/cocoa/nsCocoaUtils.h
index 4494bd473931c..2e6ff93012fde 100644
--- a/widget/cocoa/nsCocoaUtils.h
+++ b/widget/cocoa/nsCocoaUtils.h
@@ -10,7 +10,6 @@
 
 #include "nsRect.h"
 #include "imgIContainer.h"
-#include "npapi.h"
 #include "nsTArray.h"
 #include "Units.h"
 
@@ -329,11 +328,6 @@ class nsCocoaUtils {
                                                     NSInteger aWindowNumber,
                                                     NSGraphicsContext* aContext);
 
-  /**
-   * Initializes aNPCocoaEvent.
-   */
-  static void InitNPCocoaEvent(NPCocoaEvent* aNPCocoaEvent);
-
   /**
    * Initializes WidgetInputEvent for aNativeEvent or aModifiers.
    */
diff --git a/widget/cocoa/nsCocoaUtils.mm b/widget/cocoa/nsCocoaUtils.mm
index f9e77301ba90e..eb269aa85f162 100644
--- a/widget/cocoa/nsCocoaUtils.mm
+++ b/widget/cocoa/nsCocoaUtils.mm
@@ -607,11 +607,6 @@ static bool ComputeIsEntirelyBlack(const DataSourceSurface::MappedSurface& aMap,
   NS_OBJC_END_TRY_BLOCK_RETURN(nil);
 }
 
-// static
-void nsCocoaUtils::InitNPCocoaEvent(NPCocoaEvent* aNPCocoaEvent) {
-  memset(aNPCocoaEvent, 0, sizeof(NPCocoaEvent));
-}
-
 // static
 void nsCocoaUtils::InitInputEvent(WidgetInputEvent& aInputEvent, NSEvent* aNativeEvent) {
   NS_OBJC_BEGIN_TRY_IGNORE_BLOCK;
diff --git a/widget/nsBaseWidget.cpp b/widget/nsBaseWidget.cpp
index b7ee6ad74b9ca..1ed392f4826de 100644
--- a/widget/nsBaseWidget.cpp
+++ b/widget/nsBaseWidget.cpp
@@ -58,7 +58,6 @@
 #include "mozilla/layers/PLayerTransactionChild.h"
 #include "mozilla/layers/WebRenderLayerManager.h"
 #include "mozilla/webrender/WebRenderTypes.h"
-#include "npapi.h"
 #include "nsAppDirectoryServiceDefs.h"
 #include "nsCOMPtr.h"
 #include "nsContentUtils.h"
diff --git a/widget/windows/KeyboardLayout.cpp b/widget/windows/KeyboardLayout.cpp
index d00e8d75cd21c..45fb89a089fc6 100644
--- a/widget/windows/KeyboardLayout.cpp
+++ b/widget/windows/KeyboardLayout.cpp
@@ -3574,8 +3574,7 @@ void NativeKey::WillDispatchKeyboardEvent(WidgetKeyboardEvent& aKeyboardEvent,
         continue;
       }
       if (foundPrintableCharMessages++ == aIndex) {
-        // Found message which caused the eKeyPress event.  Let's set the
-        // message for plugin if it's necessary.
+        // Found message which caused the eKeyPress event.
         break;
       }
     }
